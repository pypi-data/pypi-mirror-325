# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_motion_planners_simple_python
else:
    import _tesseract_motion_planners_simple_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_motion_planners_simple_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_motion_planners_simple_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_motion_planners_simple_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python
import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
@_swig_add_metaclass(_SwigNonDynamicMeta)
class JointGroupInstructionInfo(object):
    r"""The Joint Group Instruction Information struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_JointGroupInstructionInfo

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_swiginit(self, _tesseract_motion_planners_simple_python.new_JointGroupInstructionInfo(*args))
    instruction = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_instruction_get)
    manip = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_manip_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_manip_set)
    working_frame = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_working_frame_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_working_frame_set)
    working_frame_transform = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_working_frame_transform_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_working_frame_transform_set)
    tcp_frame = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_frame_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_frame_set)
    tcp_offset = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_offset_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_offset_set)
    has_cartesian_waypoint = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_has_cartesian_waypoint_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_has_cartesian_waypoint_set)

    def calcCartesianPose(self, jp, in_world=True):
        r"""
        Calculate the cartesian pose given the joint solution
        :type jp: Eigen::VectorXd
        :param jp: The joint solution to calculate the pose
        :type in_world: boolean, optional
        :param in_world: Indicate if the results should be in world or relative to working frame
        :rtype: :py:class:`Isometry3d`
        :return: The pose give the joint solution
        """
        return _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_calcCartesianPose(self, jp, in_world)

    def extractCartesianPose(self, in_world=True):
        r"""
        Extract the cartesian pose from the instruction
        If the instruction does not have a cartesian waypoint this throws an exception
        :type in_world: boolean, optional
        :param in_world: Indicate if the results should be in world or relative to working frame
        :rtype: :py:class:`Isometry3d`
        :return: Cartesian pose
        """
        return _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_extractCartesianPose(self, in_world)

    def extractJointPosition(self):
        r"""
        Extract the joint position from the instruction waypoint
        If the instruction does not have a joint/state waypoint this throws an exception
        :rtype: Eigen::VectorXd
        :return: Joint Position
        """
        return _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_extractJointPosition(self)

# Register JointGroupInstructionInfo in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_swigregister(JointGroupInstructionInfo)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KinematicGroupInstructionInfo(object):
    r"""The Kinematic Group Instruction Information struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_KinematicGroupInstructionInfo

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_swiginit(self, _tesseract_motion_planners_simple_python.new_KinematicGroupInstructionInfo(*args))
    instruction = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_instruction_get)
    manip = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_manip_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_manip_set)
    working_frame = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_working_frame_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_working_frame_set)
    working_frame_transform = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_working_frame_transform_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_working_frame_transform_set)
    tcp_frame = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_frame_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_frame_set)
    tcp_offset = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_offset_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_offset_set)
    has_cartesian_waypoint = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_has_cartesian_waypoint_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_has_cartesian_waypoint_set)

    def calcCartesianPose(self, jp, in_world=True):
        r"""
        Calculate the cartesian pose given the joint solution
        :type jp: Eigen::VectorXd
        :param jp: The joint solution to calculate the pose
        :type in_world: boolean, optional
        :param in_world: Indicate if the results should be in world or relative to working frame
        :rtype: :py:class:`Isometry3d`
        :return: The pose give the joint solution
        """
        return _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_calcCartesianPose(self, jp, in_world)

    def extractCartesianPose(self, in_world=True):
        r"""
        Extract the cartesian pose from the instruction
        If the instruction does not have a cartesian waypoint this throws an exception
        :type in_world: boolean, optional
        :param in_world: Indicate if the results should be in world or relative to working frame
        :rtype: :py:class:`Isometry3d`
        :return: Cartesian pose
        """
        return _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_extractCartesianPose(self, in_world)

    def extractJointPosition(self):
        r"""
        Extract the joint position from the instruction waypoint
        If the instruction does not have a joint/state waypoint this throws an exception
        :rtype: Eigen::VectorXd
        :return: Joint Position
        """
        return _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_extractJointPosition(self)

# Register KinematicGroupInstructionInfo in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_swigregister(KinematicGroupInstructionInfo)

def interpolateJointJointWaypoint(*args):
    r"""
    *Overload 1:*

    JointWaypoint to JointWaypoint
    This does not include the prev instruction but does include the base instruction

    This function interpolates the motion from start state to end state.

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done in joint space

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction


    |

    *Overload 2:*

    JointWaypoint to JointWaypoint
    This does not include the prev instruction but does include the base instruction

    This function interpolates the motion from start state to end state.

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done in joint space

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction
    """
    return _tesseract_motion_planners_simple_python.interpolateJointJointWaypoint(*args)

def interpolateJointCartWaypoint(*args):
    r"""
    *Overload 1:*

    JointWaypoint to CartesianWaypoint
    This does not include the prev instruction but does include the base instruction

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done based on the condition below
      - Case 1: Joint solution found for end cartesian waypoint
        - It interpolates the joint position from the start to the end state
      - Case 2: Unable to find joint solution for end cartesian waypoint
        - It creates number states based on the steps and sets the value to start joint waypoint

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction


    |

    *Overload 2:*

    JointWaypoint to CartesianWaypoint
    This does not include the prev instruction but does include the base instruction

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done based on the condition below
      - Case 1: Joint solution found for end cartesian waypoint
        - It interpolates the joint position from the start to the end state
      - Case 2: Unable to find joint solution for end cartesian waypoint
        - It creates number states based on the steps and sets the value to start joint waypoint

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction
    """
    return _tesseract_motion_planners_simple_python.interpolateJointCartWaypoint(*args)

def interpolateCartJointWaypoint(*args):
    r"""
    *Overload 1:*

    CartesianWaypoint to JointWaypoint
    This does not include the prev instruction but does include the base instruction

    This function interpolates the motion from start state to end state.

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done based on the condition below
      - Case 1: Joint solution found for start cartesian waypoint
        - It interpolates the joint position from the start to the end state
      - Case 2: Unable to find joint solution for start cartesian waypoint
        - It creates number states based on the steps and sets the value to end joint waypoint

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction


    |

    *Overload 2:*

    CartesianWaypoint to JointWaypoint
    This does not include the prev instruction but does include the base instruction

    This function interpolates the motion from start state to end state.

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done based on the condition below
      - Case 1: Joint solution found for start cartesian waypoint
        - It interpolates the joint position from the start to the end state
      - Case 2: Unable to find joint solution for start cartesian waypoint
        - It creates number states based on the steps and sets the value to end joint waypoint

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction
    """
    return _tesseract_motion_planners_simple_python.interpolateCartJointWaypoint(*args)

def interpolateCartCartWaypoint(*args):
    r"""
    *Overload 1:*

    CartesianWaypoint to CartesianWaypoint
    This does not include the prev instruction but does include the base instruction

    This function interpolates the motion from start state to end state.

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done based on the condition below
      - Case 1: Joint solution found for start and end cartesian waypoint
        - It interpolates the joint position from the start to the end state
      - Case 2: Joint solution only found for start cartesian waypoint
        - It creates number states based on the steps and sets the value to found start solution
      - Case 3: Joint solution only found for end cartesian waypoint
        - It creates number states based on the steps and sets the value to found end solution
      - Case 4: No joint solution found for end and start cartesian waypoint
        - It creates number states based on the steps and sets the value to the current state of the environment

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction


    |

    *Overload 2:*

    CartesianWaypoint to CartesianWaypoint
    This does not include the prev instruction but does include the base instruction

    This function interpolates the motion from start state to end state.

    - the number of steps for the plan will be calculated such that:
      - the translation distance between successive steps is no longer than translation_longest_valid_segment
      - the rotational distance between successive steps is no longer than rotation_longest_valid_segment
      - the number of steps for the plan will be calculated such that the norm of all joint distances between
    successive steps is no longer than state_longest_valid_segment_length
      - the max steps from the above calculations will be be compared to the min_steps and the largest will be chosen
    - the interpolation will be done based on the condition below
      - Case 1: Joint solution found for start and end cartesian waypoint
        - It interpolates the joint position from the start to the end state
      - Case 2: Joint solution only found for start cartesian waypoint
        - It creates number states based on the steps and sets the value to found start solution
      - Case 3: Joint solution only found for end cartesian waypoint
        - It creates number states based on the steps and sets the value to found end solution
      - Case 4: No joint solution found for end and start cartesian waypoint
        - It creates number states based on the steps and sets the value to the current state of the environment

    :type state_lvs_length: float
    :param state_lvs_length: The maximum joint distance, the norm of changes to all joint positions between successive
        steps.
    :type translation_lvs_length: float
    :param translation_lvs_length: The maximum translation distance between successive steps
    :type rotation_lvs_length: float
    :param rotation_lvs_length: The maximum rotational distance between successive steps
    :type min_steps: int
    :param min_steps: The minimum number of steps for the plan
    :type max_steps: int
    :param max_steps: The maximum number of steps for the plan
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction
    """
    return _tesseract_motion_planners_simple_python.interpolateCartCartWaypoint(*args)

def interpolate(*args):
    r"""
    *Overload 1:*

    Interpolate between two transforms return a vector of Eigen::Isometry transforms.
    :type start: :py:class:`Isometry3d`
    :param start: The Start Transform
    :type stop: :py:class:`Isometry3d`
    :param stop: The Stop/End Transform
    :type steps: int
    :param steps: The number of step
    :rtype: :py:class:`VectorIsometry3d`
    :return: A vector of Eigen::Isometry with a length = steps + 1

    |

    *Overload 2:*

    Interpolate between two Eigen::VectorXd and return a Matrix
    :type start: Eigen::Ref< Eigen::VectorXd const >
    :param start: The Start State
    :type stop: Eigen::Ref< Eigen::VectorXd const >
    :param stop: The Stop/End State
    :type steps: int
    :param steps: The number of step
    :rtype: Eigen::MatrixXd
    :return: A matrix where columns = steps + 1
    """
    return _tesseract_motion_planners_simple_python.interpolate(*args)

def interpolate_waypoint(start, stop, steps):
    r"""
    Interpolate between two waypoints return a vector of waypoints.
    :type start: :py:class:`WaypointPoly`
    :param start: The Start Waypoint
    :type stop: :py:class:`WaypointPoly`
    :param stop: The Stop/End Waypoint
    :type steps: int
    :param steps: The number of step
    :rtype: std::vector< tesseract_planning::WaypointPoly,std::allocator< tesseract_planning::WaypointPoly > >
    :return: A vector of waypoints with a length = steps + 1
    """
    return _tesseract_motion_planners_simple_python.interpolate_waypoint(start, stop, steps)

def getInterpolatedInstructions(*args):
    r"""
    *Overload 1:*

    This takes the provided seed state for the base_instruction and create a vector of move instruction
    This skips the first state
    :type joint_names: std::vector< std::string,std::allocator< std::string > >
    :param joint_names: The joint names associated with the states
    :type states: Eigen::MatrixXd
    :param states: The joint states to populate the composite instruction with
    :type base_instruction: :py:class:`MoveInstructionPoly`
    :param base_instruction: The base instruction used to extract profile and manipulator information from
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction

    |

    *Overload 2:*

    This takes the provided seed state for the base_instruction and create a vector of move instruction
    This skips the first state
    :type joint_names: std::vector< std::string,std::allocator< std::string > >
    :param joint_names: The joint names associated with the states
    :type states: Eigen::MatrixXd
    :param states: The joint states to populate the composite instruction with
    :type base_instruction: :py:class:`MoveInstructionPoly`
    :param base_instruction: The base instruction used to extract profile and manipulator information from
    :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
    :return: A vector of move instruction
    """
    return _tesseract_motion_planners_simple_python.getInterpolatedInstructions(*args)

def getClosestJointSolution(*args):
    r"""
    *Overload 1:*

    Find the closest joint solution for p to the provided seed
    :type info: :py:class:`KinematicGroupInstructionInfo`
    :param info: The instruction info to find closest joint solution
    :type seed: Eigen::VectorXd
    :param seed: The seed to find the closest solution
    :rtype: Eigen::VectorXd
    :return: The closest solution to the seed. This will be empty if a solution was not found during inverse kinematics

    |

    *Overload 2:*

    Find the closest joint solution for the two provided cartesian poses.
    :type info1: :py:class:`KinematicGroupInstructionInfo`
    :param info1: The instruction info to find closest joint solution
    :type info2: :py:class:`KinematicGroupInstructionInfo`
    :param info2: The instruction info to find closest joint solution
    :type seed: Eigen::VectorXd
    :param seed: The seed to use during inverse kinematics
    :rtype: std::array< Eigen::VectorXd,2 >
    :return: The closest joint solution for the provided cartesian positions. If either are empty then it failed to solve
        inverse kinematics.
    """
    return _tesseract_motion_planners_simple_python.getClosestJointSolution(*args)

def generateInterpolatedProgram(*args):
    r"""Provided for backwards compatibility"""
    return _tesseract_motion_planners_simple_python.generateInterpolatedProgram(*args)
class SimplePlannerPlanProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    r"""
    Plan Profile for the simple planner. It defines some functions that handle each of the waypoint cases. The
    planner then simply loops over all of the plan instructions and calls the correct function
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfile_getStaticKey()

    def generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info):
        r"""
        Generate a seed for the provided base_instruction
        This should not include the prev_instruction but must include the base_instruction
        :type prev_instruction: :py:class:`MoveInstructionPoly`
        :param prev_instruction: The previous instruction
        :type prev_seed: :py:class:`MoveInstructionPoly`
        :param prev_seed: The previous seed
        :type base_instruction: :py:class:`MoveInstructionPoly`
        :param base_instruction: The base/current instruction to generate the seed for
        :type next_instruction: :py:class:`InstructionPoly`
        :param next_instruction: The next instruction. This will be a null instruction for the final instruction
        :param request: The planning request
        :type global_manip_info: :py:class:`ManipulatorInfo`
        :param global_manip_info: The global manipulator information
        :rtype: std::vector< tesseract_planning::MoveInstructionPoly,std::allocator< tesseract_planning::MoveInstructionPoly > >
        :return: A vector of move instrucitons
        """
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerPlanProfile

# Register SimplePlannerPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerPlanProfile_swigregister(SimplePlannerPlanProfile)
class SimplePlannerCompositeProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerCompositeProfile())

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfile_getStaticKey()
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerCompositeProfile

# Register SimplePlannerCompositeProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerCompositeProfile_swigregister(SimplePlannerCompositeProfile)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class SimplePlannerPlanProfileMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___nonzero__(self)

    def __bool__(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___bool__(self)

    def __len__(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___getitem__(self, key)

    def __delitem__(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___delitem__(self, key)

    def has_key(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_has_key(self, key)

    def keys(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_keys(self)

    def values(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_values(self)

    def items(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_items(self)

    def __contains__(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___contains__(self, key)

    def key_iterator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_key_iterator(self)

    def value_iterator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_value_iterator(self)

    def __setitem__(self, *args):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___setitem__(self, *args)

    def asdict(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_asdict(self)

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerPlanProfileMap(*args))

    def empty(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_empty(self)

    def size(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_size(self)

    def swap(self, v):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_swap(self, v)

    def begin(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_begin(self)

    def end(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_end(self)

    def clear(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_clear(self)

    def get_allocator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_get_allocator(self)

    def count(self, x):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_count(self, x)

    def erase(self, *args):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_erase(self, *args)

    def find(self, x):
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_find(self, x)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerPlanProfileMap

# Register SimplePlannerPlanProfileMap in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_swigregister(SimplePlannerPlanProfileMap)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class SimplePlannerCompositeProfileMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___nonzero__(self)

    def __bool__(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___bool__(self)

    def __len__(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___getitem__(self, key)

    def __delitem__(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___delitem__(self, key)

    def has_key(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_has_key(self, key)

    def keys(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_keys(self)

    def values(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_values(self)

    def items(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_items(self)

    def __contains__(self, key):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___contains__(self, key)

    def key_iterator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_key_iterator(self)

    def value_iterator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_value_iterator(self)

    def __setitem__(self, *args):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___setitem__(self, *args)

    def asdict(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_asdict(self)

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerCompositeProfileMap(*args))

    def empty(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_empty(self)

    def size(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_size(self)

    def swap(self, v):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_swap(self, v)

    def begin(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_begin(self)

    def end(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_end(self)

    def clear(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_clear(self)

    def get_allocator(self):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_get_allocator(self)

    def count(self, x):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_count(self, x)

    def erase(self, *args):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_erase(self, *args)

    def find(self, x):
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_find(self, x)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerCompositeProfileMap

# Register SimplePlannerCompositeProfileMap in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_swigregister(SimplePlannerCompositeProfileMap)
class SimplePlannerLVSPlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        SimplePlannerLVSPlanProfile
        :type state_longest_valid_segment_length: float, optional
        :param state_longest_valid_segment_length: The maximum joint distance (norm of changes to all joint positions)
            between successive steps
        :type translation_longest_valid_segment_length: float, optional
        :param translation_longest_valid_segment_length: The maximum translation distance between successive steps
        :type rotation_longest_valid_segment_length: float, optional
        :param rotation_longest_valid_segment_length: The maximum rotational distance between successive steps
        :type min_steps: int, optional
        :param min_steps: The minimum number of steps for the plan
        """
        _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerLVSPlanProfile(*args))

    def generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info):
        return _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info)
    state_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_state_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_state_longest_valid_segment_length_set, doc=r"""The maximum joint distance, the norm of changes to all joint positions between successive steps.""")
    translation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_translation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_translation_longest_valid_segment_length_set, doc=r"""The maximum translation distance between successive steps""")
    rotation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_rotation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_rotation_longest_valid_segment_length_set, doc=r"""The maximum rotational distance between successive steps""")
    min_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_min_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_min_steps_set, doc=r"""The minimum number of steps for the plan""")
    max_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_max_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_max_steps_set, doc=r"""The maximum number of steps for the plan""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerLVSPlanProfile

# Register SimplePlannerLVSPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_swigregister(SimplePlannerLVSPlanProfile)
class SimplePlannerLVSNoIKPlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        SimplePlannerLVSNoIKPlanProfile
        :type state_longest_valid_segment_length: float, optional
        :param state_longest_valid_segment_length: The maximum joint distance (norm of changes to all joint positions)
            between successive steps
        :type translation_longest_valid_segment_length: float, optional
        :param translation_longest_valid_segment_length: The maximum translation distance between successive steps
        :type rotation_longest_valid_segment_length: float, optional
        :param rotation_longest_valid_segment_length: The maximum rotational distance between successive steps
        :type min_steps: int, optional
        :param min_steps: The minimum number of steps for the plan
        :type max_steps: int, optional
        :param max_steps: The maximum number of steps for the plan
        """
        _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerLVSNoIKPlanProfile(*args))

    def generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info):
        return _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info)
    state_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_state_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_state_longest_valid_segment_length_set, doc=r"""The maximum joint distance, the norm of changes to all joint positions between successive steps.""")
    translation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_translation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_translation_longest_valid_segment_length_set, doc=r"""The maximum translation distance between successive steps""")
    rotation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_rotation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_rotation_longest_valid_segment_length_set, doc=r"""The maximum rotational distance between successive steps""")
    min_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_min_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_min_steps_set, doc=r"""The minimum number of steps for the plan""")
    max_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_max_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_max_steps_set, doc=r"""The maximum number of steps for the plan""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerLVSNoIKPlanProfile

# Register SimplePlannerLVSNoIKPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_swigregister(SimplePlannerLVSNoIKPlanProfile)
class SimplePlannerFixedSizePlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, freespace_steps=10, linear_steps=10):
        r"""
        SimplePlannerFixedSizePlanProfile
        :type freespace_steps: int, optional
        :param freespace_steps: The number of steps to use for freespace instruction
        :type linear_steps: int, optional
        :param linear_steps: The number of steps to use for linear instruction
        """
        _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerFixedSizePlanProfile(freespace_steps, linear_steps))

    def generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info):
        return _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info)
    freespace_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_freespace_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_freespace_steps_set, doc=r"""The number of steps to use for freespace instruction""")
    linear_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_linear_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_linear_steps_set, doc=r"""The number of steps to use for linear instruction""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerFixedSizePlanProfile

# Register SimplePlannerFixedSizePlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_swigregister(SimplePlannerFixedSizePlanProfile)
class SimplePlannerFixedSizeAssignPlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, freespace_steps=10, linear_steps=10):
        r"""
        SimplePlannerFixedSizeAssignPlanProfile
        :type freespace_steps: int, optional
        :param freespace_steps: The number of steps to use for freespace instruction
        :type linear_steps: int, optional
        :param linear_steps: The number of steps to use for linear instruction
        """
        _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerFixedSizeAssignPlanProfile(freespace_steps, linear_steps))

    def generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info):
        return _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, env, global_manip_info)
    freespace_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_freespace_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_freespace_steps_set, doc=r"""The number of steps to use for freespace instruction""")
    linear_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_linear_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_linear_steps_set, doc=r"""The number of steps to use for linear instruction""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerFixedSizeAssignPlanProfile

# Register SimplePlannerFixedSizeAssignPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_swigregister(SimplePlannerFixedSizeAssignPlanProfile)
class SimpleMotionPlanner(tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python.MotionPlanner):
    r"""
    The simple planner is meant to be a tool for assigning values to the seed. The planner simply loops over all
    of the MoveInstructions and then calls the appropriate function from the profile. These functions do not depend on
    the seed, so this may be used to initialize the seed appropriately using e.g. linear interpolation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name):
        r"""Construct a basic planner"""
        _tesseract_motion_planners_simple_python.SimpleMotionPlanner_swiginit(self, _tesseract_motion_planners_simple_python.new_SimpleMotionPlanner(name))
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimpleMotionPlanner

    def solve(self, request):
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_solve(self, request)

    def terminate(self):
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_terminate(self)

    def clear(self):
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_clear(self)

# Register SimpleMotionPlanner in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimpleMotionPlanner_swigregister(SimpleMotionPlanner)

