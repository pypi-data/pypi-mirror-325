# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_state_solver_python
else:
    import _tesseract_state_solver_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_state_solver_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_state_solver_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_state_solver_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_state_solver_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_state_solver_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_state_solver_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_state_solver_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_state_solver_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_state_solver_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_state_solver_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_state_solver_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_state_solver_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_state_solver_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_state_solver_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_state_solver_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_state_solver_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_state_solver_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_state_solver_python:
_tesseract_state_solver_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
@_swig_add_metaclass(_SwigNonDynamicMeta)
class StateSolverUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_state_solver_python.StateSolverUPtr_swiginit(self, _tesseract_state_solver_python.new_StateSolverUPtr(*args))

    def __deref__(self):
        return _tesseract_state_solver_python.StateSolverUPtr___deref__(self)

    def release(self):
        return _tesseract_state_solver_python.StateSolverUPtr_release(self)

    def reset(self, *args):
        return _tesseract_state_solver_python.StateSolverUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_state_solver_python.StateSolverUPtr_swap(self, __u)

    def get(self):
        return _tesseract_state_solver_python.StateSolverUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_state_solver_python.StateSolverUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_state_solver_python.delete_StateSolverUPtr

    def clone(self):
        r"""
        This should clone the object so it may be used in a multi threaded application where each thread would
        clone the solver.
        :rtype: :py:class:`UPtr`
        :return: A clone of the object.
        """
        return _tesseract_state_solver_python.StateSolverUPtr_clone(self)

    def setState(self, *args):
        r"""
        *Overload 1:*

        Set the current state of the solver
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values

        |

        *Overload 2:*

        Set the current state of the solver

        After updating the current state these function must call currentStateChanged() which
        will update the contact managers transforms


        |

        *Overload 3:*

        Set the current state of the solver

        After updating the current state these function must call currentStateChanged() which
        will update the contact managers transforms


        |

        *Overload 4:*

        Set the current state of the floating joint values
        :type floating_joint_values: :py:class:`TransformMap`
        :param floating_joint_values: The floating joint values to set
        """
        return _tesseract_state_solver_python.StateSolverUPtr_setState(self, *args)

    def getState(self, *args):
        r"""
        *Overload 1:*

        Get the state of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values
        :type floating_joint_values: :py:class:`TransformMap`, optional
        :param floating_joint_values: The floating joint origin transform

        |

        *Overload 2:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type floating_joint_values: :py:class:`TransformMap`, optional
        :param floating_joint_values: The floating joint origin transform
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :param floating_joint_values: The floating joint origin transform
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 4:*

        Get the state given floating joint values
        :type floating_joint_values: :py:class:`TransformMap`
        :param floating_joint_values: The floating joint values to leverage
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 5:*

        Get the current state of the scene
        :rtype: :py:class:`SceneState`
        :return: The current state
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getState(self, *args)

    def getJacobian(self, *args):
        r"""
        *Overload 1:*

        Get the jacobian of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values
        :type link_name: string
        :param link_name: The link name to calculate the jacobian

        |

        *Overload 2:*

        Get the jacobian of the scene for a given set or subset of joint values.

           * This does not return the jacobian based on the provided joint names. It is order based
        on the order returned from getJointNames

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type link_name: string
        :param link_name: The link name to calculate the jacobian
        :rtype: Eigen::MatrixXd
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the jacobian of the scene for a given set or subset of joint values.

           * This does not return the jacobian based on the provided joint names. It is order based
        on the order returned from getJointNames

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type link_name: string
        :param link_name: The link name to calculate the jacobian
        :rtype: Eigen::MatrixXd
        :return: A the state of the environment
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getJacobian(self, *args)

    def getRandomState(self):
        r"""
        Get the random state of the environment
        :rtype: :py:class:`SceneState`
        :return: Environment state
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getRandomState(self)

    def getJointNames(self):
        r"""
        Get the vector of joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getJointNames(self)

    def getFloatingJointNames(self):
        r"""
        Get the vector of floating joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getFloatingJointNames(self)

    def getActiveJointNames(self):
        r"""
        Get the vector of joint names which align with the limits
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getActiveJointNames(self)

    def getBaseLinkName(self):
        r"""
        Get the base link name
        :rtype: string
        :return: The base link name
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getBaseLinkName(self)

    def getLinkNames(self):
        r"""
        Get the vector of link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLinkNames(self)

    def getActiveLinkNames(self):
        r"""
        Get the vector of active link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        r"""
        Get a vector of static link names in the environment
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_state_solver_python.StateSolverUPtr_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_state_solver_python.StateSolverUPtr_hasLinkName(self, link_name)

    def getLinkTransforms(self):
        r"""
        Get all of the links transforms
        Order should be the same as getLinkNames()
        :rtype: :py:class:`VectorIsometry3d`
        :return: Get a vector of transforms for all links.
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLinkTransforms(self)

    def getLinkTransform(self, link_name):
        r"""
        Get the transform corresponding to the link.
        :rtype: :py:class:`Isometry3d`
        :return: Transform and is identity when no transform is available.
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name, to_link_name):
        r"""
        Get transform between two links using the current state
        :type from_link_name: string
        :param from_link_name: The link name the transform should be relative to
        :type to_link_name: string
        :param to_link_name: The link name to get transform
        :rtype: :py:class:`Isometry3d`
        :return: The relative transform = inv(Transform(from_link_name)) * Transform(to_link_name)
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self):
        r"""
        Getter for kinematic limits
        :rtype: :py:class:`KinematicLimits`
        :return: The kinematic limits
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLimits(self)

# Register StateSolverUPtr in _tesseract_state_solver_python:
_tesseract_state_solver_python.StateSolverUPtr_swigregister(StateSolverUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class StateSolver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_StateSolver

    def clone(self):
        r"""
        This should clone the object so it may be used in a multi threaded application where each thread would
        clone the solver.
        :rtype: :py:class:`UPtr`
        :return: A clone of the object.
        """
        return _tesseract_state_solver_python.StateSolver_clone(self)

    def setState(self, *args):
        r"""
        *Overload 1:*

        Set the current state of the solver
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values

        |

        *Overload 2:*

        Set the current state of the solver

        After updating the current state these function must call currentStateChanged() which
        will update the contact managers transforms


        |

        *Overload 3:*

        Set the current state of the solver

        After updating the current state these function must call currentStateChanged() which
        will update the contact managers transforms


        |

        *Overload 4:*

        Set the current state of the floating joint values
        :type floating_joint_values: :py:class:`TransformMap`
        :param floating_joint_values: The floating joint values to set
        """
        return _tesseract_state_solver_python.StateSolver_setState(self, *args)

    def getState(self, *args):
        r"""
        *Overload 1:*

        Get the state of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values
        :type floating_joint_values: :py:class:`TransformMap`, optional
        :param floating_joint_values: The floating joint origin transform

        |

        *Overload 2:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type floating_joint_values: :py:class:`TransformMap`, optional
        :param floating_joint_values: The floating joint origin transform
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :param floating_joint_values: The floating joint origin transform
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 4:*

        Get the state given floating joint values
        :type floating_joint_values: :py:class:`TransformMap`
        :param floating_joint_values: The floating joint values to leverage
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 5:*

        Get the current state of the scene
        :rtype: :py:class:`SceneState`
        :return: The current state
        """
        return _tesseract_state_solver_python.StateSolver_getState(self, *args)

    def getJacobian(self, *args):
        r"""
        *Overload 1:*

        Get the jacobian of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values
        :type link_name: string
        :param link_name: The link name to calculate the jacobian

        |

        *Overload 2:*

        Get the jacobian of the scene for a given set or subset of joint values.

           * This does not return the jacobian based on the provided joint names. It is order based
        on the order returned from getJointNames

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type link_name: string
        :param link_name: The link name to calculate the jacobian
        :rtype: Eigen::MatrixXd
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the jacobian of the scene for a given set or subset of joint values.

           * This does not return the jacobian based on the provided joint names. It is order based
        on the order returned from getJointNames

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type link_name: string
        :param link_name: The link name to calculate the jacobian
        :rtype: Eigen::MatrixXd
        :return: A the state of the environment
        """
        return _tesseract_state_solver_python.StateSolver_getJacobian(self, *args)

    def getRandomState(self):
        r"""
        Get the random state of the environment
        :rtype: :py:class:`SceneState`
        :return: Environment state
        """
        return _tesseract_state_solver_python.StateSolver_getRandomState(self)

    def getJointNames(self):
        r"""
        Get the vector of joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolver_getJointNames(self)

    def getFloatingJointNames(self):
        r"""
        Get the vector of floating joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolver_getFloatingJointNames(self)

    def getActiveJointNames(self):
        r"""
        Get the vector of joint names which align with the limits
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolver_getActiveJointNames(self)

    def getBaseLinkName(self):
        r"""
        Get the base link name
        :rtype: string
        :return: The base link name
        """
        return _tesseract_state_solver_python.StateSolver_getBaseLinkName(self)

    def getLinkNames(self):
        r"""
        Get the vector of link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_state_solver_python.StateSolver_getLinkNames(self)

    def getActiveLinkNames(self):
        r"""
        Get the vector of active link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_state_solver_python.StateSolver_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        r"""
        Get a vector of static link names in the environment
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_state_solver_python.StateSolver_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_state_solver_python.StateSolver_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_state_solver_python.StateSolver_hasLinkName(self, link_name)

    def getLinkTransforms(self):
        r"""
        Get all of the links transforms
        Order should be the same as getLinkNames()
        :rtype: :py:class:`VectorIsometry3d`
        :return: Get a vector of transforms for all links.
        """
        return _tesseract_state_solver_python.StateSolver_getLinkTransforms(self)

    def getLinkTransform(self, link_name):
        r"""
        Get the transform corresponding to the link.
        :rtype: :py:class:`Isometry3d`
        :return: Transform and is identity when no transform is available.
        """
        return _tesseract_state_solver_python.StateSolver_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name, to_link_name):
        r"""
        Get transform between two links using the current state
        :type from_link_name: string
        :param from_link_name: The link name the transform should be relative to
        :type to_link_name: string
        :param to_link_name: The link name to get transform
        :rtype: :py:class:`Isometry3d`
        :return: The relative transform = inv(Transform(from_link_name)) * Transform(to_link_name)
        """
        return _tesseract_state_solver_python.StateSolver_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self):
        r"""
        Getter for kinematic limits
        :rtype: :py:class:`KinematicLimits`
        :return: The kinematic limits
        """
        return _tesseract_state_solver_python.StateSolver_getLimits(self)

# Register StateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.StateSolver_swigregister(StateSolver)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class MutableStateSolverUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_state_solver_python.MutableStateSolverUPtr_swiginit(self, _tesseract_state_solver_python.new_MutableStateSolverUPtr(*args))

    def __deref__(self):
        return _tesseract_state_solver_python.MutableStateSolverUPtr___deref__(self)

    def release(self):
        return _tesseract_state_solver_python.MutableStateSolverUPtr_release(self)

    def reset(self, *args):
        return _tesseract_state_solver_python.MutableStateSolverUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_state_solver_python.MutableStateSolverUPtr_swap(self, __u)

    def get(self):
        return _tesseract_state_solver_python.MutableStateSolverUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_state_solver_python.MutableStateSolverUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_state_solver_python.delete_MutableStateSolverUPtr

    def setRevision(self, revision):
        r"""
        Set the state solver revision number
        :type revision: int
        :param revision: The revision number to assign
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_setRevision(self, revision)

    def getRevision(self):
        r"""
        Get the state solver revision number
        :rtype: int
        :return: revision number
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getRevision(self)

    def addLink(self, link, joint):
        r"""
        Adds a link/joint to the solver
        :type link: :py:class:`Link`
        :param link: The link to be added to the graph
        :type joint: :py:class:`Joint`
        :param joint: The associated joint to be added to the graph
        :rtype: boolean
        :return: Return False if a link with the same name allready exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_addLink(self, link, joint)

    def moveLink(self, joint):
        r"""
        Move a link
        :type joint: :py:class:`Joint`
        :param joint: The associated joint that defines the move
        :rtype: boolean
        :return: Return False if link does not exist or if joint name already exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_moveLink(self, joint)

    def removeLink(self, name):
        r"""
        Removes a link from the graph

        Note: this will remove all inbound and outbound edges

        :type name: string
        :param name: Name of the link to be removed
        :rtype: boolean
        :return: Return False if a link does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_removeLink(self, name)

    def replaceJoint(self, joint):
        r"""
        Replace and existing joint with the provided one
        :type joint: :py:class:`Joint`
        :param joint: The replacement joint
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_replaceJoint(self, joint)

    def removeJoint(self, name):
        r"""
        Removes a joint from the graph
        :type name: string
        :param name: Name of the joint to be removed
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_removeJoint(self, name)

    def moveJoint(self, name, parent_link):
        r"""
        Move joint to new parent link
        :type name: string
        :param name: Name of the joint to move
        :type parent_link: string
        :param parent_link: Name of parent link to move to
        :rtype: boolean
        :return: Returns true if successful, otherwise false.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_moveJoint(self, name, parent_link)

    def changeJointOrigin(self, name, new_origin):
        r"""
        Changes the "origin" transform of the joint and recomputes the associated edge
        :type name: string
        :param name: Name of the joint to be changed
        :type new_origin: :py:class:`Isometry3d`
        :param new_origin: The new transform associated with the joint
        :rtype: boolean
        :return: True if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointOrigin(self, name, new_origin)

    def changeJointPositionLimits(self, name, lower, upper):
        r"""
        Changes the position limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New position limits to be set as the joint limits
            if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointPositionLimits(self, name, lower, upper)

    def changeJointVelocityLimits(self, name, limit):
        r"""
        Changes the velocity limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New velocity limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointVelocityLimits(self, name, limit)

    def changeJointAccelerationLimits(self, name, limit):
        r"""
        Changes the acceleration limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New acceleration limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointAccelerationLimits(self, name, limit)

    def changeJointJerkLimits(self, name, limit):
        r"""
        Changes the jerk limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New jerk limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointJerkLimits(self, name, limit)

    def insertSceneGraph(self, *args):
        r"""
        Merge a scene into the current solver
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: Const ref to the graph to be merged
        :type joint: :py:class:`Joint`
        :param joint: The joint that connects current scene with the inserted scene
        :type prefix: string, optional
        :param prefix: string Will be prepended to every link and joint of the merged scene
        :rtype: boolean
        :return: Return False if any link or joint name collides with current solver, otherwise True
            The prefix argument is meant to allow adding multiple copies of the same subgraph with different names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_insertSceneGraph(self, *args)

    def clone(self):
        r"""
        This should clone the object so it may be used in a multi threaded application where each thread would
        clone the solver.
        :rtype: :py:class:`UPtr`
        :return: A clone of the object.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_clone(self)

    def setState(self, *args):
        r"""
        *Overload 1:*

        Set the current state of the solver
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values

        |

        *Overload 2:*

        Set the current state of the solver

        After updating the current state these function must call currentStateChanged() which
        will update the contact managers transforms


        |

        *Overload 3:*

        Set the current state of the solver

        After updating the current state these function must call currentStateChanged() which
        will update the contact managers transforms


        |

        *Overload 4:*

        Set the current state of the floating joint values
        :type floating_joint_values: :py:class:`TransformMap`
        :param floating_joint_values: The floating joint values to set
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_setState(self, *args)

    def getState(self, *args):
        r"""
        *Overload 1:*

        Get the state of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values
        :type floating_joint_values: :py:class:`TransformMap`, optional
        :param floating_joint_values: The floating joint origin transform

        |

        *Overload 2:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type floating_joint_values: :py:class:`TransformMap`, optional
        :param floating_joint_values: The floating joint origin transform
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :param floating_joint_values: The floating joint origin transform
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 4:*

        Get the state given floating joint values
        :type floating_joint_values: :py:class:`TransformMap`
        :param floating_joint_values: The floating joint values to leverage
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 5:*

        Get the current state of the scene
        :rtype: :py:class:`SceneState`
        :return: The current state
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getState(self, *args)

    def getJacobian(self, *args):
        r"""
        *Overload 1:*

        Get the jacobian of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values
        :type link_name: string
        :param link_name: The link name to calculate the jacobian

        |

        *Overload 2:*

        Get the jacobian of the scene for a given set or subset of joint values.

           * This does not return the jacobian based on the provided joint names. It is order based
        on the order returned from getJointNames

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type link_name: string
        :param link_name: The link name to calculate the jacobian
        :rtype: Eigen::MatrixXd
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the jacobian of the scene for a given set or subset of joint values.

           * This does not return the jacobian based on the provided joint names. It is order based
        on the order returned from getJointNames

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :type link_name: string
        :param link_name: The link name to calculate the jacobian
        :rtype: Eigen::MatrixXd
        :return: A the state of the environment
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getJacobian(self, *args)

    def getRandomState(self):
        r"""
        Get the random state of the environment
        :rtype: :py:class:`SceneState`
        :return: Environment state
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getRandomState(self)

    def getJointNames(self):
        r"""
        Get the vector of joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getJointNames(self)

    def getFloatingJointNames(self):
        r"""
        Get the vector of floating joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getFloatingJointNames(self)

    def getActiveJointNames(self):
        r"""
        Get the vector of joint names which align with the limits
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getActiveJointNames(self)

    def getBaseLinkName(self):
        r"""
        Get the base link name
        :rtype: string
        :return: The base link name
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getBaseLinkName(self)

    def getLinkNames(self):
        r"""
        Get the vector of link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLinkNames(self)

    def getActiveLinkNames(self):
        r"""
        Get the vector of active link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        r"""
        Get a vector of static link names in the environment
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_hasLinkName(self, link_name)

    def getLinkTransforms(self):
        r"""
        Get all of the links transforms
        Order should be the same as getLinkNames()
        :rtype: :py:class:`VectorIsometry3d`
        :return: Get a vector of transforms for all links.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLinkTransforms(self)

    def getLinkTransform(self, link_name):
        r"""
        Get the transform corresponding to the link.
        :rtype: :py:class:`Isometry3d`
        :return: Transform and is identity when no transform is available.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name, to_link_name):
        r"""
        Get transform between two links using the current state
        :type from_link_name: string
        :param from_link_name: The link name the transform should be relative to
        :type to_link_name: string
        :param to_link_name: The link name to get transform
        :rtype: :py:class:`Isometry3d`
        :return: The relative transform = inv(Transform(from_link_name)) * Transform(to_link_name)
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self):
        r"""
        Getter for kinematic limits
        :rtype: :py:class:`KinematicLimits`
        :return: The kinematic limits
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLimits(self)

# Register MutableStateSolverUPtr in _tesseract_state_solver_python:
_tesseract_state_solver_python.MutableStateSolverUPtr_swigregister(MutableStateSolverUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class MutableStateSolver(StateSolver):
    r"""A mutable state solver allows you to reconfigure the solver's links and joints"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_MutableStateSolver

    def setRevision(self, revision):
        r"""
        Set the state solver revision number
        :type revision: int
        :param revision: The revision number to assign
        """
        return _tesseract_state_solver_python.MutableStateSolver_setRevision(self, revision)

    def getRevision(self):
        r"""
        Get the state solver revision number
        :rtype: int
        :return: revision number
        """
        return _tesseract_state_solver_python.MutableStateSolver_getRevision(self)

    def addLink(self, link, joint):
        r"""
        Adds a link/joint to the solver
        :type link: :py:class:`Link`
        :param link: The link to be added to the graph
        :type joint: :py:class:`Joint`
        :param joint: The associated joint to be added to the graph
        :rtype: boolean
        :return: Return False if a link with the same name allready exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_addLink(self, link, joint)

    def moveLink(self, joint):
        r"""
        Move a link
        :type joint: :py:class:`Joint`
        :param joint: The associated joint that defines the move
        :rtype: boolean
        :return: Return False if link does not exist or if joint name already exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_moveLink(self, joint)

    def removeLink(self, name):
        r"""
        Removes a link from the graph

        Note: this will remove all inbound and outbound edges

        :type name: string
        :param name: Name of the link to be removed
        :rtype: boolean
        :return: Return False if a link does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_removeLink(self, name)

    def replaceJoint(self, joint):
        r"""
        Replace and existing joint with the provided one
        :type joint: :py:class:`Joint`
        :param joint: The replacement joint
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_replaceJoint(self, joint)

    def removeJoint(self, name):
        r"""
        Removes a joint from the graph
        :type name: string
        :param name: Name of the joint to be removed
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_removeJoint(self, name)

    def moveJoint(self, name, parent_link):
        r"""
        Move joint to new parent link
        :type name: string
        :param name: Name of the joint to move
        :type parent_link: string
        :param parent_link: Name of parent link to move to
        :rtype: boolean
        :return: Returns true if successful, otherwise false.
        """
        return _tesseract_state_solver_python.MutableStateSolver_moveJoint(self, name, parent_link)

    def changeJointOrigin(self, name, new_origin):
        r"""
        Changes the "origin" transform of the joint and recomputes the associated edge
        :type name: string
        :param name: Name of the joint to be changed
        :type new_origin: :py:class:`Isometry3d`
        :param new_origin: The new transform associated with the joint
        :rtype: boolean
        :return: True if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointOrigin(self, name, new_origin)

    def changeJointPositionLimits(self, name, lower, upper):
        r"""
        Changes the position limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New position limits to be set as the joint limits
            if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointPositionLimits(self, name, lower, upper)

    def changeJointVelocityLimits(self, name, limit):
        r"""
        Changes the velocity limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New velocity limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointVelocityLimits(self, name, limit)

    def changeJointAccelerationLimits(self, name, limit):
        r"""
        Changes the acceleration limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New acceleration limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointAccelerationLimits(self, name, limit)

    def changeJointJerkLimits(self, name, limit):
        r"""
        Changes the jerk limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New jerk limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointJerkLimits(self, name, limit)

    def insertSceneGraph(self, *args):
        r"""
        Merge a scene into the current solver
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: Const ref to the graph to be merged
        :type joint: :py:class:`Joint`
        :param joint: The joint that connects current scene with the inserted scene
        :type prefix: string, optional
        :param prefix: string Will be prepended to every link and joint of the merged scene
        :rtype: boolean
        :return: Return False if any link or joint name collides with current solver, otherwise True
            The prefix argument is meant to allow adding multiple copies of the same subgraph with different names
        """
        return _tesseract_state_solver_python.MutableStateSolver_insertSceneGraph(self, *args)

# Register MutableStateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.MutableStateSolver_swigregister(MutableStateSolver)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KDLStateSolver(StateSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_KDLStateSolver

    def __init__(self, *args):
        _tesseract_state_solver_python.KDLStateSolver_swiginit(self, _tesseract_state_solver_python.new_KDLStateSolver(*args))

    def clone(self):
        return _tesseract_state_solver_python.KDLStateSolver_clone(self)

    def setState(self, *args):
        return _tesseract_state_solver_python.KDLStateSolver_setState(self, *args)

    def getState(self, *args):
        return _tesseract_state_solver_python.KDLStateSolver_getState(self, *args)

    def getRandomState(self):
        return _tesseract_state_solver_python.KDLStateSolver_getRandomState(self)

    def getJacobian(self, *args):
        return _tesseract_state_solver_python.KDLStateSolver_getJacobian(self, *args)

    def getJointNames(self):
        return _tesseract_state_solver_python.KDLStateSolver_getJointNames(self)

    def getFloatingJointNames(self):
        return _tesseract_state_solver_python.KDLStateSolver_getFloatingJointNames(self)

    def getActiveJointNames(self):
        return _tesseract_state_solver_python.KDLStateSolver_getActiveJointNames(self)

    def getBaseLinkName(self):
        return _tesseract_state_solver_python.KDLStateSolver_getBaseLinkName(self)

    def getLinkNames(self):
        return _tesseract_state_solver_python.KDLStateSolver_getLinkNames(self)

    def getActiveLinkNames(self):
        return _tesseract_state_solver_python.KDLStateSolver_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        return _tesseract_state_solver_python.KDLStateSolver_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        return _tesseract_state_solver_python.KDLStateSolver_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        return _tesseract_state_solver_python.KDLStateSolver_hasLinkName(self, link_name)

    def getLinkTransforms(self):
        return _tesseract_state_solver_python.KDLStateSolver_getLinkTransforms(self)

    def getLinkTransform(self, link_name):
        return _tesseract_state_solver_python.KDLStateSolver_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name, to_link_name):
        return _tesseract_state_solver_python.KDLStateSolver_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self):
        return _tesseract_state_solver_python.KDLStateSolver_getLimits(self)

# Register KDLStateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.KDLStateSolver_swigregister(KDLStateSolver)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class OFKTStateSolver(MutableStateSolver):
    r"""
    An implementation of the Optimized Forward Kinematic Tree as a stat solver

    Starke, S., Hendrich, N., & Zhang, J. (2018). A Forward Kinematics Data Structure for Efficient Evolutionary Inverse
    Kinematics. In Computational Kinematics (pp. 560-568). Springer, Cham.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_OFKTStateSolver

    def __init__(self, *args):
        _tesseract_state_solver_python.OFKTStateSolver_swiginit(self, _tesseract_state_solver_python.new_OFKTStateSolver(*args))

    def setRevision(self, revision):
        return _tesseract_state_solver_python.OFKTStateSolver_setRevision(self, revision)

    def getRevision(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getRevision(self)

    def setState(self, *args):
        return _tesseract_state_solver_python.OFKTStateSolver_setState(self, *args)

    def getState(self, *args):
        return _tesseract_state_solver_python.OFKTStateSolver_getState(self, *args)

    def getRandomState(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getRandomState(self)

    def getJacobian(self, *args):
        return _tesseract_state_solver_python.OFKTStateSolver_getJacobian(self, *args)

    def getJointNames(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getJointNames(self)

    def getFloatingJointNames(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getFloatingJointNames(self)

    def getActiveJointNames(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getActiveJointNames(self)

    def getBaseLinkName(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getBaseLinkName(self)

    def getLinkNames(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getLinkNames(self)

    def getActiveLinkNames(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        return _tesseract_state_solver_python.OFKTStateSolver_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        return _tesseract_state_solver_python.OFKTStateSolver_hasLinkName(self, link_name)

    def getLinkTransforms(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getLinkTransforms(self)

    def getLinkTransform(self, link_name):
        return _tesseract_state_solver_python.OFKTStateSolver_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name, to_link_name):
        return _tesseract_state_solver_python.OFKTStateSolver_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self):
        return _tesseract_state_solver_python.OFKTStateSolver_getLimits(self)

    def addLink(self, link, joint):
        return _tesseract_state_solver_python.OFKTStateSolver_addLink(self, link, joint)

    def moveLink(self, joint):
        return _tesseract_state_solver_python.OFKTStateSolver_moveLink(self, joint)

    def removeLink(self, name):
        return _tesseract_state_solver_python.OFKTStateSolver_removeLink(self, name)

    def replaceJoint(self, joint):
        return _tesseract_state_solver_python.OFKTStateSolver_replaceJoint(self, joint)

    def removeJoint(self, name):
        return _tesseract_state_solver_python.OFKTStateSolver_removeJoint(self, name)

    def moveJoint(self, name, parent_link):
        return _tesseract_state_solver_python.OFKTStateSolver_moveJoint(self, name, parent_link)

    def changeJointOrigin(self, name, new_origin):
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointOrigin(self, name, new_origin)

    def changeJointPositionLimits(self, name, lower, upper):
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointPositionLimits(self, name, lower, upper)

    def changeJointVelocityLimits(self, name, limit):
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointVelocityLimits(self, name, limit)

    def changeJointAccelerationLimits(self, name, limit):
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointAccelerationLimits(self, name, limit)

    def changeJointJerkLimits(self, name, limit):
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointJerkLimits(self, name, limit)

    def insertSceneGraph(self, *args):
        return _tesseract_state_solver_python.OFKTStateSolver_insertSceneGraph(self, *args)

    def clone(self):
        return _tesseract_state_solver_python.OFKTStateSolver_clone(self)

# Register OFKTStateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.OFKTStateSolver_swigregister(OFKTStateSolver)

