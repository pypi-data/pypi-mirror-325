# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_geometry_python
else:
    import _tesseract_geometry_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_geometry_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_geometry_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_geometry_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_geometry_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_geometry_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_geometry_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_geometry_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_geometry_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_geometry_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_geometry_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_geometry_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_geometry_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_geometry_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_geometry_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_geometry_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_geometry_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_geometry_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_geometry_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_geometry_python:
_tesseract_geometry_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_common.tesseract_common_python
@_swig_add_metaclass(_SwigNonDynamicMeta)
class VectorMeshTexture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.VectorMeshTexture_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.VectorMeshTexture___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.VectorMeshTexture___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.VectorMeshTexture___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.VectorMeshTexture___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.VectorMeshTexture___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.VectorMeshTexture_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.VectorMeshTexture_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.VectorMeshTexture_empty(self)

    def size(self):
        return _tesseract_geometry_python.VectorMeshTexture_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.VectorMeshTexture_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.VectorMeshTexture_begin(self)

    def end(self):
        return _tesseract_geometry_python.VectorMeshTexture_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.VectorMeshTexture_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.VectorMeshTexture_rend(self)

    def clear(self):
        return _tesseract_geometry_python.VectorMeshTexture_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.VectorMeshTexture_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.VectorMeshTexture_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.VectorMeshTexture_swiginit(self, _tesseract_geometry_python.new_VectorMeshTexture(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.VectorMeshTexture_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.VectorMeshTexture_front(self)

    def back(self):
        return _tesseract_geometry_python.VectorMeshTexture_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.VectorMeshTexture_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.VectorMeshTexture_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.VectorMeshTexture_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.VectorMeshTexture_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_VectorMeshTexture

# Register VectorMeshTexture in _tesseract_geometry_python:
_tesseract_geometry_python.VectorMeshTexture_swigregister(VectorMeshTexture)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class MeshMaterial(object):
    r"""
    Represents material information extracted from a mesh file

    Mesh files contain material information. The mesh parser will
    extract the material information and store it in a MeshMaterial instance.
    The MeshMaterial class uses a subset PBR Metallic workflow, as specified
    in the glTF 2.0 file format standard. The four parameters supported
    are baseColorFactor, metallicFactor, roughnessFactor, and emmisiveFactor. (The
    MeshTexture class stores diffuse textures that can be used for decals and
    fiducial marks, and is stored separately from MeshMaterial.)
    These four parameters and MeshTexture should be enough to display
    "CAD quality" renderings in visualizers. The full mesh file should be used
    when higher quality rendering is required.

    The MeshMaterial favors PBR materials extracted from glTF 2.0 files. COLLADA does
    not support PBR. Only "Diffuse" and "Emissive" are read. "Specular" and "Ambient"
    are ignored.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Construct a new MeshMaterial

        :type base_color_factor: Eigen::Vector4d
        :param base_color_factor: The base color of the mesh
        :type metallic_factor: float
        :param metallic_factor: The metallic factor parameter (PBR parameter)
        :type roughness_factor: float
        :param roughness_factor: The roughness factor parameter (PBR parameter)
        :type emissive_factor: Eigen::Vector4d
        :param emissive_factor: The emissivity of the mesh
        """
        _tesseract_geometry_python.MeshMaterial_swiginit(self, _tesseract_geometry_python.new_MeshMaterial(*args))

    def getBaseColorFactor(self):
        r"""
        Get the base color of the mesh

        :rtype: Eigen::Vector4d
        :return: The base color in RGBA
        """
        return _tesseract_geometry_python.MeshMaterial_getBaseColorFactor(self)

    def getMetallicFactor(self):
        r"""
        Get the Metallic Factor of the mesh (PBR parameter)

        :rtype: float
        :return: The metallic factor, between 0 and 1
        """
        return _tesseract_geometry_python.MeshMaterial_getMetallicFactor(self)

    def getRoughnessFactor(self):
        r"""
        Get the Roughness Factor of the mesh (PBR parameter)

        :rtype: float
        :return: The roughness factor, between 0 and 1
        """
        return _tesseract_geometry_python.MeshMaterial_getRoughnessFactor(self)

    def getEmissiveFactor(self):
        r"""
        Get the emissive factor of the mesh

        "Emissive factor" is used to make the mesh "glow". How this is
        interpreted depends on the rendering engine.

        :rtype: Eigen::Vector4d
        :return: The emissive factor in RGBA
        """
        return _tesseract_geometry_python.MeshMaterial_getEmissiveFactor(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_MeshMaterial

# Register MeshMaterial in _tesseract_geometry_python:
_tesseract_geometry_python.MeshMaterial_swigregister(MeshMaterial)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class MeshTexture(object):
    r"""
    Represents a texture and UV coordinates extracted from a mesh file

    Mesh files contain (or reference) image files that form textures on the surface
    of the mesh. UV coordinates specify how the image is applied to the mesh. The
    MeshTexture structure contains a resource to the image, and the UV coordinates.
    Currently only jpg and png image formats are supported.

    UV coordinates specify the location of each vertex in the mesh
    on the texture. Each (u,v) coordinate is normalized to be
    between 0 and 1.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, texture_image, uvs):
        r"""
        Construct a new MeshTexture

        :type texture_image: :py:class:`Resource`
        :param texture_image: Resource representing the texture image (jpg or png)
        :type uvs: std::shared_ptr< tesseract_common::VectorVector2d const >
        :param uvs: UV coordinates for texture on mesh
        """
        _tesseract_geometry_python.MeshTexture_swiginit(self, _tesseract_geometry_python.new_MeshTexture(texture_image, uvs))

    def getTextureImage(self):
        r"""
        Get the texture image

        Must be jpg or png

        :rtype: :py:class:`Resource`
        :return: Resource to the texture image
        """
        return _tesseract_geometry_python.MeshTexture_getTextureImage(self)

    def getUVs(self):
        r"""
        Get the texture UV coordinates

        :rtype: std::shared_ptr< tesseract_common::VectorVector2d const >
        :return: UV coordinate vector
        """
        return _tesseract_geometry_python.MeshTexture_getUVs(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_MeshTexture

# Register MeshTexture in _tesseract_geometry_python:
_tesseract_geometry_python.MeshTexture_swigregister(MeshTexture)
GeometryType_UNINITIALIZED = _tesseract_geometry_python.GeometryType_UNINITIALIZED
GeometryType_SPHERE = _tesseract_geometry_python.GeometryType_SPHERE
GeometryType_CYLINDER = _tesseract_geometry_python.GeometryType_CYLINDER
GeometryType_CAPSULE = _tesseract_geometry_python.GeometryType_CAPSULE
GeometryType_CONE = _tesseract_geometry_python.GeometryType_CONE
GeometryType_BOX = _tesseract_geometry_python.GeometryType_BOX
GeometryType_PLANE = _tesseract_geometry_python.GeometryType_PLANE
GeometryType_MESH = _tesseract_geometry_python.GeometryType_MESH
GeometryType_CONVEX_MESH = _tesseract_geometry_python.GeometryType_CONVEX_MESH
GeometryType_SDF_MESH = _tesseract_geometry_python.GeometryType_SDF_MESH
GeometryType_OCTREE = _tesseract_geometry_python.GeometryType_OCTREE
GeometryType_POLYGON_MESH = _tesseract_geometry_python.GeometryType_POLYGON_MESH
GeometryType_COMPOUND_MESH = _tesseract_geometry_python.GeometryType_COMPOUND_MESH
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Geometry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_geometry_python.delete_Geometry

    def clone(self):
        r"""Create a copy of this shape"""
        return _tesseract_geometry_python.Geometry_clone(self)

    def getType(self):
        return _tesseract_geometry_python.Geometry_getType(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Geometry___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Geometry___ne__(self, rhs)

# Register Geometry in _tesseract_geometry_python:
_tesseract_geometry_python.Geometry_swigregister(Geometry)
cvar = _tesseract_geometry_python.cvar
GeometryTypeStrings = cvar.GeometryTypeStrings

@_swig_add_metaclass(_SwigNonDynamicMeta)
class Geometries(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.Geometries_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.Geometries___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.Geometries___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.Geometries___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.Geometries___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.Geometries___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.Geometries___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.Geometries___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.Geometries___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.Geometries___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.Geometries_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.Geometries_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.Geometries_empty(self)

    def size(self):
        return _tesseract_geometry_python.Geometries_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.Geometries_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.Geometries_begin(self)

    def end(self):
        return _tesseract_geometry_python.Geometries_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.Geometries_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.Geometries_rend(self)

    def clear(self):
        return _tesseract_geometry_python.Geometries_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.Geometries_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.Geometries_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.Geometries_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.Geometries_swiginit(self, _tesseract_geometry_python.new_Geometries(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.Geometries_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.Geometries_front(self)

    def back(self):
        return _tesseract_geometry_python.Geometries_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.Geometries_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.Geometries_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.Geometries_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.Geometries_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.Geometries_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_Geometries

# Register Geometries in _tesseract_geometry_python:
_tesseract_geometry_python.Geometries_swigregister(Geometries)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class GeometriesConst(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.GeometriesConst_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.GeometriesConst___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.GeometriesConst___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.GeometriesConst___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.GeometriesConst___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.GeometriesConst___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.GeometriesConst___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.GeometriesConst___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.GeometriesConst___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.GeometriesConst___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.GeometriesConst_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.GeometriesConst_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.GeometriesConst_empty(self)

    def size(self):
        return _tesseract_geometry_python.GeometriesConst_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.GeometriesConst_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.GeometriesConst_begin(self)

    def end(self):
        return _tesseract_geometry_python.GeometriesConst_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.GeometriesConst_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.GeometriesConst_rend(self)

    def clear(self):
        return _tesseract_geometry_python.GeometriesConst_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.GeometriesConst_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.GeometriesConst_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.GeometriesConst_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.GeometriesConst_swiginit(self, _tesseract_geometry_python.new_GeometriesConst(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.GeometriesConst_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.GeometriesConst_front(self)

    def back(self):
        return _tesseract_geometry_python.GeometriesConst_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.GeometriesConst_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.GeometriesConst_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.GeometriesConst_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.GeometriesConst_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.GeometriesConst_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_GeometriesConst

# Register GeometriesConst in _tesseract_geometry_python:
_tesseract_geometry_python.GeometriesConst_swigregister(GeometriesConst)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Box(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Box_swiginit(self, _tesseract_geometry_python.new_Box(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Box

    def getX(self):
        return _tesseract_geometry_python.Box_getX(self)

    def getY(self):
        return _tesseract_geometry_python.Box_getY(self)

    def getZ(self):
        return _tesseract_geometry_python.Box_getZ(self)

    def clone(self):
        return _tesseract_geometry_python.Box_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Box___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Box___ne__(self, rhs)

# Register Box in _tesseract_geometry_python:
_tesseract_geometry_python.Box_swigregister(Box)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Capsule(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Capsule_swiginit(self, _tesseract_geometry_python.new_Capsule(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Capsule

    def getRadius(self):
        return _tesseract_geometry_python.Capsule_getRadius(self)

    def getLength(self):
        return _tesseract_geometry_python.Capsule_getLength(self)

    def clone(self):
        return _tesseract_geometry_python.Capsule_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Capsule___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Capsule___ne__(self, rhs)

# Register Capsule in _tesseract_geometry_python:
_tesseract_geometry_python.Capsule_swigregister(Capsule)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class PolygonMeshVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.PolygonMeshVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.PolygonMeshVector___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.PolygonMeshVector___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.PolygonMeshVector___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.PolygonMeshVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.PolygonMeshVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.PolygonMeshVector_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.PolygonMeshVector_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.PolygonMeshVector_empty(self)

    def size(self):
        return _tesseract_geometry_python.PolygonMeshVector_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.PolygonMeshVector_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.PolygonMeshVector_begin(self)

    def end(self):
        return _tesseract_geometry_python.PolygonMeshVector_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.PolygonMeshVector_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.PolygonMeshVector_rend(self)

    def clear(self):
        return _tesseract_geometry_python.PolygonMeshVector_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.PolygonMeshVector_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.PolygonMeshVector_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.PolygonMeshVector_swiginit(self, _tesseract_geometry_python.new_PolygonMeshVector(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.PolygonMeshVector_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.PolygonMeshVector_front(self)

    def back(self):
        return _tesseract_geometry_python.PolygonMeshVector_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.PolygonMeshVector_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.PolygonMeshVector_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.PolygonMeshVector_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.PolygonMeshVector_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_PolygonMeshVector

# Register PolygonMeshVector in _tesseract_geometry_python:
_tesseract_geometry_python.PolygonMeshVector_swigregister(PolygonMeshVector)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class PolygonMesh(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 2:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 3:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 4:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 5:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 6:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 7:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 8:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 9:*

        Polygon Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :param resource: A resource locator for locating resource
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)
        """
        _tesseract_geometry_python.PolygonMesh_swiginit(self, _tesseract_geometry_python.new_PolygonMesh(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_PolygonMesh

    def getVertices(self):
        r"""
        Get Polygon mesh vertices
        :rtype: std::shared_ptr< tesseract_common::VectorVector3d const >
        :return: A vector of vertices
        """
        return _tesseract_geometry_python.PolygonMesh_getVertices(self)

    def getFaces(self):
        r"""
        Get Polygon mesh faces
        :rtype: std::shared_ptr< Eigen::VectorXi const >
        :return: A vector of face indices
        """
        return _tesseract_geometry_python.PolygonMesh_getFaces(self)

    def getVertexCount(self):
        r"""
        Get vertex count
        :rtype: int
        :return: Number of vertices
        """
        return _tesseract_geometry_python.PolygonMesh_getVertexCount(self)

    def getFaceCount(self):
        r"""
        Get face count
        :rtype: int
        :return: Number of faces
        """
        return _tesseract_geometry_python.PolygonMesh_getFaceCount(self)

    def getResource(self):
        r"""
        Get the path to file used to generate the mesh

        Note: If empty, assume it was manually generated.

        :rtype: :py:class:`Resource`
        :return: Absolute path to the mesh file
        """
        return _tesseract_geometry_python.PolygonMesh_getResource(self)

    def getScale(self):
        r"""
        Get the scale applied to file used to generate the mesh
        :rtype: Eigen::Vector3d
        :return: The scale x, y, z
        """
        return _tesseract_geometry_python.PolygonMesh_getScale(self)

    def getNormals(self):
        r"""
        Get the vertex normal vectors

        Optional, may be nullptr

        :rtype: std::shared_ptr< tesseract_common::VectorVector3d const >
        :return: The vertex normal vector
        """
        return _tesseract_geometry_python.PolygonMesh_getNormals(self)

    def getVertexColors(self):
        r"""
        Get the vertex colors

        Optional, may be nullptr

        :rtype: std::shared_ptr< tesseract_common::VectorVector4d const >
        :return: Vertex colors
        """
        return _tesseract_geometry_python.PolygonMesh_getVertexColors(self)

    def getMaterial(self):
        r"""
        Get material data extracted from the mesh file

        Mesh files contain material information. The mesh parser will
        extract the material information and store it in a MeshMaterial structure.

        :rtype: :py:class:`MeshMaterial`
        :return: The MeshMaterial data extracted from mesh file
        """
        return _tesseract_geometry_python.PolygonMesh_getMaterial(self)

    def getTextures(self):
        r"""
        Get textures extracted from the mesh file

        Mesh files contain (or reference) image files that form textures on the surface
        of the mesh. UV coordinates specify how the image is applied to the mesh. The
        MeshTexture structure contains a resource to the image, and the UV coordinates.
        Currently only jpg and png image formats are supported.

        :rtype: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >
        :return: Vector of mesh textures
        """
        return _tesseract_geometry_python.PolygonMesh_getTextures(self)

    def clone(self):
        return _tesseract_geometry_python.PolygonMesh_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.PolygonMesh___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.PolygonMesh___ne__(self, rhs)

# Register PolygonMesh in _tesseract_geometry_python:
_tesseract_geometry_python.PolygonMesh_swigregister(PolygonMesh)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Cone(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Cone_swiginit(self, _tesseract_geometry_python.new_Cone(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Cone

    def getRadius(self):
        return _tesseract_geometry_python.Cone_getRadius(self)

    def getLength(self):
        return _tesseract_geometry_python.Cone_getLength(self)

    def clone(self):
        return _tesseract_geometry_python.Cone_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Cone___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Cone___ne__(self, rhs)

# Register Cone in _tesseract_geometry_python:
_tesseract_geometry_python.Cone_swigregister(Cone)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ConvexMeshVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.ConvexMeshVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.ConvexMeshVector___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.ConvexMeshVector___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.ConvexMeshVector___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.ConvexMeshVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.ConvexMeshVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.ConvexMeshVector_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.ConvexMeshVector_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.ConvexMeshVector_empty(self)

    def size(self):
        return _tesseract_geometry_python.ConvexMeshVector_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.ConvexMeshVector_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.ConvexMeshVector_begin(self)

    def end(self):
        return _tesseract_geometry_python.ConvexMeshVector_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.ConvexMeshVector_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.ConvexMeshVector_rend(self)

    def clear(self):
        return _tesseract_geometry_python.ConvexMeshVector_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.ConvexMeshVector_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.ConvexMeshVector_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.ConvexMeshVector_swiginit(self, _tesseract_geometry_python.new_ConvexMeshVector(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.ConvexMeshVector_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.ConvexMeshVector_front(self)

    def back(self):
        return _tesseract_geometry_python.ConvexMeshVector_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.ConvexMeshVector_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.ConvexMeshVector_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.ConvexMeshVector_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.ConvexMeshVector_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_ConvexMeshVector

# Register ConvexMeshVector in _tesseract_geometry_python:
_tesseract_geometry_python.ConvexMeshVector_swigregister(ConvexMeshVector)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ConvexMesh(PolygonMesh):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    DEFAULT = _tesseract_geometry_python.ConvexMesh_DEFAULT
    MESH = _tesseract_geometry_python.ConvexMesh_MESH
    CONVERTED = _tesseract_geometry_python.ConvexMesh_CONVERTED

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 2:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 3:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 4:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 5:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 6:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 7:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 8:*

        Convex Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type faces: std::shared_ptr< Eigen::VectorXi const >
        :param faces: A vector of face indices, where the first number indicates the number of vertices
                         associated with the face, followed by the vertex index in parameter vertices. For
                         example, a triangle has three vertices, so there should be four inputs, where the
                         first should be 3, indicating there are three vertices that define this face,
                         followed by three indices.
        :type face_count: int
        :param face_count: Provide the number of faces. This is faster because it does not need to loop
                              over the faces.
        :param resource: A resource locator for locating resource
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: Describes the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)
        """
        _tesseract_geometry_python.ConvexMesh_swiginit(self, _tesseract_geometry_python.new_ConvexMesh(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_ConvexMesh

    def getCreationMethod(self):
        r"""
        Get how the convex hull was created
        Notes: This used when writing back out to urdf
        :rtype: int
        :return: The CreationMethod
        """
        return _tesseract_geometry_python.ConvexMesh_getCreationMethod(self)

    def setCreationMethod(self, method):
        r"""
        Set the method used to create the convex mesh
        Notes: This used when writing back out to urdf
        :param value: The CreationMethod
        """
        return _tesseract_geometry_python.ConvexMesh_setCreationMethod(self, method)

    def clone(self):
        return _tesseract_geometry_python.ConvexMesh_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.ConvexMesh___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.ConvexMesh___ne__(self, rhs)

# Register ConvexMesh in _tesseract_geometry_python:
_tesseract_geometry_python.ConvexMesh_swigregister(ConvexMesh)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Cylinder(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Cylinder_swiginit(self, _tesseract_geometry_python.new_Cylinder(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Cylinder

    def getRadius(self):
        return _tesseract_geometry_python.Cylinder_getRadius(self)

    def getLength(self):
        return _tesseract_geometry_python.Cylinder_getLength(self)

    def clone(self):
        return _tesseract_geometry_python.Cylinder_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Cylinder___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Cylinder___ne__(self, rhs)

# Register Cylinder in _tesseract_geometry_python:
_tesseract_geometry_python.Cylinder_swigregister(Cylinder)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class MeshVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.MeshVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.MeshVector___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.MeshVector___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.MeshVector___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.MeshVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.MeshVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.MeshVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.MeshVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.MeshVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.MeshVector___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.MeshVector_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.MeshVector_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.MeshVector_empty(self)

    def size(self):
        return _tesseract_geometry_python.MeshVector_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.MeshVector_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.MeshVector_begin(self)

    def end(self):
        return _tesseract_geometry_python.MeshVector_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.MeshVector_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.MeshVector_rend(self)

    def clear(self):
        return _tesseract_geometry_python.MeshVector_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.MeshVector_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.MeshVector_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.MeshVector_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.MeshVector_swiginit(self, _tesseract_geometry_python.new_MeshVector(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.MeshVector_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.MeshVector_front(self)

    def back(self):
        return _tesseract_geometry_python.MeshVector_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.MeshVector_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.MeshVector_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.MeshVector_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.MeshVector_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.MeshVector_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_MeshVector

# Register MeshVector in _tesseract_geometry_python:
_tesseract_geometry_python.MeshVector_swigregister(MeshVector)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Mesh(PolygonMesh):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 2:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 3:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 4:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 5:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 6:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 7:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 8:*

        Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertex index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :param resource: A resource locator for locating resource
        :param scale: Scale the resource mesh. The stored mesh data will already be scaled but if using the resource use
            this.
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)
        """
        _tesseract_geometry_python.Mesh_swiginit(self, _tesseract_geometry_python.new_Mesh(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Mesh

    def clone(self):
        return _tesseract_geometry_python.Mesh_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Mesh___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Mesh___ne__(self, rhs)

# Register Mesh in _tesseract_geometry_python:
_tesseract_geometry_python.Mesh_swigregister(Mesh)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class OcTree(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_geometry_python.delete_OcTree

# Register OcTree in _tesseract_geometry_python:
_tesseract_geometry_python.OcTree_swigregister(OcTree)
OctreeSubType_BOX = _tesseract_geometry_python.OctreeSubType_BOX
OctreeSubType_SPHERE_INSIDE = _tesseract_geometry_python.OctreeSubType_SPHERE_INSIDE
OctreeSubType_SPHERE_OUTSIDE = _tesseract_geometry_python.OctreeSubType_SPHERE_OUTSIDE
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Octree(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Octree_swiginit(self, _tesseract_geometry_python.new_Octree(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Octree

    def getOctree(self):
        return _tesseract_geometry_python.Octree_getOctree(self)

    def getSubType(self):
        return _tesseract_geometry_python.Octree_getSubType(self)

    def getPruned(self):
        return _tesseract_geometry_python.Octree_getPruned(self)

    def clone(self):
        return _tesseract_geometry_python.Octree_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Octree___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Octree___ne__(self, rhs)

    def update(self):
        r"""
        Octrees are typically generated from 3D sensor data so this method
        should be used to efficiently update the collision shape.
        """
        return _tesseract_geometry_python.Octree_update(self)

    def calcNumSubShapes(self):
        r"""
        Calculate the number of sub shapes that would get generated for this octree

        This is expensive and should not be called multiple times

        :rtype: int
        :return: number of sub shapes
        """
        return _tesseract_geometry_python.Octree_calcNumSubShapes(self)

    @staticmethod
    def prune(octree):
        r"""
        A custom octree prune which will prune if all children are above the occupancy threshold.

        This is different from the octomap::OcTree::prune which requires all children to have the same
        occupancy to be collapsed.

        :type octree: :py:class:`OcTree`
        :param octree: The octree to be pruned.
        """
        return _tesseract_geometry_python.Octree_prune(octree)

# Register Octree in _tesseract_geometry_python:
_tesseract_geometry_python.Octree_swigregister(Octree)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Plane(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Plane_swiginit(self, _tesseract_geometry_python.new_Plane(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Plane

    def getA(self):
        return _tesseract_geometry_python.Plane_getA(self)

    def getB(self):
        return _tesseract_geometry_python.Plane_getB(self)

    def getC(self):
        return _tesseract_geometry_python.Plane_getC(self)

    def getD(self):
        return _tesseract_geometry_python.Plane_getD(self)

    def clone(self):
        return _tesseract_geometry_python.Plane_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Plane___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Plane___ne__(self, rhs)

# Register Plane in _tesseract_geometry_python:
_tesseract_geometry_python.Plane_swigregister(Plane)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class SDFMeshVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_geometry_python.SDFMeshVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_geometry_python.SDFMeshVector___nonzero__(self)

    def __bool__(self):
        return _tesseract_geometry_python.SDFMeshVector___bool__(self)

    def __len__(self):
        return _tesseract_geometry_python.SDFMeshVector___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_geometry_python.SDFMeshVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_geometry_python.SDFMeshVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_geometry_python.SDFMeshVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_geometry_python.SDFMeshVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_geometry_python.SDFMeshVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_geometry_python.SDFMeshVector___setitem__(self, *args)

    def pop(self):
        return _tesseract_geometry_python.SDFMeshVector_pop(self)

    def append(self, x):
        return _tesseract_geometry_python.SDFMeshVector_append(self, x)

    def empty(self):
        return _tesseract_geometry_python.SDFMeshVector_empty(self)

    def size(self):
        return _tesseract_geometry_python.SDFMeshVector_size(self)

    def swap(self, v):
        return _tesseract_geometry_python.SDFMeshVector_swap(self, v)

    def begin(self):
        return _tesseract_geometry_python.SDFMeshVector_begin(self)

    def end(self):
        return _tesseract_geometry_python.SDFMeshVector_end(self)

    def rbegin(self):
        return _tesseract_geometry_python.SDFMeshVector_rbegin(self)

    def rend(self):
        return _tesseract_geometry_python.SDFMeshVector_rend(self)

    def clear(self):
        return _tesseract_geometry_python.SDFMeshVector_clear(self)

    def get_allocator(self):
        return _tesseract_geometry_python.SDFMeshVector_get_allocator(self)

    def pop_back(self):
        return _tesseract_geometry_python.SDFMeshVector_pop_back(self)

    def erase(self, *args):
        return _tesseract_geometry_python.SDFMeshVector_erase(self, *args)

    def __init__(self, *args):
        _tesseract_geometry_python.SDFMeshVector_swiginit(self, _tesseract_geometry_python.new_SDFMeshVector(*args))

    def push_back(self, x):
        return _tesseract_geometry_python.SDFMeshVector_push_back(self, x)

    def front(self):
        return _tesseract_geometry_python.SDFMeshVector_front(self)

    def back(self):
        return _tesseract_geometry_python.SDFMeshVector_back(self)

    def assign(self, n, x):
        return _tesseract_geometry_python.SDFMeshVector_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_geometry_python.SDFMeshVector_resize(self, *args)

    def insert(self, *args):
        return _tesseract_geometry_python.SDFMeshVector_insert(self, *args)

    def reserve(self, n):
        return _tesseract_geometry_python.SDFMeshVector_reserve(self, n)

    def capacity(self):
        return _tesseract_geometry_python.SDFMeshVector_capacity(self)
    __swig_destroy__ = _tesseract_geometry_python.delete_SDFMeshVector

# Register SDFMeshVector in _tesseract_geometry_python:
_tesseract_geometry_python.SDFMeshVector_swigregister(SDFMeshVector)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class SDFMesh(PolygonMesh):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 2:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :type mesh_textures: std::shared_ptr< std::vector< std::shared_ptr< tesseract_geometry::MeshTexture >,std::allocator< std::shared_ptr< tesseract_geometry::MeshTexture > > > const >, optional
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 3:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :type mesh_material: :py:class:`MeshMaterial`, optional
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 4:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :type vertex_colors: std::shared_ptr< tesseract_common::VectorVector4d const >, optional
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 5:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :type normals: std::shared_ptr< tesseract_common::VectorVector3d const >, optional
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 6:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :type scale: Eigen::Vector3d, optional
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 7:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :type resource: :py:class:`Resource`, optional
        :param resource: A resource locator for locating resource
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)

        |

        *Overload 8:*

        SDF Mesh geometry
        :type vertices: std::shared_ptr< tesseract_common::VectorVector3d const >
        :param vertices: A vector of vertices associated with the mesh
        :type triangles: std::shared_ptr< Eigen::VectorXi const >
        :param triangles: A vector of face indices where the first index indicates the number of vertices associated
                             with the face followed by the vertices index in parameter vertices. For example a triangle
                             has three vertices so there should be four inputs where the first should be 3 indicating there are
                             three vertices that define this face followed by three indices.
        :type triangle_count: int
        :param triangle_count: Provide the number of faces. This is faster because it does not need to loop over triangles.
        :param resource: A resource locator for locating resource
        :param scale: Scale the mesh
        :param normals: A vector of normals for the vertices (optional)
        :param vertex_colors: A vector of colors (RGBA) for the vertices (optional)
        :param mesh_material: A MeshMaterial describing the color and material properties of the mesh (optional)
        :param mesh_textures: A vector of MeshTexture to apply to the mesh (optional)
        """
        _tesseract_geometry_python.SDFMesh_swiginit(self, _tesseract_geometry_python.new_SDFMesh(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_SDFMesh

    def clone(self):
        return _tesseract_geometry_python.SDFMesh_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.SDFMesh___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.SDFMesh___ne__(self, rhs)

# Register SDFMesh in _tesseract_geometry_python:
_tesseract_geometry_python.SDFMesh_swigregister(SDFMesh)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Sphere(Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.Sphere_swiginit(self, _tesseract_geometry_python.new_Sphere(*args))
    __swig_destroy__ = _tesseract_geometry_python.delete_Sphere

    def getRadius(self):
        return _tesseract_geometry_python.Sphere_getRadius(self)

    def clone(self):
        return _tesseract_geometry_python.Sphere_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.Sphere___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.Sphere___ne__(self, rhs)

# Register Sphere in _tesseract_geometry_python:
_tesseract_geometry_python.Sphere_swigregister(Sphere)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class CompoundMesh(Geometry):
    r"""This is store meshes that are associated with as single resource"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_geometry_python.CompoundMesh_swiginit(self, _tesseract_geometry_python.new_CompoundMesh(*args))

    def getMeshes(self):
        r"""
        Get the meshes
        :rtype: std::vector< std::shared_ptr< tesseract_geometry::PolygonMesh >,std::allocator< std::shared_ptr< tesseract_geometry::PolygonMesh > > >
        :return: The meshes
        """
        return _tesseract_geometry_python.CompoundMesh_getMeshes(self)

    def getResource(self):
        r"""
        Get the path to file used to generate the meshs

        Note: If empty, assume it was manually generated.

        :rtype: :py:class:`Resource`
        :return: Absolute path to the mesh file
        """
        return _tesseract_geometry_python.CompoundMesh_getResource(self)

    def getScale(self):
        r"""
        Get the scale applied to file used to generate the meshs
        :rtype: Eigen::Vector3d
        :return: The scale x, y, z
        """
        return _tesseract_geometry_python.CompoundMesh_getScale(self)

    def clone(self):
        return _tesseract_geometry_python.CompoundMesh_clone(self)

    def __eq__(self, rhs):
        return _tesseract_geometry_python.CompoundMesh___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_geometry_python.CompoundMesh___ne__(self, rhs)
    __swig_destroy__ = _tesseract_geometry_python.delete_CompoundMesh

# Register CompoundMesh in _tesseract_geometry_python:
_tesseract_geometry_python.CompoundMesh_swigregister(CompoundMesh)

def isIdentical(geom1, geom2):
    r"""
    Check if two Geometries are identical
    :type geom1: :py:class:`Geometry`
    :param geom1: First Geometry
    :type geom2: :py:class:`Geometry`
    :param geom2: Second Geometry
    :rtype: boolean
    :return: True if identical, otherwise false
    """
    return _tesseract_geometry_python.isIdentical(geom1, geom2)

def createMeshFromResource(*args):
    r"""
    Create a mesh using assimp from resource
    :type resource: :py:class:`Resource`
    :param resource: The located resource
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::Mesh >,std::allocator< std::shared_ptr< tesseract_geometry::Mesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createMeshFromResource(*args)

def createSDFMeshFromResource(*args):
    r"""
    Create a mesh using assimp from resource
    :type resource: :py:class:`Resource`
    :param resource: The located resource
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::SDFMesh >,std::allocator< std::shared_ptr< tesseract_geometry::SDFMesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createSDFMeshFromResource(*args)

def createConvexMeshFromResource(*args):
    r"""
    Create a mesh using assimp from resource
    :type resource: :py:class:`Resource`
    :param resource: The located resource
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::ConvexMesh >,std::allocator< std::shared_ptr< tesseract_geometry::ConvexMesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createConvexMeshFromResource(*args)

def createMeshFromPath(*args):
    r"""
    Create a mesh using assimp from file path
    :type path: string
    :param path: The file path to the mesh
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::Mesh >,std::allocator< std::shared_ptr< tesseract_geometry::Mesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createMeshFromPath(*args)

def createSDFMeshFromPath(*args):
    r"""
    Create a mesh using assimp from file path
    :type path: string
    :param path: The file path to the mesh
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::SDFMesh >,std::allocator< std::shared_ptr< tesseract_geometry::SDFMesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createSDFMeshFromPath(*args)

def createConvexMeshFromPath(*args):
    r"""
    Create a mesh using assimp from file path
    :type path: string
    :param path: The file path to the mesh
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::ConvexMesh >,std::allocator< std::shared_ptr< tesseract_geometry::ConvexMesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createConvexMeshFromPath(*args)

def createMeshFromBytes(*args):
    r"""
    Create a mesh from byte array
    :type url: string
    :param url: The URL of source resource
    :type bytes: uint8_t
    :param bytes: Byte array
    :type bytes_len: int
    :param bytes_len: The length of bytes
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::Mesh >,std::allocator< std::shared_ptr< tesseract_geometry::Mesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createMeshFromBytes(*args)

def createSDFMeshFromBytes(*args):
    r"""
    Create a mesh from byte array
    :type url: string
    :param url: The URL of source resource
    :type bytes: uint8_t
    :param bytes: Byte array
    :type bytes_len: int
    :param bytes_len: The length of bytes
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::SDFMesh >,std::allocator< std::shared_ptr< tesseract_geometry::SDFMesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createSDFMeshFromBytes(*args)

def createConvexMeshFromBytes(*args):
    r"""
    Create a mesh from byte array
    :type url: string
    :param url: The URL of source resource
    :type bytes: uint8_t
    :param bytes: Byte array
    :type bytes_len: int
    :param bytes_len: The length of bytes
    :type scale: Eigen::Vector3d, optional
    :param scale: Perform an axis scaling
    :type triangulate: boolean, optional
    :param triangulate: If true the mesh will be triangulated. This should be done for visual meshes.
               In the case of collision meshes do not triangulate convex hull meshes.
    :type flatten: boolean, optional
    :param flatten: If true all meshes will be condensed into a single mesh. This should only be used for visual meshes,
        do not flatten collision meshes.
    :type normals: boolean, optional
    :param normals: If true, loads mesh normals
    :type vertex_colors: boolean, optional
    :param vertex_colors: If true, loads mesh vertex colors
    :type material_and_texture: boolean, optional
    :param material_and_texture: If true, loads mesh materials and textures
    :rtype: std::vector< std::shared_ptr< tesseract_geometry::ConvexMesh >,std::allocator< std::shared_ptr< tesseract_geometry::ConvexMesh > > >
    :return: 
    """
    return _tesseract_geometry_python.createConvexMeshFromBytes(*args)

