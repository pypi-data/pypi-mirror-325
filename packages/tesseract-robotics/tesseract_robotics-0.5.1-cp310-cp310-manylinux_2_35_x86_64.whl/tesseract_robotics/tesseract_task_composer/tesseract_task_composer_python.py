# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_task_composer_python
else:
    import _tesseract_task_composer_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_task_composer_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_task_composer_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_task_composer_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_task_composer_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_task_composer_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_task_composer_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_task_composer_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_task_composer_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_task_composer_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_task_composer_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_task_composer_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_task_composer_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_task_composer_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_task_composer_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_task_composer_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_task_composer_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_task_composer_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_task_composer_python:
_tesseract_task_composer_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_motion_planners_simple.tesseract_motion_planners_simple_python
import tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python
import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
import tesseract_robotics.tesseract_motion_planners_trajopt.tesseract_motion_planners_trajopt_python
import tesseract_robotics.tesseract_motion_planners_ompl.tesseract_motion_planners_ompl_python
import tesseract_robotics.tesseract_motion_planners_descartes.tesseract_motion_planners_descartes_python
import tesseract_robotics.tesseract_time_parameterization.tesseract_time_parameterization_python
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerKeys(object):
    r"""
    Copyright: Copyright (c) 2022, Levi Armstrong

    Title: License
    Software License Agreement (Apache License)
    Title: Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Title: Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def add(self, *args):
        r"""
        *Overload 1:*

        Add key
        :type port: string
        :param port: The port name associated with the key
        :type key: string
        :param key: The key assigned to the port

        |

        *Overload 2:*

        Add keys
        :type port: string
        :param port: The port name associated with the keys
        :param key: The keys assigned to the port
        """
        return _tesseract_task_composer_python.TaskComposerKeys_add(self, *args)

    def rename(self, keys):
        r"""
        Rename keys
        :type keys: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :param keys: The key renamming map
        """
        return _tesseract_task_composer_python.TaskComposerKeys_rename(self, keys)

    def has(self, port):
        r"""
        Check if port exist
        :type port: string
        :param port: The port name
        :rtype: boolean
        :return: True if entry exist, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerKeys_has(self, port)

    def data(self):
        r"""
        Get the data container object
        :rtype: tesseract_planning::TaskComposerKeys::ContainerType
        :return: The data container object
        """
        return _tesseract_task_composer_python.TaskComposerKeys_data(self)

    def size(self):
        r""" The size"""
        return _tesseract_task_composer_python.TaskComposerKeys_size(self)

    def empty(self):
        r""" Check if empty"""
        return _tesseract_task_composer_python.TaskComposerKeys_empty(self)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerKeys___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerKeys___ne__(self, rhs)

    def get(self, port):
        r"""
        Get key/keys assigned to port
        :type port: string
        :param port: The port to retrieve key/keys
        :rtype: string
        :return: The key/keys assigned to port
        """
        return _tesseract_task_composer_python.TaskComposerKeys_get(self, port)

    def __init__(self):
        _tesseract_task_composer_python.TaskComposerKeys_swiginit(self, _tesseract_task_composer_python.new_TaskComposerKeys())
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerKeys

# Register TaskComposerKeys in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerKeys_swigregister(TaskComposerKeys)

def __lshift__(os, keys):
    return _tesseract_task_composer_python.__lshift__(os, keys)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNodeInfoUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerNodeInfoUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNodeInfoUPtr
    name = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_name_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_name_set, doc=r""" The name of the task""")
    ns = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_ns_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_ns_set, doc=r""" The namespace of the task""")
    uuid = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_uuid_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_uuid_set, doc=r""" The task uuid""")
    root_uuid = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_root_uuid_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_root_uuid_set, doc=r""" If type is Pipeline or Graph this will be the root node of the pipeline or graph, otherwise null""")
    parent_uuid = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_parent_uuid_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_parent_uuid_set, doc=r"""
    The parent uuid
    This is set when the node is added to a graph
    """)
    type = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_type_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_type_set, doc=r""" The node type""")
    type_hash_code = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_type_hash_code_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_type_hash_code_set, doc=r""" The task type hash code from std::type_index""")
    conditional = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_conditional_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_conditional_set, doc=r""" The task is conditional or not""")
    inbound_edges = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_inbound_edges_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_inbound_edges_set, doc=r""" The nodes inbound edges""")
    outbound_edges = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_outbound_edges_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_outbound_edges_set, doc=r""" The nodes outbound edges""")
    input_keys = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_input_keys_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_input_keys_set, doc=r""" The input keys""")
    output_keys = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_output_keys_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_output_keys_set, doc=r""" The output keys""")
    terminals = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_terminals_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_terminals_set, doc=r""" The graph of pipeline terminals""")
    triggers_abort = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_triggers_abort_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_triggers_abort_set, doc=r""" Indicate if it can trigger a abort.""")
    return_value = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_return_value_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_return_value_set, doc=r""" Value returned from the Task on completion""")
    status_code = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_status_code_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_status_code_set, doc=r""" Status code""")
    status_message = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_status_message_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_status_message_set, doc=r""" Status message""")
    start_time = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_start_time_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_start_time_set, doc=r""" The start time""")
    elapsed_time = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_elapsed_time_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_elapsed_time_set, doc=r"""
    Time spent in this task in seconds
    This is managed by core components so implementation do not need to calculate this
    """)
    color = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_color_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_color_set, doc=r""" The DOT Graph color to fill with""")
    dotgraph = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_dotgraph_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_dotgraph_set, doc=r"""
    dot graph string for visualization
    This should only be populated if node generates dynamic nodes
    """)
    data_storage = property(_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_data_storage_get, _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_data_storage_set, doc=r""" This provides a location for task data may be stored""")

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr___ne__(self, rhs)

    def isAborted(self):
        r"""
        Check if task was not ran because process was aborted
        :rtype: boolean
        :return: True if aborted otherwise false;
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoUPtr_isAborted(self)

# Register TaskComposerNodeInfoUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNodeInfoUPtr_swigregister(TaskComposerNodeInfoUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNodeInfoContainerUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerNodeInfoContainerUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNodeInfoContainerUPtr

    def addInfo(self, info):
        r"""
        Add info to the container
        :type info: :py:class:`UPtr`
        :param info: The info to be added
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_addInfo(self, info)

    def getInfo(self, key):
        r"""
        Get info for the provided key
        :type key: :py:class:`uuid`
        :param key: The key to retrieve info for
        :rtype: :py:class:`UPtr`
        :return: If key does not exist nullptr, otherwise a clone of the info
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_getInfo(self, key)

    def insertInfoMap(self, container):
        r""" Insert the contents of another container's info map"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_insertInfoMap(self, container)

    def mergeInfoMap(self, container):
        r""" Merge the contents of another container's info map"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_mergeInfoMap(self, container)

    def setRootNode(self, node_uuid):
        r""" Set the root node"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_setRootNode(self, node_uuid)

    def getRootNode(self):
        r""" Get the root node"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_getRootNode(self)

    def setAborted(self, node_uuid):
        r"""
        Called if aborted
        This is set if abort is called in input
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_setAborted(self, node_uuid)

    def getAbortingNode(self):
        r"""
        Get the aborting node
        :rtype: :py:class:`uuid`
        :return: Null if not set, otherwise nodes uuid
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_getAbortingNode(self)

    def clear(self):
        r""" Clear the contents"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_clear(self)

    def prune(self, prune_fn):
        r""" Prune data from node infos to save space"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_prune(self, prune_fn)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr___ne__(self, rhs)

# Register TaskComposerNodeInfoContainerUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNodeInfoContainerUPtr_swigregister(TaskComposerNodeInfoContainerUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNodeInfo(object):
    r""" Stores information about a node"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNodeInfo

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerNodeInfo_swiginit(self, _tesseract_task_composer_python.new_TaskComposerNodeInfo(*args))
    name = property(_tesseract_task_composer_python.TaskComposerNodeInfo_name_get, _tesseract_task_composer_python.TaskComposerNodeInfo_name_set, doc=r""" The name of the task""")
    ns = property(_tesseract_task_composer_python.TaskComposerNodeInfo_ns_get, _tesseract_task_composer_python.TaskComposerNodeInfo_ns_set, doc=r""" The namespace of the task""")
    uuid = property(_tesseract_task_composer_python.TaskComposerNodeInfo_uuid_get, _tesseract_task_composer_python.TaskComposerNodeInfo_uuid_set, doc=r""" The task uuid""")
    root_uuid = property(_tesseract_task_composer_python.TaskComposerNodeInfo_root_uuid_get, _tesseract_task_composer_python.TaskComposerNodeInfo_root_uuid_set, doc=r""" If type is Pipeline or Graph this will be the root node of the pipeline or graph, otherwise null""")
    parent_uuid = property(_tesseract_task_composer_python.TaskComposerNodeInfo_parent_uuid_get, _tesseract_task_composer_python.TaskComposerNodeInfo_parent_uuid_set, doc=r"""
    The parent uuid
    This is set when the node is added to a graph
    """)
    type = property(_tesseract_task_composer_python.TaskComposerNodeInfo_type_get, _tesseract_task_composer_python.TaskComposerNodeInfo_type_set, doc=r""" The node type""")
    type_hash_code = property(_tesseract_task_composer_python.TaskComposerNodeInfo_type_hash_code_get, _tesseract_task_composer_python.TaskComposerNodeInfo_type_hash_code_set, doc=r""" The task type hash code from std::type_index""")
    conditional = property(_tesseract_task_composer_python.TaskComposerNodeInfo_conditional_get, _tesseract_task_composer_python.TaskComposerNodeInfo_conditional_set, doc=r""" The task is conditional or not""")
    inbound_edges = property(_tesseract_task_composer_python.TaskComposerNodeInfo_inbound_edges_get, _tesseract_task_composer_python.TaskComposerNodeInfo_inbound_edges_set, doc=r""" The nodes inbound edges""")
    outbound_edges = property(_tesseract_task_composer_python.TaskComposerNodeInfo_outbound_edges_get, _tesseract_task_composer_python.TaskComposerNodeInfo_outbound_edges_set, doc=r""" The nodes outbound edges""")
    input_keys = property(_tesseract_task_composer_python.TaskComposerNodeInfo_input_keys_get, _tesseract_task_composer_python.TaskComposerNodeInfo_input_keys_set, doc=r""" The input keys""")
    output_keys = property(_tesseract_task_composer_python.TaskComposerNodeInfo_output_keys_get, _tesseract_task_composer_python.TaskComposerNodeInfo_output_keys_set, doc=r""" The output keys""")
    terminals = property(_tesseract_task_composer_python.TaskComposerNodeInfo_terminals_get, _tesseract_task_composer_python.TaskComposerNodeInfo_terminals_set, doc=r""" The graph of pipeline terminals""")
    triggers_abort = property(_tesseract_task_composer_python.TaskComposerNodeInfo_triggers_abort_get, _tesseract_task_composer_python.TaskComposerNodeInfo_triggers_abort_set, doc=r""" Indicate if it can trigger a abort.""")
    return_value = property(_tesseract_task_composer_python.TaskComposerNodeInfo_return_value_get, _tesseract_task_composer_python.TaskComposerNodeInfo_return_value_set, doc=r""" Value returned from the Task on completion""")
    status_code = property(_tesseract_task_composer_python.TaskComposerNodeInfo_status_code_get, _tesseract_task_composer_python.TaskComposerNodeInfo_status_code_set, doc=r""" Status code""")
    status_message = property(_tesseract_task_composer_python.TaskComposerNodeInfo_status_message_get, _tesseract_task_composer_python.TaskComposerNodeInfo_status_message_set, doc=r""" Status message""")
    start_time = property(_tesseract_task_composer_python.TaskComposerNodeInfo_start_time_get, _tesseract_task_composer_python.TaskComposerNodeInfo_start_time_set, doc=r""" The start time""")
    elapsed_time = property(_tesseract_task_composer_python.TaskComposerNodeInfo_elapsed_time_get, _tesseract_task_composer_python.TaskComposerNodeInfo_elapsed_time_set, doc=r"""
    Time spent in this task in seconds
    This is managed by core components so implementation do not need to calculate this
    """)
    color = property(_tesseract_task_composer_python.TaskComposerNodeInfo_color_get, _tesseract_task_composer_python.TaskComposerNodeInfo_color_set, doc=r""" The DOT Graph color to fill with""")
    dotgraph = property(_tesseract_task_composer_python.TaskComposerNodeInfo_dotgraph_get, _tesseract_task_composer_python.TaskComposerNodeInfo_dotgraph_set, doc=r"""
    dot graph string for visualization
    This should only be populated if node generates dynamic nodes
    """)
    data_storage = property(_tesseract_task_composer_python.TaskComposerNodeInfo_data_storage_get, _tesseract_task_composer_python.TaskComposerNodeInfo_data_storage_set, doc=r""" This provides a location for task data may be stored""")

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfo___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfo___ne__(self, rhs)

    def isAborted(self):
        r"""
        Check if task was not ran because process was aborted
        :rtype: boolean
        :return: True if aborted otherwise false;
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfo_isAborted(self)

# Register TaskComposerNodeInfo in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNodeInfo_swigregister(TaskComposerNodeInfo)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNodeInfoContainer(object):
    r""" A threadsafe container for TaskComposerNodeInfo"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNodeInfoContainer

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerNodeInfoContainer_swiginit(self, _tesseract_task_composer_python.new_TaskComposerNodeInfoContainer(*args))

    def addInfo(self, info):
        r"""
        Add info to the container
        :type info: :py:class:`UPtr`
        :param info: The info to be added
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_addInfo(self, info)

    def getInfo(self, key):
        r"""
        Get info for the provided key
        :type key: :py:class:`uuid`
        :param key: The key to retrieve info for
        :rtype: :py:class:`UPtr`
        :return: If key does not exist nullptr, otherwise a clone of the info
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_getInfo(self, key)

    def insertInfoMap(self, container):
        r""" Insert the contents of another container's info map"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_insertInfoMap(self, container)

    def mergeInfoMap(self, container):
        r""" Merge the contents of another container's info map"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_mergeInfoMap(self, container)

    def setRootNode(self, node_uuid):
        r""" Set the root node"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_setRootNode(self, node_uuid)

    def getRootNode(self):
        r""" Get the root node"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_getRootNode(self)

    def setAborted(self, node_uuid):
        r"""
        Called if aborted
        This is set if abort is called in input
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_setAborted(self, node_uuid)

    def getAbortingNode(self):
        r"""
        Get the aborting node
        :rtype: :py:class:`uuid`
        :return: Null if not set, otherwise nodes uuid
        """
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_getAbortingNode(self)

    def clear(self):
        r""" Clear the contents"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_clear(self)

    def prune(self, prune_fn):
        r""" Prune data from node infos to save space"""
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer_prune(self, prune_fn)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeInfoContainer___ne__(self, rhs)

# Register TaskComposerNodeInfoContainer in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNodeInfoContainer_swigregister(TaskComposerNodeInfoContainer)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerDataStorageUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerDataStorageUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerDataStorageUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerDataStorageUPtr

    @staticmethod
    def make_unique():
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_make_unique()

    def getName(self):
        r"""
        Get the name data storage.
        This is primarily used to hold the pipeline name
        :rtype: string
        :return: The name
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_getName(self)

    def setName(self, name):
        r"""
        Set the name
        :type name: string
        :param name: The name
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_setName(self, name)

    def hasKey(self, key):
        r"""
        Check if key exists
        :type key: string
        :param key: The key to check for
        :rtype: boolean
        :return: True if the key exist, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_hasKey(self, key)

    def setData(self, key, data):
        r"""
        Set data for the provided key
        :type key: string
        :param key: The key to set data for
        :type data: :py:class:`AnyPoly`
        :param data: The data to assign to the provided key
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_setData(self, key, data)

    def getData(self, *args):
        r"""
        *Overload 1:*

        Get the data for the provided key
        If the key does not exist it will be null
        :type key: string
        :param key: The key to retreive the data
        :rtype: :py:class:`AnyPoly`
        :return: The data associated with the key

        |

        *Overload 2:*

        Get all data stored
        :rtype: std::unordered_map< std::string,tesseract_common::AnyPoly,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,tesseract_common::AnyPoly > > >
        :return: A copy of the data
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_getData(self, *args)

    def removeData(self, key):
        r"""
        Remove data for the provide key
        :type key: string
        :param key: The key to remove data for
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_removeData(self, key)

    def remapData(self, remapping, copy=False):
        r"""
        Remap data from one key to another
        :type remapping: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :param remapping: The key value pairs to remap data from the first to the second
        :type copy: boolean, optional
        :param copy: Default behavior is not move the data, but if copy is desired set this to true
        :rtype: boolean
        :return: True if successful, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr_remapData(self, remapping, copy)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerDataStorageUPtr___ne__(self, rhs)

# Register TaskComposerDataStorageUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerDataStorageUPtr_swigregister(TaskComposerDataStorageUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerDataStorage(object):
    r""" A thread save data storage"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerDataStorage

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerDataStorage_swiginit(self, _tesseract_task_composer_python.new_TaskComposerDataStorage(*args))

    def getName(self):
        r"""
        Get the name data storage.
        This is primarily used to hold the pipeline name
        :rtype: string
        :return: The name
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_getName(self)

    def setName(self, name):
        r"""
        Set the name
        :type name: string
        :param name: The name
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_setName(self, name)

    def hasKey(self, key):
        r"""
        Check if key exists
        :type key: string
        :param key: The key to check for
        :rtype: boolean
        :return: True if the key exist, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_hasKey(self, key)

    def setData(self, key, data):
        r"""
        Set data for the provided key
        :type key: string
        :param key: The key to set data for
        :type data: :py:class:`AnyPoly`
        :param data: The data to assign to the provided key
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_setData(self, key, data)

    def removeData(self, key):
        r"""
        Remove data for the provide key
        :type key: string
        :param key: The key to remove data for
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_removeData(self, key)

    def getData(self, *args):
        r"""
        *Overload 1:*

        Get the data for the provided key
        If the key does not exist it will be null
        :type key: string
        :param key: The key to retreive the data
        :rtype: :py:class:`AnyPoly`
        :return: The data associated with the key

        |

        *Overload 2:*

        Get all data stored
        :rtype: std::unordered_map< std::string,tesseract_common::AnyPoly,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,tesseract_common::AnyPoly > > >
        :return: A copy of the data
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_getData(self, *args)

    def remapData(self, remapping, copy=False):
        r"""
        Remap data from one key to another
        :type remapping: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :param remapping: The key value pairs to remap data from the first to the second
        :type copy: boolean, optional
        :param copy: Default behavior is not move the data, but if copy is desired set this to true
        :rtype: boolean
        :return: True if successful, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerDataStorage_remapData(self, remapping, copy)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerDataStorage___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerDataStorage___ne__(self, rhs)

# Register TaskComposerDataStorage in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerDataStorage_swigregister(TaskComposerDataStorage)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerContextUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerContextUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerContextUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerContextUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerContextUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerContextUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerContextUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerContextUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerContextUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerContextUPtr
    name = property(_tesseract_task_composer_python.TaskComposerContextUPtr_name_get, _tesseract_task_composer_python.TaskComposerContextUPtr_name_set, doc=r""" The name of the root level task being ran""")
    dotgraph = property(_tesseract_task_composer_python.TaskComposerContextUPtr_dotgraph_get, _tesseract_task_composer_python.TaskComposerContextUPtr_dotgraph_set, doc=r""" Indicate if dotgraph should be provided""")
    data_storage = property(_tesseract_task_composer_python.TaskComposerContextUPtr_data_storage_get, _tesseract_task_composer_python.TaskComposerContextUPtr_data_storage_set, doc=r"""
    The location data is stored and retrieved during execution
    The problem input data is copied into this structure when constructed
    """)
    task_infos = property(_tesseract_task_composer_python.TaskComposerContextUPtr_task_infos_get, _tesseract_task_composer_python.TaskComposerContextUPtr_task_infos_set, doc=r""" Container for meta-data generated by task(s) during execution""")

    def isAborted(self):
        r"""
        Check if process has been aborted
        This accesses the internal process interface class
        :rtype: boolean
        :return: True if aborted otherwise false;
        """
        return _tesseract_task_composer_python.TaskComposerContextUPtr_isAborted(self)

    def isSuccessful(self):
        r"""
        If it was not aborted then it was successful
        :rtype: boolean
        :return: True if successful, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerContextUPtr_isSuccessful(self)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerContextUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerContextUPtr___ne__(self, rhs)

# Register TaskComposerContextUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerContextUPtr_swigregister(TaskComposerContextUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerContext(object):
    r"""
    This class is passed as an input to each process in the decision tree

    Container for use internally by tasks and task executors to facilitate the execution of tasks

    This object contains:
    - `TaskComposerProblem`: represents the mutable input data needed to initiate the task and additional meta-data.
    - `TaskComposerDataStorage`: container in which tasks are expected to find their required input data and where tasks
    should save their results at run-time. This class member is originally set equal to the `TaskComposerDataStorage`
    member of the `TaskComposerProblem`, which represents the immutable input data for the task
    - `TaskComposerNodeInfoContainer`: container for meta-data generated by task(s) during execution.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerContext_swiginit(self, _tesseract_task_composer_python.new_TaskComposerContext(*args))
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerContext
    name = property(_tesseract_task_composer_python.TaskComposerContext_name_get, _tesseract_task_composer_python.TaskComposerContext_name_set, doc=r""" The name of the root level task being ran""")
    dotgraph = property(_tesseract_task_composer_python.TaskComposerContext_dotgraph_get, _tesseract_task_composer_python.TaskComposerContext_dotgraph_set, doc=r""" Indicate if dotgraph should be provided""")
    data_storage = property(_tesseract_task_composer_python.TaskComposerContext_data_storage_get, _tesseract_task_composer_python.TaskComposerContext_data_storage_set, doc=r"""
    The location data is stored and retrieved during execution
    The problem input data is copied into this structure when constructed
    """)
    task_infos = property(_tesseract_task_composer_python.TaskComposerContext_task_infos_get, _tesseract_task_composer_python.TaskComposerContext_task_infos_set, doc=r""" Container for meta-data generated by task(s) during execution""")

    def isAborted(self):
        r"""
        Check if process has been aborted
        This accesses the internal process interface class
        :rtype: boolean
        :return: True if aborted otherwise false;
        """
        return _tesseract_task_composer_python.TaskComposerContext_isAborted(self)

    def isSuccessful(self):
        r"""
        If it was not aborted then it was successful
        :rtype: boolean
        :return: True if successful, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerContext_isSuccessful(self)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerContext___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerContext___ne__(self, rhs)

# Register TaskComposerContext in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerContext_swigregister(TaskComposerContext)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNodeUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerNodeUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerNodeUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNodeUPtr

    def run(self, *args):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_run(self, *args)

    def setName(self, name):
        r""" Set the name of the node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_setName(self, name)

    def getName(self):
        r""" The name of the node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getName(self)

    def setNamespace(self, ns):
        r""" Set the namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_setNamespace(self, ns)

    def getNamespace(self):
        r""" The namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getNamespace(self)

    def getType(self):
        r""" The node type TASK, GRAPH, etc"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getType(self)

    def getUUID(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getUUID(self)

    def getUUIDString(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getUUIDString(self)

    def getParentUUID(self):
        r"""
        The parent uuid which can be null
        This is not null if the node is part of a graph
        """
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getParentUUID(self)

    def isConditional(self):
        r"""
        Check if node is conditional
        :rtype: boolean
        :return: 
        """
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_isConditional(self)

    def validatePorts(self):
        r""" This will validate that all required ports exist and that no extra ports exist"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_validatePorts(self)

    def getOutboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run after this node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getOutboundEdges(self)

    def getInboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run before this node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getInboundEdges(self)

    def setInputKeys(self, input_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_setInputKeys(self, input_keys)

    def getInputKeys(self):
        r""" The nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getInputKeys(self)

    def setOutputKeys(self, output_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_setOutputKeys(self, output_keys)

    def getOutputKeys(self):
        r""" The nodes output keys"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getOutputKeys(self)

    def getPorts(self):
        r""" Get the ports associated with the node"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getPorts(self)

    def getDotgraph(self, *args):
        r""" Generate the Dotgraph as a string"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_getDotgraph(self, *args)

    def saveDotgraph(self, *args):
        r""" Generate the Dotgraph and save to file"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_saveDotgraph(self, *args)

    def renameInputKeys(self, input_keys):
        r""" Rename input keys"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_renameInputKeys(self, input_keys)

    def renameOutputKeys(self, output_keys):
        r""" Rename output keys"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_renameOutputKeys(self, output_keys)

    def setConditional(self, enable):
        r""" Set if conditional"""
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_setConditional(self, enable)

    def dump(self, *args):
        r"""
        dump the task to dot
        Return additional subgraphs which should get appended if needed
        """
        return _tesseract_task_composer_python.TaskComposerNodeUPtr_dump(self, *args)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNodeUPtr___ne__(self, rhs)

# Register TaskComposerNodeUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNodeUPtr_swigregister(TaskComposerNodeUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNode(object):
    r""" Represents a node the pipeline to be executed"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNode

    def run(self, *args):
        return _tesseract_task_composer_python.TaskComposerNode_run(self, *args)

    def setName(self, name):
        r""" Set the name of the node"""
        return _tesseract_task_composer_python.TaskComposerNode_setName(self, name)

    def getName(self):
        r""" The name of the node"""
        return _tesseract_task_composer_python.TaskComposerNode_getName(self)

    def setNamespace(self, ns):
        r""" Set the namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerNode_setNamespace(self, ns)

    def getNamespace(self):
        r""" The namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerNode_getNamespace(self)

    def getType(self):
        r""" The node type TASK, GRAPH, etc"""
        return _tesseract_task_composer_python.TaskComposerNode_getType(self)

    def getUUID(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerNode_getUUID(self)

    def getUUIDString(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerNode_getUUIDString(self)

    def getParentUUID(self):
        r"""
        The parent uuid which can be null
        This is not null if the node is part of a graph
        """
        return _tesseract_task_composer_python.TaskComposerNode_getParentUUID(self)

    def isConditional(self):
        r"""
        Check if node is conditional
        :rtype: boolean
        :return: 
        """
        return _tesseract_task_composer_python.TaskComposerNode_isConditional(self)

    def validatePorts(self):
        r""" This will validate that all required ports exist and that no extra ports exist"""
        return _tesseract_task_composer_python.TaskComposerNode_validatePorts(self)

    def getOutboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run after this node"""
        return _tesseract_task_composer_python.TaskComposerNode_getOutboundEdges(self)

    def getInboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run before this node"""
        return _tesseract_task_composer_python.TaskComposerNode_getInboundEdges(self)

    def setInputKeys(self, input_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerNode_setInputKeys(self, input_keys)

    def getInputKeys(self):
        r""" The nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerNode_getInputKeys(self)

    def setOutputKeys(self, output_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerNode_setOutputKeys(self, output_keys)

    def getOutputKeys(self):
        r""" The nodes output keys"""
        return _tesseract_task_composer_python.TaskComposerNode_getOutputKeys(self)

    def getPorts(self):
        r""" Get the ports associated with the node"""
        return _tesseract_task_composer_python.TaskComposerNode_getPorts(self)

    def getDotgraph(self, *args):
        r""" Generate the Dotgraph as a string"""
        return _tesseract_task_composer_python.TaskComposerNode_getDotgraph(self, *args)

    def saveDotgraph(self, *args):
        r""" Generate the Dotgraph and save to file"""
        return _tesseract_task_composer_python.TaskComposerNode_saveDotgraph(self, *args)

    def renameInputKeys(self, input_keys):
        r""" Rename input keys"""
        return _tesseract_task_composer_python.TaskComposerNode_renameInputKeys(self, input_keys)

    def renameOutputKeys(self, output_keys):
        r""" Rename output keys"""
        return _tesseract_task_composer_python.TaskComposerNode_renameOutputKeys(self, output_keys)

    def setConditional(self, enable):
        r""" Set if conditional"""
        return _tesseract_task_composer_python.TaskComposerNode_setConditional(self, enable)

    def dump(self, *args):
        r"""
        dump the task to dot
        Return additional subgraphs which should get appended if needed
        """
        return _tesseract_task_composer_python.TaskComposerNode_dump(self, *args)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNode___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerNode___ne__(self, rhs)

# Register TaskComposerNode in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNode_swigregister(TaskComposerNode)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerGraphUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerGraphUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerGraphUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerGraphUPtr

    def getRootNode(self):
        r"""
        Get the root node of the graph
        :rtype: :py:class:`uuid`
        :return: The root node uuid
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getRootNode(self)

    def addNode(self, task_node):
        r"""
        Add a node to the pipeline
        :rtype: :py:class:`uuid`
        :return: The node ID which should be used with adding edges
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_addNode(self, task_node)

    def addEdges(self, source, destinations):
        r"""
        Adds directed edges from a source node to destination nodes in the taskflow graph
        If source is a non-conditional task, it is only relevant to provide one destination as the output of a
        non-conditional tf::Task is void. If source is a conditional task, the order of the destinations should correspond
        to the integer output of the conditional tf::Task. For example,if the output of the conditional tf::Task is 0, the
        taskflow would transition to the node identified by the ID at index 0 in the destinations input. A leaf node (i.e.
        node without defined edges) is always connected to the done callback. If the leaf node is a conditional node, it is
        connected to the error task at index 0 and the done task at index 1
        :param from: The ID of the source node of the edge
        :param dest: A list of IDs of the destination nodes of the edges.
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_addEdges(self, source, destinations)

    def getNodes(self):
        r""" Get the nodes associated with the pipeline mapped by uuid"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getNodes(self)

    def getNodeByName(self, name):
        r"""
        Get a node by name
        :type name: string
        :param name: The name of the node to search for
        :rtype: :py:class:`TaskComposerNode`
        :return: The node with the name, otherwise nullptr
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getNodeByName(self, name)

    def setTerminals(self, terminals):
        r"""
        Set the terminals nodes
        must be called after all nodes and edges are setup.
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setTerminals(self, terminals)

    def getTerminals(self):
        r""" Get the terminal nodes for the pipeline"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getTerminals(self)

    def setTerminalTriggerAbort(self, terminal):
        r"""
        Set if the pipeline should call abort if terminal node is reached
        If null, it will not abort
        :type terminal: :py:class:`uuid`
        :param terminal: The terminal uuid
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setTerminalTriggerAbort(self, terminal)

    def setTerminalTriggerAbortByIndex(self, terminal_index):
        r"""
        Set if the pipeline should call abort if terminal node is reached
        If less than zero, it will not abort
        :param terminal: The terminal index
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setTerminalTriggerAbortByIndex(self, terminal_index)

    def getAbortTerminal(self):
        r""" Get the abort terminal uuid if set"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getAbortTerminal(self)

    def getAbortTerminalIndex(self):
        r""" Get the abort terminal index if set"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getAbortTerminalIndex(self)

    def isValid(self):
        r"""
        Check if the current state of the graph is valid
        TODO: Replace return type with std::expected when upgraded to use c++23
        :rtype: std::pair< bool,std::string >
        :return: True if valid otherwise false with a reason
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_isValid(self)

    def renameInputKeys(self, input_keys):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_renameInputKeys(self, input_keys)

    def renameOutputKeys(self, output_keys):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_renameOutputKeys(self, output_keys)

    def dump(self, *args):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_dump(self, *args)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr___ne__(self, rhs)

    def run(self, *args):
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_run(self, *args)

    def setName(self, name):
        r""" Set the name of the node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setName(self, name)

    def getName(self):
        r""" The name of the node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getName(self)

    def setNamespace(self, ns):
        r""" Set the namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setNamespace(self, ns)

    def getNamespace(self):
        r""" The namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getNamespace(self)

    def getType(self):
        r""" The node type TASK, GRAPH, etc"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getType(self)

    def getUUID(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getUUID(self)

    def getUUIDString(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getUUIDString(self)

    def getParentUUID(self):
        r"""
        The parent uuid which can be null
        This is not null if the node is part of a graph
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getParentUUID(self)

    def isConditional(self):
        r"""
        Check if node is conditional
        :rtype: boolean
        :return: 
        """
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_isConditional(self)

    def validatePorts(self):
        r""" This will validate that all required ports exist and that no extra ports exist"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_validatePorts(self)

    def getOutboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run after this node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getOutboundEdges(self)

    def getInboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run before this node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getInboundEdges(self)

    def setInputKeys(self, input_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setInputKeys(self, input_keys)

    def getInputKeys(self):
        r""" The nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getInputKeys(self)

    def setOutputKeys(self, output_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setOutputKeys(self, output_keys)

    def getOutputKeys(self):
        r""" The nodes output keys"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getOutputKeys(self)

    def getPorts(self):
        r""" Get the ports associated with the node"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getPorts(self)

    def getDotgraph(self, *args):
        r""" Generate the Dotgraph as a string"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_getDotgraph(self, *args)

    def saveDotgraph(self, *args):
        r""" Generate the Dotgraph and save to file"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_saveDotgraph(self, *args)

    def setConditional(self, enable):
        r""" Set if conditional"""
        return _tesseract_task_composer_python.TaskComposerGraphUPtr_setConditional(self, enable)

# Register TaskComposerGraphUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerGraphUPtr_swigregister(TaskComposerGraphUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class MapUuidTaskComposerNodeConstPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___nonzero__(self)

    def __bool__(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___bool__(self)

    def __len__(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___getitem__(self, key)

    def __delitem__(self, key):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___delitem__(self, key)

    def has_key(self, key):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_has_key(self, key)

    def keys(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_keys(self)

    def values(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_values(self)

    def items(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_items(self)

    def __contains__(self, key):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___contains__(self, key)

    def key_iterator(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_key_iterator(self)

    def value_iterator(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_value_iterator(self)

    def __setitem__(self, *args):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr___setitem__(self, *args)

    def asdict(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_asdict(self)

    def __init__(self, *args):
        _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_swiginit(self, _tesseract_task_composer_python.new_MapUuidTaskComposerNodeConstPtr(*args))

    def empty(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_empty(self)

    def size(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_size(self)

    def swap(self, v):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_swap(self, v)

    def begin(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_begin(self)

    def end(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_end(self)

    def rbegin(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_rbegin(self)

    def rend(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_rend(self)

    def clear(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_clear(self)

    def get_allocator(self):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_get_allocator(self)

    def count(self, x):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_count(self, x)

    def erase(self, *args):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_erase(self, *args)

    def find(self, x):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_find(self, x)

    def lower_bound(self, x):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_lower_bound(self, x)

    def upper_bound(self, x):
        return _tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_upper_bound(self, x)
    __swig_destroy__ = _tesseract_task_composer_python.delete_MapUuidTaskComposerNodeConstPtr

# Register MapUuidTaskComposerNodeConstPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.MapUuidTaskComposerNodeConstPtr_swigregister(MapUuidTaskComposerNodeConstPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerGraph(TaskComposerNode):
    r"""
    This class facilitates the composition of an arbitrary taskflow graph.
    Tasks are nodes in the graph connected to each other in a configurable order by directed edges
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerGraph_swiginit(self, _tesseract_task_composer_python.new_TaskComposerGraph(*args))
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerGraph

    def getRootNode(self):
        r"""
        Get the root node of the graph
        :rtype: :py:class:`uuid`
        :return: The root node uuid
        """
        return _tesseract_task_composer_python.TaskComposerGraph_getRootNode(self)

    def addNode(self, task_node):
        r"""
        Add a node to the pipeline
        :rtype: :py:class:`uuid`
        :return: The node ID which should be used with adding edges
        """
        return _tesseract_task_composer_python.TaskComposerGraph_addNode(self, task_node)

    def addEdges(self, source, destinations):
        r"""
        Adds directed edges from a source node to destination nodes in the taskflow graph
        If source is a non-conditional task, it is only relevant to provide one destination as the output of a
        non-conditional tf::Task is void. If source is a conditional task, the order of the destinations should correspond
        to the integer output of the conditional tf::Task. For example,if the output of the conditional tf::Task is 0, the
        taskflow would transition to the node identified by the ID at index 0 in the destinations input. A leaf node (i.e.
        node without defined edges) is always connected to the done callback. If the leaf node is a conditional node, it is
        connected to the error task at index 0 and the done task at index 1
        :param from: The ID of the source node of the edge
        :param dest: A list of IDs of the destination nodes of the edges.
        """
        return _tesseract_task_composer_python.TaskComposerGraph_addEdges(self, source, destinations)

    def getNodes(self):
        r""" Get the nodes associated with the pipeline mapped by uuid"""
        return _tesseract_task_composer_python.TaskComposerGraph_getNodes(self)

    def getNodeByName(self, name):
        r"""
        Get a node by name
        :type name: string
        :param name: The name of the node to search for
        :rtype: :py:class:`TaskComposerNode`
        :return: The node with the name, otherwise nullptr
        """
        return _tesseract_task_composer_python.TaskComposerGraph_getNodeByName(self, name)

    def setTerminals(self, terminals):
        r"""
        Set the terminals nodes
        must be called after all nodes and edges are setup.
        """
        return _tesseract_task_composer_python.TaskComposerGraph_setTerminals(self, terminals)

    def getTerminals(self):
        r""" Get the terminal nodes for the pipeline"""
        return _tesseract_task_composer_python.TaskComposerGraph_getTerminals(self)

    def setTerminalTriggerAbort(self, terminal):
        r"""
        Set if the pipeline should call abort if terminal node is reached
        If null, it will not abort
        :type terminal: :py:class:`uuid`
        :param terminal: The terminal uuid
        """
        return _tesseract_task_composer_python.TaskComposerGraph_setTerminalTriggerAbort(self, terminal)

    def setTerminalTriggerAbortByIndex(self, terminal_index):
        r"""
        Set if the pipeline should call abort if terminal node is reached
        If less than zero, it will not abort
        :param terminal: The terminal index
        """
        return _tesseract_task_composer_python.TaskComposerGraph_setTerminalTriggerAbortByIndex(self, terminal_index)

    def getAbortTerminal(self):
        r""" Get the abort terminal uuid if set"""
        return _tesseract_task_composer_python.TaskComposerGraph_getAbortTerminal(self)

    def getAbortTerminalIndex(self):
        r""" Get the abort terminal index if set"""
        return _tesseract_task_composer_python.TaskComposerGraph_getAbortTerminalIndex(self)

    def isValid(self):
        r"""
        Check if the current state of the graph is valid
        TODO: Replace return type with std::expected when upgraded to use c++23
        :rtype: std::pair< bool,std::string >
        :return: True if valid otherwise false with a reason
        """
        return _tesseract_task_composer_python.TaskComposerGraph_isValid(self)

    def renameInputKeys(self, input_keys):
        return _tesseract_task_composer_python.TaskComposerGraph_renameInputKeys(self, input_keys)

    def renameOutputKeys(self, output_keys):
        return _tesseract_task_composer_python.TaskComposerGraph_renameOutputKeys(self, output_keys)

    def dump(self, *args):
        return _tesseract_task_composer_python.TaskComposerGraph_dump(self, *args)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerGraph___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerGraph___ne__(self, rhs)

# Register TaskComposerGraph in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerGraph_swigregister(TaskComposerGraph)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerPipelineUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerPipelineUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerPipelineUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerPipelineUPtr

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr___ne__(self, rhs)

    def getRootNode(self):
        r"""
        Get the root node of the graph
        :rtype: :py:class:`uuid`
        :return: The root node uuid
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getRootNode(self)

    def addNode(self, task_node):
        r"""
        Add a node to the pipeline
        :rtype: :py:class:`uuid`
        :return: The node ID which should be used with adding edges
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_addNode(self, task_node)

    def addEdges(self, source, destinations):
        r"""
        Adds directed edges from a source node to destination nodes in the taskflow graph
        If source is a non-conditional task, it is only relevant to provide one destination as the output of a
        non-conditional tf::Task is void. If source is a conditional task, the order of the destinations should correspond
        to the integer output of the conditional tf::Task. For example,if the output of the conditional tf::Task is 0, the
        taskflow would transition to the node identified by the ID at index 0 in the destinations input. A leaf node (i.e.
        node without defined edges) is always connected to the done callback. If the leaf node is a conditional node, it is
        connected to the error task at index 0 and the done task at index 1
        :param from: The ID of the source node of the edge
        :param dest: A list of IDs of the destination nodes of the edges.
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_addEdges(self, source, destinations)

    def getNodes(self):
        r""" Get the nodes associated with the pipeline mapped by uuid"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getNodes(self)

    def getNodeByName(self, name):
        r"""
        Get a node by name
        :type name: string
        :param name: The name of the node to search for
        :rtype: :py:class:`TaskComposerNode`
        :return: The node with the name, otherwise nullptr
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getNodeByName(self, name)

    def setTerminals(self, terminals):
        r"""
        Set the terminals nodes
        must be called after all nodes and edges are setup.
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setTerminals(self, terminals)

    def getTerminals(self):
        r""" Get the terminal nodes for the pipeline"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getTerminals(self)

    def setTerminalTriggerAbort(self, terminal):
        r"""
        Set if the pipeline should call abort if terminal node is reached
        If null, it will not abort
        :type terminal: :py:class:`uuid`
        :param terminal: The terminal uuid
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setTerminalTriggerAbort(self, terminal)

    def setTerminalTriggerAbortByIndex(self, terminal_index):
        r"""
        Set if the pipeline should call abort if terminal node is reached
        If less than zero, it will not abort
        :param terminal: The terminal index
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setTerminalTriggerAbortByIndex(self, terminal_index)

    def getAbortTerminal(self):
        r""" Get the abort terminal uuid if set"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getAbortTerminal(self)

    def getAbortTerminalIndex(self):
        r""" Get the abort terminal index if set"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getAbortTerminalIndex(self)

    def isValid(self):
        r"""
        Check if the current state of the graph is valid
        TODO: Replace return type with std::expected when upgraded to use c++23
        :rtype: std::pair< bool,std::string >
        :return: True if valid otherwise false with a reason
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_isValid(self)

    def renameInputKeys(self, input_keys):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_renameInputKeys(self, input_keys)

    def renameOutputKeys(self, output_keys):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_renameOutputKeys(self, output_keys)

    def dump(self, *args):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_dump(self, *args)

    def run(self, *args):
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_run(self, *args)

    def setName(self, name):
        r""" Set the name of the node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setName(self, name)

    def getName(self):
        r""" The name of the node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getName(self)

    def setNamespace(self, ns):
        r""" Set the namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setNamespace(self, ns)

    def getNamespace(self):
        r""" The namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getNamespace(self)

    def getType(self):
        r""" The node type TASK, GRAPH, etc"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getType(self)

    def getUUID(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getUUID(self)

    def getUUIDString(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getUUIDString(self)

    def getParentUUID(self):
        r"""
        The parent uuid which can be null
        This is not null if the node is part of a graph
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getParentUUID(self)

    def isConditional(self):
        r"""
        Check if node is conditional
        :rtype: boolean
        :return: 
        """
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_isConditional(self)

    def validatePorts(self):
        r""" This will validate that all required ports exist and that no extra ports exist"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_validatePorts(self)

    def getOutboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run after this node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getOutboundEdges(self)

    def getInboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run before this node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getInboundEdges(self)

    def setInputKeys(self, input_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setInputKeys(self, input_keys)

    def getInputKeys(self):
        r""" The nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getInputKeys(self)

    def setOutputKeys(self, output_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setOutputKeys(self, output_keys)

    def getOutputKeys(self):
        r""" The nodes output keys"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getOutputKeys(self)

    def getPorts(self):
        r""" Get the ports associated with the node"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getPorts(self)

    def getDotgraph(self, *args):
        r""" Generate the Dotgraph as a string"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_getDotgraph(self, *args)

    def saveDotgraph(self, *args):
        r""" Generate the Dotgraph and save to file"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_saveDotgraph(self, *args)

    def setConditional(self, enable):
        r""" Set if conditional"""
        return _tesseract_task_composer_python.TaskComposerPipelineUPtr_setConditional(self, enable)

# Register TaskComposerPipelineUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerPipelineUPtr_swigregister(TaskComposerPipelineUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerPipeline(TaskComposerGraph):
    r"""
    This class facilitates the composition of an arbitrary taskflow pipeline.
    Tasks are nodes in the graph connected to each other in a configurable order by directed edges
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerPipeline_swiginit(self, _tesseract_task_composer_python.new_TaskComposerPipeline(*args))
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerPipeline

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerPipeline___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerPipeline___ne__(self, rhs)

# Register TaskComposerPipeline in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerPipeline_swigregister(TaskComposerPipeline)
future_status_ready = _tesseract_task_composer_python.future_status_ready
future_status_timeout = _tesseract_task_composer_python.future_status_timeout
future_status_deferred = _tesseract_task_composer_python.future_status_deferred
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerFutureUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerFutureUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerFutureUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerFutureUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerFutureUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerFutureUPtr
    context = property(_tesseract_task_composer_python.TaskComposerFutureUPtr_context_get, _tesseract_task_composer_python.TaskComposerFutureUPtr_context_set)

    def clear(self):
        r""" Clear all content"""
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_clear(self)

    def valid(self):
        r""" Checks if the future has a shared state"""
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_valid(self)

    def ready(self):
        r"""
        This checks if the tasks are finished
        :rtype: boolean
        :return: True if the tasks finished, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_ready(self)

    def wait(self):
        r""" Wait until the process has finished"""
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_wait(self)

    def waitFor(self, duration):
        r"""
        Check if a process has finished for a given duration
        :rtype: int
        :return: The future status
        """
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_waitFor(self, duration)

    def waitUntil(self, abs):
        r"""
        Check if a process has finished up to a given time point
        :rtype: int
        :return: The future status
        """
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_waitUntil(self, abs)

    def copy(self):
        r"""
        Make a copy of the future
        :rtype: :py:class:`UPtr`
        :return: A copy, for example to allow access from multiple thread
        """
        return _tesseract_task_composer_python.TaskComposerFutureUPtr_copy(self)

# Register TaskComposerFutureUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerFutureUPtr_swigregister(TaskComposerFutureUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerFuture(object):
    r"""
    This contains the result for the task composer request
    Also this must be copyable so recommend using shared future or something comparable
    Must check the status before access the results to know if available.
    Notes: This stores a shared future and is copy-able to allow access from multiple threads
    This must not go out of scope until the process has finished
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerFuture
    context = property(_tesseract_task_composer_python.TaskComposerFuture_context_get, _tesseract_task_composer_python.TaskComposerFuture_context_set)

    def clear(self):
        r""" Clear all content"""
        return _tesseract_task_composer_python.TaskComposerFuture_clear(self)

    def valid(self):
        r""" Checks if the future has a shared state"""
        return _tesseract_task_composer_python.TaskComposerFuture_valid(self)

    def ready(self):
        r"""
        This checks if the tasks are finished
        :rtype: boolean
        :return: True if the tasks finished, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerFuture_ready(self)

    def wait(self):
        r""" Wait until the process has finished"""
        return _tesseract_task_composer_python.TaskComposerFuture_wait(self)

    def waitFor(self, duration):
        r"""
        Check if a process has finished for a given duration
        :rtype: int
        :return: The future status
        """
        return _tesseract_task_composer_python.TaskComposerFuture_waitFor(self, duration)

    def waitUntil(self, abs):
        r"""
        Check if a process has finished up to a given time point
        :rtype: int
        :return: The future status
        """
        return _tesseract_task_composer_python.TaskComposerFuture_waitUntil(self, abs)

    def copy(self):
        r"""
        Make a copy of the future
        :rtype: :py:class:`UPtr`
        :return: A copy, for example to allow access from multiple thread
        """
        return _tesseract_task_composer_python.TaskComposerFuture_copy(self)

# Register TaskComposerFuture in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerFuture_swigregister(TaskComposerFuture)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerTaskUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerTaskUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerTaskUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerTaskUPtr

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr___ne__(self, rhs)

    def setTriggerAbort(self, enable):
        r"""
        If true this node should call context.abort(uuid_) after run method returns
        :type enable: boolean
        :param enable: True if task should call context.abort(uuid_) after run method returns
        """
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_setTriggerAbort(self, enable)

    def run(self, *args):
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_run(self, *args)

    def setName(self, name):
        r""" Set the name of the node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_setName(self, name)

    def getName(self):
        r""" The name of the node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getName(self)

    def setNamespace(self, ns):
        r""" Set the namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_setNamespace(self, ns)

    def getNamespace(self):
        r""" The namespace of the node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getNamespace(self)

    def getType(self):
        r""" The node type TASK, GRAPH, etc"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getType(self)

    def getUUID(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getUUID(self)

    def getUUIDString(self):
        r""" The node uuid"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getUUIDString(self)

    def getParentUUID(self):
        r"""
        The parent uuid which can be null
        This is not null if the node is part of a graph
        """
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getParentUUID(self)

    def isConditional(self):
        r"""
        Check if node is conditional
        :rtype: boolean
        :return: 
        """
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_isConditional(self)

    def validatePorts(self):
        r""" This will validate that all required ports exist and that no extra ports exist"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_validatePorts(self)

    def getOutboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run after this node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getOutboundEdges(self)

    def getInboundEdges(self):
        r""" IDs of nodes (i.e. node) that should run before this node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getInboundEdges(self)

    def setInputKeys(self, input_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_setInputKeys(self, input_keys)

    def getInputKeys(self):
        r""" The nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getInputKeys(self)

    def setOutputKeys(self, output_keys):
        r""" Set the nodes input keys"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_setOutputKeys(self, output_keys)

    def getOutputKeys(self):
        r""" The nodes output keys"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getOutputKeys(self)

    def getPorts(self):
        r""" Get the ports associated with the node"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getPorts(self)

    def getDotgraph(self, *args):
        r""" Generate the Dotgraph as a string"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_getDotgraph(self, *args)

    def saveDotgraph(self, *args):
        r""" Generate the Dotgraph and save to file"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_saveDotgraph(self, *args)

    def renameInputKeys(self, input_keys):
        r""" Rename input keys"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_renameInputKeys(self, input_keys)

    def renameOutputKeys(self, output_keys):
        r""" Rename output keys"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_renameOutputKeys(self, output_keys)

    def setConditional(self, enable):
        r""" Set if conditional"""
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_setConditional(self, enable)

    def dump(self, *args):
        r"""
        dump the task to dot
        Return additional subgraphs which should get appended if needed
        """
        return _tesseract_task_composer_python.TaskComposerTaskUPtr_dump(self, *args)

# Register TaskComposerTaskUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerTaskUPtr_swigregister(TaskComposerTaskUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerTask(TaskComposerNode):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerTask

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerTask___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerTask___ne__(self, rhs)

    def setTriggerAbort(self, enable):
        r"""
        If true this node should call context.abort(uuid_) after run method returns
        :type enable: boolean
        :param enable: True if task should call context.abort(uuid_) after run method returns
        """
        return _tesseract_task_composer_python.TaskComposerTask_setTriggerAbort(self, enable)

# Register TaskComposerTask in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerTask_swigregister(TaskComposerTask)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerExecutorUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TaskComposerExecutorUPtr_swiginit(self, _tesseract_task_composer_python.new_TaskComposerExecutorUPtr(*args))

    def __deref__(self):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr___deref__(self)

    def release(self):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_release(self)

    def reset(self, *args):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_swap(self, __u)

    def get(self):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerExecutorUPtr

    def getName(self):
        r""" Get the name of the executor"""
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_getName(self)

    def run(self, node, data_storage, dotgraph=False):
        r"""
        Execute the provided node
        :type node: :py:class:`TaskComposerNode`
        :param node: The node to execute
        :type data_storage: :py:class:`TaskComposerDataStorage`
        :param data_storage: The data storage object to leverage
        :type dotgraph: boolean, optional
        :param dotgraph: Indicate if dotgraph should be generated
        :rtype: std::unique_ptr< tesseract_planning::TaskComposerFuture >
        :return: The future associated with execution
        """
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_run(self, node, data_storage, dotgraph)

    def getWorkerCount(self):
        r""" Queries the number of workers (example: number of threads)"""
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_getWorkerCount(self)

    def getTaskCount(self):
        r""" Queries the number of running tasks at the time of this call"""
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr_getTaskCount(self)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerExecutorUPtr___ne__(self, rhs)

# Register TaskComposerExecutorUPtr in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerExecutorUPtr_swigregister(TaskComposerExecutorUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerExecutor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerExecutor

    def getName(self):
        r""" Get the name of the executor"""
        return _tesseract_task_composer_python.TaskComposerExecutor_getName(self)

    def run(self, node, data_storage, dotgraph=False):
        r"""
        Execute the provided node
        :type node: :py:class:`TaskComposerNode`
        :param node: The node to execute
        :type data_storage: :py:class:`TaskComposerDataStorage`
        :param data_storage: The data storage object to leverage
        :type dotgraph: boolean, optional
        :param dotgraph: Indicate if dotgraph should be generated
        :rtype: std::unique_ptr< tesseract_planning::TaskComposerFuture >
        :return: The future associated with execution
        """
        return _tesseract_task_composer_python.TaskComposerExecutor_run(self, node, data_storage, dotgraph)

    def getWorkerCount(self):
        r""" Queries the number of workers (example: number of threads)"""
        return _tesseract_task_composer_python.TaskComposerExecutor_getWorkerCount(self)

    def getTaskCount(self):
        r""" Queries the number of running tasks at the time of this call"""
        return _tesseract_task_composer_python.TaskComposerExecutor_getTaskCount(self)

    def __eq__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerExecutor___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_task_composer_python.TaskComposerExecutor___ne__(self, rhs)

# Register TaskComposerExecutor in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerExecutor_swigregister(TaskComposerExecutor)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerNodeFactory(object):
    r"""
     Task Composer Node Factory class used by the TaskComposerServer for loading top level task to be called by
    name
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerNodeFactory

    def create(self, name, config, plugin_factory):
        return _tesseract_task_composer_python.TaskComposerNodeFactory_create(self, name, config, plugin_factory)

# Register TaskComposerNodeFactory in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerNodeFactory_swigregister(TaskComposerNodeFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerExecutorFactory(object):
    r"""
     Task Composer Executor Factory class used by the TaskComposerServer for loading executors to be called by
    name
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerExecutorFactory

    def create(self, name, config):
        return _tesseract_task_composer_python.TaskComposerExecutorFactory_create(self, name, config)

# Register TaskComposerExecutorFactory in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerExecutorFactory_swigregister(TaskComposerExecutorFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerPluginFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerPluginFactory

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Load plugins from a configuration object
        :type config: tesseract_common::TaskComposerPluginInfo
        :param config: The config object

        |

        *Overload 2:*

        Load plugins from yaml node
        :type config: YAML::Node
        :param config: The config node

        |

        *Overload 3:*

        Load plugins from file path
        :type config: :py:class:`path`
        :param config: The config file path

        |

        *Overload 4:*

        Load plugins from string
        :type config: string
        :param config: The config string
        """
        _tesseract_task_composer_python.TaskComposerPluginFactory_swiginit(self, _tesseract_task_composer_python.new_TaskComposerPluginFactory(*args))

    def loadConfig(self, *args):
        r"""
        *Overload 1:*

        Loads plugins from a configuration object
        :type config: tesseract_common::TaskComposerPluginInfo
        :param config: the config object

        |

        *Overload 2:*

        Load plugins from yaml node
        :type config: YAML::Node
        :param config: The config node

        |

        *Overload 3:*

        Load plugins from file path
        :type config: :py:class:`path`
        :param config: The config file path

        |

        *Overload 4:*

        Load plugins from string
        :type config: string
        :param config: The config string
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_loadConfig(self, *args)

    def addSearchPath(self, path):
        r"""
        Add location for the plugin loader to search
        :type path: string
        :param path: The full path to the directory
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_addSearchPath(self, path)

    def getSearchPaths(self):
        r"""
        Get the plugin search paths
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search paths
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getSearchPaths(self)

    def clearSearchPaths(self):
        r"""Clear the search paths"""
        return _tesseract_task_composer_python.TaskComposerPluginFactory_clearSearchPaths(self)

    def addSearchLibrary(self, library_name):
        r"""
        Add a library to search for plugin name
        :type library_name: string
        :param library_name: The library name without the prefix or suffix
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_addSearchLibrary(self, library_name)

    def getSearchLibraries(self):
        r"""
        Get the plugin search libraries
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search libraries
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getSearchLibraries(self)

    def clearSearchLibraries(self):
        r"""Clean the search libraries"""
        return _tesseract_task_composer_python.TaskComposerPluginFactory_clearSearchLibraries(self)

    def addTaskComposerExecutorPlugin(self, name, plugin_info):
        r"""
        Add a task composer executor plugin
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_addTaskComposerExecutorPlugin(self, name, plugin_info)

    def hasTaskComposerExecutorPlugins(self):
        r"""
        Check if it has task composer executor plugins
        :rtype: boolean
        :return: True if task composer executor PluginInfoMap is not empty, otherwise fale
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_hasTaskComposerExecutorPlugins(self)

    def getTaskComposerExecutorPlugins(self):
        r"""
        Get the map of task composer executor plugins
        :rtype: :py:class:`PluginInfoMap`
        :return: A map of plugins
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getTaskComposerExecutorPlugins(self)

    def removeTaskComposerExecutorPlugin(self, name):
        r"""
        Remove task composer executor plugin
        :type name: string
        :param name: The name of the executor to remove
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_removeTaskComposerExecutorPlugin(self, name)

    def setDefaultTaskComposerExecutorPlugin(self, name):
        r"""
        Set a default task composer executor
        :type name: string
        :param name: The name
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_setDefaultTaskComposerExecutorPlugin(self, name)

    def getDefaultTaskComposerExecutorPlugin(self):
        r"""
        Get the default task composer executor
        :rtype: string
        :return: The default task composer executor
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getDefaultTaskComposerExecutorPlugin(self)

    def addTaskComposerNodePlugin(self, name, plugin_info):
        r"""
        Add a task composer node plugin
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_addTaskComposerNodePlugin(self, name, plugin_info)

    def hasTaskComposerNodePlugins(self):
        r"""
        Check if it has task composer node plugins
        :rtype: boolean
        :return: True if task composer node PluginInfoMap is not empty, otherwise fale
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_hasTaskComposerNodePlugins(self)

    def getTaskComposerNodePlugins(self):
        r"""
        Get the map of task composer node plugins
        :rtype: :py:class:`PluginInfoMap`
        :return: A map of plugins
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getTaskComposerNodePlugins(self)

    def removeTaskComposerNodePlugin(self, name):
        r"""
        Remove task composer node plugin
        :type name: string
        :param name: The name of the task composer node to remove
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_removeTaskComposerNodePlugin(self, name)

    def setDefaultTaskComposerNodePlugin(self, name):
        r"""
        Set a default task composer node
        :type name: string
        :param name: The name
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_setDefaultTaskComposerNodePlugin(self, name)

    def getDefaultTaskComposerNodePlugin(self):
        r"""
        Get the default task composer node
        :rtype: string
        :return: The default task composer node name
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getDefaultTaskComposerNodePlugin(self)

    def createTaskComposerExecutor(self, *args):
        r"""
        *Overload 1:*

        Get task composer executor object given name
        This looks for task composer executor plugin info. If not found nullptr is returned.
        :type name: string
        :param name: The name

        |

        *Overload 2:*

        Get task composer executor object given plugin info
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information to create task composer executor object
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_createTaskComposerExecutor(self, *args)

    def createTaskComposerNode(self, *args):
        r"""
        *Overload 1:*

        Get task composer node object given name
        This looks for task composer node plugin info. If not found nullptr is returned.
        :type name: string
        :param name: The name

        |

        *Overload 2:*

        Get task composer node  object given plugin info
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information to task composer node  object
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_createTaskComposerNode(self, *args)

    def saveConfig(self, file_path):
        r"""
        Save the plugin information to a yaml config file
        :type file_path: :py:class:`path`
        :param file_path: The file path
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_saveConfig(self, file_path)

    def getConfig(self):
        r"""
        Get the plugin information config as a yaml node
        :rtype: YAML::Node
        :return: The plugin information config yaml node/
        """
        return _tesseract_task_composer_python.TaskComposerPluginFactory_getConfig(self)

# Register TaskComposerPluginFactory in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerPluginFactory_swigregister(TaskComposerPluginFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TaskComposerServer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        _tesseract_task_composer_python.TaskComposerServer_swiginit(self, _tesseract_task_composer_python.new_TaskComposerServer())

    def loadConfig(self, *args):
        r"""
        *Overload 1:*

        Load plugins from yaml node
        :type config: YAML::Node
        :param config: The config node

        |

        *Overload 2:*

        Load plugins from file path
        :type config: :py:class:`path`
        :param config: The config file path

        |

        *Overload 3:*

        Load plugins from string
        :type config: string
        :param config: The config string
        """
        return _tesseract_task_composer_python.TaskComposerServer_loadConfig(self, *args)

    def addExecutor(self, executor):
        r"""
        Add a executors (thread pool)
        :type executor: :py:class:`TaskComposerExecutor`
        :param executor: The executor to add
        """
        return _tesseract_task_composer_python.TaskComposerServer_addExecutor(self, executor)

    def getExecutor(self, name):
        r"""
        Get an executor by name
        :type name: string
        :param name: The name of the executor
        :rtype: :py:class:`TaskComposerExecutor`
        :return: The exector, if not found nullptr is returned
        """
        return _tesseract_task_composer_python.TaskComposerServer_getExecutor(self, name)

    def hasExecutor(self, name):
        r"""
        Check if executors (thread pool) exists with the provided name
        :type name: string
        :param name: The name to search
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerServer_hasExecutor(self, name)

    def getAvailableExecutors(self):
        r"""
        Get the available executors (thread pool) names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of names
        """
        return _tesseract_task_composer_python.TaskComposerServer_getAvailableExecutors(self)

    def addTask(self, task):
        r"""
        Add a task
        :type task: std::unique_ptr< tesseract_planning::TaskComposerNode >
        :param task: The task to add
        """
        return _tesseract_task_composer_python.TaskComposerServer_addTask(self, task)

    def getTask(self, name):
        r"""
        Get a task
        :type name: string
        :param name: The the name of task to retrieve
        """
        return _tesseract_task_composer_python.TaskComposerServer_getTask(self, name)

    def hasTask(self, name):
        r"""
        Check if task exists with the provided name
        :type name: string
        :param name: The name to search
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_task_composer_python.TaskComposerServer_hasTask(self, name)

    def getAvailableTasks(self):
        r"""
        Get the available task names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of names
        """
        return _tesseract_task_composer_python.TaskComposerServer_getAvailableTasks(self)

    def run(self, *args):
        r"""
        *Overload 1:*

        Execute the provided task graph
        :type task_name: string
        :param task_name: The task name to run
        :type data_storage: :py:class:`TaskComposerDataStorage`
        :param data_storage: The data storage
        :type dotgraph: boolean
        :param dotgraph: Indicate if dotgraph should be generated
        :param excutor_name: The name of the executor to use
        :rtype: std::unique_ptr< tesseract_planning::TaskComposerFuture >
        :return: The future associated with execution

        |

        *Overload 2:*

        Execute the provided node
        It will call one of the methods below based on the node type
        :type node: :py:class:`TaskComposerNode`
        :param node: The node to execute
        :type data_storage: :py:class:`TaskComposerDataStorage`
        :param data_storage: The data storage
        :type dotgraph: boolean
        :param dotgraph: Indicate if dotgraph should be generated
        :param excutor_name: The name of the executor to use
        :rtype: std::unique_ptr< tesseract_planning::TaskComposerFuture >
        :return: The future associated with execution
        """
        return _tesseract_task_composer_python.TaskComposerServer_run(self, *args)

    def getWorkerCount(self, name):
        r""" Queries the number of workers (example: number of threads)"""
        return _tesseract_task_composer_python.TaskComposerServer_getWorkerCount(self, name)

    def getTaskCount(self, name):
        r""" Queries the number of running tasks at the time of this call"""
        return _tesseract_task_composer_python.TaskComposerServer_getTaskCount(self, name)
    __swig_destroy__ = _tesseract_task_composer_python.delete_TaskComposerServer

# Register TaskComposerServer in _tesseract_task_composer_python:
_tesseract_task_composer_python.TaskComposerServer_swigregister(TaskComposerServer)
class ContactCheckProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.ContactCheckProfile_swiginit(self, _tesseract_task_composer_python.new_ContactCheckProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.ContactCheckProfile_getStaticKey()
    config = property(_tesseract_task_composer_python.ContactCheckProfile_config_get, _tesseract_task_composer_python.ContactCheckProfile_config_set, doc=r""" The contact manager config""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_ContactCheckProfile

# Register ContactCheckProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.ContactCheckProfile_swigregister(ContactCheckProfile)
class FixStateBoundsProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Settings_START_ONLY = _tesseract_task_composer_python.FixStateBoundsProfile_Settings_START_ONLY
    Settings_END_ONLY = _tesseract_task_composer_python.FixStateBoundsProfile_Settings_END_ONLY
    Settings_ALL = _tesseract_task_composer_python.FixStateBoundsProfile_Settings_ALL
    Settings_DISABLED = _tesseract_task_composer_python.FixStateBoundsProfile_Settings_DISABLED

    def __init__(self, *args):
        _tesseract_task_composer_python.FixStateBoundsProfile_swiginit(self, _tesseract_task_composer_python.new_FixStateBoundsProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.FixStateBoundsProfile_getStaticKey()
    mode = property(_tesseract_task_composer_python.FixStateBoundsProfile_mode_get, _tesseract_task_composer_python.FixStateBoundsProfile_mode_set, doc=r""" Sets which terms will be corrected""")
    max_deviation_global = property(_tesseract_task_composer_python.FixStateBoundsProfile_max_deviation_global_get, _tesseract_task_composer_python.FixStateBoundsProfile_max_deviation_global_set, doc=r""" Maximum amount the process is allowed to correct. If deviation is further than this, it will fail""")
    upper_bounds_reduction = property(_tesseract_task_composer_python.FixStateBoundsProfile_upper_bounds_reduction_get, _tesseract_task_composer_python.FixStateBoundsProfile_upper_bounds_reduction_set, doc=r""" Amount to reduce the upper bounds before clamping limits. Should be > 1""")
    lower_bounds_reduction = property(_tesseract_task_composer_python.FixStateBoundsProfile_lower_bounds_reduction_get, _tesseract_task_composer_python.FixStateBoundsProfile_lower_bounds_reduction_set, doc=r""" Amount to increase the lower bounds before clamping limits. Should be > 1""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_FixStateBoundsProfile

# Register FixStateBoundsProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.FixStateBoundsProfile_swigregister(FixStateBoundsProfile)
class FixStateCollisionProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Settings_START_ONLY = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_START_ONLY
    Settings_END_ONLY = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_END_ONLY
    Settings_INTERMEDIATE_ONLY = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_INTERMEDIATE_ONLY
    Settings_ALL = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_ALL
    Settings_ALL_EXCEPT_START = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_ALL_EXCEPT_START
    Settings_ALL_EXCEPT_END = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_ALL_EXCEPT_END
    Settings_DISABLED = _tesseract_task_composer_python.FixStateCollisionProfile_Settings_DISABLED
    CorrectionMethod_NONE = _tesseract_task_composer_python.FixStateCollisionProfile_CorrectionMethod_NONE
    CorrectionMethod_TRAJOPT = _tesseract_task_composer_python.FixStateCollisionProfile_CorrectionMethod_TRAJOPT
    CorrectionMethod_RANDOM_SAMPLER = _tesseract_task_composer_python.FixStateCollisionProfile_CorrectionMethod_RANDOM_SAMPLER

    def __init__(self, *args):
        _tesseract_task_composer_python.FixStateCollisionProfile_swiginit(self, _tesseract_task_composer_python.new_FixStateCollisionProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.FixStateCollisionProfile_getStaticKey()
    mode = property(_tesseract_task_composer_python.FixStateCollisionProfile_mode_get, _tesseract_task_composer_python.FixStateCollisionProfile_mode_set, doc=r""" Sets which terms will be corrected""")
    correction_workflow = property(_tesseract_task_composer_python.FixStateCollisionProfile_correction_workflow_get, _tesseract_task_composer_python.FixStateCollisionProfile_correction_workflow_set, doc=r"""
     Order that correction methods will be applied. These will be attempted in order until one succeeds or all
    have been tried
    """)
    jiggle_factor = property(_tesseract_task_composer_python.FixStateCollisionProfile_jiggle_factor_get, _tesseract_task_composer_python.FixStateCollisionProfile_jiggle_factor_set, doc=r""" Percent of the total joint range that a joint will be allowed to be adjusted""")
    collision_check_config = property(_tesseract_task_composer_python.FixStateCollisionProfile_collision_check_config_get, _tesseract_task_composer_python.FixStateCollisionProfile_collision_check_config_set, doc=r""" Safety margin applied to collision costs/cnts when using trajopt to correct collisions""")
    sampling_attempts = property(_tesseract_task_composer_python.FixStateCollisionProfile_sampling_attempts_get, _tesseract_task_composer_python.FixStateCollisionProfile_sampling_attempts_set, doc=r""" Number of sampling attempts if TrajOpt correction fails""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_FixStateCollisionProfile

# Register FixStateCollisionProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.FixStateCollisionProfile_swigregister(FixStateCollisionProfile)
class IterativeSplineParameterizationProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.IterativeSplineParameterizationProfile_swiginit(self, _tesseract_task_composer_python.new_IterativeSplineParameterizationProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.IterativeSplineParameterizationProfile_getStaticKey()
    max_velocity_scaling_factor = property(_tesseract_task_composer_python.IterativeSplineParameterizationProfile_max_velocity_scaling_factor_get, _tesseract_task_composer_python.IterativeSplineParameterizationProfile_max_velocity_scaling_factor_set, doc=r""" max_velocity_scaling_factor The max velocity scaling factor passed to the solver""")
    max_acceleration_scaling_factor = property(_tesseract_task_composer_python.IterativeSplineParameterizationProfile_max_acceleration_scaling_factor_get, _tesseract_task_composer_python.IterativeSplineParameterizationProfile_max_acceleration_scaling_factor_set, doc=r""" max_velocity_scaling_factor The max acceleration scaling factor passed to the solver""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_IterativeSplineParameterizationProfile

# Register IterativeSplineParameterizationProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.IterativeSplineParameterizationProfile_swigregister(IterativeSplineParameterizationProfile)
class MinLengthProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.MinLengthProfile_swiginit(self, _tesseract_task_composer_python.new_MinLengthProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.MinLengthProfile_getStaticKey()
    min_length = property(_tesseract_task_composer_python.MinLengthProfile_min_length_get, _tesseract_task_composer_python.MinLengthProfile_min_length_set)
    __swig_destroy__ = _tesseract_task_composer_python.delete_MinLengthProfile

# Register MinLengthProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.MinLengthProfile_swigregister(MinLengthProfile)
class ProfileSwitchProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, return_value=1):
        _tesseract_task_composer_python.ProfileSwitchProfile_swiginit(self, _tesseract_task_composer_python.new_ProfileSwitchProfile(return_value))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.ProfileSwitchProfile_getStaticKey()
    return_value = property(_tesseract_task_composer_python.ProfileSwitchProfile_return_value_get, _tesseract_task_composer_python.ProfileSwitchProfile_return_value_set)
    __swig_destroy__ = _tesseract_task_composer_python.delete_ProfileSwitchProfile

# Register ProfileSwitchProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.ProfileSwitchProfile_swigregister(ProfileSwitchProfile)
class RuckigTrajectorySmoothingCompositeProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_swiginit(self, _tesseract_task_composer_python.new_RuckigTrajectorySmoothingCompositeProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_getStaticKey()
    duration_extension_fraction = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_duration_extension_fraction_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_duration_extension_fraction_set, doc=r""" duration_extension_fraction The amount to scale the trajectory each time""")
    max_duration_extension_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_duration_extension_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_duration_extension_factor_set, doc=r""" The max allow extension factor""")
    max_velocity_scaling_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_velocity_scaling_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_velocity_scaling_factor_set, doc=r""" max_velocity_scaling_factor The max velocity scaling factor passed to the solver""")
    max_acceleration_scaling_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_acceleration_scaling_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_acceleration_scaling_factor_set, doc=r""" max_velocity_scaling_factor The max acceleration scaling factor passed to the solver""")
    max_jerk_scaling_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_jerk_scaling_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_max_jerk_scaling_factor_set, doc=r""" max_jerk_scaling_factor The max jerk scaling factor passed to the solver""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_RuckigTrajectorySmoothingCompositeProfile

# Register RuckigTrajectorySmoothingCompositeProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.RuckigTrajectorySmoothingCompositeProfile_swigregister(RuckigTrajectorySmoothingCompositeProfile)
class RuckigTrajectorySmoothingMoveProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_swiginit(self, _tesseract_task_composer_python.new_RuckigTrajectorySmoothingMoveProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_getStaticKey()
    max_velocity_scaling_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_max_velocity_scaling_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_max_velocity_scaling_factor_set, doc=r""" max_velocity_scaling_factor The max velocity scaling factor passed to the solver""")
    max_acceleration_scaling_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_max_acceleration_scaling_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_max_acceleration_scaling_factor_set, doc=r""" max_velocity_scaling_factor The max acceleration scaling factor passed to the solver""")
    max_jerk_scaling_factor = property(_tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_max_jerk_scaling_factor_get, _tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_max_jerk_scaling_factor_set, doc=r""" max_jerk_scaling_factor The max jerk scaling factor passed to the solver""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_RuckigTrajectorySmoothingMoveProfile

# Register RuckigTrajectorySmoothingMoveProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.RuckigTrajectorySmoothingMoveProfile_swigregister(RuckigTrajectorySmoothingMoveProfile)
class TimeOptimalParameterizationProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.TimeOptimalParameterizationProfile_swiginit(self, _tesseract_task_composer_python.new_TimeOptimalParameterizationProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.TimeOptimalParameterizationProfile_getStaticKey()
    max_velocity_scaling_factor = property(_tesseract_task_composer_python.TimeOptimalParameterizationProfile_max_velocity_scaling_factor_get, _tesseract_task_composer_python.TimeOptimalParameterizationProfile_max_velocity_scaling_factor_set, doc=r""" The max velocity scaling factor passed to the solver. Default: 1.0""")
    max_acceleration_scaling_factor = property(_tesseract_task_composer_python.TimeOptimalParameterizationProfile_max_acceleration_scaling_factor_get, _tesseract_task_composer_python.TimeOptimalParameterizationProfile_max_acceleration_scaling_factor_set, doc=r""" The max acceleration scaling factor passed to the solver. Default: 1.0""")
    max_jerk_scaling_factor = property(_tesseract_task_composer_python.TimeOptimalParameterizationProfile_max_jerk_scaling_factor_get, _tesseract_task_composer_python.TimeOptimalParameterizationProfile_max_jerk_scaling_factor_set, doc=r""" The max acceleration scaling factor passed to the solver. Default: 1.0""")
    path_tolerance = property(_tesseract_task_composer_python.TimeOptimalParameterizationProfile_path_tolerance_get, _tesseract_task_composer_python.TimeOptimalParameterizationProfile_path_tolerance_set, doc=r""" path_tolerance. Default: 0.1""")
    min_angle_change = property(_tesseract_task_composer_python.TimeOptimalParameterizationProfile_min_angle_change_get, _tesseract_task_composer_python.TimeOptimalParameterizationProfile_min_angle_change_set, doc=r""" At least one joint must change by greater than this amount for the point to be added. Default: 0.001""")
    __swig_destroy__ = _tesseract_task_composer_python.delete_TimeOptimalParameterizationProfile

# Register TimeOptimalParameterizationProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.TimeOptimalParameterizationProfile_swigregister(TimeOptimalParameterizationProfile)
class UpsampleTrajectoryProfile(tesseract_robotics.tesseract_command_language.tesseract_command_language_python.Profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_task_composer_python.UpsampleTrajectoryProfile_swiginit(self, _tesseract_task_composer_python.new_UpsampleTrajectoryProfile(*args))

    @staticmethod
    def getStaticKey():
        r"""
        A utility function for getting profile ID
        :rtype: int
        :return: The profile ID used when storing in profile dictionary
        """
        return _tesseract_task_composer_python.UpsampleTrajectoryProfile_getStaticKey()
    longest_valid_segment_length = property(_tesseract_task_composer_python.UpsampleTrajectoryProfile_longest_valid_segment_length_get, _tesseract_task_composer_python.UpsampleTrajectoryProfile_longest_valid_segment_length_set)
    __swig_destroy__ = _tesseract_task_composer_python.delete_UpsampleTrajectoryProfile

# Register UpsampleTrajectoryProfile in _tesseract_task_composer_python:
_tesseract_task_composer_python.UpsampleTrajectoryProfile_swigregister(UpsampleTrajectoryProfile)

