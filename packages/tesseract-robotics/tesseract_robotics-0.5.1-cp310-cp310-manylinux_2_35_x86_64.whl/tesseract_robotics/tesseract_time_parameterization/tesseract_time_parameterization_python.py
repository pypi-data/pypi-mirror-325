# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_time_parameterization_python
else:
    import _tesseract_time_parameterization_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_time_parameterization_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_time_parameterization_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_time_parameterization_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_time_parameterization_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_time_parameterization_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_time_parameterization_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_time_parameterization_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_time_parameterization_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_time_parameterization_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_time_parameterization_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_time_parameterization_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_time_parameterization_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_time_parameterization_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_time_parameterization_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_time_parameterization_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_time_parameterization_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_time_parameterization_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
import tesseract_robotics.tesseract_common.tesseract_common_python
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TrajectoryContainer(object):
    r""" A generic container that the time parameterization classes use"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_TrajectoryContainer

    def getPosition(self, *args):
        return _tesseract_time_parameterization_python.TrajectoryContainer_getPosition(self, *args)

    def getVelocity(self, *args):
        return _tesseract_time_parameterization_python.TrajectoryContainer_getVelocity(self, *args)

    def getAcceleration(self, *args):
        return _tesseract_time_parameterization_python.TrajectoryContainer_getAcceleration(self, *args)

    def getTimeFromStart(self, i):
        r"""
        Get the time from start at a given index
        :type i: Eigen::Index
        :param i: The index to extract time from start
        :rtype: float
        :return: The time from start
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_getTimeFromStart(self, i)

    def setData(self, i, velocity, acceleration, time):
        r"""
        Set data for a given index
        :type i: Eigen::Index
        :param i: The index to set data
        :type velocity: Eigen::VectorXd
        :param velocity: The velocity data to assign to index
        :type acceleration: Eigen::VectorXd
        :param acceleration: The acceleration data to assign to index
        :type time: float
        :param time: The time from start to assign to index
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_setData(self, i, velocity, acceleration, time)

    def size(self):
        r""" The size of the path"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_size(self)

    def dof(self):
        r""" The degree of freedom for the path"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_dof(self)

    def empty(self):
        r""" Check if the path is empty"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_empty(self)

    def isTimeStrictlyIncreasing(self):
        r""" Check if time is strictly increasing"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_isTimeStrictlyIncreasing(self)

# Register TrajectoryContainer in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.TrajectoryContainer_swigregister(TrajectoryContainer)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class InstructionsTrajectory(TrajectoryContainer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_time_parameterization_python.InstructionsTrajectory_swiginit(self, _tesseract_time_parameterization_python.new_InstructionsTrajectory(*args))

    def getPosition(self, *args):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getPosition(self, *args)

    def getVelocity(self, *args):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getVelocity(self, *args)

    def getAcceleration(self, *args):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getAcceleration(self, *args)

    def getTimeFromStart(self, i):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getTimeFromStart(self, i)

    def setData(self, i, velocity, acceleration, time):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_setData(self, i, velocity, acceleration, time)

    def size(self):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_size(self)

    def dof(self):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_dof(self)

    def empty(self):
        return _tesseract_time_parameterization_python.InstructionsTrajectory_empty(self)
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_InstructionsTrajectory

# Register InstructionsTrajectory in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.InstructionsTrajectory_swigregister(InstructionsTrajectory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class IterativeSplineParameterization(object):
    r"""
    This class sets the timestamps of a trajectory
    to enforce velocity, acceleration constraints.
    Initial/final velocities and accelerations may be specified in the trajectory.
    Velocity and acceleration limits are specified in the model.

    This algorithm repeatedly fits a cubic spline, adjusts the timing intervals,
    and repeats until all constraints are satisfied.
    When finished, each trajectory waypoint will have the time set,
    as well as the velocities and accelerations for each joint.
    Since we fit to a cubic spline, the position, velocity, and
    acceleration will be continuous and within bounds.
    The jerk will be discontinuous.

    To match the velocity and acceleration at the endpoints,
    the second and second-last point locations need to move.
    By default, two extra points are added to leave the original trajectory unaffected.
    If points are not added, the trajectory could potentially be faster,
    but the 2nd and 2nd-last points should be re-checked for collisions.

    Migration notes:  If migrating from Iterative Parabolic Time Parameterization,
    be aware that the velocity and acceleration limits are more strictly enforced
    using this technique.
    This means that time-parameterizing the same trajectory with the same
    velocity and acceleration limits, will result in a longer trajectory.
    If this is a problem, try retuning (increasing) the limits.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_IterativeSplineParameterization

    def __init__(self, *args):
        _tesseract_time_parameterization_python.IterativeSplineParameterization_swiginit(self, _tesseract_time_parameterization_python.new_IterativeSplineParameterization(*args))

    def compute(self, *args):
        return _tesseract_time_parameterization_python.IterativeSplineParameterization_compute(self, *args)

# Register IterativeSplineParameterization in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.IterativeSplineParameterization_swigregister(IterativeSplineParameterization)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TimeOptimalTrajectoryGeneration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, path_tolerance=0.1, min_angle_change=0.001):
        _tesseract_time_parameterization_python.TimeOptimalTrajectoryGeneration_swiginit(self, _tesseract_time_parameterization_python.new_TimeOptimalTrajectoryGeneration(path_tolerance, min_angle_change))

    def compute(self, *args):
        r"""
        Compute timestampes
        Currently this only supports using max velocity and acceleration so min values are ignored
        Currently only supports a single scale factor so the input must be of length one.
        """
        return _tesseract_time_parameterization_python.TimeOptimalTrajectoryGeneration_compute(self, *args)
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_TimeOptimalTrajectoryGeneration

# Register TimeOptimalTrajectoryGeneration in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.TimeOptimalTrajectoryGeneration_swigregister(TimeOptimalTrajectoryGeneration)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class RuckigTrajectorySmoothing(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_RuckigTrajectorySmoothing

    def __init__(self, *args):
        _tesseract_time_parameterization_python.RuckigTrajectorySmoothing_swiginit(self, _tesseract_time_parameterization_python.new_RuckigTrajectorySmoothing(*args))

    def setDurationExtensionFraction(self, duration_extension_fraction):
        r""" Set the duration extension fraction"""
        return _tesseract_time_parameterization_python.RuckigTrajectorySmoothing_setDurationExtensionFraction(self, duration_extension_fraction)

    def setMaxDurationExtensionFactor(self, max_duration_extension_factor):
        r""" Set the max duration extension factor"""
        return _tesseract_time_parameterization_python.RuckigTrajectorySmoothing_setMaxDurationExtensionFactor(self, max_duration_extension_factor)

    def compute(self, *args):
        return _tesseract_time_parameterization_python.RuckigTrajectorySmoothing_compute(self, *args)

# Register RuckigTrajectorySmoothing in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.RuckigTrajectorySmoothing_swigregister(RuckigTrajectorySmoothing)

