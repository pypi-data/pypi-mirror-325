# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_collision_python
else:
    import _tesseract_collision_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_collision_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_collision_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_collision_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_collision_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_collision_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_collision_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_collision_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_collision_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_collision_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_collision_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_collision_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_collision_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_collision_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_collision_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_collision_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_collision_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_collision_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_collision_python:
_tesseract_collision_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_common.tesseract_common_python
class IsContactAllowedFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a, b):
        return _tesseract_collision_python.IsContactAllowedFnBase_call(self, a, b)
    __swig_destroy__ = _tesseract_collision_python.delete_IsContactAllowedFnBase

    def __init__(self):
        if self.__class__ == IsContactAllowedFnBase:
            _self = None
        else:
            _self = self
        _tesseract_collision_python.IsContactAllowedFnBase_swiginit(self, _tesseract_collision_python.new_IsContactAllowedFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_collision_python.disown_IsContactAllowedFnBase(self)
        return weakref.proxy(self)

# Register IsContactAllowedFnBase in _tesseract_collision_python:
_tesseract_collision_python.IsContactAllowedFnBase_swigregister(IsContactAllowedFnBase)


class IsContactAllowedFn(IsContactAllowedFnBase):
  def __init__(self,fn):
    super(IsContactAllowedFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class IsContactValidFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a):
        return _tesseract_collision_python.IsContactValidFnBase_call(self, a)
    __swig_destroy__ = _tesseract_collision_python.delete_IsContactValidFnBase

    def __init__(self):
        if self.__class__ == IsContactValidFnBase:
            _self = None
        else:
            _self = self
        _tesseract_collision_python.IsContactValidFnBase_swiginit(self, _tesseract_collision_python.new_IsContactValidFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_collision_python.disown_IsContactValidFnBase(self)
        return weakref.proxy(self)

# Register IsContactValidFnBase in _tesseract_collision_python:
_tesseract_collision_python.IsContactValidFnBase_swigregister(IsContactValidFnBase)


class IsContactValidFn(IsContactValidFnBase):
  def __init__(self,fn):
    super(IsContactValidFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContinuousContactManagerUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContinuousContactManagerUPtr_swiginit(self, _tesseract_collision_python.new_ContinuousContactManagerUPtr(*args))

    def __deref__(self):
        return _tesseract_collision_python.ContinuousContactManagerUPtr___deref__(self)

    def release(self):
        return _tesseract_collision_python.ContinuousContactManagerUPtr_release(self)

    def reset(self, *args):
        return _tesseract_collision_python.ContinuousContactManagerUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_collision_python.ContinuousContactManagerUPtr_swap(self, __u)

    def get(self):
        return _tesseract_collision_python.ContinuousContactManagerUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_collision_python.ContinuousContactManagerUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_collision_python.delete_ContinuousContactManagerUPtr

    def getName(self):
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getName(self)

    def clone(self):
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_clone(self)

    def addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled=True):
        r"""
        Add a collision object to the checker

        All objects are added should initially be added as static objects. Use the
        setContactRequest method of defining which collision objects are moving.

        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :param shape_types:     A vector of shape types for encode the collision object. If the vector is of length 1 it is
            used for all shapes.
        :param collision_object_types: A int identifying a conversion mode for the object. (ex. convert meshes to
            convex_hulls)
        :type enabled: boolean, optional
        :param enabled:         Indicate if the object is enabled for collision checking.
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name):
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name):
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name):
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_hasCollisionObject(self, name)

    def removeCollisionObject(self, name):
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_removeCollisionObject(self, name)

    def enableCollisionObject(self, name):
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_enableCollisionObject(self, name)

    def disableCollisionObject(self, name):
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name):
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args):
        r"""
        *Overload 1:*

        Set a single static collision object's tansforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The tranformation in world

        |

        *Overload 2:*

        Set a series of static collision object's tranforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The tranformation in world

        |

        *Overload 3:*

        Set a series of static collision object's tranforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>

        |

        *Overload 4:*

        Set a single cast(moving) collision object's tansforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type name: string
        :param name: The name of the object
        :type pose1: :py:class:`Isometry3d`
        :param pose1: The start tranformation in world
        :type pose2: :py:class:`Isometry3d`
        :param pose2: The end tranformation in world

        |

        *Overload 5:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type pose1: :py:class:`VectorIsometry3d`
        :param pose1: The start tranformations in world
        :type pose2: :py:class:`VectorIsometry3d`
        :param pose2: The end tranformations in world

        |

        *Overload 6:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type pose1: :py:class:`TransformMap`
        :param pose1: A start transform map <name, pose>
        :type pose2: :py:class:`TransformMap`
        :param pose2: A end transform map <name, pose>
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self):
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names):
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self):
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args):
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin):
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1, name2, collision_margin):
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self):
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionMarginData(self)

    def setContactAllowedValidator(self, validator):
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setContactAllowedValidator(self, validator)

    def getContactAllowedValidator(self):
        r""" Get the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getContactAllowedValidator(self)

    def contactTest(self, collisions, request):
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The Contact results data
        :param type: The type of contact test
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config):
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_applyContactManagerConfig(self, config)

# Register ContinuousContactManagerUPtr in _tesseract_collision_python:
_tesseract_collision_python.ContinuousContactManagerUPtr_swigregister(ContinuousContactManagerUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class DiscreteContactManagerUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.DiscreteContactManagerUPtr_swiginit(self, _tesseract_collision_python.new_DiscreteContactManagerUPtr(*args))

    def __deref__(self):
        return _tesseract_collision_python.DiscreteContactManagerUPtr___deref__(self)

    def release(self):
        return _tesseract_collision_python.DiscreteContactManagerUPtr_release(self)

    def reset(self, *args):
        return _tesseract_collision_python.DiscreteContactManagerUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_collision_python.DiscreteContactManagerUPtr_swap(self, __u)

    def get(self):
        return _tesseract_collision_python.DiscreteContactManagerUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_collision_python.DiscreteContactManagerUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_collision_python.delete_DiscreteContactManagerUPtr

    def getName(self):
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getName(self)

    def clone(self):
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_clone(self)

    def addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled=True):
        r"""
        Add a object to the checker
        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name):
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name):
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name):
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_hasCollisionObject(self, name)

    def removeCollisionObject(self, name):
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_removeCollisionObject(self, name)

    def enableCollisionObject(self, name):
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_enableCollisionObject(self, name)

    def disableCollisionObject(self, name):
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name):
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args):
        r"""
        *Overload 1:*

        Set a single collision object's transforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The transformation in world

        |

        *Overload 2:*

        Set a series of collision object's transforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The transformation in world

        |

        *Overload 3:*

        Set a series of collision object's transforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self):
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names):
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self):
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args):
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin):
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1, name2, collision_margin):
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self):
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionMarginData(self)

    def setContactAllowedValidator(self, validator):
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setContactAllowedValidator(self, validator)

    def getContactAllowedValidator(self):
        r""" Get the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getContactAllowedValidator(self)

    def contactTest(self, collisions, request):
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The contact results data
        :type request: :py:class:`ContactRequest`
        :param request: The contact request data
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config):
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_applyContactManagerConfig(self, config)

# Register DiscreteContactManagerUPtr in _tesseract_collision_python:
_tesseract_collision_python.DiscreteContactManagerUPtr_swigregister(DiscreteContactManagerUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactResultVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_collision_python.ContactResultVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_collision_python.ContactResultVector___nonzero__(self)

    def __bool__(self):
        return _tesseract_collision_python.ContactResultVector___bool__(self)

    def __len__(self):
        return _tesseract_collision_python.ContactResultVector___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_collision_python.ContactResultVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_collision_python.ContactResultVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_collision_python.ContactResultVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_collision_python.ContactResultVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_collision_python.ContactResultVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_collision_python.ContactResultVector___setitem__(self, *args)

    def pop(self):
        return _tesseract_collision_python.ContactResultVector_pop(self)

    def append(self, x):
        return _tesseract_collision_python.ContactResultVector_append(self, x)

    def empty(self):
        return _tesseract_collision_python.ContactResultVector_empty(self)

    def size(self):
        return _tesseract_collision_python.ContactResultVector_size(self)

    def swap(self, v):
        return _tesseract_collision_python.ContactResultVector_swap(self, v)

    def begin(self):
        return _tesseract_collision_python.ContactResultVector_begin(self)

    def end(self):
        return _tesseract_collision_python.ContactResultVector_end(self)

    def rbegin(self):
        return _tesseract_collision_python.ContactResultVector_rbegin(self)

    def rend(self):
        return _tesseract_collision_python.ContactResultVector_rend(self)

    def clear(self):
        return _tesseract_collision_python.ContactResultVector_clear(self)

    def get_allocator(self):
        return _tesseract_collision_python.ContactResultVector_get_allocator(self)

    def pop_back(self):
        return _tesseract_collision_python.ContactResultVector_pop_back(self)

    def erase(self, *args):
        return _tesseract_collision_python.ContactResultVector_erase(self, *args)

    def __init__(self, *args):
        _tesseract_collision_python.ContactResultVector_swiginit(self, _tesseract_collision_python.new_ContactResultVector(*args))

    def push_back(self, x):
        return _tesseract_collision_python.ContactResultVector_push_back(self, x)

    def front(self):
        return _tesseract_collision_python.ContactResultVector_front(self)

    def back(self):
        return _tesseract_collision_python.ContactResultVector_back(self)

    def assign(self, n, x):
        return _tesseract_collision_python.ContactResultVector_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_collision_python.ContactResultVector_resize(self, *args)

    def insert(self, *args):
        return _tesseract_collision_python.ContactResultVector_insert(self, *args)

    def reserve(self, n):
        return _tesseract_collision_python.ContactResultVector_reserve(self, n)

    def capacity(self):
        return _tesseract_collision_python.ContactResultVector_capacity(self)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactResultVector

# Register ContactResultVector in _tesseract_collision_python:
_tesseract_collision_python.ContactResultVector_swigregister(ContactResultVector)
ContinuousCollisionType_CCType_None = _tesseract_collision_python.ContinuousCollisionType_CCType_None
ContinuousCollisionType_CCType_Time0 = _tesseract_collision_python.ContinuousCollisionType_CCType_Time0
ContinuousCollisionType_CCType_Time1 = _tesseract_collision_python.ContinuousCollisionType_CCType_Time1
ContinuousCollisionType_CCType_Between = _tesseract_collision_python.ContinuousCollisionType_CCType_Between
ContactTestType_FIRST = _tesseract_collision_python.ContactTestType_FIRST
r""" Return at first contact for any pair of objects"""
ContactTestType_CLOSEST = _tesseract_collision_python.ContactTestType_CLOSEST
r""" Return the global minimum for a pair of objects"""
ContactTestType_ALL = _tesseract_collision_python.ContactTestType_ALL
r""" Return all contacts for a pair of objects"""
ContactTestType_LIMITED = _tesseract_collision_python.ContactTestType_LIMITED
r""" Return limited set of contacts for a pair of objects"""
class ContactResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    distance = property(_tesseract_collision_python.ContactResult_distance_get, _tesseract_collision_python.ContactResult_distance_set, doc=r""" The distance between two links""")
    type_id = property(_tesseract_collision_python.ContactResult_type_id_get, _tesseract_collision_python.ContactResult_type_id_set, doc=r""" A user defined type id that is added to the contact shapes""")
    link_names = property(_tesseract_collision_python.ContactResult_link_names_get, _tesseract_collision_python.ContactResult_link_names_set, doc=r""" The two links that are in contact""")
    shape_id = property(_tesseract_collision_python.ContactResult_shape_id_get, _tesseract_collision_python.ContactResult_shape_id_set, doc=r""" The two shapes that are in contact. Each link can be made up of multiple shapes""")
    subshape_id = property(_tesseract_collision_python.ContactResult_subshape_id_get, _tesseract_collision_python.ContactResult_subshape_id_set, doc=r""" Some shapes like octomap and mesh have subshape (boxes and triangles)""")
    nearest_points = property(_tesseract_collision_python.ContactResult_nearest_points_get, _tesseract_collision_python.ContactResult_nearest_points_set, doc=r""" The nearest point on both links in world coordinates""")
    nearest_points_local = property(_tesseract_collision_python.ContactResult_nearest_points_local_get, _tesseract_collision_python.ContactResult_nearest_points_local_set, doc=r""" The nearest point on both links in local(link) coordinates""")
    transform = property(_tesseract_collision_python.ContactResult_transform_get, _tesseract_collision_python.ContactResult_transform_set, doc=r""" The transform of link in world coordinates""")
    normal = property(_tesseract_collision_python.ContactResult_normal_get, _tesseract_collision_python.ContactResult_normal_set, doc=r"""
    The normal vector to move the two objects out of contact in world coordinates

    Notes: This points from link_name[0] to link_name[1], so it shows the direction to move link_name[1] to avoid or get
          out of collision with link_name[0].
    """)
    cc_time = property(_tesseract_collision_python.ContactResult_cc_time_get, _tesseract_collision_python.ContactResult_cc_time_set, doc=r""" This is between 0 and 1 indicating the point of contact""")
    cc_type = property(_tesseract_collision_python.ContactResult_cc_type_get, _tesseract_collision_python.ContactResult_cc_type_set, doc=r""" The type of continuous contact""")
    cc_transform = property(_tesseract_collision_python.ContactResult_cc_transform_get, _tesseract_collision_python.ContactResult_cc_transform_set, doc=r"""
     The transform of link in world coordinates at its desired final location.
    Note: This is not the location of the link at the point of contact but the final location the link when performing
          continuous collision checking. If you desire the location of contact use cc_time and interpolate between
          transform and cc_transform;
    """)
    single_contact_point = property(_tesseract_collision_python.ContactResult_single_contact_point_get, _tesseract_collision_python.ContactResult_single_contact_point_set, doc=r"""
     Some collision checkers only provide a single contact point for a given pair. This is used to indicate
    if only one contact point is provided which means nearest_points[0] must equal nearest_points[1].
    """)

    def __init__(self):
        _tesseract_collision_python.ContactResult_swiginit(self, _tesseract_collision_python.new_ContactResult())

    def clear(self):
        r""" reset to default values"""
        return _tesseract_collision_python.ContactResult_clear(self)

    def __eq__(self, rhs):
        return _tesseract_collision_python.ContactResult___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_collision_python.ContactResult___ne__(self, rhs)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactResult

# Register ContactResult in _tesseract_collision_python:
_tesseract_collision_python.ContactResult_swigregister(ContactResult)
cvar = _tesseract_collision_python.cvar
ContactTestTypeStrings = cvar.ContactTestTypeStrings

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactResultMap(object):
    r"""
    This structure hold contact results for link pairs
    A custom class was implemented to avoid a large number of heap allocations during motion which avoids full
    clearing the map. This class provides methods const container methods for access the internal map and has
    two distinct different when it comes to the clear, size and release methods.

    The clear method does not call clear on the map but instead it loops over all entries and calls clear on
    the vector being stored. This allows the memory to remain with the map and not get release for each of the vectors
    stored in the map.

    The size method loops over the map and counts those that have vectors which are not empty.

    The release method actually calls clear on the internal map relasing all memory.

    TODO: This should be updated to leverage a object pool for `ContactResultVector` where in the set and add methods
    it would check it the pair exists and if not it would pull from the object pool.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def addContactResult(self, *args):
        r"""
        *Overload 1:*

        Add contact results for the provided key
        :type key: :py:class:`KeyType`
        :param key: The key to append the results to
        :type result: :py:class:`ContactResult`
        :param result: The results to add

        |

        *Overload 2:*

        Add contact results for the provided key
        :type key: :py:class:`KeyType`
        :param key: The key to append the results to
        :param result: The results to add
        """
        return _tesseract_collision_python.ContactResultMap_addContactResult(self, *args)

    def setContactResult(self, *args):
        r"""
        *Overload 1:*

        Set contact results for the provided key
        :type key: :py:class:`KeyType`
        :param key: The key to assign the provided results to
        :type result: :py:class:`ContactResult`
        :param result: The results to assign

        |

        *Overload 2:*

        Set contact results for the provided key
        :type key: :py:class:`KeyType`
        :param key: The key to assign the provided results to
        :param result: The results to assign
        """
        return _tesseract_collision_python.ContactResultMap_setContactResult(self, *args)

    def addInterpolatedCollisionResults(self, sub_segment_results, sub_segment_index, sub_segment_last_index, active_link_names, segment_dt, discrete, filter=0):
        r"""
        This processes interpolated contact results by updating the cc_time and cc_type and then adds the result
        This is copied from the trajopt utility processInterpolatedCollisionResults
        :type sub_segment_results: :py:class:`ContactResultMap`
        :param sub_segment_results: The interpolated results to process
        :type sub_segment_index: int
        :param sub_segment_index: The current sub segment index
        :type sub_segment_last_index: int
        :param sub_segment_last_index: The last sub segment index
        :type active_link_names: std::vector< std::string,std::allocator< std::string > >
        :param active_link_names: The active link names
        :type segment_dt: float
        :param segment_dt: The segment dt
        :type discrete: boolean
        :param discrete: If discrete contact checker was used
        :type filter: tesseract_collision::ContactResultMap::FilterFn, optional
        :param filter: An option filter to exclude results
        """
        return _tesseract_collision_python.ContactResultMap_addInterpolatedCollisionResults(self, sub_segment_results, sub_segment_index, sub_segment_last_index, active_link_names, segment_dt, discrete, filter)

    def flattenMoveResults(self, v):
        return _tesseract_collision_python.ContactResultMap_flattenMoveResults(self, v)

    def flattenCopyResults(self, v):
        return _tesseract_collision_python.ContactResultMap_flattenCopyResults(self, v)

    def flattenWrapperResults(self, *args):
        return _tesseract_collision_python.ContactResultMap_flattenWrapperResults(self, *args)

    def filter(self, filter):
        r"""
        Filter out results using the provided function
        :param fn: The filter function
        """
        return _tesseract_collision_python.ContactResultMap_filter(self, filter)

    def count(self):
        r"""
        Get the total number of contact results storted
        :rtype: int
        :return: The number of contact results
        """
        return _tesseract_collision_python.ContactResultMap_count(self)

    def size(self):
        r"""
        Get the size of the map
        This loops over the internal map and counts entries with contacts
        :rtype: int
        :return: The number of entries with contacts
        """
        return _tesseract_collision_python.ContactResultMap_size(self)

    def empty(self):
        r"""
        Check if results are present
        :rtype: boolean
        :return: 
        """
        return _tesseract_collision_python.ContactResultMap_empty(self)

    def clear(self):
        r"""
        This is a consurvative clear.
        This does not call clear on the internal map but instead loops over each link pair entry and calls clear
        on the underlying vector. This way the vector capacity remains the same to avoid uneccessary heap allocation for
        subsequent contact requests.
        Notes: Use release to fully clear the internal data structure
        """
        return _tesseract_collision_python.ContactResultMap_clear(self)

    def shrinkToFit(self):
        r""" Remove map entries with no contact results"""
        return _tesseract_collision_python.ContactResultMap_shrinkToFit(self)

    def release(self):
        r""" Fully clear all internal data"""
        return _tesseract_collision_python.ContactResultMap_release(self)

    def getContainer(self):
        r"""
        Get the underlying container
        Warning: Do not use this for anything other than debugging or serialization
        """
        return _tesseract_collision_python.ContactResultMap_getContainer(self)

    def begin(self):
        r""" returns an iterator to the beginning"""
        return _tesseract_collision_python.ContactResultMap_begin(self)

    def end(self):
        r""" returns an iterator to the end"""
        return _tesseract_collision_python.ContactResultMap_end(self)

    def cbegin(self):
        r""" returns an iterator to the beginning"""
        return _tesseract_collision_python.ContactResultMap_cbegin(self)

    def cend(self):
        r""" returns an iterator to the end"""
        return _tesseract_collision_python.ContactResultMap_cend(self)

    def at(self, key):
        r""" access specified element with bounds checking"""
        return _tesseract_collision_python.ContactResultMap_at(self, key)

    def find(self, key):
        return _tesseract_collision_python.ContactResultMap_find(self, key)

    def __eq__(self, rhs):
        return _tesseract_collision_python.ContactResultMap___eq__(self, rhs)

    def __ne__(self, rhs):
        return _tesseract_collision_python.ContactResultMap___ne__(self, rhs)

    def getSummary(self):
        r"""
        Get a brief summary of the most frequently colliding link pair
        :rtype: string
        :return: A string containing the collision summary
        """
        return _tesseract_collision_python.ContactResultMap_getSummary(self)

    def __init__(self):
        _tesseract_collision_python.ContactResultMap_swiginit(self, _tesseract_collision_python.new_ContactResultMap())
    __swig_destroy__ = _tesseract_collision_python.delete_ContactResultMap

# Register ContactResultMap in _tesseract_collision_python:
_tesseract_collision_python.ContactResultMap_swigregister(ContactResultMap)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactRequest(object):
    r""" The ContactRequest struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    type = property(_tesseract_collision_python.ContactRequest_type_get, _tesseract_collision_python.ContactRequest_type_set, doc=r""" This controls the exit condition for the contact test type""")
    calculate_penetration = property(_tesseract_collision_python.ContactRequest_calculate_penetration_get, _tesseract_collision_python.ContactRequest_calculate_penetration_set, doc=r""" This enables the calculation of penetration contact data if two objects are in collision""")
    calculate_distance = property(_tesseract_collision_python.ContactRequest_calculate_distance_get, _tesseract_collision_python.ContactRequest_calculate_distance_set, doc=r""" This enables the calculation of distance data if two objects are within the contact threshold""")
    contact_limit = property(_tesseract_collision_python.ContactRequest_contact_limit_get, _tesseract_collision_python.ContactRequest_contact_limit_set, doc=r"""
     This is used if the ContactTestType is set to LIMITED, where the test will exit when number of contacts
    reach this limit
    """)
    is_valid = property(_tesseract_collision_python.ContactRequest_is_valid_get, _tesseract_collision_python.ContactRequest_is_valid_set, doc=r""" This provides a user defined function approve/reject contact results""")

    def __init__(self, *args):
        _tesseract_collision_python.ContactRequest_swiginit(self, _tesseract_collision_python.new_ContactRequest(*args))
    __swig_destroy__ = _tesseract_collision_python.delete_ContactRequest

# Register ContactRequest in _tesseract_collision_python:
_tesseract_collision_python.ContactRequest_swigregister(ContactRequest)
CollisionEvaluatorType_NONE = _tesseract_collision_python.CollisionEvaluatorType_NONE
r""" None"""
CollisionEvaluatorType_DISCRETE = _tesseract_collision_python.CollisionEvaluatorType_DISCRETE
r""" Discrete contact manager using only steps specified"""
CollisionEvaluatorType_LVS_DISCRETE = _tesseract_collision_python.CollisionEvaluatorType_LVS_DISCRETE
r""" Discrete contact manager interpolating using longest valid segment"""
CollisionEvaluatorType_CONTINUOUS = _tesseract_collision_python.CollisionEvaluatorType_CONTINUOUS
r""" Continuous contact manager using only steps specified"""
CollisionEvaluatorType_LVS_CONTINUOUS = _tesseract_collision_python.CollisionEvaluatorType_LVS_CONTINUOUS
r""" Continuous contact manager interpolating using longest valid segment"""
CollisionCheckProgramType_ALL = _tesseract_collision_python.CollisionCheckProgramType_ALL
r""" Check all states"""
CollisionCheckProgramType_ALL_EXCEPT_START = _tesseract_collision_python.CollisionCheckProgramType_ALL_EXCEPT_START
r""" Check all states except the start state"""
CollisionCheckProgramType_ALL_EXCEPT_END = _tesseract_collision_python.CollisionCheckProgramType_ALL_EXCEPT_END
r""" Check all states except the end state"""
CollisionCheckProgramType_START_ONLY = _tesseract_collision_python.CollisionCheckProgramType_START_ONLY
r""" Check only the start state"""
CollisionCheckProgramType_END_ONLY = _tesseract_collision_python.CollisionCheckProgramType_END_ONLY
r""" Check only the end state"""
CollisionCheckProgramType_INTERMEDIATE_ONLY = _tesseract_collision_python.CollisionCheckProgramType_INTERMEDIATE_ONLY
r""" Check only the intermediate states"""
ACMOverrideType_NONE = _tesseract_collision_python.ACMOverrideType_NONE
r""" Do not apply AllowedCollisionMatrix"""
ACMOverrideType_ASSIGN = _tesseract_collision_python.ACMOverrideType_ASSIGN
r""" Replace the current ContactAllowedValidator with one generated from the ACM provided"""
ACMOverrideType_AND = _tesseract_collision_python.ACMOverrideType_AND
r""" New ContactAllowedValidator combines the contact manager fn and the ACM generated fn with and AND"""
ACMOverrideType_OR = _tesseract_collision_python.ACMOverrideType_OR
r""" New ContactAllowedValidator combines the contact manager fn and the ACM generated fn with and OR"""
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactManagerConfig(object):
    r"""
    Contains parameters used to configure a contact manager before a series of contact checks.

    It should not contain information that is usually specific to a single contactTest such as CollisionObjectTransforms
    or specific to the way contactTests are carried out such as LVS parameters

    Notes: Active links were not added to this config since this config could be shared by multiple manipulators, and
    those are set based on which one is being checked
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContactManagerConfig_swiginit(self, _tesseract_collision_python.new_ContactManagerConfig(*args))
    margin_data_override_type = property(_tesseract_collision_python.ContactManagerConfig_margin_data_override_type_get, _tesseract_collision_python.ContactManagerConfig_margin_data_override_type_set, doc=r""" Identify how the collision margin data should be applied to the contact manager""")
    margin_data = property(_tesseract_collision_python.ContactManagerConfig_margin_data_get, _tesseract_collision_python.ContactManagerConfig_margin_data_set, doc=r""" Stores information about how the margins allowed between collision objects""")
    acm = property(_tesseract_collision_python.ContactManagerConfig_acm_get, _tesseract_collision_python.ContactManagerConfig_acm_set, doc=r""" Additional AllowedCollisionMatrix to consider for this collision check.""")
    acm_override_type = property(_tesseract_collision_python.ContactManagerConfig_acm_override_type_get, _tesseract_collision_python.ContactManagerConfig_acm_override_type_set, doc=r""" Specifies how to combine the ContactAllowedValidator from acm with the one preset in the contact manager""")
    modify_object_enabled = property(_tesseract_collision_python.ContactManagerConfig_modify_object_enabled_get, _tesseract_collision_python.ContactManagerConfig_modify_object_enabled_set, doc=r"""
     Each key is an object name. Objects will be enabled/disabled based on the value. Objects that aren't in the
    map are unmodified from the defaults
    """)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactManagerConfig

# Register ContactManagerConfig in _tesseract_collision_python:
_tesseract_collision_python.ContactManagerConfig_swigregister(ContactManagerConfig)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class CollisionCheckConfig(object):
    r"""
    This is a high level structure containing common information that collision checking utilities need. The goal
    of this config is to allow all collision checking utilities and planners to use the same data structure
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.CollisionCheckConfig_swiginit(self, _tesseract_collision_python.new_CollisionCheckConfig(*args))
    contact_manager_config = property(_tesseract_collision_python.CollisionCheckConfig_contact_manager_config_get, _tesseract_collision_python.CollisionCheckConfig_contact_manager_config_set, doc=r""" Used to configure the contact manager prior to a series of checks""")
    contact_request = property(_tesseract_collision_python.CollisionCheckConfig_contact_request_get, _tesseract_collision_python.CollisionCheckConfig_contact_request_set, doc=r""" ContactRequest that will be used for this check. Default test type: ALL""")
    type = property(_tesseract_collision_python.CollisionCheckConfig_type_get, _tesseract_collision_python.CollisionCheckConfig_type_set, doc=r""" Specifies the type of collision check to be performed. Default: DISCRETE""")
    longest_valid_segment_length = property(_tesseract_collision_python.CollisionCheckConfig_longest_valid_segment_length_get, _tesseract_collision_python.CollisionCheckConfig_longest_valid_segment_length_set, doc=r""" Longest valid segment to use if type supports lvs. Default: 0.005""")
    check_program_mode = property(_tesseract_collision_python.CollisionCheckConfig_check_program_mode_get, _tesseract_collision_python.CollisionCheckConfig_check_program_mode_set, doc=r""" Secifies the mode used when collision checking program/trajectory. Default: ALL""")
    __swig_destroy__ = _tesseract_collision_python.delete_CollisionCheckConfig

# Register CollisionCheckConfig in _tesseract_collision_python:
_tesseract_collision_python.CollisionCheckConfig_swigregister(CollisionCheckConfig)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactTrajectorySubstepResults(object):
    r"""
    The ContactTrajectorySubstepResults struct is the lowest level struct for tracking contacts in a trajectory.
    This struct is used for substeps between waypoints in a trajectory when a longest valid segment is used, storing the
    relevant states of the substep.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContactTrajectorySubstepResults_swiginit(self, _tesseract_collision_python.new_ContactTrajectorySubstepResults(*args))

    def numContacts(self):
        return _tesseract_collision_python.ContactTrajectorySubstepResults_numContacts(self)

    def worstCollision(self):
        return _tesseract_collision_python.ContactTrajectorySubstepResults_worstCollision(self)
    contacts = property(_tesseract_collision_python.ContactTrajectorySubstepResults_contacts_get, _tesseract_collision_python.ContactTrajectorySubstepResults_contacts_set)
    substep = property(_tesseract_collision_python.ContactTrajectorySubstepResults_substep_get, _tesseract_collision_python.ContactTrajectorySubstepResults_substep_set)
    state0 = property(_tesseract_collision_python.ContactTrajectorySubstepResults_state0_get, _tesseract_collision_python.ContactTrajectorySubstepResults_state0_set)
    state1 = property(_tesseract_collision_python.ContactTrajectorySubstepResults_state1_get, _tesseract_collision_python.ContactTrajectorySubstepResults_state1_set)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactTrajectorySubstepResults

# Register ContactTrajectorySubstepResults in _tesseract_collision_python:
_tesseract_collision_python.ContactTrajectorySubstepResults_swigregister(ContactTrajectorySubstepResults)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactTrajectoryStepResults(object):
    r"""
    The ContactTrajectoryStepResults struct is the second level struct for tracking contacts in a trajectory. This
    struct stores all the substep contact information as well as the start and end state of the given step in the
    trajectory.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContactTrajectoryStepResults_swiginit(self, _tesseract_collision_python.new_ContactTrajectoryStepResults(*args))

    def resize(self, num_substeps):
        return _tesseract_collision_python.ContactTrajectoryStepResults_resize(self, num_substeps)

    def numSubsteps(self):
        return _tesseract_collision_python.ContactTrajectoryStepResults_numSubsteps(self)

    def numContacts(self):
        return _tesseract_collision_python.ContactTrajectoryStepResults_numContacts(self)

    def worstSubstep(self):
        return _tesseract_collision_python.ContactTrajectoryStepResults_worstSubstep(self)

    def worstCollision(self):
        return _tesseract_collision_python.ContactTrajectoryStepResults_worstCollision(self)

    def mostCollisionsSubstep(self):
        return _tesseract_collision_python.ContactTrajectoryStepResults_mostCollisionsSubstep(self)
    substeps = property(_tesseract_collision_python.ContactTrajectoryStepResults_substeps_get, _tesseract_collision_python.ContactTrajectoryStepResults_substeps_set)
    step = property(_tesseract_collision_python.ContactTrajectoryStepResults_step_get, _tesseract_collision_python.ContactTrajectoryStepResults_step_set)
    state0 = property(_tesseract_collision_python.ContactTrajectoryStepResults_state0_get, _tesseract_collision_python.ContactTrajectoryStepResults_state0_set)
    state1 = property(_tesseract_collision_python.ContactTrajectoryStepResults_state1_get, _tesseract_collision_python.ContactTrajectoryStepResults_state1_set)
    total_substeps = property(_tesseract_collision_python.ContactTrajectoryStepResults_total_substeps_get, _tesseract_collision_python.ContactTrajectoryStepResults_total_substeps_set)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactTrajectoryStepResults

# Register ContactTrajectoryStepResults in _tesseract_collision_python:
_tesseract_collision_python.ContactTrajectoryStepResults_swigregister(ContactTrajectoryStepResults)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactTrajectoryResults(object):
    r"""
    The ContactTrajectoryResults struct is the top level struct for tracking contacts in a trajectory. This struct
    stores all the steps and therefore all the contacts in a trajectory. It also exposes a method for returning a contact
    summary table as a string for printing to a terminal.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContactTrajectoryResults_swiginit(self, _tesseract_collision_python.new_ContactTrajectoryResults(*args))

    def resize(self, num_steps):
        return _tesseract_collision_python.ContactTrajectoryResults_resize(self, num_steps)

    def numSteps(self):
        return _tesseract_collision_python.ContactTrajectoryResults_numSteps(self)

    def numContacts(self):
        return _tesseract_collision_python.ContactTrajectoryResults_numContacts(self)

    def worstStep(self):
        return _tesseract_collision_python.ContactTrajectoryResults_worstStep(self)

    def worstCollision(self):
        return _tesseract_collision_python.ContactTrajectoryResults_worstCollision(self)

    def mostCollisionsStep(self):
        return _tesseract_collision_python.ContactTrajectoryResults_mostCollisionsStep(self)
    steps = property(_tesseract_collision_python.ContactTrajectoryResults_steps_get, _tesseract_collision_python.ContactTrajectoryResults_steps_set)
    joint_names = property(_tesseract_collision_python.ContactTrajectoryResults_joint_names_get, _tesseract_collision_python.ContactTrajectoryResults_joint_names_set)
    total_steps = property(_tesseract_collision_python.ContactTrajectoryResults_total_steps_get, _tesseract_collision_python.ContactTrajectoryResults_total_steps_set)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactTrajectoryResults

# Register ContactTrajectoryResults in _tesseract_collision_python:
_tesseract_collision_python.ContactTrajectoryResults_swigregister(ContactTrajectoryResults)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class DiscreteContactManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_DiscreteContactManager

    def getName(self):
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.DiscreteContactManager_getName(self)

    def clone(self):
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.DiscreteContactManager_clone(self)

    def addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled=True):
        r"""
        Add a object to the checker
        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManager_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name):
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name):
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name):
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManager_hasCollisionObject(self, name)

    def removeCollisionObject(self, name):
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManager_removeCollisionObject(self, name)

    def enableCollisionObject(self, name):
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManager_enableCollisionObject(self, name)

    def disableCollisionObject(self, name):
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManager_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name):
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.DiscreteContactManager_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args):
        r"""
        *Overload 1:*

        Set a single collision object's transforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The transformation in world

        |

        *Overload 2:*

        Set a series of collision object's transforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The transformation in world

        |

        *Overload 3:*

        Set a series of collision object's transforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>
        """
        return _tesseract_collision_python.DiscreteContactManager_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self):
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names):
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManager_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self):
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManager_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args):
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.DiscreteContactManager_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin):
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.DiscreteContactManager_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1, name2, collision_margin):
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.DiscreteContactManager_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self):
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionMarginData(self)

    def setContactAllowedValidator(self, validator):
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.DiscreteContactManager_setContactAllowedValidator(self, validator)

    def getContactAllowedValidator(self):
        r""" Get the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.DiscreteContactManager_getContactAllowedValidator(self)

    def contactTest(self, collisions, request):
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The contact results data
        :type request: :py:class:`ContactRequest`
        :param request: The contact request data
        """
        return _tesseract_collision_python.DiscreteContactManager_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config):
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.DiscreteContactManager_applyContactManagerConfig(self, config)

# Register DiscreteContactManager in _tesseract_collision_python:
_tesseract_collision_python.DiscreteContactManager_swigregister(DiscreteContactManager)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContinuousContactManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_ContinuousContactManager

    def getName(self):
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.ContinuousContactManager_getName(self)

    def clone(self):
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.ContinuousContactManager_clone(self)

    def addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled=True):
        r"""
        Add a collision object to the checker

        All objects are added should initially be added as static objects. Use the
        setContactRequest method of defining which collision objects are moving.

        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :param shape_types:     A vector of shape types for encode the collision object. If the vector is of length 1 it is
            used for all shapes.
        :param collision_object_types: A int identifying a conversion mode for the object. (ex. convert meshes to
            convex_hulls)
        :type enabled: boolean, optional
        :param enabled:         Indicate if the object is enabled for collision checking.
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManager_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name):
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name):
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name):
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManager_hasCollisionObject(self, name)

    def removeCollisionObject(self, name):
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManager_removeCollisionObject(self, name)

    def enableCollisionObject(self, name):
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManager_enableCollisionObject(self, name)

    def disableCollisionObject(self, name):
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManager_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name):
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.ContinuousContactManager_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args):
        r"""
        *Overload 1:*

        Set a single static collision object's tansforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The tranformation in world

        |

        *Overload 2:*

        Set a series of static collision object's tranforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The tranformation in world

        |

        *Overload 3:*

        Set a series of static collision object's tranforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>

        |

        *Overload 4:*

        Set a single cast(moving) collision object's tansforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type name: string
        :param name: The name of the object
        :type pose1: :py:class:`Isometry3d`
        :param pose1: The start tranformation in world
        :type pose2: :py:class:`Isometry3d`
        :param pose2: The end tranformation in world

        |

        *Overload 5:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type pose1: :py:class:`VectorIsometry3d`
        :param pose1: The start tranformations in world
        :type pose2: :py:class:`VectorIsometry3d`
        :param pose2: The end tranformations in world

        |

        *Overload 6:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type pose1: :py:class:`TransformMap`
        :param pose1: A start transform map <name, pose>
        :type pose2: :py:class:`TransformMap`
        :param pose2: A end transform map <name, pose>
        """
        return _tesseract_collision_python.ContinuousContactManager_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self):
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names):
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManager_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self):
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManager_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args):
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.ContinuousContactManager_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin):
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.ContinuousContactManager_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1, name2, collision_margin):
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.ContinuousContactManager_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self):
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionMarginData(self)

    def setContactAllowedValidator(self, validator):
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.ContinuousContactManager_setContactAllowedValidator(self, validator)

    def getContactAllowedValidator(self):
        r""" Get the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.ContinuousContactManager_getContactAllowedValidator(self)

    def contactTest(self, collisions, request):
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The Contact results data
        :param type: The type of contact test
        """
        return _tesseract_collision_python.ContinuousContactManager_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config):
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.ContinuousContactManager_applyContactManagerConfig(self, config)

# Register ContinuousContactManager in _tesseract_collision_python:
_tesseract_collision_python.ContinuousContactManager_swigregister(ContinuousContactManager)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class DiscreteContactManagerFactory(object):
    r""" Define a discrete contact manager plugin which the factory can create an instance"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_DiscreteContactManagerFactory

    def create(self, name, config):
        r"""
        Create Discrete Contact Manager Object
        :type name: string
        :param name: The name of the contact manager object
        :rtype: std::unique_ptr< tesseract_collision::DiscreteContactManager >
        :return: If failed to create, nullptr is returned.
        """
        return _tesseract_collision_python.DiscreteContactManagerFactory_create(self, name, config)

# Register DiscreteContactManagerFactory in _tesseract_collision_python:
_tesseract_collision_python.DiscreteContactManagerFactory_swigregister(DiscreteContactManagerFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContinuousContactManagerFactory(object):
    r""" Define a continuous contact manager plugin which the factory can create an instance"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_ContinuousContactManagerFactory

    def create(self, solver_name, config):
        r"""
        Create Inverse Kinematics Object
        :param name: The name of the contact manager object
        :rtype: std::unique_ptr< tesseract_collision::ContinuousContactManager >
        :return: If failed to create, nullptr is returned.
        """
        return _tesseract_collision_python.ContinuousContactManagerFactory_create(self, solver_name, config)

# Register ContinuousContactManagerFactory in _tesseract_collision_python:
_tesseract_collision_python.ContinuousContactManagerFactory_swigregister(ContinuousContactManagerFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactManagersPluginFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_ContactManagersPluginFactory

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Load plugins from yaml node
        :type config: YAML::Node
        :param config: The config node

        |

        *Overload 2:*

        Load plugins from file path
        :type config: :py:class:`path`
        :param config: The config file path

        |

        *Overload 3:*

        Load plugins from string
        :type config: string
        :param config: The config string
        """
        _tesseract_collision_python.ContactManagersPluginFactory_swiginit(self, _tesseract_collision_python.new_ContactManagersPluginFactory(*args))

    def addSearchPath(self, path):
        r"""
        Add location for the plugin loader to search
        :type path: string
        :param path: The full path to the directory
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addSearchPath(self, path)

    def getSearchPaths(self):
        r"""
        Get the plugin search paths
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search paths
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getSearchPaths(self)

    def clearSearchPaths(self):
        r"""Clear the search paths"""
        return _tesseract_collision_python.ContactManagersPluginFactory_clearSearchPaths(self)

    def addSearchLibrary(self, library_name):
        r"""
        Add a library to search for plugin name
        :type library_name: string
        :param library_name: The library name without the prefix or suffix
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addSearchLibrary(self, library_name)

    def getSearchLibraries(self):
        r"""
        Get the plugin search libraries
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search libraries
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getSearchLibraries(self)

    def clearSearchLibraries(self):
        r"""Clean the search libraries"""
        return _tesseract_collision_python.ContactManagersPluginFactory_clearSearchLibraries(self)

    def addDiscreteContactManagerPlugin(self, name, plugin_info):
        r"""
        Add a discrete contact manager plugin
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addDiscreteContactManagerPlugin(self, name, plugin_info)

    def hasDiscreteContactManagerPlugins(self):
        r"""
        Check if it has discrete contact manager plugins
        :rtype: boolean
        :return: True if discrete PluginInfoMap is not empty, otherwise fale
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_hasDiscreteContactManagerPlugins(self)

    def getDiscreteContactManagerPlugins(self):
        r"""
        Get the map of discrete contact manager plugin
        :rtype: tesseract_common::PluginInfoMap
        :return: A map of plugins
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getDiscreteContactManagerPlugins(self)

    def removeDiscreteContactManagerPlugin(self, name):
        r"""
        Remove discrete contact manager plugin
        :type name: string
        :param name: The name of the contact manager to remove
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_removeDiscreteContactManagerPlugin(self, name)

    def setDefaultDiscreteContactManagerPlugin(self, name):
        r"""
        Set a default discrete contact manager
        :type name: string
        :param name: The name
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_setDefaultDiscreteContactManagerPlugin(self, name)

    def getDefaultDiscreteContactManagerPlugin(self):
        r"""
        Get the default discrete contact manager
        :rtype: string
        :return: The default discrete contact manager
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getDefaultDiscreteContactManagerPlugin(self)

    def addContinuousContactManagerPlugin(self, name, plugin_info):
        r"""
        Add a continuous contact manager plugin
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addContinuousContactManagerPlugin(self, name, plugin_info)

    def hasContinuousContactManagerPlugins(self):
        r"""
        Check if it has continuous contact manager plugins
        :rtype: boolean
        :return: True if continuous PluginInfoMap is not empty, otherwise fale
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_hasContinuousContactManagerPlugins(self)

    def getContinuousContactManagerPlugins(self):
        r"""
        Get the map of continuous contact manager plugin
        :rtype: tesseract_common::PluginInfoMap
        :return: A map of plugins
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getContinuousContactManagerPlugins(self)

    def removeContinuousContactManagerPlugin(self, name):
        r"""
        Remove continuous contact manager plugin
        :type name: string
        :param name: The name of the contact manager to remove
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_removeContinuousContactManagerPlugin(self, name)

    def setDefaultContinuousContactManagerPlugin(self, name):
        r"""
        Set a default continuous contact manager
        :type name: string
        :param name: The name
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_setDefaultContinuousContactManagerPlugin(self, name)

    def getDefaultContinuousContactManagerPlugin(self):
        r"""
        Get the default continuous contact manager
        :rtype: string
        :return: The default continuous contact manager name
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getDefaultContinuousContactManagerPlugin(self)

    def createDiscreteContactManager(self, *args):
        r"""
        *Overload 1:*

        Get discrete contact manager object given name
        This looks for discrete contact manager plugin info. If not found nullptr is returned.
        :type name: string
        :param name: The name

        |

        *Overload 2:*

        Get discrete contact manager object given plugin info
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information to create kinematics object
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_createDiscreteContactManager(self, *args)

    def createContinuousContactManager(self, *args):
        r"""
        *Overload 1:*

        Get continuous contact manager object given name
        This looks for continuous contact manager plugin info. If not found nullptr is returned.
        :type name: string
        :param name: The name

        |

        *Overload 2:*

        Get continuous contact manager object given plugin info
        :type name: string
        :param name: The name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information to create kinematics object
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_createContinuousContactManager(self, *args)

    def saveConfig(self, file_path):
        r"""
        Save the plugin information to a yaml config file
        :type file_path: :py:class:`path`
        :param file_path: The file path
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_saveConfig(self, file_path)

    def getConfig(self):
        r"""
        Get the plugin information config as a yaml node
        :rtype: YAML::Node
        :return: The plugin information config yaml node/
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getConfig(self)

# Register ContactManagersPluginFactory in _tesseract_collision_python:
_tesseract_collision_python.ContactManagersPluginFactory_swigregister(ContactManagersPluginFactory)

