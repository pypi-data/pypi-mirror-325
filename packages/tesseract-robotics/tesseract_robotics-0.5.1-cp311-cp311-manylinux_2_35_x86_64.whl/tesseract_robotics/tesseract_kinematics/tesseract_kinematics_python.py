# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_kinematics_python
else:
    import _tesseract_kinematics_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_kinematics_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_kinematics_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_kinematics_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_kinematics_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_kinematics_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_kinematics_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_kinematics_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_kinematics_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_kinematics_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_kinematics_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_kinematics_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_kinematics_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_kinematics_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_kinematics_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_kinematics_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_kinematics_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_kinematics_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_kinematics_python:
_tesseract_kinematics_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
@_swig_add_metaclass(_SwigNonDynamicMeta)
class pair_bool_matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.pair_bool_matrix_swiginit(self, _tesseract_kinematics_python.new_pair_bool_matrix(*args))
    first = property(_tesseract_kinematics_python.pair_bool_matrix_first_get, _tesseract_kinematics_python.pair_bool_matrix_first_set)
    second = property(_tesseract_kinematics_python.pair_bool_matrix_second_get, _tesseract_kinematics_python.pair_bool_matrix_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _tesseract_kinematics_python.delete_pair_bool_matrix

# Register pair_bool_matrix in _tesseract_kinematics_python:
_tesseract_kinematics_python.pair_bool_matrix_swigregister(pair_bool_matrix)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class URParameters(object):
    r""" The Universal Robot kinematic parameters"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.URParameters_swiginit(self, _tesseract_kinematics_python.new_URParameters(*args))
    d1 = property(_tesseract_kinematics_python.URParameters_d1_get, _tesseract_kinematics_python.URParameters_d1_set)
    a2 = property(_tesseract_kinematics_python.URParameters_a2_get, _tesseract_kinematics_python.URParameters_a2_set)
    a3 = property(_tesseract_kinematics_python.URParameters_a3_get, _tesseract_kinematics_python.URParameters_a3_set)
    d4 = property(_tesseract_kinematics_python.URParameters_d4_get, _tesseract_kinematics_python.URParameters_d4_set)
    d5 = property(_tesseract_kinematics_python.URParameters_d5_get, _tesseract_kinematics_python.URParameters_d5_set)
    d6 = property(_tesseract_kinematics_python.URParameters_d6_get, _tesseract_kinematics_python.URParameters_d6_set)
    __swig_destroy__ = _tesseract_kinematics_python.delete_URParameters

# Register URParameters in _tesseract_kinematics_python:
_tesseract_kinematics_python.URParameters_swigregister(URParameters)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ForwardKinematicsUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.ForwardKinematicsUPtr_swiginit(self, _tesseract_kinematics_python.new_ForwardKinematicsUPtr(*args))

    def __deref__(self):
        return _tesseract_kinematics_python.ForwardKinematicsUPtr___deref__(self)

    def release(self):
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_release(self)

    def reset(self, *args):
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_swap(self, __u)

    def get(self):
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_kinematics_python.ForwardKinematicsUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_kinematics_python.delete_ForwardKinematicsUPtr

    def calcFwdKin(self, joint_angles):
        r"""
        Calculates the transform for each tip link in the kinematic group

        This should return a transform for every link listed in getTipLinkNames()
        Throws an exception on failures (including uninitialized)
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Vector of joint angles (size must match number of joints in robot chain)
        :rtype: :py:class:`TransformMap`
        :return: A map of tip link names and transforms
        """
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_calcFwdKin(self, joint_angles)

    def calcJacobian(self, joint_angles, link_name):
        r"""
        Calculates the Jacobian matrix for a given joint state in the reference frame of the specified link

        This should be able to return a jacobian given any link listed in getTipLinkNames()
        Throws an exception on failures (including uninitialized)
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The link name to calculate jacobian
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link
        """
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_calcJacobian(self, joint_angles, link_name)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_getBaseLinkName(self)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_getJointNames(self)

    def getTipLinkNames(self):
        r"""
        Get list of tip link names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_getTipLinkNames(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_numJoints(self)

    def getSolverName(self):
        r""" Get the name of the solver. Recommend using the name of the class."""
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_getSolverName(self)

    def clone(self):
        r""" Clone the forward kinematics object"""
        return _tesseract_kinematics_python.ForwardKinematicsUPtr_clone(self)

# Register ForwardKinematicsUPtr in _tesseract_kinematics_python:
_tesseract_kinematics_python.ForwardKinematicsUPtr_swigregister(ForwardKinematicsUPtr)
cvar = _tesseract_kinematics_python.cvar
UR10Parameters = cvar.UR10Parameters
UR5Parameters = cvar.UR5Parameters
UR3Parameters = cvar.UR3Parameters
UR10eParameters = cvar.UR10eParameters
UR5eParameters = cvar.UR5eParameters
UR3eParameters = cvar.UR3eParameters

@_swig_add_metaclass(_SwigNonDynamicMeta)
class ForwardKinematics(object):
    r""" Forward kinematics functions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_ForwardKinematics

    def calcFwdKin(self, joint_angles):
        r"""
        Calculates the transform for each tip link in the kinematic group

        This should return a transform for every link listed in getTipLinkNames()
        Throws an exception on failures (including uninitialized)
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Vector of joint angles (size must match number of joints in robot chain)
        :rtype: :py:class:`TransformMap`
        :return: A map of tip link names and transforms
        """
        return _tesseract_kinematics_python.ForwardKinematics_calcFwdKin(self, joint_angles)

    def calcJacobian(self, joint_angles, link_name):
        r"""
        Calculates the Jacobian matrix for a given joint state in the reference frame of the specified link

        This should be able to return a jacobian given any link listed in getTipLinkNames()
        Throws an exception on failures (including uninitialized)
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The link name to calculate jacobian
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link
        """
        return _tesseract_kinematics_python.ForwardKinematics_calcJacobian(self, joint_angles, link_name)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.ForwardKinematics_getBaseLinkName(self)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_kinematics_python.ForwardKinematics_getJointNames(self)

    def getTipLinkNames(self):
        r"""
        Get list of tip link names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_kinematics_python.ForwardKinematics_getTipLinkNames(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.ForwardKinematics_numJoints(self)

    def getSolverName(self):
        r""" Get the name of the solver. Recommend using the name of the class."""
        return _tesseract_kinematics_python.ForwardKinematics_getSolverName(self)

    def clone(self):
        r""" Clone the forward kinematics object"""
        return _tesseract_kinematics_python.ForwardKinematics_clone(self)

# Register ForwardKinematics in _tesseract_kinematics_python:
_tesseract_kinematics_python.ForwardKinematics_swigregister(ForwardKinematics)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class InverseKinematicsUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.InverseKinematicsUPtr_swiginit(self, _tesseract_kinematics_python.new_InverseKinematicsUPtr(*args))

    def __deref__(self):
        return _tesseract_kinematics_python.InverseKinematicsUPtr___deref__(self)

    def release(self):
        return _tesseract_kinematics_python.InverseKinematicsUPtr_release(self)

    def reset(self, *args):
        return _tesseract_kinematics_python.InverseKinematicsUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_kinematics_python.InverseKinematicsUPtr_swap(self, __u)

    def get(self):
        return _tesseract_kinematics_python.InverseKinematicsUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_kinematics_python.InverseKinematicsUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_kinematics_python.delete_InverseKinematicsUPtr

    def calcInvKin(self, tip_link_poses, seed):
        r"""
        Calculates joint solutions given a pose for each tip link.
        This interface supports IK for both kinematic chains that have a single tool tip link and kinematic chains
        that have multiple tip links. For example, consider a robot with external part positioner: a pose can be specified
        to be relative to the tip link of the robot or the tip link of the positioner is to support a pose relative to a
        active link. For example a robot with an external positioner where the pose is relative to the tip link of the
        positioner.
        Notes: Redundant joint solutions can be provided by the utility function getRedundantSolutions
        :type tip_link_poses: :py:class:`TransformMap`
        :param tip_link_poses: A map of poses corresponding to each tip link provided in getTipLinkNames and relative to the
            working frame of the kinematics group for which to solve inverse kinematics
        :type seed: Eigen::Ref< Eigen::VectorXd const >
        :param seed: Vector of seed joint angles (size must match number of joints in kinematic object)
        :rtype: tesseract_kinematics::IKSolutions
        :return: A vector of solutions, If empty it failed to find a solution (including uninitialized)
        """
        return _tesseract_kinematics_python.InverseKinematicsUPtr_calcInvKin(self, tip_link_poses, seed)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names, joint_list_
        """
        return _tesseract_kinematics_python.InverseKinematicsUPtr_getJointNames(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.InverseKinematicsUPtr_numJoints(self)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.InverseKinematicsUPtr_getBaseLinkName(self)

    def getWorkingFrame(self):
        r"""
        Get the inverse kinematics working frame
        This is the frame of reference in which all poses given to the calcInvKin function should be defined
        """
        return _tesseract_kinematics_python.InverseKinematicsUPtr_getWorkingFrame(self)

    def getTipLinkNames(self):
        r"""
        Get the names of the tip links of the kinematics group
        In the case of a kinematic chain, this returns one tip link; in the case of a kinematic tree this returns
        the tip link for each branch of the tree.
        """
        return _tesseract_kinematics_python.InverseKinematicsUPtr_getTipLinkNames(self)

    def getSolverName(self):
        r""" Get the name of the solver. Recommend using the name of the class."""
        return _tesseract_kinematics_python.InverseKinematicsUPtr_getSolverName(self)

    def clone(self):
        r""" Clone the forward kinematics object"""
        return _tesseract_kinematics_python.InverseKinematicsUPtr_clone(self)

# Register InverseKinematicsUPtr in _tesseract_kinematics_python:
_tesseract_kinematics_python.InverseKinematicsUPtr_swigregister(InverseKinematicsUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class InverseKinematics(object):
    r""" Inverse kinematics functions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_InverseKinematics

    def calcInvKin(self, tip_link_poses, seed):
        r"""
        Calculates joint solutions given a pose for each tip link.
        This interface supports IK for both kinematic chains that have a single tool tip link and kinematic chains
        that have multiple tip links. For example, consider a robot with external part positioner: a pose can be specified
        to be relative to the tip link of the robot or the tip link of the positioner is to support a pose relative to a
        active link. For example a robot with an external positioner where the pose is relative to the tip link of the
        positioner.
        Notes: Redundant joint solutions can be provided by the utility function getRedundantSolutions
        :type tip_link_poses: :py:class:`TransformMap`
        :param tip_link_poses: A map of poses corresponding to each tip link provided in getTipLinkNames and relative to the
            working frame of the kinematics group for which to solve inverse kinematics
        :type seed: Eigen::Ref< Eigen::VectorXd const >
        :param seed: Vector of seed joint angles (size must match number of joints in kinematic object)
        :rtype: tesseract_kinematics::IKSolutions
        :return: A vector of solutions, If empty it failed to find a solution (including uninitialized)
        """
        return _tesseract_kinematics_python.InverseKinematics_calcInvKin(self, tip_link_poses, seed)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names, joint_list_
        """
        return _tesseract_kinematics_python.InverseKinematics_getJointNames(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.InverseKinematics_numJoints(self)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.InverseKinematics_getBaseLinkName(self)

    def getWorkingFrame(self):
        r"""
        Get the inverse kinematics working frame
        This is the frame of reference in which all poses given to the calcInvKin function should be defined
        """
        return _tesseract_kinematics_python.InverseKinematics_getWorkingFrame(self)

    def getTipLinkNames(self):
        r"""
        Get the names of the tip links of the kinematics group
        In the case of a kinematic chain, this returns one tip link; in the case of a kinematic tree this returns
        the tip link for each branch of the tree.
        """
        return _tesseract_kinematics_python.InverseKinematics_getTipLinkNames(self)

    def getSolverName(self):
        r""" Get the name of the solver. Recommend using the name of the class."""
        return _tesseract_kinematics_python.InverseKinematics_getSolverName(self)

    def clone(self):
        r""" Clone the forward kinematics object"""
        return _tesseract_kinematics_python.InverseKinematics_clone(self)

# Register InverseKinematics in _tesseract_kinematics_python:
_tesseract_kinematics_python.InverseKinematics_swigregister(InverseKinematics)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class JointGroupUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.JointGroupUPtr_swiginit(self, _tesseract_kinematics_python.new_JointGroupUPtr(*args))

    def __deref__(self):
        return _tesseract_kinematics_python.JointGroupUPtr___deref__(self)

    def release(self):
        return _tesseract_kinematics_python.JointGroupUPtr_release(self)

    def reset(self, *args):
        return _tesseract_kinematics_python.JointGroupUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_kinematics_python.JointGroupUPtr_swap(self, __u)

    def get(self):
        return _tesseract_kinematics_python.JointGroupUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_kinematics_python.JointGroupUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_kinematics_python.delete_JointGroupUPtr

    def calcFwdKin(self, joint_angles):
        r"""
        Calculates tool pose of robot chain
        Throws an exception on failures (including uninitialized)
        :param pose: Transform of end-of-tip relative to root
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Vector of joint angles (size must match number of joints in robot chain)
        """
        return _tesseract_kinematics_python.JointGroupUPtr_calcFwdKin(self, joint_angles)

    def calcJacobian(self, *args):
        r"""
        *Overload 1:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the joint group base link

        |

        *Overload 2:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :type link_point: Eigen::Vector3d
        :param link_point: A point on the link that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the joint group base link

        |

        *Overload 3:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type base_link_name: string
        :param base_link_name: The frame that the jacobian is calculated in
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the provided base_link_name

        |

        *Overload 4:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type base_link_name: string
        :param base_link_name: The frame that the jacobian is calculated in
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :type link_point: Eigen::Vector3d
        :param link_point: A point on the link that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the provided base_link_name
        """
        return _tesseract_kinematics_python.JointGroupUPtr_calcJacobian(self, *args)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_kinematics_python.JointGroupUPtr_getJointNames(self)

    def getLinkNames(self):
        r"""
        Get list of all link names (with and without geometry) for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_kinematics_python.JointGroupUPtr_getLinkNames(self)

    def getActiveLinkNames(self):
        r"""
        Get list of active link names (with and without geometry) for kinematic object

        Note: This only includes links that are children of the active joints

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_kinematics_python.JointGroupUPtr_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        r"""
        Get list of static link names (with and without geometry) for kinematic object

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_kinematics_python.JointGroupUPtr_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_kinematics_python.JointGroupUPtr_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_kinematics_python.JointGroupUPtr_hasLinkName(self, link_name)

    def getLimits(self):
        r"""
        Get the kinematic limits (joint, velocity, acceleration, etc.)
        :rtype: :py:class:`KinematicLimits`
        :return: Kinematic Limits
        """
        return _tesseract_kinematics_python.JointGroupUPtr_getLimits(self)

    def setLimits(self, limits):
        r"""
        Setter for kinematic limits (joint, velocity, acceleration, etc.)
        :param Kinematic: Limits
        """
        return _tesseract_kinematics_python.JointGroupUPtr_setLimits(self, limits)

    def getRedundancyCapableJointIndices(self):
        r"""
        Get vector indicating which joints are capable of producing redundant solutions
        :rtype: std::vector< Eigen::Index,std::allocator< Eigen::Index > >
        :return: A vector of joint indices
        """
        return _tesseract_kinematics_python.JointGroupUPtr_getRedundancyCapableJointIndices(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.JointGroupUPtr_numJoints(self)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.JointGroupUPtr_getBaseLinkName(self)

    def getName(self):
        r""" Name of the manipulator"""
        return _tesseract_kinematics_python.JointGroupUPtr_getName(self)

    def checkJoints(self, vec):
        r"""
        Check for consistency in # and limits of joints
        :type vec: Eigen::Ref< Eigen::VectorXd const >
        :param vec: Vector of joint values
        :rtype: boolean
        :return: True if size of vec matches # of robot joints and all joints are within limits
        """
        return _tesseract_kinematics_python.JointGroupUPtr_checkJoints(self, vec)

# Register JointGroupUPtr in _tesseract_kinematics_python:
_tesseract_kinematics_python.JointGroupUPtr_swigregister(JointGroupUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class JointGroup(object):
    r"""
    A Joint Group is defined by a list of joint_names.
    Provides the ability to calculate forward kinematics and jacobian.
    Notes: This creates an optimized object replace all joints not listed in the provided list with a fixed joint
    calculated using the provided state. Also the calcFwdKin only return the link transforms in the optimized object
    which is all active links and root of the scene graph usually.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_JointGroup

    def __init__(self, *args):
        r"""
        Create a kinematics group without inverse kinematics for the provided joint names
        :type name: string
        :param name: The name of the kinematic group
        :type joint_names: std::vector< std::string,std::allocator< std::string > >
        :param joint_names: The joints names to create kinematic group from
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The scene graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The scene state
        """
        _tesseract_kinematics_python.JointGroup_swiginit(self, _tesseract_kinematics_python.new_JointGroup(*args))

    def calcFwdKin(self, joint_angles):
        r"""
        Calculates tool pose of robot chain
        Throws an exception on failures (including uninitialized)
        :param pose: Transform of end-of-tip relative to root
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Vector of joint angles (size must match number of joints in robot chain)
        """
        return _tesseract_kinematics_python.JointGroup_calcFwdKin(self, joint_angles)

    def calcJacobian(self, *args):
        r"""
        *Overload 1:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the joint group base link

        |

        *Overload 2:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :type link_point: Eigen::Vector3d
        :param link_point: A point on the link that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the joint group base link

        |

        *Overload 3:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type base_link_name: string
        :param base_link_name: The frame that the jacobian is calculated in
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the provided base_link_name

        |

        *Overload 4:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type base_link_name: string
        :param base_link_name: The frame that the jacobian is calculated in
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :type link_point: Eigen::Vector3d
        :param link_point: A point on the link that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the provided base_link_name
        """
        return _tesseract_kinematics_python.JointGroup_calcJacobian(self, *args)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_kinematics_python.JointGroup_getJointNames(self)

    def getLinkNames(self):
        r"""
        Get list of all link names (with and without geometry) for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_kinematics_python.JointGroup_getLinkNames(self)

    def getActiveLinkNames(self):
        r"""
        Get list of active link names (with and without geometry) for kinematic object

        Note: This only includes links that are children of the active joints

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_kinematics_python.JointGroup_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        r"""
        Get list of static link names (with and without geometry) for kinematic object

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_kinematics_python.JointGroup_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_kinematics_python.JointGroup_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_kinematics_python.JointGroup_hasLinkName(self, link_name)

    def getLimits(self):
        r"""
        Get the kinematic limits (joint, velocity, acceleration, etc.)
        :rtype: :py:class:`KinematicLimits`
        :return: Kinematic Limits
        """
        return _tesseract_kinematics_python.JointGroup_getLimits(self)

    def setLimits(self, limits):
        r"""
        Setter for kinematic limits (joint, velocity, acceleration, etc.)
        :param Kinematic: Limits
        """
        return _tesseract_kinematics_python.JointGroup_setLimits(self, limits)

    def getRedundancyCapableJointIndices(self):
        r"""
        Get vector indicating which joints are capable of producing redundant solutions
        :rtype: std::vector< Eigen::Index,std::allocator< Eigen::Index > >
        :return: A vector of joint indices
        """
        return _tesseract_kinematics_python.JointGroup_getRedundancyCapableJointIndices(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.JointGroup_numJoints(self)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.JointGroup_getBaseLinkName(self)

    def getName(self):
        r""" Name of the manipulator"""
        return _tesseract_kinematics_python.JointGroup_getName(self)

    def checkJoints(self, vec):
        r"""
        Check for consistency in # and limits of joints
        :type vec: Eigen::Ref< Eigen::VectorXd const >
        :param vec: Vector of joint values
        :rtype: boolean
        :return: True if size of vec matches # of robot joints and all joints are within limits
        """
        return _tesseract_kinematics_python.JointGroup_checkJoints(self, vec)

# Register JointGroup in _tesseract_kinematics_python:
_tesseract_kinematics_python.JointGroup_swigregister(JointGroup)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KinematicGroupUPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.KinematicGroupUPtr_swiginit(self, _tesseract_kinematics_python.new_KinematicGroupUPtr(*args))

    def __deref__(self):
        return _tesseract_kinematics_python.KinematicGroupUPtr___deref__(self)

    def release(self):
        return _tesseract_kinematics_python.KinematicGroupUPtr_release(self)

    def reset(self, *args):
        return _tesseract_kinematics_python.KinematicGroupUPtr_reset(self, *args)

    def swap(self, __u):
        return _tesseract_kinematics_python.KinematicGroupUPtr_swap(self, __u)

    def get(self):
        return _tesseract_kinematics_python.KinematicGroupUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_kinematics_python.KinematicGroupUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_kinematics_python.delete_KinematicGroupUPtr

    def calcInvKin(self, *args):
        r"""
        *Overload 1:*

        Calculates joint solutions given a pose.
        If redundant solutions are needed see utility function getRedundantSolutions.
        :type tip_link_poses: :py:class:`KinGroupIKInputs`
        :param tip_link_poses: The input information to solve inverse kinematics for. There must be an input for each link
            provided in getTipLinkNames
        :type seed: Eigen::Ref< Eigen::VectorXd const >
        :param seed: Vector of seed joint angles (size must match number of joints in robot chain)
        :rtype: tesseract_kinematics::IKSolutions
        :return: A vector of solutions, If empty it failed to find a solution (including uninitialized)

        |

        *Overload 2:*

        Calculates joint solutions given a pose.
        If redundant solutions are needed see utility function getRedundantSolutions.
        :type tip_link_pose: :py:class:`KinGroupIKInput`
        :param tip_link_pose: The input information to solve inverse kinematics for. This is a convenience function for
            when only one tip link exists
        :type seed: Eigen::Ref< Eigen::VectorXd const >
        :param seed: Vector of seed joint angles (size must match number of joints in robot chain)
        :rtype: tesseract_kinematics::IKSolutions
        :return: A vector of solutions, If empty it failed to find a solution (including uninitialized)
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_calcInvKin(self, *args)

    def getAllValidWorkingFrames(self):
        r"""
         Returns all possible working frames in which goal poses can be defined
        The inverse kinematics solver requires that all poses be defined relative to a single working frame.
        However if this working frame is static, a pose can be defined in another static frame in the environment and
        transformed into the IK solver working frame. Similarly if the working frame is an active link (e.g. attached to a
        part positioner), a target pose can also be defined relative to any child link of the working frame and transformed
        into the IK solver working frame. This function identifies all of these other possible working frames and performs
        the appropriate transformations internally when solving IK.
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getAllValidWorkingFrames(self)

    def getAllPossibleTipLinkNames(self):
        r"""
         Get the tip link name
        The inverse kinematics solver requires that all poses be solved for a set of tip link frames that
        terminate a kinematic chain or tree. In the case of some closed-form IK solvers, this tip link must the tool flange
        of the robot rather than another preferred link. If the desired tip link is a statically connected child of the
        required IK solver tip link, then the target IK pose can be transformed into a target pose for the IK solver tip
        link. This function identifies all possible tip links that can be used for IK (i.e. static child links of the IK
        solver tip link(s)) and internally performs the appropriate transformations when solving IK
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getAllPossibleTipLinkNames(self)

    def getInverseKinematics(self):
        r"""
        Get the inverse kinematics sovler
        :rtype: :py:class:`InverseKinematics`
        :return: The inverse kinematics solver
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getInverseKinematics(self)

    def calcFwdKin(self, joint_angles):
        r"""
        Calculates tool pose of robot chain
        Throws an exception on failures (including uninitialized)
        :param pose: Transform of end-of-tip relative to root
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Vector of joint angles (size must match number of joints in robot chain)
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_calcFwdKin(self, joint_angles)

    def calcJacobian(self, *args):
        r"""
        *Overload 1:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the joint group base link

        |

        *Overload 2:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :type link_point: Eigen::Vector3d
        :param link_point: A point on the link that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the joint group base link

        |

        *Overload 3:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type base_link_name: string
        :param base_link_name: The frame that the jacobian is calculated in
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the provided base_link_name

        |

        *Overload 4:*

        Calculated jacobian of robot given joint angles
        :type joint_angles: Eigen::Ref< Eigen::VectorXd const >
        :param joint_angles: Input vector of joint angles
        :type base_link_name: string
        :param base_link_name: The frame that the jacobian is calculated in
        :type link_name: string
        :param link_name: The frame that the jacobian is calculated for
        :type link_point: Eigen::Vector3d
        :param link_point: A point on the link that the jacobian is calculated for
        :rtype: Eigen::MatrixXd
        :return: The jacobian at the provided link_name relative to the provided base_link_name
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_calcJacobian(self, *args)

    def getJointNames(self):
        r"""
        Get list of joint names for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getJointNames(self)

    def getLinkNames(self):
        r"""
        Get list of all link names (with and without geometry) for kinematic object
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getLinkNames(self)

    def getActiveLinkNames(self):
        r"""
        Get list of active link names (with and without geometry) for kinematic object

        Note: This only includes links that are children of the active joints

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getActiveLinkNames(self)

    def getStaticLinkNames(self):
        r"""
        Get list of static link names (with and without geometry) for kinematic object

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name):
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name):
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_hasLinkName(self, link_name)

    def getLimits(self):
        r"""
        Get the kinematic limits (joint, velocity, acceleration, etc.)
        :rtype: :py:class:`KinematicLimits`
        :return: Kinematic Limits
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getLimits(self)

    def setLimits(self, limits):
        r"""
        Setter for kinematic limits (joint, velocity, acceleration, etc.)
        :param Kinematic: Limits
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_setLimits(self, limits)

    def getRedundancyCapableJointIndices(self):
        r"""
        Get vector indicating which joints are capable of producing redundant solutions
        :rtype: std::vector< Eigen::Index,std::allocator< Eigen::Index > >
        :return: A vector of joint indices
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_getRedundancyCapableJointIndices(self)

    def numJoints(self):
        r"""
        Number of joints in robot
        :rtype: Eigen::Index
        :return: Number of joints in robot
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_numJoints(self)

    def getBaseLinkName(self):
        r""" Get the robot base link name"""
        return _tesseract_kinematics_python.KinematicGroupUPtr_getBaseLinkName(self)

    def getName(self):
        r""" Name of the manipulator"""
        return _tesseract_kinematics_python.KinematicGroupUPtr_getName(self)

    def checkJoints(self, vec):
        r"""
        Check for consistency in # and limits of joints
        :type vec: Eigen::Ref< Eigen::VectorXd const >
        :param vec: Vector of joint values
        :rtype: boolean
        :return: True if size of vec matches # of robot joints and all joints are within limits
        """
        return _tesseract_kinematics_python.KinematicGroupUPtr_checkJoints(self, vec)

# Register KinematicGroupUPtr in _tesseract_kinematics_python:
_tesseract_kinematics_python.KinematicGroupUPtr_swigregister(KinematicGroupUPtr)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KinGroupIKInput(object):
    r"""
    Structure containing the data required to solve inverse kinematics
    This structure provides the ability to specify IK targets for arbitrary tool links and defined with respect
    to arbitrary reference frames. Under the hood, the KinematicGroup class will transform these poses appropriately into
    the correct working frame required by the inverse kinematics solver. This improves the flexibility and ease-of-use of
    this class for performing IK
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_kinematics_python.KinGroupIKInput_swiginit(self, _tesseract_kinematics_python.new_KinGroupIKInput(*args))
    pose = property(_tesseract_kinematics_python.KinGroupIKInput_pose_get, _tesseract_kinematics_python.KinGroupIKInput_pose_set, doc=r""" The desired inverse kinematic pose""")
    working_frame = property(_tesseract_kinematics_python.KinGroupIKInput_working_frame_get, _tesseract_kinematics_python.KinGroupIKInput_working_frame_set, doc=r"""
    The link name the pose is relative to
    The provided working frame must be listed in InverseKinematics::getWorkingFrames()
    """)
    tip_link_name = property(_tesseract_kinematics_python.KinGroupIKInput_tip_link_name_get, _tesseract_kinematics_python.KinGroupIKInput_tip_link_name_set, doc=r"""
    The tip link of the kinematic object to solve IK
    The provided tip link name must be listed in InverseKinematics::getTipLinkNames()
    """)
    __swig_destroy__ = _tesseract_kinematics_python.delete_KinGroupIKInput

# Register KinGroupIKInput in _tesseract_kinematics_python:
_tesseract_kinematics_python.KinGroupIKInput_swigregister(KinGroupIKInput)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KinematicGroup(JointGroup):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_KinematicGroup

    def calcInvKin(self, *args):
        r"""
        *Overload 1:*

        Calculates joint solutions given a pose.
        If redundant solutions are needed see utility function getRedundantSolutions.
        :type tip_link_poses: :py:class:`KinGroupIKInputs`
        :param tip_link_poses: The input information to solve inverse kinematics for. There must be an input for each link
            provided in getTipLinkNames
        :type seed: Eigen::Ref< Eigen::VectorXd const >
        :param seed: Vector of seed joint angles (size must match number of joints in robot chain)
        :rtype: tesseract_kinematics::IKSolutions
        :return: A vector of solutions, If empty it failed to find a solution (including uninitialized)

        |

        *Overload 2:*

        Calculates joint solutions given a pose.
        If redundant solutions are needed see utility function getRedundantSolutions.
        :type tip_link_pose: :py:class:`KinGroupIKInput`
        :param tip_link_pose: The input information to solve inverse kinematics for. This is a convenience function for
            when only one tip link exists
        :type seed: Eigen::Ref< Eigen::VectorXd const >
        :param seed: Vector of seed joint angles (size must match number of joints in robot chain)
        :rtype: tesseract_kinematics::IKSolutions
        :return: A vector of solutions, If empty it failed to find a solution (including uninitialized)
        """
        return _tesseract_kinematics_python.KinematicGroup_calcInvKin(self, *args)

    def getAllValidWorkingFrames(self):
        r"""
         Returns all possible working frames in which goal poses can be defined
        The inverse kinematics solver requires that all poses be defined relative to a single working frame.
        However if this working frame is static, a pose can be defined in another static frame in the environment and
        transformed into the IK solver working frame. Similarly if the working frame is an active link (e.g. attached to a
        part positioner), a target pose can also be defined relative to any child link of the working frame and transformed
        into the IK solver working frame. This function identifies all of these other possible working frames and performs
        the appropriate transformations internally when solving IK.
        """
        return _tesseract_kinematics_python.KinematicGroup_getAllValidWorkingFrames(self)

    def getAllPossibleTipLinkNames(self):
        r"""
         Get the tip link name
        The inverse kinematics solver requires that all poses be solved for a set of tip link frames that
        terminate a kinematic chain or tree. In the case of some closed-form IK solvers, this tip link must the tool flange
        of the robot rather than another preferred link. If the desired tip link is a statically connected child of the
        required IK solver tip link, then the target IK pose can be transformed into a target pose for the IK solver tip
        link. This function identifies all possible tip links that can be used for IK (i.e. static child links of the IK
        solver tip link(s)) and internally performs the appropriate transformations when solving IK
        """
        return _tesseract_kinematics_python.KinematicGroup_getAllPossibleTipLinkNames(self)

    def getInverseKinematics(self):
        r"""
        Get the inverse kinematics sovler
        :rtype: :py:class:`InverseKinematics`
        :return: The inverse kinematics solver
        """
        return _tesseract_kinematics_python.KinematicGroup_getInverseKinematics(self)

# Register KinematicGroup in _tesseract_kinematics_python:
_tesseract_kinematics_python.KinematicGroup_swigregister(KinematicGroup)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KinGroupIKInputs(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tesseract_kinematics_python.KinGroupIKInputs___nonzero__(self)

    def __bool__(self):
        return _tesseract_kinematics_python.KinGroupIKInputs___bool__(self)

    def __len__(self):
        return _tesseract_kinematics_python.KinGroupIKInputs___len__(self)

    def __getslice__(self, i, j):
        return _tesseract_kinematics_python.KinGroupIKInputs___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tesseract_kinematics_python.KinGroupIKInputs___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs___setitem__(self, *args)

    def pop(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_pop(self)

    def append(self, x):
        return _tesseract_kinematics_python.KinGroupIKInputs_append(self, x)

    def empty(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_empty(self)

    def size(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_size(self)

    def swap(self, v):
        return _tesseract_kinematics_python.KinGroupIKInputs_swap(self, v)

    def begin(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_begin(self)

    def end(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_end(self)

    def rbegin(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_rbegin(self)

    def rend(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_rend(self)

    def clear(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_clear(self)

    def get_allocator(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_get_allocator(self)

    def pop_back(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_pop_back(self)

    def erase(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs_erase(self, *args)

    def __init__(self, *args):
        _tesseract_kinematics_python.KinGroupIKInputs_swiginit(self, _tesseract_kinematics_python.new_KinGroupIKInputs(*args))

    def push_back(self, x):
        return _tesseract_kinematics_python.KinGroupIKInputs_push_back(self, x)

    def front(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_front(self)

    def back(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_back(self)

    def assign(self, n, x):
        return _tesseract_kinematics_python.KinGroupIKInputs_assign(self, n, x)

    def resize(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs_resize(self, *args)

    def insert(self, *args):
        return _tesseract_kinematics_python.KinGroupIKInputs_insert(self, *args)

    def reserve(self, n):
        return _tesseract_kinematics_python.KinGroupIKInputs_reserve(self, n)

    def capacity(self):
        return _tesseract_kinematics_python.KinGroupIKInputs_capacity(self)
    __swig_destroy__ = _tesseract_kinematics_python.delete_KinGroupIKInputs

# Register KinGroupIKInputs in _tesseract_kinematics_python:
_tesseract_kinematics_python.KinGroupIKInputs_swigregister(KinGroupIKInputs)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class InvKinFactory(object):
    r""" Define a inverse kinematics plugin which the factory can create an instance"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_InvKinFactory

    def create(self, solver_name, scene_graph, scene_state, plugin_factory, config):
        r"""
        Create Inverse Kinematics Object
        :type solver_name: string
        :param solver_name: The solver name of the kinematic object
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The Tesseract Scene Graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The state of the scene graph
        :type plugin_factory: :py:class:`KinematicsPluginFactory`
        :param plugin_factory: Provide access to the plugin factory so plugins and load plugins
        :rtype: std::unique_ptr< tesseract_kinematics::InverseKinematics >
        :return: If failed to create, nullptr is returned.
        """
        return _tesseract_kinematics_python.InvKinFactory_create(self, solver_name, scene_graph, scene_state, plugin_factory, config)

# Register InvKinFactory in _tesseract_kinematics_python:
_tesseract_kinematics_python.InvKinFactory_swigregister(InvKinFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class FwdKinFactory(object):
    r""" Define a forward kinematics plugin which the factory can create an instance"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_FwdKinFactory

    def create(self, solver_name, scene_graph, scene_state, plugin_factory, config):
        r"""
        Create Inverse Kinematics Object
        :type solver_name: string
        :param solver_name: The solver name of the kinematic object
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The Tesseract Scene Graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The state of the scene graph
        :type plugin_factory: :py:class:`KinematicsPluginFactory`
        :param plugin_factory: Provide access to the plugin factory so plugins and load plugins
        :rtype: std::unique_ptr< tesseract_kinematics::ForwardKinematics >
        :return: If failed to create, nullptr is returned.
        """
        return _tesseract_kinematics_python.FwdKinFactory_create(self, solver_name, scene_graph, scene_state, plugin_factory, config)

# Register FwdKinFactory in _tesseract_kinematics_python:
_tesseract_kinematics_python.FwdKinFactory_swigregister(FwdKinFactory)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class KinematicsPluginFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_kinematics_python.delete_KinematicsPluginFactory

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Load plugins from yaml node
        :type config: YAML::Node
        :param config: The config node

        |

        *Overload 2:*

        Load plugins from file path
        :type config: :py:class:`path`
        :param config: The config file path

        |

        *Overload 3:*

        Load plugins from string
        :type config: string
        :param config: The config string
        """
        _tesseract_kinematics_python.KinematicsPluginFactory_swiginit(self, _tesseract_kinematics_python.new_KinematicsPluginFactory(*args))

    def addSearchPath(self, path):
        r"""
        Add location for the plugin loader to search
        :type path: string
        :param path: The full path to the directory
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_addSearchPath(self, path)

    def getSearchPaths(self):
        r"""
        Get the plugin search paths
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search paths
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getSearchPaths(self)

    def addSearchLibrary(self, library_name):
        r"""
        Add a library to search for plugin name
        :type library_name: string
        :param library_name: The library name without the prefix or suffix
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_addSearchLibrary(self, library_name)

    def getSearchLibraries(self):
        r"""
        Get the plugin search libraries
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search libraries
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getSearchLibraries(self)

    def addFwdKinPlugin(self, group_name, solver_name, plugin_info):
        r"""
        Add a forward kinematics plugin to the manager
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_addFwdKinPlugin(self, group_name, solver_name, plugin_info)

    def getFwdKinPlugins(self):
        r"""
        Get the map of forward kinematic plugins
        :rtype: std::map< std::string,tesseract_common::PluginInfoContainer,std::less< std::string >,std::allocator< std::pair< std::string const,tesseract_common::PluginInfoContainer > > >
        :return: A map of plugins
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getFwdKinPlugins(self)

    def removeFwdKinPlugin(self, group_name, solver_name):
        r"""
        remove forward kinematics plugin from the manager
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver name
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_removeFwdKinPlugin(self, group_name, solver_name)

    def setDefaultFwdKinPlugin(self, group_name, solver_name):
        r"""
        Set a groups default forward kinematics solver
        A group can have multiple inverse kinematics solvers
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver name
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_setDefaultFwdKinPlugin(self, group_name, solver_name)

    def getDefaultFwdKinPlugin(self, group_name):
        r"""
        Get the default forward kinematics solver for a group
        :type group_name: string
        :param group_name: The group
        :rtype: string
        :return: The default solver name
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getDefaultFwdKinPlugin(self, group_name)

    def addInvKinPlugin(self, group_name, solver_name, plugin_info):
        r"""
        Add a inverse kinematics plugin to the manager
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver name
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_addInvKinPlugin(self, group_name, solver_name, plugin_info)

    def getInvKinPlugins(self):
        r"""
        Get the map of inverse kinematic plugins
        :rtype: std::map< std::string,tesseract_common::PluginInfoContainer,std::less< std::string >,std::allocator< std::pair< std::string const,tesseract_common::PluginInfoContainer > > >
        :return: A map of plugins
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getInvKinPlugins(self)

    def removeInvKinPlugin(self, group_name, solver_name):
        r"""
        remove inverse kinematics plugin from the manager
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver name
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_removeInvKinPlugin(self, group_name, solver_name)

    def setDefaultInvKinPlugin(self, group_name, solver_name):
        r"""
        Set a groups default inverse kinematics solver
        A group can have multiple inverse kinematics solvers
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver name
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_setDefaultInvKinPlugin(self, group_name, solver_name)

    def getDefaultInvKinPlugin(self, group_name):
        r"""
        Get the default forward inverse solver for a group
        :type group_name: string
        :param group_name: The group
        :rtype: string
        :return: The default solver name
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getDefaultInvKinPlugin(self, group_name)

    def createFwdKin(self, *args):
        r"""
        *Overload 1:*

        Get forward kinematics object given group name and solver name
        This looks for kinematics plugin info added using addFwdKinPlugin. If not found nullptr is returned.
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The scene graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The scene state

        |

        *Overload 2:*

        Get forward kinematics object given plugin info
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information to create kinematics object
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The scene graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The scene state
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_createFwdKin(self, *args)

    def createInvKin(self, *args):
        r"""
        *Overload 1:*

        Get inverse kinematics object given group name and solver name
        This looks for kinematics plugin info added using addInvKinPlugin. If not found nullptr is returned.
        :type group_name: string
        :param group_name: The group name
        :type solver_name: string
        :param solver_name: The solver
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The scene graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The scene state

        |

        *Overload 2:*

        Get inverse kinematics object given plugin info
        :type plugin_info: tesseract_common::PluginInfo
        :param plugin_info: The plugin information to create kinematics object
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: The scene graph
        :type scene_state: :py:class:`SceneState`
        :param scene_state: The scene state
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_createInvKin(self, *args)

    def saveConfig(self, file_path):
        r"""
        Save the plugin information to a yaml config file
        :type file_path: :py:class:`path`
        :param file_path: The file path
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_saveConfig(self, file_path)

    def getConfig(self):
        r"""
        Get the plugin information config as a yaml node
        :rtype: YAML::Node
        :return: The plugin information config yaml node/
        """
        return _tesseract_kinematics_python.KinematicsPluginFactory_getConfig(self)

# Register KinematicsPluginFactory in _tesseract_kinematics_python:
_tesseract_kinematics_python.KinematicsPluginFactory_swigregister(KinematicsPluginFactory)

def numericalJacobian(*args):
    r"""
    *Overload 1:*

    Numerically calculate a jacobian. This is mainly used for testing
    :type jacobian: Eigen::Ref< Eigen::MatrixXd >
    :param jacobian: (Return) The jacobian which gets filled out.
    :type kin: :py:class:`ForwardKinematics`
    :param kin:          The kinematics object
    :type joint_values: Eigen::Ref< Eigen::VectorXd const >
    :param joint_values: The joint values for which to calculate the jacobian
    :type link_name: string
    :param link_name:    The link_name for which the jacobian should be calculated
    :type link_point: Eigen::Ref< Eigen::Vector3d const >
    :param link_point:   The point on the link for which to calculate the jacobian

    |

    *Overload 2:*

    Numerically calculate a jacobian. This is mainly used for testing
    :type jacobian: Eigen::Ref< Eigen::MatrixXd >
    :param jacobian: (Return) The jacobian which gets filled out.
    :type joint_group: :py:class:`JointGroup`
    :param joint_group:          The joint group object
    :type joint_values: Eigen::Ref< Eigen::VectorXd const >
    :param joint_values: The joint values for which to calculate the jacobian
    :type link_name: string
    :param link_name:    The link_name for which the jacobian should be calculated
    :type link_point: Eigen::Ref< Eigen::Vector3d const >
    :param link_point:   The point on the link for which to calculate the jacobian
    """
    return _tesseract_kinematics_python.numericalJacobian(*args)

def solvePInv(A, b):
    r"""
    Solve equation Ax=b for x
    Use this SVD to compute A+ (pseudoinverse of A). Weighting still TBD.
    :type A: Eigen::Ref< Eigen::MatrixXd const >
    :param A: Input matrix (represents Jacobian)
    :type b: Eigen::Ref< Eigen::VectorXd const >
    :param b: Input vector (represents desired pose)
    :type x: Eigen::Ref< Eigen::VectorXd >
    :param x: Output vector (represents joint values)
    :rtype: boolean
    :return: True if solver completes properly
    """
    return _tesseract_kinematics_python.solvePInv(A, b)

def dampedPInv(A, eps=0.011, _lambda=0.01):
    r"""
    Calculate Damped Pseudoinverse
    Use this SVD to compute A+ (pseudoinverse of A). Weighting still TBD.
    :type A: Eigen::Ref< Eigen::MatrixXd const >
    :param A: Input matrix (represents Jacobian)
    :type P: Eigen::Ref< Eigen::MatrixXd >
    :param P: Output matrix (represents pseudoinverse of A)
    :type eps: float, optional
    :param eps: Singular value threshold
    :type lambda: float, optional
    :param lambda: Damping factor
    :rtype: boolean
    :return: True if Pseudoinverse completes properly
    """
    return _tesseract_kinematics_python.dampedPInv(A, eps, _lambda)

def isNearSingularity(jacobian, threshold=0.01):
    r"""
    Check if the provided jacobian is near a singularity
    This is keep separated from the forward kinematics because special consideration may need to be made
    based on the kinematics arrangement.
    :type jacobian: Eigen::Ref< Eigen::MatrixXd const >
    :param jacobian: The jacobian to check if near a singularity
    :type threshold: float, optional
    :param threshold: The threshold that all singular values must be greater than or equal to not be considered near a
        singularity
    """
    return _tesseract_kinematics_python.isNearSingularity(jacobian, threshold)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ManipulabilityEllipsoid(object):
    r""" Used to store Manipulability and Force Ellipsoid data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    eigen_values = property(_tesseract_kinematics_python.ManipulabilityEllipsoid_eigen_values_get, _tesseract_kinematics_python.ManipulabilityEllipsoid_eigen_values_set, doc=r""" The manipulability ellipsoid eigen values""")
    measure = property(_tesseract_kinematics_python.ManipulabilityEllipsoid_measure_get, _tesseract_kinematics_python.ManipulabilityEllipsoid_measure_set, doc=r"""
    The ratio of longest and shortes axes of the manipulability ellipsoid
    As this grows large it is approaching a singularity
      - measure = sqrt(max eigen value) / sqrt(min eigen value)
      - This should be greater than or equal to 1
      - If equal to 1 it is isotropic
    """)
    condition = property(_tesseract_kinematics_python.ManipulabilityEllipsoid_condition_get, _tesseract_kinematics_python.ManipulabilityEllipsoid_condition_set, doc=r"""
    The condition number of A

      - condition = (max eigen value) / (min eigen value)
    """)
    volume = property(_tesseract_kinematics_python.ManipulabilityEllipsoid_volume_get, _tesseract_kinematics_python.ManipulabilityEllipsoid_volume_set, doc=r""" This is propotial to the volume""")

    def __init__(self):
        _tesseract_kinematics_python.ManipulabilityEllipsoid_swiginit(self, _tesseract_kinematics_python.new_ManipulabilityEllipsoid())
    __swig_destroy__ = _tesseract_kinematics_python.delete_ManipulabilityEllipsoid

# Register ManipulabilityEllipsoid in _tesseract_kinematics_python:
_tesseract_kinematics_python.ManipulabilityEllipsoid_swigregister(ManipulabilityEllipsoid)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Manipulability(object):
    r""" Contains both manipulability ellipsoid and force ellipsoid data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    m = property(_tesseract_kinematics_python.Manipulability_m_get, _tesseract_kinematics_python.Manipulability_m_set, doc=r""" Full Manipulability Ellipsoid""")
    m_linear = property(_tesseract_kinematics_python.Manipulability_m_linear_get, _tesseract_kinematics_python.Manipulability_m_linear_set, doc=r""" Linear velocity manipulability ellipsoid""")
    m_angular = property(_tesseract_kinematics_python.Manipulability_m_angular_get, _tesseract_kinematics_python.Manipulability_m_angular_set, doc=r""" Angular velocity manipulability ellipsoid""")
    f = property(_tesseract_kinematics_python.Manipulability_f_get, _tesseract_kinematics_python.Manipulability_f_set, doc=r""" Full Force Ellipsoid""")
    f_linear = property(_tesseract_kinematics_python.Manipulability_f_linear_get, _tesseract_kinematics_python.Manipulability_f_linear_set, doc=r""" Linear force manipulability ellipsoid""")
    f_angular = property(_tesseract_kinematics_python.Manipulability_f_angular_get, _tesseract_kinematics_python.Manipulability_f_angular_set, doc=r""" Angular momentum manipulability ellipsoid""")

    def __init__(self):
        _tesseract_kinematics_python.Manipulability_swiginit(self, _tesseract_kinematics_python.new_Manipulability())
    __swig_destroy__ = _tesseract_kinematics_python.delete_Manipulability

# Register Manipulability in _tesseract_kinematics_python:
_tesseract_kinematics_python.Manipulability_swigregister(Manipulability)

def calcManipulability(jacobian):
    r"""
    Calculate manipulability data about the provided jacobian
    :type jacobian: Eigen::Ref< Eigen::MatrixXd const >
    :param jacobian: The jacobian used to calculate manipulability
    :rtype: :py:class:`Manipulability`
    :return: The manipulability data
    """
    return _tesseract_kinematics_python.calcManipulability(jacobian)

def getRedundantSolutions(sol, limits, redundancy_capable_joints):
    r"""
    Kinematics only return solution between PI and -PI. Provided the limits it will append redundant solutions.
    The list of redundant solutions does not include the provided solutions.
    :type sol: Eigen::Ref< tesseract_kinematics::VectorX< double > const >
    :param sol: The solution to calculate redundant solutions about
    :type limits: Eigen::MatrixX2d
    :param limits: The joint limits of the robot
    :type redundancy_capable_joints: std::vector< Eigen::Index,std::allocator< Eigen::Index > >
    :param redundancy_capable_joints: The indices of the redundancy capable joints
    """
    return _tesseract_kinematics_python.getRedundantSolutions(sol, limits, redundancy_capable_joints)

