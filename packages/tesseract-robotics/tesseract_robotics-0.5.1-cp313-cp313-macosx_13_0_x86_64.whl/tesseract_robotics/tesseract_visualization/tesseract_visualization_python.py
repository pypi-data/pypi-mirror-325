# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_visualization_python
else:
    import _tesseract_visualization_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_visualization_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_visualization_python.delete_SwigPyIterator

    def value(self):
        return _tesseract_visualization_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tesseract_visualization_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tesseract_visualization_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tesseract_visualization_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tesseract_visualization_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tesseract_visualization_python.SwigPyIterator_copy(self)

    def next(self):
        return _tesseract_visualization_python.SwigPyIterator_next(self)

    def __next__(self):
        return _tesseract_visualization_python.SwigPyIterator___next__(self)

    def previous(self):
        return _tesseract_visualization_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tesseract_visualization_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tesseract_visualization_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tesseract_visualization_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tesseract_visualization_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tesseract_visualization_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tesseract_visualization_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tesseract_visualization_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_visualization_python:
_tesseract_visualization_python.SwigPyIterator_swigregister(SwigPyIterator)
import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
MarkerType_NONE = _tesseract_visualization_python.MarkerType_NONE
r"""No type"""
MarkerType_GEOMETRY = _tesseract_visualization_python.MarkerType_GEOMETRY
r"""Tesseract geometry"""
MarkerType_AXIS = _tesseract_visualization_python.MarkerType_AXIS
r"""Axis primitive"""
MarkerType_ARROW = _tesseract_visualization_python.MarkerType_ARROW
r"""Arrow primitive"""
MarkerType_LINE_STRIP = _tesseract_visualization_python.MarkerType_LINE_STRIP
r"""Line strip primitive"""
MarkerType_LINE_LIST = _tesseract_visualization_python.MarkerType_LINE_LIST
r"""Line list primitive"""
MarkerType_POINTS = _tesseract_visualization_python.MarkerType_POINTS
r"""Points primitive"""
MarkerType_TEXT = _tesseract_visualization_python.MarkerType_TEXT
r"""Text geometry"""
MarkerType_TRIANGLE_FAN = _tesseract_visualization_python.MarkerType_TRIANGLE_FAN
r"""Triangle fan primitive"""
MarkerType_TRIANGLE_LIST = _tesseract_visualization_python.MarkerType_TRIANGLE_LIST
r"""Triangle list primitive"""
MarkerType_TRIANGLE_STRIP = _tesseract_visualization_python.MarkerType_TRIANGLE_STRIP
r"""Triangle strip primitive"""
MarkerType_TOOLPATH = _tesseract_visualization_python.MarkerType_TOOLPATH
r"""Toolpath marker"""
MarkerType_CONTACT_RESULTS = _tesseract_visualization_python.MarkerType_CONTACT_RESULTS
r"""Contact results marker"""
MarkerType_USER_DEFINED = _tesseract_visualization_python.MarkerType_USER_DEFINED
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Marker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_visualization_python.delete_Marker

    def getType(self):
        r"""
        Get the marker type
        :rtype: int
        :return: The type of the marker
        """
        return _tesseract_visualization_python.Marker_getType(self)

    def setParentLink(self, parent_link):
        r"""
        The parent link name the marker should be attached to
        :type parent_link: string
        :param parent_link: The parent link name
        """
        return _tesseract_visualization_python.Marker_setParentLink(self, parent_link)

    def getParentLink(self):
        r"""
        Get the parent link name that marker should be attached to
        If empty then it should be relative world coordinates
        """
        return _tesseract_visualization_python.Marker_getParentLink(self)

    def setLifetime(self, lifetime):
        r"""
        Set the lifetime of the this marker
        :type lifetime: std::chrono::steady_clock::duration
        :param lifetime: The time at which the marker will be removed
        """
        return _tesseract_visualization_python.Marker_setLifetime(self, lifetime)

    def getLifetime(self):
        r"""
        Get the lifetime of this Marker
        :rtype: std::chrono::steady_clock::duration
        :return: The time at which the marker will be removed
        """
        return _tesseract_visualization_python.Marker_getLifetime(self)

    def setLayer(self, layer):
        r"""
        Set the layer of this Marker
        :type layer: int
        :param layer: Layer at which the marker will reside
        """
        return _tesseract_visualization_python.Marker_setLayer(self, layer)

    def getLayer(self):
        r"""
        Get the layer of this Marker
        :rtype: int
        :return: The layer of the marker
        """
        return _tesseract_visualization_python.Marker_getLayer(self)

    def setScale(self, scale):
        r"""
        Set the marker scale
        :type scale: Eigen::Vector3d
        :param scale: The marker scale
        """
        return _tesseract_visualization_python.Marker_setScale(self, scale)

    def getScale(self):
        r"""
        Get the marker scale
        :rtype: Eigen::Vector3d
        :return: The scale of the marker
        """
        return _tesseract_visualization_python.Marker_getScale(self)

# Register Marker in _tesseract_visualization_python:
_tesseract_visualization_python.Marker_swigregister(Marker)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ArrowMarker(Marker):
    r"""
    An arrow marker
    The arrow will be created along the z-axis of the provided pose with the base of the shaft at the origin
    point in the positive direction
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Define an arrow marker using two points
        The class parameters are calculated based on distance
        :type pt1: Eigen::Vector3d
        :param pt1: The starting point
        :type pt2: Eigen::Vector3d
        :param pt2: The final point
        """
        _tesseract_visualization_python.ArrowMarker_swiginit(self, _tesseract_visualization_python.new_ArrowMarker(*args))

    def getType(self):
        return _tesseract_visualization_python.ArrowMarker_getType(self)
    shaft_length = property(_tesseract_visualization_python.ArrowMarker_shaft_length_get, _tesseract_visualization_python.ArrowMarker_shaft_length_set, doc=r"""The arrow shaft length""")
    shaft_radius = property(_tesseract_visualization_python.ArrowMarker_shaft_radius_get, _tesseract_visualization_python.ArrowMarker_shaft_radius_set, doc=r"""The arrow shaft radius""")
    head_length = property(_tesseract_visualization_python.ArrowMarker_head_length_get, _tesseract_visualization_python.ArrowMarker_head_length_set, doc=r"""The arrow head length""")
    head_radius = property(_tesseract_visualization_python.ArrowMarker_head_radius_get, _tesseract_visualization_python.ArrowMarker_head_radius_set, doc=r"""The arrow head radius""")
    pose = property(_tesseract_visualization_python.ArrowMarker_pose_get, _tesseract_visualization_python.ArrowMarker_pose_set, doc=r"""The arrow pose""")
    material = property(_tesseract_visualization_python.ArrowMarker_material_get, _tesseract_visualization_python.ArrowMarker_material_set, doc=r"""The material information for the marker""")
    __swig_destroy__ = _tesseract_visualization_python.delete_ArrowMarker

# Register ArrowMarker in _tesseract_visualization_python:
_tesseract_visualization_python.ArrowMarker_swigregister(ArrowMarker)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class AxisMarker(Marker):
    r"""An axis"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_visualization_python.AxisMarker_swiginit(self, _tesseract_visualization_python.new_AxisMarker(*args))

    def getType(self):
        return _tesseract_visualization_python.AxisMarker_getType(self)
    axis = property(_tesseract_visualization_python.AxisMarker_axis_get, _tesseract_visualization_python.AxisMarker_axis_set, doc=r"""The axis definition""")
    __swig_destroy__ = _tesseract_visualization_python.delete_AxisMarker

# Register AxisMarker in _tesseract_visualization_python:
_tesseract_visualization_python.AxisMarker_swigregister(AxisMarker)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ContactResultsMarker(Marker):
    r"""
    A contact results marker
    If margin_fn is provided it takes priority. This can be removed once trajopt_ifopt is fully tested and
    trajopt_sco and trajopt packages are removed
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_visualization_python.ContactResultsMarker_swiginit(self, _tesseract_visualization_python.new_ContactResultsMarker(*args))

    def getType(self):
        return _tesseract_visualization_python.ContactResultsMarker_getType(self)
    link_names = property(_tesseract_visualization_python.ContactResultsMarker_link_names_get, _tesseract_visualization_python.ContactResultsMarker_link_names_set)
    dist_results = property(_tesseract_visualization_python.ContactResultsMarker_dist_results_get, _tesseract_visualization_python.ContactResultsMarker_dist_results_set)
    margin_data = property(_tesseract_visualization_python.ContactResultsMarker_margin_data_get, _tesseract_visualization_python.ContactResultsMarker_margin_data_set)
    margin_fn = property(_tesseract_visualization_python.ContactResultsMarker_margin_fn_get, _tesseract_visualization_python.ContactResultsMarker_margin_fn_set)
    __swig_destroy__ = _tesseract_visualization_python.delete_ContactResultsMarker

# Register ContactResultsMarker in _tesseract_visualization_python:
_tesseract_visualization_python.ContactResultsMarker_swigregister(ContactResultsMarker)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class GeometryMarker(Marker):
    r"""An geometry marker"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_visualization_python.GeometryMarker_swiginit(self, _tesseract_visualization_python.new_GeometryMarker(*args))

    def getType(self):
        return _tesseract_visualization_python.GeometryMarker_getType(self)
    geom = property(_tesseract_visualization_python.GeometryMarker_geom_get, _tesseract_visualization_python.GeometryMarker_geom_set, doc=r"""The geometry object""")
    origin = property(_tesseract_visualization_python.GeometryMarker_origin_get, _tesseract_visualization_python.GeometryMarker_origin_set, doc=r"""The origin definition""")
    __swig_destroy__ = _tesseract_visualization_python.delete_GeometryMarker

# Register GeometryMarker in _tesseract_visualization_python:
_tesseract_visualization_python.GeometryMarker_swigregister(GeometryMarker)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class ToolpathMarker(Marker):
    r"""An arrow defined by two points"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_visualization_python.ToolpathMarker_swiginit(self, _tesseract_visualization_python.new_ToolpathMarker(*args))

    def getType(self):
        return _tesseract_visualization_python.ToolpathMarker_getType(self)
    show_path = property(_tesseract_visualization_python.ToolpathMarker_show_path_get, _tesseract_visualization_python.ToolpathMarker_show_path_set)
    show_axis = property(_tesseract_visualization_python.ToolpathMarker_show_axis_get, _tesseract_visualization_python.ToolpathMarker_show_axis_set)
    toolpath = property(_tesseract_visualization_python.ToolpathMarker_toolpath_get, _tesseract_visualization_python.ToolpathMarker_toolpath_set)
    scale = property(_tesseract_visualization_python.ToolpathMarker_scale_get, _tesseract_visualization_python.ToolpathMarker_scale_set)
    __swig_destroy__ = _tesseract_visualization_python.delete_ToolpathMarker

# Register ToolpathMarker in _tesseract_visualization_python:
_tesseract_visualization_python.ToolpathMarker_swigregister(ToolpathMarker)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TrajectoryInterpolator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, trajectory):
        _tesseract_visualization_python.TrajectoryInterpolator_swiginit(self, _tesseract_visualization_python.new_TrajectoryInterpolator(trajectory))
    __swig_destroy__ = _tesseract_visualization_python.delete_TrajectoryInterpolator

    def getState(self, request_duration):
        return _tesseract_visualization_python.TrajectoryInterpolator_getState(self, request_duration)

    def getStateDuration(self, index):
        return _tesseract_visualization_python.TrajectoryInterpolator_getStateDuration(self, index)

    def getStateCount(self):
        return _tesseract_visualization_python.TrajectoryInterpolator_getStateCount(self)

    def empty(self):
        return _tesseract_visualization_python.TrajectoryInterpolator_empty(self)

# Register TrajectoryInterpolator in _tesseract_visualization_python:
_tesseract_visualization_python.TrajectoryInterpolator_swigregister(TrajectoryInterpolator)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class TrajectoryPlayer(object):
    r"""Enables the ability to play a trajectory provided by the set program"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_visualization_python.delete_TrajectoryPlayer

    def __init__(self, *args):
        _tesseract_visualization_python.TrajectoryPlayer_swiginit(self, _tesseract_visualization_python.new_TrajectoryPlayer(*args))

    def setTrajectory(self, trajectory):
        r"""
        Set the the trajectory for the trajectory player
        :param program: The trajectory to play
        """
        return _tesseract_visualization_python.TrajectoryPlayer_setTrajectory(self, trajectory)

    def setScale(self, scale):
        r"""
        Set the scale factor for the play back of the trajectory
        :type scale: float
        :param scale: The scale playback of the trajectory
        """
        return _tesseract_visualization_python.TrajectoryPlayer_setScale(self, scale)

    def setCurrentDurationByIndex(self, index):
        r"""
        Set the current time for the player by index of the input trajectoy
        :type index: int
        :param index: The input trajectory index for which to set the current time from
        :rtype: :py:class:`JointState`
        :return: The trajectory state at the input trajectory index
        """
        return _tesseract_visualization_python.TrajectoryPlayer_setCurrentDurationByIndex(self, index)

    def setCurrentDuration(self, duration):
        r"""
        Set the current time for the player by duration
        :type duration: float
        :param duration: The duration for which to set the current time from
        :rtype: :py:class:`JointState`
        :return: The trajectory state at the provided duration
        """
        return _tesseract_visualization_python.TrajectoryPlayer_setCurrentDuration(self, duration)

    def getNext(self):
        r"""
        Get the next move instruction from the player
        :rtype: :py:class:`JointState`
        :return: The move instruction at the next time interval
        """
        return _tesseract_visualization_python.TrajectoryPlayer_getNext(self)

    def getByIndex(self, index):
        r"""
        Get move instruction by index
        :type index: int
        :param index: The index of the input program to extract the move instruction from
        :rtype: :py:class:`JointState`
        :return: The move instruction at the input index
        """
        return _tesseract_visualization_python.TrajectoryPlayer_getByIndex(self, index)

    def currentDuration(self):
        r"""
        Get the current duration populated by the last call to getNext()
        :rtype: float
        :return: The current duration
        """
        return _tesseract_visualization_python.TrajectoryPlayer_currentDuration(self)

    def trajectoryDurationBegin(self):
        r"""
        Get the trajectory duration at the begin state
        :rtype: float
        :return: The trajectory duration
        """
        return _tesseract_visualization_python.TrajectoryPlayer_trajectoryDurationBegin(self)

    def trajectoryDurationEnd(self):
        r"""
        Get the trajectory duration at the end state
        :rtype: float
        :return: The trajectory duration
        """
        return _tesseract_visualization_python.TrajectoryPlayer_trajectoryDurationEnd(self)

    def isFinished(self):
        r"""
        Check if the player has the reached the end of the trajectory
        :rtype: boolean
        :return: True if end has been reached, otherwise false.
        """
        return _tesseract_visualization_python.TrajectoryPlayer_isFinished(self)

    def enableLoop(self, loop):
        r"""
        Enable looping playback of the trajectory
        :type loop: boolean
        :param loop: True to enable looping play, otherwise single playback.
        """
        return _tesseract_visualization_python.TrajectoryPlayer_enableLoop(self, loop)

    def isLoopEnabled(self):
        r"""
        Get if looping playback is enabled
        :rtype: boolean
        :return: True if looping playback is enabled otherwise false.
        """
        return _tesseract_visualization_python.TrajectoryPlayer_isLoopEnabled(self)

    def reset(self):
        r"""Reset the state of the trajectory player"""
        return _tesseract_visualization_python.TrajectoryPlayer_reset(self)

    def size(self):
        r"""The size of the tajectory"""
        return _tesseract_visualization_python.TrajectoryPlayer_size(self)

# Register TrajectoryPlayer in _tesseract_visualization_python:
_tesseract_visualization_python.TrajectoryPlayer_swigregister(TrajectoryPlayer)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class Visualization(object):
    r"""The Vizualization class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_visualization_python.delete_Visualization

    def isConnected(self):
        r"""
        Some plotters may require connecting to external software.
        :rtype: boolean
        :return: True if connected, otherwise false
        """
        return _tesseract_visualization_python.Visualization_isConnected(self)

    def waitForConnection(self, seconds=0):
        r"""
        Wait for connection
        :type seconds: int, optional
        :param seconds: The number of seconds to wait before returning, if zero it waits indefinitely
        """
        return _tesseract_visualization_python.Visualization_waitForConnection(self, seconds)

    def plotEnvironment(self, *args):
        r"""
        Plot environment
        :type env: :py:class:`Environment`
        :param env: The environment.
        """
        return _tesseract_visualization_python.Visualization_plotEnvironment(self, *args)

    def plotEnvironmentState(self, *args):
        r"""
        Plot state of the environment
        :type state: :py:class:`SceneState`
        :param state: The state of the environment.
        """
        return _tesseract_visualization_python.Visualization_plotEnvironmentState(self, *args)

    def plotTrajectory(self, *args):
        r"""
        Plot a JointTrajectory
        :type state_solver: :py:class:`StateSolver`
        :param state_solver: The environment
        :param trajectory: JointTrajectory to be plotted
        """
        return _tesseract_visualization_python.Visualization_plotTrajectory(self, *args)

    def plotMarker(self, *args):
        r"""
        Plot marker
        :type marker: :py:class:`Marker`
        :param marker: The marker to plot
        :type ns: string, optional
        :param ns: The namespace to plot the object under
        """
        return _tesseract_visualization_python.Visualization_plotMarker(self, *args)

    def plotMarkers(self, *args):
        r"""
        Plot a vector of markers under a given namespace
        :type markers: std::vector< std::shared_ptr< tesseract_visualization::Marker >,std::allocator< std::shared_ptr< tesseract_visualization::Marker > > >
        :param markers: The markers to plot
        :type ns: string, optional
        :param ns: The namespace to plot the objects under
        """
        return _tesseract_visualization_python.Visualization_plotMarkers(self, *args)

    def clear(self, *args):
        r"""
        This is called at the start of the plotting for each iteration
               to clear previous iteration graphics if necessary.
        """
        return _tesseract_visualization_python.Visualization_clear(self, *args)

    def waitForInput(self, *args):
        r"""Pause code and wait for enter key in terminal"""
        return _tesseract_visualization_python.Visualization_waitForInput(self, *args)

# Register Visualization in _tesseract_visualization_python:
_tesseract_visualization_python.Visualization_swigregister(Visualization)
@_swig_add_metaclass(_SwigNonDynamicMeta)
class VisualizationLoader(object):
    r"""
    This is used to dynamically load tesseract visualizer.
    This class must remain around for the life of the loaded visualization class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        r"""This will attempt to load the tesseract_ignition visualizer provided by snap package"""
        _tesseract_visualization_python.VisualizationLoader_swiginit(self, _tesseract_visualization_python.new_VisualizationLoader())

    def get(self, *args):
        r"""
        Load the default visualization plugin
        :type plugin_name: string, optional
        :param plugin_name: The plugin name, if empty it tries to load default plugin
        :rtype: :py:class:`Visualization`
        :return: Returns nullptr if failed
        """
        return _tesseract_visualization_python.VisualizationLoader_get(self, *args)
    __swig_destroy__ = _tesseract_visualization_python.delete_VisualizationLoader

# Register VisualizationLoader in _tesseract_visualization_python:
_tesseract_visualization_python.VisualizationLoader_swigregister(VisualizationLoader)

