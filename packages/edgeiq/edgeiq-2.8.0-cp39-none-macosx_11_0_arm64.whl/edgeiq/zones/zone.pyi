import numpy as np
from edgeiq.bounding_box import BoundingBox as BoundingBox
from edgeiq.object_detection import ObjectDetectionPrediction as ObjectDetectionPrediction, ObjectDetectionResults as ObjectDetectionResults
from edgeiq.object_tracking import TrackingResults as TrackingResults
from enum import Enum
from typing import Any

BOX_ZONE_DEPRECATION_WARNING: str

def generate_boundary(points): ...
def validate_dimension(dimension: Any) -> int: ...
def create_binary_mask(points: list[tuple[int, int]], image_width: int, image_height: int) -> np.ndarray: ...

class ZoneType(Enum):
    BOX = 'BOX'
    POLYGON = 'POLYGON'

def convert_to_zone_type(val: str) -> ZoneType: ...
def get_bbox_center(prediction: ObjectDetectionPrediction) -> tuple[int, int]: ...

class Zone:
    def __init__(self, name: str, points: list[tuple[int, int]], image_width: int, image_height: int, description: str = '', **kwargs) -> None: ...
    @classmethod
    def from_bounding_box(cls, name: str, box: BoundingBox, image_width: int, image_height: int, description: str = '') -> Zone: ...
    def __eq__(self, other): ...
    @property
    def image_width(self) -> int: ...
    @property
    def image_height(self) -> int: ...
    @property
    def mask(self) -> np.ndarray: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, name: str): ...
    @property
    def points(self) -> list[tuple[int, int]]: ...
    @points.setter
    def points(self, points: list[tuple[int, int]]): ...
    @property
    def description(self) -> str: ...
    @property
    def type(self) -> ZoneType: ...
    def to_bounding_box(self) -> BoundingBox: ...
    def update_image_dimensions(self, image_width: int | None = None, image_height: int | None = None): ...
    def check_prediction_within_zone(self, prediction: ObjectDetectionPrediction, **kwargs) -> bool: ...
    def get_predictions_in_zone(self, results: ObjectDetectionResults, **kwargs) -> ObjectDetectionResults: ...
    def get_tracked_objects_in_zone(self, objects: TrackingResults) -> TrackingResults: ...
    def compute_prediction_overlap_with_zone(self, prediction: ObjectDetectionPrediction) -> float: ...
