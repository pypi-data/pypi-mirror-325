class BoundingBox:
    def __init__(self, start_x: int, start_y: int, end_x: int, end_y: int) -> None: ...
    @classmethod
    def from_width_height_center(cls, width: int, height: int, center: tuple[float, float]): ...
    def __eq__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    @property
    def start_x(self) -> int: ...
    @start_x.setter
    def start_x(self, val: int): ...
    @property
    def start_y(self) -> int: ...
    @start_y.setter
    def start_y(self, val: int): ...
    @property
    def end_x(self) -> int: ...
    @end_x.setter
    def end_x(self, val: int): ...
    @property
    def end_y(self) -> int: ...
    @end_y.setter
    def end_y(self, val: int): ...
    @property
    def width(self): ...
    @property
    def height(self): ...
    @property
    def area(self): ...
    @property
    def center(self): ...
    @center.setter
    def center(self, val: tuple[float, float]): ...
    @property
    def opencv_bbox(self): ...
    def compute_distance(self, other_box: BoundingBox): ...
    def get_intersection(self, other_box: BoundingBox): ...
    def compute_overlap(self, other_box: BoundingBox): ...
    def compute_iou(self, other_box: BoundingBox): ...
    def scale_about_center(self, scale_x: float = 1.0, scale_y: float = 1.0): ...
    def scale_with_image(self, scale_x: float = 1.0, scale_y: float = 1.0): ...

class BoundingBoxPrediction:
    def __init__(self, box: BoundingBox, confidence: float) -> None: ...
    def __eq__(self, other): ...
    @property
    def box(self) -> BoundingBox: ...
    @box.setter
    def box(self, box: BoundingBox): ...
    @property
    def confidence(self) -> float: ...
    @confidence.setter
    def confidence(self, confidence: float): ...
