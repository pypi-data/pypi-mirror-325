# coding: utf-8

"""
    Acre Platform User API

    # CORS CORS is implemented by all Acre API endpoints and only certain hostnames are allowed for each deployment of the API. If your use case requires calling the Acre User API from a browser, please contact Acre to arrange the appropriate configuration. # API Authentication The primary method of authentication for users of the Acre API is with the use of JSON Web Tokens (JWTs), which are suplemented by an application specific API Key. The API key must be provided through the `X-API-KEY` HTTP header and will be provided by your Acre Customer Success Manager. The JWT must be provided through a cookie with key of `authorization`. The JWT must be generated and signed as per the following section. # Generating JWTs JWT must either be generated by a third-party such as Azure ADB2C that has been configured for the appropriate service and/or user account, or alternatively can be generated locally and signed by an private key for which the public key has been made available to Acre via a JWKS URL. In addition to being signed by your private key, the JWT will also need to contain at a minimum:  * An issuer `iss`, which must be a valid URI previously agreed with Acre.  * A subject `sub`, which must be a unique identifier for the user and/or service account previously agreed with Acre.  * An expiry time `exp` which must not be more than four hours in the future.  * A not before time `nbf` which must be in the past, but not greater than six hours in the past.  The JWT should be signed using RS256.

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from acre_api.models.cdm_create_permission_assignment_response import CdmCreatePermissionAssignmentResponse
from acre_api.models.cdm_create_permission_assignments_request import CdmCreatePermissionAssignmentsRequest
from acre_api.models.cdm_create_permission_assignments_response import CdmCreatePermissionAssignmentsResponse
from acre_api.models.cdm_get_permission_assignment_response import CdmGetPermissionAssignmentResponse
from acre_api.models.cdm_get_permission_response import CdmGetPermissionResponse
from acre_api.models.cdm_permission_assignment import CdmPermissionAssignment
from acre_api.models.cdm_replace_permission_assignment_response import CdmReplacePermissionAssignmentResponse
from acre_api.models.cdm_resolve_permission_request import CdmResolvePermissionRequest
from acre_api.models.cdm_resolve_permission_response import CdmResolvePermissionResponse
from acre_api.models.cdm_update_permission_assignment_response import CdmUpdatePermissionAssignmentResponse
from acre_api.models.cdm_update_permission_assignments_request import CdmUpdatePermissionAssignmentsRequest
from acre_api.models.cdm_update_permission_assignments_response import CdmUpdatePermissionAssignmentsResponse
from acre_api.models.complete_details_of_the_permission_assignment_to_be_replaced_currently_only_the_disabled_field_can_be_set_and_it_must_be_set_required import CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
from acre_api.models.partial_details_of_the_permission_assignment_to_be_patched_currently_only_the_disabled_field_can_be_set_and_it_must_be_set_required import PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired

from acre_api.api_client import ApiClient, RequestSerialized
from acre_api.api_response import ApiResponse
from acre_api.rest import RESTResponseType


class PermissionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_permission_assignment(
        self,
        permission_assignment: Annotated[CdmPermissionAssignment, Field(description="Details of the new permission assignment to be created. Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmCreatePermissionAssignmentResponse:
        """Create a new permission assignment.


        :param permission_assignment: Details of the new permission assignment to be created. Required. (required)
        :type permission_assignment: CdmPermissionAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_permission_assignment_serialize(
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmCreatePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_permission_assignment_with_http_info(
        self,
        permission_assignment: Annotated[CdmPermissionAssignment, Field(description="Details of the new permission assignment to be created. Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmCreatePermissionAssignmentResponse]:
        """Create a new permission assignment.


        :param permission_assignment: Details of the new permission assignment to be created. Required. (required)
        :type permission_assignment: CdmPermissionAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_permission_assignment_serialize(
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmCreatePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_permission_assignment_without_preload_content(
        self,
        permission_assignment: Annotated[CdmPermissionAssignment, Field(description="Details of the new permission assignment to be created. Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new permission assignment.


        :param permission_assignment: Details of the new permission assignment to be created. Required. (required)
        :type permission_assignment: CdmPermissionAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_permission_assignment_serialize(
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmCreatePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_permission_assignment_serialize(
        self,
        permission_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if permission_assignment is not None:
            _body_params = permission_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/acre/permission_assignment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_permission_assignments(
        self,
        body: Annotated[CdmCreatePermissionAssignmentsRequest, Field(description="Create multiple new permission assignments. If one fails the call, none will be applied.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmCreatePermissionAssignmentsResponse:
        """Create new permission assignments. If one fails the call, none will be applied. Note that this endpoint must be defined after /v1/acre/permission_assignment/{permission_assignment.permission_assignment_id}, otherwise requests to /v1/acre/permission_assignment/bulk will be handled as if `bulk` is permission_assignment_id


        :param body: Create multiple new permission assignments. If one fails the call, none will be applied. (required)
        :type body: CdmCreatePermissionAssignmentsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_permission_assignments_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmCreatePermissionAssignmentsResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_permission_assignments_with_http_info(
        self,
        body: Annotated[CdmCreatePermissionAssignmentsRequest, Field(description="Create multiple new permission assignments. If one fails the call, none will be applied.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmCreatePermissionAssignmentsResponse]:
        """Create new permission assignments. If one fails the call, none will be applied. Note that this endpoint must be defined after /v1/acre/permission_assignment/{permission_assignment.permission_assignment_id}, otherwise requests to /v1/acre/permission_assignment/bulk will be handled as if `bulk` is permission_assignment_id


        :param body: Create multiple new permission assignments. If one fails the call, none will be applied. (required)
        :type body: CdmCreatePermissionAssignmentsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_permission_assignments_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmCreatePermissionAssignmentsResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_permission_assignments_without_preload_content(
        self,
        body: Annotated[CdmCreatePermissionAssignmentsRequest, Field(description="Create multiple new permission assignments. If one fails the call, none will be applied.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create new permission assignments. If one fails the call, none will be applied. Note that this endpoint must be defined after /v1/acre/permission_assignment/{permission_assignment.permission_assignment_id}, otherwise requests to /v1/acre/permission_assignment/bulk will be handled as if `bulk` is permission_assignment_id


        :param body: Create multiple new permission assignments. If one fails the call, none will be applied. (required)
        :type body: CdmCreatePermissionAssignmentsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_permission_assignments_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmCreatePermissionAssignmentsResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_permission_assignments_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/acre/permission_assignment/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_permission(
        self,
        permission_ids: Annotated[Optional[List[StrictStr]], Field(description="Permission IDs (optional, default wildcard for all IDs user can access).")] = None,
        permission_names: Annotated[Optional[List[StrictStr]], Field(description="Permission names (optional, default wildcard for all names user can access).")] = None,
        filter_permission_type: Annotated[Optional[StrictStr], Field(description="Only include permissions with the specified type.")] = None,
        bookmark: Annotated[Optional[StrictStr], Field(description="Opaque pagination bookmark. Set to the empty string (or omit) to begin.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 100.")] = None,
        show_allowlist: Annotated[Optional[StrictBool], Field(description="If true, the permissions returned will be showing only the ones marked as allowed to show to users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmGetPermissionResponse:
        """Get permission details. Permissions are populated using a default configuration, and cannot be manipulated via API.


        :param permission_ids: Permission IDs (optional, default wildcard for all IDs user can access).
        :type permission_ids: List[str]
        :param permission_names: Permission names (optional, default wildcard for all names user can access).
        :type permission_names: List[str]
        :param filter_permission_type: Only include permissions with the specified type.
        :type filter_permission_type: str
        :param bookmark: Opaque pagination bookmark. Set to the empty string (or omit) to begin.
        :type bookmark: str
        :param page_size: Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 100.
        :type page_size: int
        :param show_allowlist: If true, the permissions returned will be showing only the ones marked as allowed to show to users.
        :type show_allowlist: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_permission_serialize(
            permission_ids=permission_ids,
            permission_names=permission_names,
            filter_permission_type=filter_permission_type,
            bookmark=bookmark,
            page_size=page_size,
            show_allowlist=show_allowlist,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmGetPermissionResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_permission_with_http_info(
        self,
        permission_ids: Annotated[Optional[List[StrictStr]], Field(description="Permission IDs (optional, default wildcard for all IDs user can access).")] = None,
        permission_names: Annotated[Optional[List[StrictStr]], Field(description="Permission names (optional, default wildcard for all names user can access).")] = None,
        filter_permission_type: Annotated[Optional[StrictStr], Field(description="Only include permissions with the specified type.")] = None,
        bookmark: Annotated[Optional[StrictStr], Field(description="Opaque pagination bookmark. Set to the empty string (or omit) to begin.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 100.")] = None,
        show_allowlist: Annotated[Optional[StrictBool], Field(description="If true, the permissions returned will be showing only the ones marked as allowed to show to users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmGetPermissionResponse]:
        """Get permission details. Permissions are populated using a default configuration, and cannot be manipulated via API.


        :param permission_ids: Permission IDs (optional, default wildcard for all IDs user can access).
        :type permission_ids: List[str]
        :param permission_names: Permission names (optional, default wildcard for all names user can access).
        :type permission_names: List[str]
        :param filter_permission_type: Only include permissions with the specified type.
        :type filter_permission_type: str
        :param bookmark: Opaque pagination bookmark. Set to the empty string (or omit) to begin.
        :type bookmark: str
        :param page_size: Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 100.
        :type page_size: int
        :param show_allowlist: If true, the permissions returned will be showing only the ones marked as allowed to show to users.
        :type show_allowlist: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_permission_serialize(
            permission_ids=permission_ids,
            permission_names=permission_names,
            filter_permission_type=filter_permission_type,
            bookmark=bookmark,
            page_size=page_size,
            show_allowlist=show_allowlist,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmGetPermissionResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_permission_without_preload_content(
        self,
        permission_ids: Annotated[Optional[List[StrictStr]], Field(description="Permission IDs (optional, default wildcard for all IDs user can access).")] = None,
        permission_names: Annotated[Optional[List[StrictStr]], Field(description="Permission names (optional, default wildcard for all names user can access).")] = None,
        filter_permission_type: Annotated[Optional[StrictStr], Field(description="Only include permissions with the specified type.")] = None,
        bookmark: Annotated[Optional[StrictStr], Field(description="Opaque pagination bookmark. Set to the empty string (or omit) to begin.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 100.")] = None,
        show_allowlist: Annotated[Optional[StrictBool], Field(description="If true, the permissions returned will be showing only the ones marked as allowed to show to users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get permission details. Permissions are populated using a default configuration, and cannot be manipulated via API.


        :param permission_ids: Permission IDs (optional, default wildcard for all IDs user can access).
        :type permission_ids: List[str]
        :param permission_names: Permission names (optional, default wildcard for all names user can access).
        :type permission_names: List[str]
        :param filter_permission_type: Only include permissions with the specified type.
        :type filter_permission_type: str
        :param bookmark: Opaque pagination bookmark. Set to the empty string (or omit) to begin.
        :type bookmark: str
        :param page_size: Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 100.
        :type page_size: int
        :param show_allowlist: If true, the permissions returned will be showing only the ones marked as allowed to show to users.
        :type show_allowlist: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_permission_serialize(
            permission_ids=permission_ids,
            permission_names=permission_names,
            filter_permission_type=filter_permission_type,
            bookmark=bookmark,
            page_size=page_size,
            show_allowlist=show_allowlist,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmGetPermissionResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_permission_serialize(
        self,
        permission_ids,
        permission_names,
        filter_permission_type,
        bookmark,
        page_size,
        show_allowlist,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'permission_ids': 'multi',
            'permission_names': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if permission_ids is not None:
            
            _query_params.append(('permission_ids', permission_ids))
            
        if permission_names is not None:
            
            _query_params.append(('permission_names', permission_names))
            
        if filter_permission_type is not None:
            
            _query_params.append(('filter_permission_type', filter_permission_type))
            
        if bookmark is not None:
            
            _query_params.append(('bookmark', bookmark))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        if show_allowlist is not None:
            
            _query_params.append(('show_allowlist', show_allowlist))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/acre/permission',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_permission_assignment(
        self,
        permission_assignment_details: Annotated[Optional[StrictBool], Field(description="Return the entire permission assignment details. By default this value is false, and only the IDs are returned.")] = None,
        permission_assignment_ids: Annotated[Optional[List[StrictStr]], Field(description="Permission assignment IDs (optional, default wildcard for all IDs user can access). It is an error to request a permission assignment by ID without having the required view permissions.")] = None,
        show_disabled: Annotated[Optional[StrictBool], Field(description="Specify to show disabled permission assignments. By default they are not shown on a wildcard query. This only has effect for a wildcard query.")] = None,
        filter_organisation_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the specified organisation scope.")] = None,
        filter_user_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the permission is assigned.")] = None,
        filter_role_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the user has a role. All users are allowed set this filter.")] = None,
        filter_group_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the user has a group.")] = None,
        filter_group_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter to only include permission assignments to whom the user has groups.")] = None,
        filter_client_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the client scope.")] = None,
        filter_case_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the case scope.")] = None,
        filter_user_scope_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with a scope for the user assigning the permission.")] = None,
        bookmark: Annotated[Optional[StrictStr], Field(description="Opaque pagination bookmark. Set to the empty string (or omit) to begin.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 500.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmGetPermissionAssignmentResponse:
        """Get the permission assignment details.


        :param permission_assignment_details: Return the entire permission assignment details. By default this value is false, and only the IDs are returned.
        :type permission_assignment_details: bool
        :param permission_assignment_ids: Permission assignment IDs (optional, default wildcard for all IDs user can access). It is an error to request a permission assignment by ID without having the required view permissions.
        :type permission_assignment_ids: List[str]
        :param show_disabled: Specify to show disabled permission assignments. By default they are not shown on a wildcard query. This only has effect for a wildcard query.
        :type show_disabled: bool
        :param filter_organisation_id: Filter to only include permission assignments with the specified organisation scope.
        :type filter_organisation_id: str
        :param filter_user_id: Filter to only include permission assignments to whom the permission is assigned.
        :type filter_user_id: str
        :param filter_role_id: Filter to only include permission assignments to whom the user has a role. All users are allowed set this filter.
        :type filter_role_id: str
        :param filter_group_id: Filter to only include permission assignments to whom the user has a group.
        :type filter_group_id: str
        :param filter_group_ids: Filter to only include permission assignments to whom the user has groups.
        :type filter_group_ids: List[str]
        :param filter_client_id: Filter to only include permission assignments with the client scope.
        :type filter_client_id: str
        :param filter_case_id: Filter to only include permission assignments with the case scope.
        :type filter_case_id: str
        :param filter_user_scope_id: Filter to only include permission assignments with a scope for the user assigning the permission.
        :type filter_user_scope_id: str
        :param bookmark: Opaque pagination bookmark. Set to the empty string (or omit) to begin.
        :type bookmark: str
        :param page_size: Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 500.
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_permission_assignment_serialize(
            permission_assignment_details=permission_assignment_details,
            permission_assignment_ids=permission_assignment_ids,
            show_disabled=show_disabled,
            filter_organisation_id=filter_organisation_id,
            filter_user_id=filter_user_id,
            filter_role_id=filter_role_id,
            filter_group_id=filter_group_id,
            filter_group_ids=filter_group_ids,
            filter_client_id=filter_client_id,
            filter_case_id=filter_case_id,
            filter_user_scope_id=filter_user_scope_id,
            bookmark=bookmark,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmGetPermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_permission_assignment_with_http_info(
        self,
        permission_assignment_details: Annotated[Optional[StrictBool], Field(description="Return the entire permission assignment details. By default this value is false, and only the IDs are returned.")] = None,
        permission_assignment_ids: Annotated[Optional[List[StrictStr]], Field(description="Permission assignment IDs (optional, default wildcard for all IDs user can access). It is an error to request a permission assignment by ID without having the required view permissions.")] = None,
        show_disabled: Annotated[Optional[StrictBool], Field(description="Specify to show disabled permission assignments. By default they are not shown on a wildcard query. This only has effect for a wildcard query.")] = None,
        filter_organisation_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the specified organisation scope.")] = None,
        filter_user_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the permission is assigned.")] = None,
        filter_role_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the user has a role. All users are allowed set this filter.")] = None,
        filter_group_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the user has a group.")] = None,
        filter_group_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter to only include permission assignments to whom the user has groups.")] = None,
        filter_client_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the client scope.")] = None,
        filter_case_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the case scope.")] = None,
        filter_user_scope_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with a scope for the user assigning the permission.")] = None,
        bookmark: Annotated[Optional[StrictStr], Field(description="Opaque pagination bookmark. Set to the empty string (or omit) to begin.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 500.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmGetPermissionAssignmentResponse]:
        """Get the permission assignment details.


        :param permission_assignment_details: Return the entire permission assignment details. By default this value is false, and only the IDs are returned.
        :type permission_assignment_details: bool
        :param permission_assignment_ids: Permission assignment IDs (optional, default wildcard for all IDs user can access). It is an error to request a permission assignment by ID without having the required view permissions.
        :type permission_assignment_ids: List[str]
        :param show_disabled: Specify to show disabled permission assignments. By default they are not shown on a wildcard query. This only has effect for a wildcard query.
        :type show_disabled: bool
        :param filter_organisation_id: Filter to only include permission assignments with the specified organisation scope.
        :type filter_organisation_id: str
        :param filter_user_id: Filter to only include permission assignments to whom the permission is assigned.
        :type filter_user_id: str
        :param filter_role_id: Filter to only include permission assignments to whom the user has a role. All users are allowed set this filter.
        :type filter_role_id: str
        :param filter_group_id: Filter to only include permission assignments to whom the user has a group.
        :type filter_group_id: str
        :param filter_group_ids: Filter to only include permission assignments to whom the user has groups.
        :type filter_group_ids: List[str]
        :param filter_client_id: Filter to only include permission assignments with the client scope.
        :type filter_client_id: str
        :param filter_case_id: Filter to only include permission assignments with the case scope.
        :type filter_case_id: str
        :param filter_user_scope_id: Filter to only include permission assignments with a scope for the user assigning the permission.
        :type filter_user_scope_id: str
        :param bookmark: Opaque pagination bookmark. Set to the empty string (or omit) to begin.
        :type bookmark: str
        :param page_size: Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 500.
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_permission_assignment_serialize(
            permission_assignment_details=permission_assignment_details,
            permission_assignment_ids=permission_assignment_ids,
            show_disabled=show_disabled,
            filter_organisation_id=filter_organisation_id,
            filter_user_id=filter_user_id,
            filter_role_id=filter_role_id,
            filter_group_id=filter_group_id,
            filter_group_ids=filter_group_ids,
            filter_client_id=filter_client_id,
            filter_case_id=filter_case_id,
            filter_user_scope_id=filter_user_scope_id,
            bookmark=bookmark,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmGetPermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_permission_assignment_without_preload_content(
        self,
        permission_assignment_details: Annotated[Optional[StrictBool], Field(description="Return the entire permission assignment details. By default this value is false, and only the IDs are returned.")] = None,
        permission_assignment_ids: Annotated[Optional[List[StrictStr]], Field(description="Permission assignment IDs (optional, default wildcard for all IDs user can access). It is an error to request a permission assignment by ID without having the required view permissions.")] = None,
        show_disabled: Annotated[Optional[StrictBool], Field(description="Specify to show disabled permission assignments. By default they are not shown on a wildcard query. This only has effect for a wildcard query.")] = None,
        filter_organisation_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the specified organisation scope.")] = None,
        filter_user_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the permission is assigned.")] = None,
        filter_role_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the user has a role. All users are allowed set this filter.")] = None,
        filter_group_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments to whom the user has a group.")] = None,
        filter_group_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter to only include permission assignments to whom the user has groups.")] = None,
        filter_client_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the client scope.")] = None,
        filter_case_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with the case scope.")] = None,
        filter_user_scope_id: Annotated[Optional[StrictStr], Field(description="Filter to only include permission assignments with a scope for the user assigning the permission.")] = None,
        bookmark: Annotated[Optional[StrictStr], Field(description="Opaque pagination bookmark. Set to the empty string (or omit) to begin.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 500.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the permission assignment details.


        :param permission_assignment_details: Return the entire permission assignment details. By default this value is false, and only the IDs are returned.
        :type permission_assignment_details: bool
        :param permission_assignment_ids: Permission assignment IDs (optional, default wildcard for all IDs user can access). It is an error to request a permission assignment by ID without having the required view permissions.
        :type permission_assignment_ids: List[str]
        :param show_disabled: Specify to show disabled permission assignments. By default they are not shown on a wildcard query. This only has effect for a wildcard query.
        :type show_disabled: bool
        :param filter_organisation_id: Filter to only include permission assignments with the specified organisation scope.
        :type filter_organisation_id: str
        :param filter_user_id: Filter to only include permission assignments to whom the permission is assigned.
        :type filter_user_id: str
        :param filter_role_id: Filter to only include permission assignments to whom the user has a role. All users are allowed set this filter.
        :type filter_role_id: str
        :param filter_group_id: Filter to only include permission assignments to whom the user has a group.
        :type filter_group_id: str
        :param filter_group_ids: Filter to only include permission assignments to whom the user has groups.
        :type filter_group_ids: List[str]
        :param filter_client_id: Filter to only include permission assignments with the client scope.
        :type filter_client_id: str
        :param filter_case_id: Filter to only include permission assignments with the case scope.
        :type filter_case_id: str
        :param filter_user_scope_id: Filter to only include permission assignments with a scope for the user assigning the permission.
        :type filter_user_scope_id: str
        :param bookmark: Opaque pagination bookmark. Set to the empty string (or omit) to begin.
        :type bookmark: str
        :param page_size: Specify a limit on the number of items returned in a page. Values that are too large will be rejected. All requests are subject to the page size, which is 100 if not specified and can be specified up to 500.
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_permission_assignment_serialize(
            permission_assignment_details=permission_assignment_details,
            permission_assignment_ids=permission_assignment_ids,
            show_disabled=show_disabled,
            filter_organisation_id=filter_organisation_id,
            filter_user_id=filter_user_id,
            filter_role_id=filter_role_id,
            filter_group_id=filter_group_id,
            filter_group_ids=filter_group_ids,
            filter_client_id=filter_client_id,
            filter_case_id=filter_case_id,
            filter_user_scope_id=filter_user_scope_id,
            bookmark=bookmark,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmGetPermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_permission_assignment_serialize(
        self,
        permission_assignment_details,
        permission_assignment_ids,
        show_disabled,
        filter_organisation_id,
        filter_user_id,
        filter_role_id,
        filter_group_id,
        filter_group_ids,
        filter_client_id,
        filter_case_id,
        filter_user_scope_id,
        bookmark,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'permission_assignment_ids': 'multi',
            'filter_group_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if permission_assignment_details is not None:
            
            _query_params.append(('permission_assignment_details', permission_assignment_details))
            
        if permission_assignment_ids is not None:
            
            _query_params.append(('permission_assignment_ids', permission_assignment_ids))
            
        if show_disabled is not None:
            
            _query_params.append(('show_disabled', show_disabled))
            
        if filter_organisation_id is not None:
            
            _query_params.append(('filter_organisation_id', filter_organisation_id))
            
        if filter_user_id is not None:
            
            _query_params.append(('filter_user_id', filter_user_id))
            
        if filter_role_id is not None:
            
            _query_params.append(('filter_role_id', filter_role_id))
            
        if filter_group_id is not None:
            
            _query_params.append(('filter_group_id', filter_group_id))
            
        if filter_group_ids is not None:
            
            _query_params.append(('filter_group_ids', filter_group_ids))
            
        if filter_client_id is not None:
            
            _query_params.append(('filter_client_id', filter_client_id))
            
        if filter_case_id is not None:
            
            _query_params.append(('filter_case_id', filter_case_id))
            
        if filter_user_scope_id is not None:
            
            _query_params.append(('filter_user_scope_id', filter_user_scope_id))
            
        if bookmark is not None:
            
            _query_params.append(('bookmark', bookmark))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/acre/permission_assignment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replace_permission_assignment(
        self,
        permission_assignment_permission_assignment_id: Annotated[StrictStr, Field(description="ID of the permission assignment.")],
        permission_assignment: Annotated[CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired, Field(description="Complete details of the permission assignment to be replaced. Currently, only the disabled field can be set (and it must be set). Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmReplacePermissionAssignmentResponse:
        """Replace (PUT) a permission assignment.


        :param permission_assignment_permission_assignment_id: ID of the permission assignment. (required)
        :type permission_assignment_permission_assignment_id: str
        :param permission_assignment: Complete details of the permission assignment to be replaced. Currently, only the disabled field can be set (and it must be set). Required. (required)
        :type permission_assignment: CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_permission_assignment_serialize(
            permission_assignment_permission_assignment_id=permission_assignment_permission_assignment_id,
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmReplacePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replace_permission_assignment_with_http_info(
        self,
        permission_assignment_permission_assignment_id: Annotated[StrictStr, Field(description="ID of the permission assignment.")],
        permission_assignment: Annotated[CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired, Field(description="Complete details of the permission assignment to be replaced. Currently, only the disabled field can be set (and it must be set). Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmReplacePermissionAssignmentResponse]:
        """Replace (PUT) a permission assignment.


        :param permission_assignment_permission_assignment_id: ID of the permission assignment. (required)
        :type permission_assignment_permission_assignment_id: str
        :param permission_assignment: Complete details of the permission assignment to be replaced. Currently, only the disabled field can be set (and it must be set). Required. (required)
        :type permission_assignment: CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_permission_assignment_serialize(
            permission_assignment_permission_assignment_id=permission_assignment_permission_assignment_id,
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmReplacePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replace_permission_assignment_without_preload_content(
        self,
        permission_assignment_permission_assignment_id: Annotated[StrictStr, Field(description="ID of the permission assignment.")],
        permission_assignment: Annotated[CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired, Field(description="Complete details of the permission assignment to be replaced. Currently, only the disabled field can be set (and it must be set). Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Replace (PUT) a permission assignment.


        :param permission_assignment_permission_assignment_id: ID of the permission assignment. (required)
        :type permission_assignment_permission_assignment_id: str
        :param permission_assignment: Complete details of the permission assignment to be replaced. Currently, only the disabled field can be set (and it must be set). Required. (required)
        :type permission_assignment: CompleteDetailsOfThePermissionAssignmentToBeReplacedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_permission_assignment_serialize(
            permission_assignment_permission_assignment_id=permission_assignment_permission_assignment_id,
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmReplacePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replace_permission_assignment_serialize(
        self,
        permission_assignment_permission_assignment_id,
        permission_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if permission_assignment_permission_assignment_id is not None:
            _path_params['permission_assignment.permission_assignment_id'] = permission_assignment_permission_assignment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if permission_assignment is not None:
            _body_params = permission_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v1/acre/permission_assignment/{permission_assignment.permission_assignment_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resolve_permission(
        self,
        body: Annotated[CdmResolvePermissionRequest, Field(description="Resolve a permission, ie. check if the user has the listed permissions for the specific scopes.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmResolvePermissionResponse:
        """Check permissions with the given scopes.


        :param body: Resolve a permission, ie. check if the user has the listed permissions for the specific scopes. (required)
        :type body: CdmResolvePermissionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resolve_permission_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmResolvePermissionResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resolve_permission_with_http_info(
        self,
        body: Annotated[CdmResolvePermissionRequest, Field(description="Resolve a permission, ie. check if the user has the listed permissions for the specific scopes.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmResolvePermissionResponse]:
        """Check permissions with the given scopes.


        :param body: Resolve a permission, ie. check if the user has the listed permissions for the specific scopes. (required)
        :type body: CdmResolvePermissionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resolve_permission_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmResolvePermissionResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resolve_permission_without_preload_content(
        self,
        body: Annotated[CdmResolvePermissionRequest, Field(description="Resolve a permission, ie. check if the user has the listed permissions for the specific scopes.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Check permissions with the given scopes.


        :param body: Resolve a permission, ie. check if the user has the listed permissions for the specific scopes. (required)
        :type body: CdmResolvePermissionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resolve_permission_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmResolvePermissionResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resolve_permission_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/acre/resolve_permission',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_permission_assignment(
        self,
        permission_assignment_permission_assignment_id: Annotated[StrictStr, Field(description="ID of the permission assignment.")],
        permission_assignment: Annotated[PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired, Field(description="Partial details of the permission assignment to be patched. Currently, only the disabled field can be set (and it must be set). Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmUpdatePermissionAssignmentResponse:
        """Update (PATCH) a permission assignment. Note that this endpoint must be defined before /v1/acre/permission_assignment/bulk, otherwise requests to /v1/acre/permission_assignment/bulk will be handled as if `bulk` is permission_assignment_id


        :param permission_assignment_permission_assignment_id: ID of the permission assignment. (required)
        :type permission_assignment_permission_assignment_id: str
        :param permission_assignment: Partial details of the permission assignment to be patched. Currently, only the disabled field can be set (and it must be set). Required. (required)
        :type permission_assignment: PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_permission_assignment_serialize(
            permission_assignment_permission_assignment_id=permission_assignment_permission_assignment_id,
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmUpdatePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_permission_assignment_with_http_info(
        self,
        permission_assignment_permission_assignment_id: Annotated[StrictStr, Field(description="ID of the permission assignment.")],
        permission_assignment: Annotated[PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired, Field(description="Partial details of the permission assignment to be patched. Currently, only the disabled field can be set (and it must be set). Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmUpdatePermissionAssignmentResponse]:
        """Update (PATCH) a permission assignment. Note that this endpoint must be defined before /v1/acre/permission_assignment/bulk, otherwise requests to /v1/acre/permission_assignment/bulk will be handled as if `bulk` is permission_assignment_id


        :param permission_assignment_permission_assignment_id: ID of the permission assignment. (required)
        :type permission_assignment_permission_assignment_id: str
        :param permission_assignment: Partial details of the permission assignment to be patched. Currently, only the disabled field can be set (and it must be set). Required. (required)
        :type permission_assignment: PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_permission_assignment_serialize(
            permission_assignment_permission_assignment_id=permission_assignment_permission_assignment_id,
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmUpdatePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_permission_assignment_without_preload_content(
        self,
        permission_assignment_permission_assignment_id: Annotated[StrictStr, Field(description="ID of the permission assignment.")],
        permission_assignment: Annotated[PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired, Field(description="Partial details of the permission assignment to be patched. Currently, only the disabled field can be set (and it must be set). Required.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update (PATCH) a permission assignment. Note that this endpoint must be defined before /v1/acre/permission_assignment/bulk, otherwise requests to /v1/acre/permission_assignment/bulk will be handled as if `bulk` is permission_assignment_id


        :param permission_assignment_permission_assignment_id: ID of the permission assignment. (required)
        :type permission_assignment_permission_assignment_id: str
        :param permission_assignment: Partial details of the permission assignment to be patched. Currently, only the disabled field can be set (and it must be set). Required. (required)
        :type permission_assignment: PartialDetailsOfThePermissionAssignmentToBePatchedCurrentlyOnlyTheDisabledFieldCanBeSetAndItMustBeSetRequired
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_permission_assignment_serialize(
            permission_assignment_permission_assignment_id=permission_assignment_permission_assignment_id,
            permission_assignment=permission_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmUpdatePermissionAssignmentResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_permission_assignment_serialize(
        self,
        permission_assignment_permission_assignment_id,
        permission_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if permission_assignment_permission_assignment_id is not None:
            _path_params['permission_assignment.permission_assignment_id'] = permission_assignment_permission_assignment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if permission_assignment is not None:
            _body_params = permission_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/v1/acre/permission_assignment/{permission_assignment.permission_assignment_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_permission_assignments(
        self,
        body: Annotated[CdmUpdatePermissionAssignmentsRequest, Field(description="Update multiple permission assignments. If one fails the call, none will be applied.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CdmUpdatePermissionAssignmentsResponse:
        """Update (PATCH) permission assignments. If one fails the call, none will be applied.


        :param body: Update multiple permission assignments. If one fails the call, none will be applied. (required)
        :type body: CdmUpdatePermissionAssignmentsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_permission_assignments_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmUpdatePermissionAssignmentsResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_permission_assignments_with_http_info(
        self,
        body: Annotated[CdmUpdatePermissionAssignmentsRequest, Field(description="Update multiple permission assignments. If one fails the call, none will be applied.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CdmUpdatePermissionAssignmentsResponse]:
        """Update (PATCH) permission assignments. If one fails the call, none will be applied.


        :param body: Update multiple permission assignments. If one fails the call, none will be applied. (required)
        :type body: CdmUpdatePermissionAssignmentsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_permission_assignments_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmUpdatePermissionAssignmentsResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_permission_assignments_without_preload_content(
        self,
        body: Annotated[CdmUpdatePermissionAssignmentsRequest, Field(description="Update multiple permission assignments. If one fails the call, none will be applied.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update (PATCH) permission assignments. If one fails the call, none will be applied.


        :param body: Update multiple permission assignments. If one fails the call, none will be applied. (required)
        :type body: CdmUpdatePermissionAssignmentsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_permission_assignments_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CdmUpdatePermissionAssignmentsResponse",
            '400': "V1ExceptionResponse",
            '401': "V1ExceptionResponse",
            '403': "V1ExceptionResponse",
            '404': "V1ExceptionResponse",
            '405': "str",
            '500': "V1ExceptionResponse",
            '503': "V1ExceptionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_permission_assignments_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/v1/acre/permission_assignment/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


