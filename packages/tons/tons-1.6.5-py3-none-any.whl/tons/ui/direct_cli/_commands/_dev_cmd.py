import importlib.util
import os
import sys

import click
from appdirs import user_config_dir

from tons.tonclient import ton_exceptions_handler
from tons.tonclient.utils import RecordDoesNotExistError, KeyStoreInvalidPasswordError
from tons.tonsdk.contract.wallet import SendModeEnum, Wallets, WalletVersionEnum, InternalMessage
from tons.tonsdk.utils import Address, TonCurrencyEnum
from ._base_cmd import cli
from .._utils import CustomClickException, click_ton_exception_handler, \
    click_echo_success, with_keystore, with_whitelist
from ..._utils import SharedObject, get_wallet_from_record_ctx


# TODO: optimize code, this part was developed fast

@cli.group()
def dev():
    """
    Development tools
    """


@dev.command(context_settings=dict(
    ignore_unknown_options=True,
))
@ton_exceptions_handler(click_ton_exception_handler)
@with_keystore(sensitive_data=True)
@click.argument('python_script_path', required=True, type=click.Path(exists=True))
@click.argument('method_to_call', required=True)
@click.argument('from_wallet', required=True)
@click.argument('amount', required=False, metavar='TON_COINS_NUM')
@click.option('--wait', '-w', is_flag=True, help='Wait until transaction is committed', default=False)
@click.option('--pay-gas-separately', default="y", type=click.Choice(["y", "n"]), show_default=True)
@click.option('--ignore-errors', default="n", type=click.Choice(["y", "n"]), show_default=True,
              help='Bounce back if error occurs.')
@click.option('--destroy-if-zero', default="n", type=click.Choice(["y", "n"]), show_default=True)
@click.option('--transfer-all', default="n", type=click.Choice(["y", "n"]), show_default=True)
@click.argument('custom_args', nargs=-1, type=click.UNPROCESSED)
@click.pass_obj
def send_internal(shared_object: SharedObject, from_wallet, python_script_path, method_to_call, amount,
                  wait, pay_gas_separately, ignore_errors, destroy_if_zero, transfer_all,
                  custom_args):
    """
    Generate internal message by METHOD_TO_CALL from PYTHON_SCRIPT_PATH
    and send it by selected FROM_WALLET wallet
    """
    if amount is None and not transfer_all:
        raise CustomClickException(
            "You must specify amount when you do not use --transfer-all flag.")

    try:
        record = shared_object.keystore.get_record_by_name(
            from_wallet, raise_none=True)
        wallet = get_wallet_from_record_ctx(shared_object, record)
    except (RecordDoesNotExistError,
            KeyStoreInvalidPasswordError) as e:
        raise CustomClickException(repr(e))

    send_mode = 0
    if ignore_errors == "y":
        send_mode |= SendModeEnum.ignore_errors
    if pay_gas_separately == "y":
        send_mode |= SendModeEnum.pay_gas_separately
    if destroy_if_zero == "y":
        send_mode |= SendModeEnum.destroy_account_if_zero
    if transfer_all == "y":
        send_mode |= SendModeEnum.carry_all_remaining_balance

    spec = importlib.util.spec_from_file_location("module.name", python_script_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["module.name"] = module
    spec.loader.exec_module(module)
    addr, state_init, body = getattr(module, method_to_call)(wallet, custom_args)

    messages = [InternalMessage(
        to_addr=Address(addr),
        amount=amount,
        currency=TonCurrencyEnum.ton,
        body=body,
        state_init=state_init,
    )]

    _, result = shared_object.ton_client.transfer(wallet, messages, wait)
    click_echo_success(
        f"Internal message generated by {method_to_call} was sent to address {addr}. Result: {result}")


@dev.command(context_settings=dict(
    ignore_unknown_options=True,
))
@ton_exceptions_handler(click_ton_exception_handler)
@click.argument('python_script_path', required=True, type=click.Path(exists=True))
@click.argument('method_to_call', required=True)
@click.option('--wait', '-w', is_flag=True, help='Wait until transaction is committed', default=False)
@click.argument('custom_args', nargs=-1, type=click.UNPROCESSED)
@click.pass_obj
def send_external(shared_object: SharedObject, python_script_path, method_to_call, wait, custom_args):
    """
    Generate external message by METHOD_TO_CALL from PYTHON_SCRIPT_PATH and send it as an external message
    """
    spec = importlib.util.spec_from_file_location("module.name", python_script_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["module.name"] = module
    spec.loader.exec_module(module)
    dest, message_cell = getattr(module, method_to_call)(custom_args)
    result = shared_object.ton_client.send_boc(message_cell.to_boc(False), wait)

    click_echo_success(
        f"External message generated by {method_to_call} was sent to address {dest}. Result: {result}")


@dev.command()
@ton_exceptions_handler(click_ton_exception_handler)
@click.argument('boc_file', required=True, type=click.Path(exists=True))
@click.option('--wait', '-w', is_flag=True, help='Wait until transaction is committed', default=False)
@click.pass_obj
def send_boc(shared_object: SharedObject, boc_file: str, wait: bool):
    """
    Send boc from the binary BOC_FILE
    """
    with open(boc_file, "rb") as f:
        result = shared_object.ton_client.send_boc(f.read(), wait)

    click_echo_success(f"{result}")


@dev.command(context_settings=dict(
    ignore_unknown_options=True,
))
@ton_exceptions_handler(click_ton_exception_handler)
@with_keystore(sensitive_data=True)
@click.argument('python_script_path', required=True, type=click.Path(exists=True))
@click.argument('method_to_call', required=True)
@click.argument('custom_args', nargs=-1, type=click.UNPROCESSED)
@click.pass_obj
def pass_forward(shared_object: SharedObject, python_script_path, method_to_call, custom_args):
    """
    Pass shared_object and all provided arguments to the python_script_path.method_to_call script
    """
    spec = importlib.util.spec_from_file_location("module.name", python_script_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["module.name"] = module
    spec.loader.exec_module(module)
    getattr(module, method_to_call)(shared_object, custom_args)


@dev.command()
@with_keystore(sensitive_data=True)
@click.argument('name', required=True)
@click.option('--yes', '-y', 'is_sure', is_flag=True, help='Do not show the prompt')
@click.pass_obj
def replace_toncli_wallet(shared_object: SharedObject, name, is_sure: bool):
    """
    Replace standard toncli wallet
    """
    wallet_build_path = os.path.join(user_config_dir("toncli"), "wallet", "build")

    if not is_sure:
        click.confirm(
            f'This command will replace .pk and .addr files inside {wallet_build_path} directory. '
            f'Do you want to proceed?',
            abort=True)

    try:
        record = shared_object.keystore.get_record_by_name(
            name, raise_none=True)
        secret = shared_object.keystore.get_secret(record)
    except (RecordDoesNotExistError, KeyStoreInvalidPasswordError, OSError) as e:
        raise CustomClickException(repr(e))

    if record.subwallet_id != 0 or record.version != WalletVersionEnum.v3r2:
        raise CustomClickException(f"Wallet '{name}' can not be used because "
                                   f"toncli uses subwallet_id == 0 and wallet version == v3r2.")

    wallet_pk = os.path.join(wallet_build_path, "contract.pk")
    wallet_addr = os.path.join(wallet_build_path, "contract.addr")
    wallet_contract_addr = os.path.join(wallet_build_path, "contract_address")
    addr = record.address.to_buffer()
    pk = secret.private_key[:32]

    record_addr = Address(record.address)
    with open(wallet_contract_addr, "w") as f:
        f.write(f"{record_addr.to_string(False, False, False)} "
                f"{record_addr.to_string(True, False, True)} "
                f"{record_addr.to_string(True, False, False)} ")

    with open(wallet_pk, "wb") as f:
        f.write(pk)

    with open(wallet_addr, "wb") as f:
        f.write(addr)

    click_echo_success("Wallet has been replaced.")


@dev.command()
@ton_exceptions_handler(click_ton_exception_handler)
@with_whitelist
@with_keystore(sensitive_data=True)
@click.argument('name', required=True)
@click.argument('filepath', required=True)
@click.pass_obj
def generate_state_init(shared_object: SharedObject, name: str, filepath: str):
    """
    Write state init boc to a specific file
    """
    try:
        record = shared_object.keystore.get_record_by_name(name, raise_none=True)
    except RecordDoesNotExistError as e:
        raise CustomClickException(repr(e))

    try:
        wallet, _secret = shared_object.keystore.get_wallet_from_record(record)
    except KeyStoreInvalidPasswordError as e:
        raise CustomClickException(repr(e))
    if os.path.exists(filepath):
        raise CustomClickException("File already exists!")

    with open(filepath, "wb") as f:
        f.write(wallet.create_state_init()["state_init"].to_boc(True))

    click_echo_success(f"Successfully wrote state_init to {filepath}")
