import time
from enum import Enum
from typing import List, Optional, Union

from gql import gql
from graphql import DocumentNode
from graphql_query import Query, Operation, Field, Argument

from tons import settings
from tons.tonsdk.utils import Address
from .._base import NftItemType


class DAppGqlBase(Query):
    filter: Optional['Filter'] = None

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.filter is None:
            self.filter = Filter()
        self.arguments.append(self.filter)


class DAppGqlQuery(DAppGqlBase):
    @property
    def query_text(self) -> str:
        return Operation(type='query', queries=[self]).render()

    def gql(self) -> DocumentNode:
        return gql(self.query_text)


class DAppGqlIdOrderedQuery(DAppGqlQuery):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        if 'id' not in self.fields:
            self.fields.insert(0, 'id')
        self.arguments.append(OrderById())
        self.arguments.append(Limit())

    def add_pagination(self, prev_last_id: Optional[str]):
        self.filter.add(Comparison.id_gt(prev_last_id), behavior='replace')


class Message(Field):
    def __init__(self, **kwargs):
        super().__init__(fields=[
            'msg_type_name',
            'src',  # account that sent the message
            'dst',  # same as account_addr
            'value'  # value attached to the message
        ], **kwargs)

    @classmethod
    def with_body(cls, **kwargs) -> 'Message':
        query = cls(**kwargs)
        query.fields.append('body')
        return query


class InMessage(Message):
    def __init__(self, **kwargs):
        super().__init__(name='in_message', **kwargs)


class OutMessages(Message):
    def __init__(self, **kwargs):
        super().__init__(name='out_messages', **kwargs)


class Transactions(DAppGqlIdOrderedQuery):
    """
    Sample transactions query:

    query {
      transactions(
        filter: {
          id: {
            eq: "092dbac60cefa2a7d01ac19704a5a66de85e916c26d436cd13073c20743c1885"
          }
        }
      ) {
        id
        tr_type
        tr_type_name
        aborted # if the transaction was executed successfully
        block_id
        account_addr
        balance_delta # how balance of account_addr has changed after transaction
        total_fees # transaction fees
        workchain_id
        lt # transaction logical time
        prev_trans_lt
        now # block time that contains transaction. transaction execution time
        outmsg_cnt # number of external messages, generated by the transaction
        orig_status_name
        end_status_name
        in_msg # message that produced the transaction
        in_message {
          msg_type_name
          src # account that sent the message
          dst # same as account_addr
          value # value attached to the message
        }
        out_msgs
        out_messages {
          msg_type_name
          src # account that sent the message
          dst # same as account_addr
          value # value attached to the message
        }
      }
    }
    """
    def __init__(self, **kwargs):
        super().__init__(name='transactions',
                         fields=[
                             'id',
                             'tr_type',
                             'tr_type_name',
                             'aborted',  # if the transaction was executed successfully
                             'block_id',
                             'account_addr',
                             'balance_delta',  # how balance of account_addr has changed after transaction
                             'total_fees',  # transaction fees
                             'workchain_id',
                             'lt',  # transaction logical time
                             'prev_trans_lt',
                             'now',  # block time that contains transaction. transaction execution time
                             'outmsg_cnt',  # number of external messages, generated by the transaction
                             'orig_status_name',
                             'end_status_name',
                             'in_msg',  # message that produced the transaction
                             InMessage.with_body(),
                             'out_msgs',
                             OutMessages.with_body()
                         ],
                         **kwargs)

    @classmethod
    def by_id(cls, transaction_id: str) -> 'Transactions':
        query = cls()
        query.filter.add(Comparison.id(transaction_id))
        return query

    @classmethod
    def by_in_msg(cls, in_msg_hash: str) -> 'Transactions':
        query = cls()
        query.filter.add(Comparison.basic('in_msg', 'eq', quote_unquote(in_msg_hash)))
        return query


class Info(Query):
    """
    Sample query:

    query {
      info {
        time
        blocksLatency
        messagesLatency
        transactionsLatency
        latency
        lastBlockTime
      }
    }
    """
    def __init__(self, **kwargs):
        super().__init__(name='info', fields=['time', 'blocksLatency', 'messagesLatency', 'transactionsLatency',
                                              'latency', 'lastBlockTime'], **kwargs)

    @property
    def query_text(self) -> str:  # TODO DRY
        return Operation(type='query', queries=[self]).render()

    def gql(self) -> DocumentNode:  # TODO DRY
        return gql(self.query_text)


class Blocks(DAppGqlQuery):
    """
    Sample query:

    query {
      blocks(
        filter: { workchain_id: { eq: -1 } }
        orderBy: { path: "gen_utime", direction: DESC }
        limit: 1
      ) {
        id
        workchain_id
        shard
        seq_no
        gen_utime
      }
    }
    """
    def __init__(self, **kwargs):
        super().__init__(name='blocks', fields=['id', 'workchain_id', 'shard', 'seq_no', 'gen_utime'], **kwargs)

    @classmethod
    def latest_masterchain_block(cls) -> 'Blocks':
        query = cls()
        query.filter.add(Comparison.basic('workchain_id', 'eq', -1))
        query.arguments.append(Argument(name='orderBy',
                                        value=[Argument(name='path', value='"gen_utime"'),
                                               Argument(name='direction', value='DESC')]
                                       )
                              )
        query.arguments.append(Argument(name='limit', value=1))
        return query


class Price(Query):
    def __init__(self, **kwargs):
        super().__init__(name='price', fields=[Field(name='usd')], **kwargs)

    @property
    def query_text(self) -> str:
        return Operation(type='query', queries=[self]).render()

    def gql(self) -> DocumentNode:
        return gql(self.query_text)


class Accounts(DAppGqlIdOrderedQuery):
    """
    Sample accounts query:

    query {
      accounts(
        filter: {
          id: {
            in: ["%address1", "%address2"]
          }
        }
        orderBy: {
          path: "id"
          direction: ASC
        }
        limit: 50
      ) {
        id
        address
        acc_type_name
        state_hash
        last_paid
        balance
        last_trans_lt
        code
        code_hash
        data
      }
    }
    """

    def __init__(self, **kwargs):
        super().__init__(name='accounts', fields=Account().fields, **kwargs)

    @classmethod
    def by_ids(cls, ids: List[str], **kwargs) -> 'Accounts':
        query = cls(**kwargs)
        query.filter.add(Comparison.id_in(ids))
        return query

    def add_pagination(self, prev_last_id: Optional[str]):
        raise NotImplementedError('Pagination should not be used for "accounts" query')


class NftItems(DAppGqlIdOrderedQuery):
    """
    Sample nft_items query:

    query {
      nft_items(
        filter: {
          collection_address: {
            eq: "EQDjPtM6QusgMgWfl9kMcG-EALslbTITnKcH8VZK1pnH3UZA"
          }
          dns_domain: {
            ne: null
          }
          owner_address: {
            in: ["%address1", "%address2"]
          }
        }
        orderBy: {
          path: "id"
          direction: ASC
        }
        limit: 50
      ) {
        id
        nft_item_type
        owner_address
        account {
          id
          address
          acc_type_name
          state_hash
          last_paid
          balance
          last_trans_lt
        }
        dns_domain
        dns_last_fill_up_time
        dns_auction {
          auction_end_time
          max_bid_amount
          max_bid_address
        }
      }
    }
    """

    def __init__(self, **kwargs):
        super().__init__(name='nft_items',
                         fields=['nft_item_type',
                                 'owner_address',
                                 Account(include_code=False, include_data=False, include_code_hash=False)],
                         **kwargs)

    @classmethod
    def DNS(cls, dns_collection_address: str, **kwargs) -> 'NftItems':
        query = cls(**kwargs)
        query.fields.append('dns_domain')
        query.fields.append('dns_last_fill_up_time')
        query.fields.append(DNSAuction())
        query.filter.add(Comparison.collection_address(dns_collection_address))
        query.filter.add(Comparison.dns_domain_available(), behavior='ignore')
        return query

    def add_dns_pagination(self, prev_last_id: Optional[str]):
        if prev_last_id is None:
            return

        super().add_pagination(prev_last_id)
        comparison = Comparison.basic('id', 'gt', quote_unquote(prev_last_id))
        try:
            existing_value = next(val for val in self.filter.value if val.name == 'OR')
        except StopIteration:
            pass
        else:
            try:
                existing_value = next(val for val in existing_value.value if val.name == 'id')
            except StopIteration:
                existing_value.value.append(comparison)
            else:
                existing_value.value = comparison.value


class JettonWallets(DAppGqlIdOrderedQuery):
    """
    Sample jetton_wallets query:

    query {
      jetton_wallets(
        filter: {
          owner_address: {
            in: ["%address1", "%address2", "%address3"]
          }
        }
        orderBy: {
          path: "id"
          direction: ASC
        }
        limit: 50
      ) {
        id
        balance
        owner_address
        jetton_master_address
        jetton_wallet_code_hash
        last_trans_lt
        account {
          id
          address
          acc_type_name
          state_hash
          last_paid
          balance
          last_trans_lt
        }
      }
    }
    """

    def __init__(self, **kwargs):
        super().__init__(name='jetton_wallets',
                         fields=['balance',
                                 'owner_address',
                                 'jetton_master_address',
                                 'jetton_wallet_code_hash',
                                 'last_trans_lt',
                                 Account(include_code=False, include_data=False, include_code_hash=False)],
                         **kwargs)


class JettonMinters(DAppGqlIdOrderedQuery):
    """
    Sample jetton_minters query:

    query {
      jetton_minters(
        filter: {
          address: {
            in: ["0:7e33c39e10eeb9463bdd031f14f5774916e135a79ebdf4ed53ca345e0ae9d809"]
          }
        }
        orderBy: {
          path: "id"
          direction: ASC
        }
        limit: 50
      ) {
        id
        jetton_wallet_code_hash
        admin_address
        last_trans_lt
        account {
          id
          address
          acc_type_name
          state_hash
          last_paid
          balance
          last_trans_lt
        }
        content {
          content_type
          content_type_name
          data {
            key
            value
          }
          uri
        }
      }
    }
    """

    def __init__(self, **kwargs):
        super().__init__(name='jetton_minters',
                         fields=['jetton_wallet_code_hash',
                                 'admin_address',
                                 'last_trans_lt',
                                 Account(include_code=False, include_data=False, include_code_hash=False),
                                 Field(name='content', fields=['content_type',
                                                               'content_type_name',
                                                               Field(name='data', fields=['key', 'value']),
                                                               'uri'])],
                         **kwargs)


# ======================================================================================================================
class DAppGqlSubscription(DAppGqlBase):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def gql(self) -> DocumentNode:
        query_text = Operation(type='subscription', queries=[self]).render()
        return gql(query_text)


class TransactionSubscription(DAppGqlSubscription):
    def __init__(self, **kwargs):
        super().__init__(name='transactions', fields=[
            'id',
            'lt',
            'block_id',
            'in_msg',
            'now',
            'credit_first',
            'aborted'])


# ======================================================================================================================


class Account(Field):
    def __init__(self, include_code: bool = True, include_data: bool = True, include_code_hash: bool = True, **kwargs):
        fields = ['id',
                  'address',
                  'acc_type_name',
                  'state_hash',
                  'last_paid',
                  'balance',
                  'contract_type',
                  'last_trans_lt']

        if include_code:
            fields.append('code')
        if include_data:
            fields.append('data')
        if include_code_hash:
            fields.append('code_hash')
        super().__init__(name='account', fields=fields, **kwargs)


class DNSAuction(Field):
    def __init__(self, **kwargs):
        fields = ['auction_end_time', 'max_bid_amount', 'max_bid_address']
        super().__init__(name='dns_auction', fields=fields, **kwargs)


# ======================================================================================================================


class Comparison(Argument):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    @classmethod
    def basic(cls, field: str, comparison_operator: str, value):
        return cls(name=field, value=Argument(name=comparison_operator, value=value))

    @classmethod
    def id_gt(cls, last_id: Optional[str]) -> Optional['Comparison']:
        if last_id is None:
            return
        return cls.basic('id', 'gt', quote_unquote(last_id))

    @classmethod
    def id_in(cls, ids: List[str]) -> 'Comparison':
        return cls.basic('id', 'in', quote_unquote(ids))

    @classmethod
    def id(cls, id_: str) -> 'Comparison':
        return cls.basic('id', 'eq', quote_unquote(id_))

    @classmethod
    def address(cls, address: Union[Address, str]) -> 'Comparison':
        return cls.basic('address', 'eq', quote_unquote(Address.raw_id(address)))

    @classmethod
    def address_in(cls, addresses: List[Union[Address, str]]) -> 'Comparison':
        return cls.basic('address', 'in', quote_unquote(raw_ids(addresses)))

    @classmethod
    def owner_address(cls, address: Union[Address, str]) -> 'Comparison':
        return cls.basic('owner_address', 'eq', quote_unquote(Address.raw_id(address)))

    @classmethod
    def owner_address_in(cls, addresses: List[Union[Address, str]]) -> 'Comparison':
        return cls.basic('owner_address', 'in', quote_unquote(raw_ids(addresses)))

    @classmethod
    def nft_item_type_in(cls, nft_item_types: List['NftItemType']) -> 'Comparison':
        return cls.basic('nft_item_type', 'in', [str(int(item_id)) for item_id in nft_item_types])

    @classmethod
    def collection_address(cls, collection_address: str) -> 'Comparison':
        return cls.basic('collection_address', 'eq', quote_unquote(collection_address))

    @classmethod
    def dns_domain(cls, dns_domain: str):
        return cls.basic('dns_domain', 'eq', quote_unquote(dns_domain))

    @classmethod
    def jetton_master_address(cls, jetton_minter_address: Union[Address, str]):
        return cls.basic('jetton_master_address', 'eq', quote_unquote(Address.raw_id(jetton_minter_address)))

    @classmethod
    def dns_domain_available(cls):
        return cls.basic('dns_domain', 'ne', 'null')

    @classmethod
    def dns_max_bidder_in(cls, bidder_address_in: List[Union[Address, str]]) -> 'Comparison':
        return cls(name='dns_auction',
                   value=cls.basic('max_bid_address', 'in', quote_unquote(raw_ids(bidder_address_in))))

    @classmethod
    def dns_auction_finished(cls):
        current_time = int(time.time())
        return cls(name='dns_auction', value=Argument(name='auction_end_time',
                                                      value=[Argument(name='le', value=f'"{current_time}"'),
                                                             Argument(name='ne', value="null")]
                                                      )
                   )

    @classmethod
    def or_dns(cls, bidder_address_in: List[Union[Address, str]],
               time_: int, dns_collection_address: str) -> 'Comparison':
        return cls(name='OR',
                   value=[
                       Argument(name='dns_auction',
                                value=[
                                    cls.basic('max_bid_address', 'in',
                                              quote_unquote(raw_ids(bidder_address_in))),
                                    Argument(name='auction_end_time',
                                             value=[Argument(name='le', value=f'"{time_}"'),
                                                    Argument(name='ne', value="null")]
                                             ),
                                ]
                                ),
                       Comparison.collection_address(dns_collection_address),
                       Comparison.dns_domain_available()
                   ]
                   )


class Filter(Argument):
    def __init__(self, comparison_list: Optional[List[Comparison]] = None, **kwargs):
        if comparison_list is None:
            comparison_list = []
        super().__init__(name='filter', value=comparison_list, **kwargs)

    class AddBehavior(str, Enum):
        extend = 'extend'
        replace = 'replace'
        ignore = 'ignore'
        raise_error = 'raise_error'

    def add(self, comparison: Optional[Comparison], behavior: Union[str, AddBehavior] = 'extend'):
        """
        :param comparison: Comparison to add
        :param behavior:
            extend | replace | ignore | raise_error - What happens if same comparison already exists
        """
        behavior = Filter.AddBehavior(behavior)
        if not comparison:
            return
        try:
            existing_value = next(val for val in self.value if val.name == comparison.name)
        except StopIteration:
            self.value.append(comparison)
        else:
            if behavior == 'extend':
                if isinstance(existing_value.value, list):
                    existing_value.value.append(comparison.value)
                else:
                    existing_value.value = [existing_value.value, comparison.value]
            elif behavior == 'replace':
                existing_value.value = comparison.value
            elif behavior == 'ignore':
                pass
            elif behavior == 'raise_error':
                raise ValueError("Comparison '{}' already exists".format(comparison.name))


class OrderById(Argument):
    def __init__(self, direction: str = 'ASC', **kwargs):
        super().__init__(name='orderBy', value=[Argument(name='path', value='"id"'),
                                                Argument(name='direction', value=direction)], **kwargs)


class Limit(Argument):
    def __init__(self, value=settings.DAPP_RECORDS_LIMIT, **kwargs):
        super().__init__(name='limit', value=value, **kwargs)


def quote_unquote(value: Union[str, List[str]]) -> Union[str, List[str]]:
    if isinstance(value, str):
        return '"' + value + '"'
    return [quote_unquote(v) for v in value]


def raw_ids(addresses: List[Union[Address, str]]) -> List[str]:
    return [Address.raw_id(address) for address in addresses]
