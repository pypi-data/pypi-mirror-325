# Trosnoth (UberTweak Platform Game)
# Copyright (C) Joshua D Bartlett
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

import logging
import random

import simplejson

from trosnoth.const import MAX_EMOTE
from trosnoth.messages import EmoteRequestMsg
from trosnoth.messages.base import AgentRequest, ServerCommand, ClientCommand
from trosnoth.utils.utils import timeNow

log = logging.getLogger()


class PlayerHasMacGuffin(ServerCommand):
    idString = b'mguf'
    fields = 'player_id', 'macguffin_id'
    packspec = 'cB'

    def applyOrderToWorld(self, world):
        player = world.getPlayer(self.player_id)
        world.macguffin_manager.received_transfer_message(player, self.macguffin_id)


class PlayerHasTrosballMsg(ServerCommand):
    idString = b'ball'
    fields = 'playerId'
    packspec = 'c'

    def applyOrderToWorld(self, world):
        player = world.getPlayer(self.playerId)
        world.trosballManager.gotPlayerHasTrosballMsg(player)

    def applyOrderToLocalState(self, localState, world):
        localState.revertTrosball()


class TrosballPositionMsg(ServerCommand):
    idString = b'bing'
    fields = 'xpos', 'ypos', 'xvel', 'yvel', 'inNet'
    packspec = 'ffff?'
    inNet = False

    def applyOrderToWorld(self, world):
        world.trosballManager.gotTrosballPositionMsg(
            (self.xpos, self.ypos), (self.xvel, self.yvel), self.inNet)

    def applyOrderToLocalState(self, localState, world):
        if localState.localTrosball:
            if localState.localTrosball.realShotStarted:
                localState.revertTrosball()
            else:
                localState.matchTrosball()


class ThrowTrosballMsg(AgentRequest):
    idString = b'pass'
    fields = ()
    packspec = ''
    is_tick_action = True

    def clientValidate(self, localState, world, sendResponse):
        if not localState.player:
            return False
        return localState.player.hasTrosball()

    def applyRequestToLocalState(self, localState):
        localState.trosballThrown()

    def serverApply(self, game, agent):
        if agent.player and agent.player.hasTrosball():
            game.world.trosballManager.throwTrosball()


class AchievementUnlockedMsg(ServerCommand):
    idString = b'Achm'
    fields = 'playerId', 'achievementId'
    packspec = 'c*'


class UpdateClockStateMsg(ServerCommand):
    idString = b'clok'
    fields = 'showing', 'counting', 'upwards', 'value', 'flashBelow'
    packspec = 'bbbff'

    def applyOrderToWorld(self, world):
        if world.isServer:
            # These messages are generated by World.clock.propagateToClients,
            # based off the existing state of the clock, so we don't need to
            #  set it again on the server.
            return
        world.clock.value = self.value
        world.clock.flashBelow = self.flashBelow
        world.clock.setMode(
            showing=self.showing,
            counting=self.counting,
            upwards=self.upwards,
        )


class PlaySoundMsg(ServerCommand):
    idString = b'noyz'
    fields = 'filename'
    packspec = '*'


class UpdateGameInfoMsg(ServerCommand):
    idString = b'info'
    fields = 'info'
    packspec = '*'

    @classmethod
    def build(cls, title, info, botGoal):
        return cls(simplejson.dumps([title, info, botGoal]).encode('utf-8'))

    def applyOrderToLocalState(self, localState, world):
        (
            localState.userTitle,
            localState.userInfo,
            localState.botGoal,
        ) = simplejson.loads(self.info.decode('utf-8'))
        localState.onGameInfoChanged()


class UpdateScoreBoardModeMsg(ServerCommand):
    idString = b'xorz'
    fields = 'teamScoresEnabled', 'playerScoresEnabled'
    packspec = 'bb'

    def applyOrderToWorld(self, world):
        world.scoreboard.gotUpdateScoreBoardModeMsg(
            self.teamScoresEnabled,
            self.playerScoresEnabled,
        )


class SetTeamAbilitiesMsg(ServerCommand):
    idString = b'tAbl'
    fields = 'teamId', 'data'
    packspec = 'c*'

    def applyOrderToWorld(self, world):
        world.getTeam(self.teamId).abilities.applyMessage(self.data)


class SetTeamScoreMsg(ServerCommand):
    idString = b'tXor'
    fields = 'teamId', 'score'
    packspec = 'cf'

    def applyOrderToWorld(self, world):
        team = world.getTeam(self.teamId)
        if team:
            world.scoreboard.gotTeamScoreMsg(team, self.score)


class SetPlayerAbilitiesMsg(ServerCommand):
    idString = b'pAbl'
    fields = 'playerId', 'data'
    packspec = 'c*'

    def applyOrderToWorld(self, world):
        world.getPlayer(self.playerId).abilities.applyMessage(self.data)


class SetPlayerScoreMsg(ServerCommand):
    idString = b'pXor'
    fields = 'playerId', 'score'
    packspec = 'cf'

    def applyOrderToWorld(self, world):
        player = world.getPlayer(self.playerId)
        if player:
            world.scoreboard.gotPlayerScoreMsg(player, self.score)


class PauseOrResumeMsg(ServerCommand):
    idString = b'paws'
    fields = 'paused',
    packspec = 'b'
    isControl = True

    def applyOrderToWorld(self, world):
        was_paused = world.paused
        world.paused = self.paused
        if was_paused != self.paused:
            world.on_pause_state_changed()


class SetUIOptionsMsg(ServerCommand):
    idString = b'uiOp'
    fields = 'data'
    packspec = '*'
    isControl = False

    def applyOrderToWorld(self, world):
        world.uiOptions.applyMessage(self.data)


class AcknowledgeGameOverMsg(AgentRequest):
    idString = b'done'
    fields = 'emote_id',
    packspec = 'B'
    is_tick_action = True

    def clientValidate(self, local_state, world, send_response):
        return self.is_valid(local_state.player, world)

    def is_valid(self, player, world):
        if player is None or player.resyncing:
            return False
        if player.has_won() is None:
            return False
        return True

    def serverApply(self, game, agent):
        if agent.player is None or agent.player.resyncing:
            return False

        if not self.is_valid(agent.player, game.world):
            agent.player.sendResync(reason='Invalid game over acknowledgement')
            return

        emote_id = min(self.emote_id, MAX_EMOTE) if agent.player.has_won() else -1
        game.sendServerCommand(RespondToGameEndMsg(agent.player.id, emote_id))

    def applyRequestToLocalState(self, local_state):
        if not local_state.player.allDead and local_state.player.has_won():
            local_state.player.doEmote(self.emote_id, 500)


class RespondToGameEndMsg(ServerCommand):
    idString = b'BOOM'
    fields = 'player_id', 'emote_id'
    packspec = 'cb'

    def applyOrderToWorld(self, world):
        player = world.getPlayer(self.player_id)
        if not player.allDead:
            if self.emote_id >= 0:
                player.doEmote(self.emote_id, 500)
            else:
                world.bomber_exploded(player)


class SetWorldAbilitiesMsg(ServerCommand):
    idString = b'able'
    fields = 'data'
    packspec = '*'

    def applyOrderToWorld(self, world):
        world.abilities.gotSetWorldAbilitiesMsg(
            simplejson.loads(self.data.decode('utf-8')))


class PingMsg(ClientCommand):
    idString = b'ping'
    fields = 'data'
    packspec = '*'
    isControl = True

    def applyRequestToLocalState(self, localState):
        localState.pings[self.data] = timeNow()

    def serverApply(self, game, agent):
        agent.messageToAgent(self)

    def applyOrderToLocalState(self, localState, world):
        now = timeNow()
        try:
            sendTime = localState.pings.pop(self.data)
        except KeyError:
            return
        localState.gotPingTime(now - sendTime)


class SlowPingMsg(ClientCommand):
    '''
    Like a ping, but goes through any delays and smoothing due to recent
    network spikes.
    '''
    idString = b'piin'
    fields = 'data'
    packspec = '*'
    is_tick_action = True

    def applyRequestToLocalState(self, localState):
        localState.slow_pings[self.data] = timeNow()

    def serverApply(self, game, agent):
        agent.messageToAgent(self)

    def applyOrderToLocalState(self, localState, world):
        now = timeNow()
        try:
            sendTime = localState.slow_pings.pop(self.data)
        except KeyError:
            return
        localState.got_slow_ping(now - sendTime)


class ScenarioCompleteMsg(ServerCommand):
    '''
    Sent when a scenario is complete and the client should show a
    scoreboard and perhaps disconnect.
    '''
    idString = b'done'
    fields = 'data'
    packspec = '*'

    def applyOrderToWorld(self, world):
        from trosnoth.levels.base import LevelResult
        world.set_result(LevelResult.rebuild(world, self.data))

    def applyOrderToLocalState(self, local_state, world):
        if local_state.player:
            emote_id = random.randrange(MAX_EMOTE + 1)
            local_state.agent.sendRequest(AcknowledgeGameOverMsg(emote_id))
