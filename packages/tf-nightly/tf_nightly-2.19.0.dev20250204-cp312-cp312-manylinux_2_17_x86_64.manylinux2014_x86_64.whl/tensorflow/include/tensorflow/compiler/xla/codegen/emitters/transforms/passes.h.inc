/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_EXPANDFLOATOPSPASS
#define GEN_PASS_DECL_FLATTENTENSORSPASS
#define GEN_PASS_DECL_LOWERTENSORSPASS
#define GEN_PASS_DECL_LOWERTOLLVMPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ExpandFloatOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDFLOATOPSPASS
#undef GEN_PASS_DECL_EXPANDFLOATOPSPASS
#endif // GEN_PASS_DECL_EXPANDFLOATOPSPASS
#ifdef GEN_PASS_DEF_EXPANDFLOATOPSPASS
namespace impl {

template <typename DerivedT>
class ExpandFloatOpsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExpandFloatOpsPassBase;

  ExpandFloatOpsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandFloatOpsPassBase(const ExpandFloatOpsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExpandFloatOpsPassBase& operator=(const ExpandFloatOpsPassBase &) = delete;
  ExpandFloatOpsPassBase(ExpandFloatOpsPassBase &&) = delete;
  ExpandFloatOpsPassBase& operator=(ExpandFloatOpsPassBase &&) = delete;
  ~ExpandFloatOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-expand-float-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-expand-float-ops"; }

  ::llvm::StringRef getDescription() const override { return "Expands float ops that are not natively supported."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandFloatOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandFloatOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandFloatOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXPANDFLOATOPSPASS
#endif // GEN_PASS_DEF_EXPANDFLOATOPSPASS

//===----------------------------------------------------------------------===//
// FlattenTensorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FLATTENTENSORSPASS
#undef GEN_PASS_DECL_FLATTENTENSORSPASS
#endif // GEN_PASS_DECL_FLATTENTENSORSPASS
#ifdef GEN_PASS_DEF_FLATTENTENSORSPASS
namespace impl {

template <typename DerivedT>
class FlattenTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = FlattenTensorsPassBase;

  FlattenTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenTensorsPassBase(const FlattenTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  FlattenTensorsPassBase& operator=(const FlattenTensorsPassBase &) = delete;
  FlattenTensorsPassBase(FlattenTensorsPassBase &&) = delete;
  FlattenTensorsPassBase& operator=(FlattenTensorsPassBase &&) = delete;
  ~FlattenTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-flatten-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-flatten-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Flatten tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "FlattenTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenTensorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FLATTENTENSORSPASS
#endif // GEN_PASS_DEF_FLATTENTENSORSPASS

//===----------------------------------------------------------------------===//
// LowerTensorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERTENSORSPASS
struct LowerTensorsPassOptions {
  std::string gpu_device_info_;
  std::string target_type_ = "gpu";
};
#undef GEN_PASS_DECL_LOWERTENSORSPASS
#endif // GEN_PASS_DECL_LOWERTENSORSPASS
#ifdef GEN_PASS_DEF_LOWERTENSORSPASS
namespace impl {

template <typename DerivedT>
class LowerTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerTensorsPassBase;

  LowerTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerTensorsPassBase(const LowerTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerTensorsPassBase& operator=(const LowerTensorsPassBase &) = delete;
  LowerTensorsPassBase(LowerTensorsPassBase &&) = delete;
  LowerTensorsPassBase& operator=(LowerTensorsPassBase &&) = delete;
  ~LowerTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lower-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lower-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Lowers tensors to llvm pointers and loads/stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerTensorsPassBase<DerivedT>)

  LowerTensorsPassBase(LowerTensorsPassOptions options) : LowerTensorsPassBase() {
    gpu_device_info_ = std::move(options.gpu_device_info_);
    target_type_ = std::move(options.target_type_);
  }
protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc("Serialized stream_executor::GPUDeviceInfo proto.")};
  ::mlir::Pass::Option<std::string> target_type_{*this, "target_type", ::llvm::cl::desc("Whether the pass targets a 'cpu' or 'gpu'. If 'cpu', gpu_device_info_ must be empty."), ::llvm::cl::init("gpu")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERTENSORSPASS
#endif // GEN_PASS_DEF_LOWERTENSORSPASS

//===----------------------------------------------------------------------===//
// LowerToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERTOLLVMPASS
struct LowerToLLVMPassOptions {
  std::string gpu_device_info_;
  std::string target_type_ = "gpu";
};
#undef GEN_PASS_DECL_LOWERTOLLVMPASS
#endif // GEN_PASS_DECL_LOWERTOLLVMPASS
#ifdef GEN_PASS_DEF_LOWERTOLLVMPASS
namespace impl {

template <typename DerivedT>
class LowerToLLVMPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerToLLVMPassBase;

  LowerToLLVMPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerToLLVMPassBase(const LowerToLLVMPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerToLLVMPassBase& operator=(const LowerToLLVMPassBase &) = delete;
  LowerToLLVMPassBase(LowerToLLVMPassBase &&) = delete;
  LowerToLLVMPassBase& operator=(LowerToLLVMPassBase &&) = delete;
  ~LowerToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lower-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lower-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerToLLVMPassBase<DerivedT>)

  LowerToLLVMPassBase(LowerToLLVMPassOptions options) : LowerToLLVMPassBase() {
    gpu_device_info_ = std::move(options.gpu_device_info_);
    target_type_ = std::move(options.target_type_);
  }
protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc("Serialized stream_executor::GPUDeviceInfo proto.")};
  ::mlir::Pass::Option<std::string> target_type_{*this, "target_type", ::llvm::cl::desc("Whether the pass targets a 'cpu' or 'gpu'. If 'cpu', gpu_device_info_ must be empty."), ::llvm::cl::init("gpu")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERTOLLVMPASS
#endif // GEN_PASS_DEF_LOWERTOLLVMPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ExpandFloatOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandFloatOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExpandFloatOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandFloatOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExpandFloatOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// FlattenTensorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFlattenTensorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFlattenTensorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFlattenTensorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFlattenTensorsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerTensorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerTensorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerTensorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerTensorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerTensorsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// Transforms Registration
//===----------------------------------------------------------------------===//

inline void registerTransformsPasses() {
  registerExpandFloatOpsPass();
  registerFlattenTensorsPass();
  registerLowerTensorsPass();
  registerLowerToLLVMPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ExpandFloatOpsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExpandFloatOpsPassBase;

  ExpandFloatOpsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandFloatOpsPassBase(const ExpandFloatOpsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExpandFloatOpsPassBase& operator=(const ExpandFloatOpsPassBase &) = delete;
  ExpandFloatOpsPassBase(ExpandFloatOpsPassBase &&) = delete;
  ExpandFloatOpsPassBase& operator=(ExpandFloatOpsPassBase &&) = delete;
  ~ExpandFloatOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-expand-float-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-expand-float-ops"; }

  ::llvm::StringRef getDescription() const override { return "Expands float ops that are not natively supported."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandFloatOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandFloatOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandFloatOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FlattenTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = FlattenTensorsPassBase;

  FlattenTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenTensorsPassBase(const FlattenTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  FlattenTensorsPassBase& operator=(const FlattenTensorsPassBase &) = delete;
  FlattenTensorsPassBase(FlattenTensorsPassBase &&) = delete;
  FlattenTensorsPassBase& operator=(FlattenTensorsPassBase &&) = delete;
  ~FlattenTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-flatten-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-flatten-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Flatten tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "FlattenTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenTensorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerTensorsPassBase;

  LowerTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerTensorsPassBase(const LowerTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerTensorsPassBase& operator=(const LowerTensorsPassBase &) = delete;
  LowerTensorsPassBase(LowerTensorsPassBase &&) = delete;
  LowerTensorsPassBase& operator=(LowerTensorsPassBase &&) = delete;
  ~LowerTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lower-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lower-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Lowers tensors to llvm pointers and loads/stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerTensorsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc("Serialized stream_executor::GPUDeviceInfo proto.")};
  ::mlir::Pass::Option<std::string> target_type_{*this, "target_type", ::llvm::cl::desc("Whether the pass targets a 'cpu' or 'gpu'. If 'cpu', gpu_device_info_ must be empty."), ::llvm::cl::init("gpu")};
};

template <typename DerivedT>
class LowerToLLVMPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerToLLVMPassBase;

  LowerToLLVMPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerToLLVMPassBase(const LowerToLLVMPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerToLLVMPassBase& operator=(const LowerToLLVMPassBase &) = delete;
  LowerToLLVMPassBase(LowerToLLVMPassBase &&) = delete;
  LowerToLLVMPassBase& operator=(LowerToLLVMPassBase &&) = delete;
  ~LowerToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lower-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lower-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc("Serialized stream_executor::GPUDeviceInfo proto.")};
  ::mlir::Pass::Option<std::string> target_type_{*this, "target_type", ::llvm::cl::desc("Whether the pass targets a 'cpu' or 'gpu'. If 'cpu', gpu_device_info_ must be empty."), ::llvm::cl::init("gpu")};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
