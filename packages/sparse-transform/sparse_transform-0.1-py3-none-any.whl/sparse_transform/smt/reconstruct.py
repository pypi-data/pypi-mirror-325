'''
Methods for the reconstruction engine; specifically, to:

1. carry out singleton detection
2. get the cardinalities of all bins in a subsampling group (debugging only).
'''

import numpy as np


def singleton_detection_noiseless(U_slice, **kwargs):
    '''
    Finds the true index of a singleton, or the best-approximation singleton of a multiton.
    
    Arguments
    ---------
    U_slice : numpy.ndarray, (P,).
    The WHT component of a subsampled bin, with element i corresponding to delay i.
    
    Returns
    -------
    k : numpy.ndarray
    Index of the corresponding right node, in binary form.
    '''
    tol = 1e-8
    y = U_slice[1:] / U_slice[0]
    # are the values of y all close to 0 or 1
    is_singleton = (np.min(np.vstack((np.abs(y - 1), np.abs(y))), 0) < tol).all()
    k_hat = 1 - y.round() if is_singleton else np.zeros_like(y)
    return k_hat, is_singleton

def singleton_detection_closest(U_slice, **kwargs):
    '''
    Finds the true index of a singleton, or the best-approximation singleton of a multiton.

    Arguments
    ---------
    U_slice : numpy.ndarray, (P,).
    The WHT component of a subsampled bin, with element i corresponding to delay i.

    Returns
    -------
    k : numpy.ndarray
    Index of the corresponding right node, in binary form.
    '''
    return (1 - (U_slice[1:]/U_slice[0] > 0.5)).astype(int), True  # Assumes success

def singleton_detection_coded(k, **kwargs):
    '''
    Finds the true index of a singleton, or the best-approximation singleton of a multiton.
    Assumes the Delays matrix is generated by a code, and the syndrome decoder is passed to it.

    Arguments
    ---------
    U_slice : numpy.ndarray, (P,).
    The WHT component of a subsampled bin, with element i corresponding to delay i.

    Returns
    -------
    k : numpy.ndarray
    Index of the corresponding right node, in binary form.
    '''
    decoder = kwargs.get('source_decoder')
    dec, success = decoder(k[np.newaxis, :].astype(bool).T)
    return dec, success


def singleton_detection_mle(U_slice, **kwargs):
    '''
    Finds the true index of a singleton, or the best-approximation singleton of a multiton, in the presence of noise.
    Uses MLE: looks at the residuals created by peeling off each possible singleton.
    
    Arguments
    ---------
    U_slice : numpy.ndarray, (P,).
    The WHT component of a subsampled bin, with element i corresponding to delay i.

    selection : numpy.ndarray.
    The decimal preimage of the bin index, i.e. the list of potential singletons whose signature under M could be the j of the bin.

    S_slice : numpy.ndarray
    The set of signatures under the delays matrix D associated with each of the elements of 'selection'.

    n : int
    The signal's number of bits.

    Returns
    -------
    k : numpy.ndarray, (n,)
    The index of the singleton.

    '''
    selection, S_slice, q, n = kwargs.get("selection"), kwargs.get("S_slice"), kwargs.get("q"), kwargs.get("source_parity")
    P = S_slice.shape[0]
    alphas = 1/P * np.dot(np.conjugate(S_slice).T, U_slice)
    residuals = np.linalg.norm(U_slice - (alphas * S_slice).T, ord=2, axis=1)
    k_sel = np.argmin(residuals)
    return selection[k_sel], S_slice[:, k_sel]




def singleton_detection(U_slice, method_source="identity", method_channel="identity", **kwargs):
    """
    Recovers the index value k of a singleton.
    Parameters
    ----------
    U_slice : np.array
    The relevant subsampled fourier transform to be considered

    method_source
    method of reconstruction for source coding: "identity" - default setting, should be used unless you know that all
                                                indicies have low hamming weight
                                                "coded" - Currently only supports prime q, if you know the max hamming
                                                weight of less than t this option should be used and will greatly reduce
                                                complexity. Note a source_decoder object must also be passed

    method_channel
    Method of reconstruction for channel coding: "mle" - exact MLE computation. Fine for small problems but not
                                                         recommended it is exponential in n
                                                 "nso" - symbol-wise recovery suitable when a repetition type code is used
                                                 "identity" - no channel coding, only use when there is no noise

    Returns
    -------
    Value of the computed singleton index k
    """
    # Split detection into two phases, channel and source decoding

    k, decode_success = {
        "identity": singleton_detection_noiseless,
        "nso": singleton_detection_closest
    }.get(method_channel)(U_slice, **kwargs)
    if method_source != "identity":
        k, decode_success = {
            "coded": singleton_detection_coded
        }.get(method_source)(k, **kwargs)
    return k, decode_success

