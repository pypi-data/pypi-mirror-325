# Utils

## Autoscore

[Autoscore]((../utils/autoscore.py)) is a program which automatically scores Fish 8.1a 
and/or Choose 32.1 output files. The program takes in a directory with
Fish 8.1a and Choose 32.1 output files and outputs two summaries of the
data, one for the fish files, and the other for the choose files, as CSV
files.

### Usage

```
python autoscore.py <DATA PATH>
```

Where `<DATA PATH>` is the path to a directory containing Fish 8.1a and
Choose 32.1 output files in either their raw format (plain text) or as
excel files.

### How it works

#### Convert the files to CSV

The program first converts all the data files to CSV files. This is so the files can be
processed as if they were plain text files. It is necessary to do it in this manner since
the files generated by Fish 8.1a and Choose 32.1 can only be processed as plain text files
due to their format. Most of the time the files will be in a plain text format that can
be processed by the program, however it not a guaranteed as a handful of files may have been
converted to XLS or XLXS files somewhere along the way. Thus, this step is taken preemptively
to make sure all the files are in a plain text format before scoring.

The choice of converting them to CSV files instead of say a TXT file,
is because the lab members tend to prefer to open these files using excel
for manual scoring. Hence, if they ever wanted to double check the scoring, 
they can open the files in excel and score them mannually for comparison. However
the files could be opened and read as if they were plain text files with no issues whatsoever.

#### Scoring functions

The program contains the functions that read and score Fish 8.1a and Choose 32.1 output
files. These functions (called `score_fish` and `score_choose`,
respectively) consist of rather convoluted processes of reading the files line by line
and using many conditionals to extract the relevant data. All the relevant data
is stored in a dictionary which is used to write a summary file containing
the scores for all the subjects with a file in the `DATA PATH`. The functions score one
file at a time, and keep adding rows to their corresponding summary file (one for Fish and 
one for Choose) until all the files are exhausted.

The scoring functions (`score_fish` and `score_choose`) can be modified or replaced by new functions with the same signature to score data files from different versions of the Fish 
and/or Choose experiments. The rest of the functionality of the program should work exactly
same.

## SubjectID to SeqID

[SubjectID to SeqID](../utils/subjectid_to_seqid.py) is a program that allows you to get a
subject's Sequential ID and REDCap repeat instance (A.K.A. visit number, instance number,
instance) based on their SubjectID and vice versa.

### Usage

```bash
python subjectid2seqid.py [-f <FILE PATH>]
```

In the command line, the program can be used in two modes: **file mode** and 
**interactive mode.**

#### File mode:

```bash
python subjectid2seqid.py -f <FILE PATH>
```

The file input for file mode is a text file with each line containing a SubjectID.
The output will be a CSV file named SeqIDs.csv in the same directory as the input file.

#### Interactive mode:

```bash
python subjectid2seqid.py 
```

In interactive mode you will be prompted to enter one or many subject IDs separated by spaces.
The output will be printed to the terminal.

### Using it as a module

[SubjectID to SeqID](../utils/subjectid_to_seqid.py) may also be imported as a module into
a different Python program. 

```python
from GluckLab.utils import subjectid_to_seqid
```

Then the functions one may want to use are the `get_seqid`, `get_instance_no`, and 
`get_subjectid`. Examples:

```python
# Getting SeqID and instance number from a SubjectID
subject_id = "AA001"
seqid = subjectid_to_seqid.get_seqid(subject_id)
instance_no = subjectid_to_seqid.get_instance_no(subject_id)

# Getting a SubjectID from a SeqID and instance number
seqid = "A001"
instance_no = 1
subject_id = subjectid_to_seqid.get_subjectid(seqid, instance_no)
```

This program and its functions become most useful when used in combination with Pandas
dataframes. In this way one may add the SeqIDs and/or visit number (instance number) to
an existing dataset that only has SubjectIDs and viceversa. Examples:

#### Example: Adding SeqID and Visit Number (Instance) to a dataframe

```python
import pandas as pd
from GluckLab.utils import subjectid_to_seqid as s2s

df = pd.read_csv("data.csv")

# Adding SeqIDs to dataframe
df["seqid"] = df["subjectid"].apply(s2s.get_seqid)

# Adding instance numbers to dataframe
df["redcap_repeat_instance"] = df["subjectid"].apply(s2s.get_instance_no) 

```

#### Example: Adding SubjectIDs to a dataframe

```python
import pandas as pd
from GluckLab.utils import subjectid_to_seqid as s2s

df = pd.read_csv("data.csv")

# Adding Subject Ids to dataframe

# First create an empty list
subjectids = []

# iterate over all the rows
for index, row in df.iterrows(): 
    # Append the generated subject id for this row to the list
    subject_ids.append(s2s.get_subjectid(row["seqid"], row["redcap_repeat_instance"]))

# Add the subjectids to the dataframe
df["subjectids"] = subjectids

```

### How it works

Our SubjectIDs are divided up into three categories: exercise participants, longitudinal
participants and new participants. Each of these categories has their own separate set of rules
for the format of the SubjectID and the translation between SubjectID and SeqID + Visit
Number. These rules are summarized in the following tables:

#### Exercise Participants

| SubjectID | SeqID | Visit Number (Instance) |
|---|---|---|
| AA### | A### | 1 |
| AA_R### | A### | 2 |
| AA_R###_L | A### | 3 |
| AA_3R###_L | A### | 4 |
| AA_4R###_L | A### | 5 |
| AA_5R###_L | A### | 6 |


#### Longitudinal Participants

| SubjectID | SeqID | Visit Number (Instance) |
|---|---|---|
| AAL_### | L### | 1 |
| AAL_R### | L### | 2 |
| AAL_3R### | L### | 3 |
| AAL_4R### | L### | 4 |
| AAL_5R### | L### | 5 |

#### New Participants

| SubjectID | SeqID | Visit Number (Instance) |
|---|---|---|
| COV### | C### | 1 |
| COV_R### | C### | 2 |
| COV_3R### | C### | 3 |


One may notice that the Subject ID format for each type of participant is a regular language, and
hence every valid Subject ID may be recognized with a regular expression. The program uses
regular expressions to validate and classify SubjectIDs into one of the three categories. 
The regular expressions as well as a validation method is encapsulated in the `SubjectID` 
class.

#### Getting the SeqID from a SubjectID

To get the SeqID from a valid SubjectID a regular expression method is used to search 
for the three digit group included in every SubjectID. Then the appropriate SeqID is returned
based on the category of participant the SubjectID falls into. This process is done through
the `get_seqid` function.

#### Getting the Instnce Number from a SubjectID

To get the visit number from a SujectID we made a separate function for each of the participant
categories. These functions simply consist of a series of conditionals examining the SubjectID
format to determine the appropriate visit number in accordance with the rules defined by the
tables above. A general function called `get_instance_no` takes a SubjectID and then calls the
appropriate specialized function for the type of participant the SubjectID represents. This
is the function intended for the user to use.

#### Getting the SubjectID from a SeqID and Instance Number

To get the SubjectID from a SeqID and instance number we extract the digits from the SeqID,
then based on the SeqID letter we enter into a different set of conditionals corresponding to
each participant type. Each of these series of conditionals simply check the instance number
and produces the appropriately formatted SubjectID using the extracted digits in accordance
to the rules defined in the tables above. This process is done through the `get_subjectid`
function.