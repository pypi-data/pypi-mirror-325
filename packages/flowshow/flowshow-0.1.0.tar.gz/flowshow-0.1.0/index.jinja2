<style>
.timeline-container {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    padding: 20px;
    position: relative;
    width: 100%;
    max-width: 1000px;
    margin: 0 auto;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.timeline-content {
    margin-left: 150px;
    position: relative;
    background: white;
    padding: 20px;
    border-radius: 6px;
    border: 1px solid #e9ecef;
}
.axis {
    position: relative;
    height: 30px;
    border-top: 1px solid #dee2e6;
    margin: 10px 20px 20px 0;
}
.tick {
    position: absolute;
    top: 0;
    transform: translateX(-50%);
    padding-top: 5px;
    border-left: 1px solid #dee2e6;
    font-size: 12px;
    color: #6c757d;
}
.bar {
    height: 20px;
    background-color: #4a9eff;
    position: absolute;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    opacity: 0.9;
}
.bar:hover {
    background-color: #2980b9;
    opacity: 1;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.bar.selected {
    outline: 2px solid #2c3e50;
    opacity: 1;
}
.task-info {
    margin-top: 20px;
    padding: 16px;
    border: 1px solid #e9ecef;
    border-radius: 6px;
    background-color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.task-info h3 {
    margin: 0 0 12px 0;
    color: #2c3e50;
    font-size: 18px;
}
.task-info p {
    margin: 8px 0;
    color: #495057;
    font-size: 14px;
}
.task-info .logs {
    font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
    background: #f8f9fa;
    padding: 12px;
    border-radius: 4px;
    white-space: pre-wrap;
    font-size: 13px;
    color: #495057;
    border: 1px solid #e9ecef;
    margin-top: 12px;
}
.task-row {
    height: 30px;
    position: relative;
    margin: 8px 0;
    display: flex;
    align-items: center;
}
.task-row.hidden {
    display: none;
}
.task-label {
    position: absolute;
    left: -150px;
    width: 140px;
    padding-right: 10px;
    text-align: left;
    line-height: 20px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #495057;
    font-size: 13px;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
}
.task-label:hover {
    color: #228be6;
}
.task-label.has-children::before {
    content: '';
    display: inline-block;
    width: 12px;
    height: 12px;
    margin-right: 4px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%23495057' d='M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
    background-size: contain;
    background-repeat: no-repeat;
    transition: transform 0.2s;
    transform: rotate(90deg);
}
.task-label.has-children.collapsed::before {
    transform: rotate(0deg);
}
.task-label:not(.has-children) {
    padding-left: 16px;
}
</style>
</head>
<body>
<div class="timeline-container">
<div class="timeline-content">
    <div id="timeline"></div>
    <div class="axis" id="axis"></div>
</div>
<div id="taskInfo" class="task-info" style="display: none;"></div>
</div>

<script>
const data = {{data}};

function flattenTasks(task, depth = 0, tasks = [], parentCollapsed = false) {
    // Debug: log the raw task name to see the exact characters
    console.log('Raw task name:', task.task_name, Array.from(task.task_name).map(c => c.charCodeAt(0)));
    
    // Clean up task name by removing anything before the actual name
    const cleanTaskName = task.task_name.split(/[\u0080-\uffff]/).pop().trim();
    console.log('Cleaned task name:', cleanTaskName);
    
    const cleanedTask = {
        ...task,
        task_name: cleanTaskName,
        depth: depth,
        hasChildren: !!(task.subtasks && task.subtasks.length),
        collapsed: false,
        hidden: parentCollapsed
    };
    
    tasks.push(cleanedTask);
    
    if (task.subtasks) {
        task.subtasks.forEach(subtask => {
            flattenTasks(subtask, depth + 1, tasks, parentCollapsed || cleanedTask.collapsed);
        });
    }
    return tasks;
}

function toggleChildren(taskIndex, tasks) {
    const task = tasks[taskIndex];
    task.collapsed = !task.collapsed;
    
    // Update visibility of children
    let depth = task.depth;
    for (let i = taskIndex + 1; i < tasks.length; i++) {
        if (tasks[i].depth <= depth) break;
        
        if (tasks[i].depth === depth + 1) {
            tasks[i].hidden = task.collapsed;
        } else {
            tasks[i].hidden = task.collapsed || tasks[i].hidden;
        }
    }
    
    // Redraw the timeline
    document.getElementById('timeline').innerHTML = '';
    renderTimeline(tasks);
}

function renderTimeline(tasks) {
    const timeline = document.getElementById('timeline');
    const startTime = new Date(data.start_time).getTime();
    const endTime = new Date(data.end_time).getTime();
    const duration = endTime - startTime;
    const width = 800;
    const margin = 10;

    tasks.forEach((task, index) => {
        if (task.hidden) return;
        
        const row = document.createElement('div');
        row.className = 'task-row';
        
        const label = document.createElement('div');
        label.className = 'task-label';
        if (task.hasChildren) {
            label.classList.add('has-children');
            if (task.collapsed) {
                label.classList.add('collapsed');
            }
        }
        label.textContent = task.task_name.replace(/[^\x20-\x7E]/g, '').trim();
        
        if (task.hasChildren) {
            label.addEventListener('click', () => toggleChildren(index, tasks));
        }
        
        const bar = document.createElement('div');
        bar.className = 'bar';
        const taskStart = new Date(task.start_time).getTime();
        const taskDuration = task.duration * 1000;
        const left = ((taskStart - startTime) / duration) * width + margin;
        const barWidth = (taskDuration / duration) * width;
        
        bar.style.left = `${left}px`;
        bar.style.width = `${barWidth}px`;
        
        bar.addEventListener('click', () => {
            document.querySelectorAll('.bar').forEach(b => b.classList.remove('selected'));
            bar.classList.add('selected');
        });
        
        bar.addEventListener('mouseenter', () => {
            showTaskInfo(task);
        });
        
        bar.addEventListener('mouseleave', () => {
            if (!document.querySelector('.bar.selected')) {
                document.getElementById('taskInfo').style.display = 'none';
            } else {
                const selectedBar = document.querySelector('.bar.selected');
                const selectedTask = tasks.find((t, i) => 
                    document.querySelectorAll('.bar')[i] === selectedBar
                );
                if (selectedTask) {
                    showTaskInfo(selectedTask);
                }
            }
        });
        
        row.appendChild(label);
        row.appendChild(bar);
        timeline.appendChild(row);
    });
}

function createAxis(startTime, endTime, width, margin) {
    const axis = document.getElementById('axis');
    const duration = endTime - startTime;
    const numTicks = 5;
    
    for (let i = 0; i <= numTicks; i++) {
        const tick = document.createElement('div');
        tick.className = 'tick';
        const time = new Date(startTime + (duration * i / numTicks));
        tick.style.left = `${(i / numTicks) * width + margin}px`;
        tick.textContent = time.toLocaleTimeString('en-US', {
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        axis.appendChild(tick);
    }
}

function createTimeline() {
    const tasks = flattenTasks(data);
    renderTimeline(tasks);
    createAxis(new Date(data.start_time).getTime(), new Date(data.end_time).getTime(), 800, 10);
}

function showTaskInfo(task) {
    const taskInfo = document.getElementById('taskInfo');
    taskInfo.style.display = 'block';
    
    const formatDuration = (duration) => `${(duration * 1000).toFixed(2)}ms`;
    const formatTime = (time) => new Date(time).toLocaleTimeString('en-US', {
        hour12: false,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3
    });

    taskInfo.innerHTML = `
        <h3>${task.task_name.replace(/[^\x20-\x7E]/g, '').trim()}</h3>
        <p><strong>Duration:</strong> ${formatDuration(task.duration)}</p>
        <p><strong>Start:</strong> ${formatTime(task.start_time)}</p>
        <p><strong>End:</strong> ${formatTime(task.end_time)}</p>
        ${task.inputs && Object.keys(task.inputs).length ? 
            `<p><strong>Inputs:</strong> ${JSON.stringify(task.inputs, null, 2)}</p>` : ''}
        ${task.logs ? `<div class="logs">${task.logs}</div>` : ''}
    `;
}

createTimeline();
</script>