import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import ScalarFormatter
import matplotlib.dates as mdates
import os
import shutil
import folium
import plotly.express as px
import plotly.io as pio
from pyproj import Transformer
from tqdm import tqdm
import plotly.graph_objects as go
import geopandas as gpd

def plot_hydrograms(obs_dir, sim_dir, scale, format_date='%d/%m/%Y', lang='EN'):
    """
    Function to plot water level hydrograms. 
    obs_dir: Directory to observation data. Format as John Doherty's Groundwater Utilities.
    sim_dir: Directory to simulated data generated by John Doherty's "mod2smp" utility.
    scale: Vertical scale (+- from mean values)
    format_date: Date format to build DataFrames. Default is '%d/%m/%Y'
    lang: Language. Can choose between EN and SP. Default is EN.
    """
    # Current working directory
    cwd = os.getcwd()
    
    # Directories for plots
    plot_dir = os.path.join(cwd, 'graphs')
    if not os.path.exists(plot_dir):
        os.makedirs(plot_dir)
    if os.path.exists(plot_dir):
        shutil.rmtree(plot_dir)
        os.makedirs(plot_dir)
        
    # Dataframes are loaded
    df_sim = pd.read_csv(sim_dir, sep=r'\s+', header=None)
    df_sim.columns=['well', 'date', 'time', 'water_level']
    df_sim['well'] = df_sim.well.str.upper()
    df_sim['date'] = pd.to_datetime(df_sim.date, format=format_date)

    df_obs = pd.read_csv(obs_dir, sep=r'\s+', header=None)
    df_obs.columns=['well', 'date', 'time', 'water_level']
    df_obs['well'] = df_obs.well.str.upper()
    df_obs['date'] = pd.to_datetime(df_obs.date, format=format_date)
    
    for well in df_obs.well.unique():
        # Hydrograms
        fig, axs = plt.subplots(1, figsize=(7,5))

        # Plot simulated and observed data
        if lang == 'EN':
            axs.scatter(df_obs.loc[df_obs.well == well]['date'], df_obs.loc[df_obs.well == well]['water_level'], label='Observed', color='black')
            axs.plot(df_sim.loc[df_sim.well == well]['date'], df_sim.loc[df_sim.well == well]['water_level'], label='Simulated')
            
            # Axis format
            axs.set_ylabel('Water Level (msnm)')
            axs.legend()
            axs.set_title(well)
            axs.xaxis.set_major_locator(mdates.YearLocator(1)) 
            axs.xaxis.set_tick_params(rotation=45)
            axs.yaxis.set_major_formatter(ScalarFormatter(useOffset=False))
        elif lang=='SP':
            axs.scatter(df_obs.loc[df_obs.well == well]['date'], df_obs.loc[df_obs.well == well]['water_level'], label='Observado', color='black')
            axs.plot(df_sim.loc[df_sim.well == well]['date'], df_sim.loc[df_sim.well == well]['water_level'], label='Simulado')
            
            # Axis format
            axs.set_ylabel('Nivel (msnm)')
            axs.legend()
            axs.set_title(well)
            axs.xaxis.set_major_locator(mdates.YearLocator(1)) 
            axs.xaxis.set_tick_params(rotation=45)
            axs.yaxis.set_major_formatter(ScalarFormatter(useOffset=False))

        # Vertical scale
        means = (df_obs.loc[df_obs.well == well]['water_level'].mean()+df_sim.loc[df_sim.well == well]['water_level'].mean())/2
        maxs = max(df_obs.loc[df_obs.well == well]['water_level'].max(), df_sim.loc[df_sim.well == well]['water_level'].max())
        mins = min(df_obs.loc[df_obs.well == well]['water_level'].min(), df_sim.loc[df_sim.well == well]['water_level'].min())
        maxs = means+maxs-mins
        mins = means-maxs+mins
        maxs = max(maxs, means+scale)
        mins = min(mins, means-scale)
        axs.set_ylim(mins, maxs)

        # Save plot
        plt.savefig(os.path.join(plot_dir, well+'.png'), dpi=300)
        plt.close()
        fig.clear()

def plot_fit(obs_dir, sim_dir_mod2obs, format_date='%d/%m/%Y', lang='EN'):
    """
    Function to plot simulated fit to observed data. 
    obs_dir: Directory to observation data. Format as John Doherty's Groundwater Utilities.
    sim_dir_mod2obs: Directory to simulated data generated by John Doherty's "mod2obs" utility.
    format_date: Date format to build DataFrames. Default is '%d/%m/%Y'
    lang: Language. Can choose between EN and SP. Default is EN.
    """
    # Current working directory
    cwd = os.getcwd()
    
    # Dataframes are generated
    df_mod2obs = pd.read_csv(sim_dir_mod2obs, sep=r'\s+', header=None)
    df_mod2obs.columns=['well', 'date', 'time', 'water_level']
    df_mod2obs['well'] = df_mod2obs.well.str.upper()
    df_mod2obs['date'] = pd.to_datetime(df_mod2obs.date, format=format_date)

    df_obs = pd.read_csv(obs_dir, sep=r'\s+', header=None)
    df_obs.columns=['well', 'date', 'time', 'water_level']
    df_obs['well'] = df_obs.well.str.upper()
    df_obs['date'] = pd.to_datetime(df_obs.date, format='%d/%m/%Y')
    
    # Plot is generated
    fig, axs = plt.subplots(1, figsize=(7,7))

    # Plot 1:1 fit line
    maxs = max(df_obs['water_level'].max(), df_mod2obs['water_level'].max())
    mins = min(df_obs['water_level'].min(), df_mod2obs['water_level'].min())
    axs.plot([0,maxs], [0,maxs], color='red')

    # Plot model fit
    axs.scatter(df_obs['water_level'], df_mod2obs['water_level'], s=6)

    # Format axes and save figure
    if lang == 'EN':
        axs.set_xlabel('Observed (msnm)')
        axs.set_ylabel('Simulated (msnm)')
        axs.set_ylim(mins,maxs)
        axs.set_xlim(mins,maxs)

        plt.savefig(os.path.join(cwd, 'ajuste.png'), dpi=300)
    elif lang == 'SP':
        axs.set_xlabel('Nivel Observado (msnm)')
        axs.set_ylabel('Nivel Simulado (msnm)')
        axs.set_ylim(mins,maxs)
        axs.set_xlim(mins,maxs)

        plt.savefig(os.path.join(cwd, 'ajuste.png'), dpi=300)

def get_stats(obs_dir, sim_dir_mod2obs, format_date='%d/%m/%Y', lang='EN'):
    """
    Function to generate table with fit statistics. 
    obs_dir: Directory to observation data. Format as John Doherty's Groundwater Utilities.
    sim_dir_mod2obs: Directory to simulated data generated by John Doherty's "mod2obs" utility.
    format_date: Date format to build DataFrames. Default is '%d/%m/%Y'
    lang: Language. Can choose between EN and SP. Default is EN.
    """
    # Current working directory
    cwd = os.getcwd()
    
    # Dataframes are generated
    df_mod2obs = pd.read_csv(sim_dir_mod2obs, sep=r'\s+', header=None)
    df_mod2obs.columns=['well', 'date', 'time', 'water_level']
    df_mod2obs['well'] = df_mod2obs.well.str.upper()
    df_mod2obs['date'] = pd.to_datetime(df_mod2obs.date, format=format_date)

    df_obs = pd.read_csv(obs_dir, sep=r'\s+', header=None)
    df_obs.columns=['well', 'date', 'time', 'water_level']
    df_obs['well'] = df_obs.well.str.upper()
    df_obs['date'] = pd.to_datetime(df_obs.date, format='%d/%m/%Y')
    
    # Absolute and squared errors are calculated
    df_fit = df_mod2obs.copy()
    df_fit.rename({'water_level':'simulated'}, axis=1, inplace=True)
    df_fit['observed'] = df_obs['water_level']
    df_fit['r'] = np.abs(df_fit.simulated - df_fit.observed)
    df_fit['r2'] = df_fit.r**2
    
    # MAE and RMS are calculated
    mae = df_fit.r.sum()/len(df_fit)
    rms = np.sqrt(df_fit.r2.sum()/len(df_fit))
    
    # Observed range
    min_obs = df_fit.observed.min()
    max_obs = df_fit.observed.max()
    range_obs = max_obs-min_obs
    
    # KGE is calculated
    mean_sim = df_fit.simulated.mean()
    mean_obs = df_fit.observed.mean()
    std_sim = df_fit.simulated.std()
    std_obs = df_fit.observed.std()
    correlation = df_fit[['simulated', 'observed']].corr().iloc[0, 1]
    beta = mean_sim / mean_obs
    gamma = (std_sim / mean_sim) / (std_obs / mean_obs)
    kge = 1 - np.sqrt((correlation - 1)**2 + (beta - 1)**2 + (gamma - 1)**2)

    # Stats are generated as csv
    if lang=='EN':
        df = pd.DataFrame({'Parameter':['Total wells', 'Total points', 'Minimum observed (msnm)', 'Maximum observed (msnm)', 'Observed range Max - Min (m)', 'MAE (m)', 'NMAE (%)', 'RMS (m)', 'NRMS (%)', 'KGE'],
                    'Transient calibration':[len(df_fit.well.unique()),len(df_fit),min_obs,max_obs,range_obs,mae,100*mae/range_obs,rms,100*rms/range_obs, kge]})
        df.to_csv(os.path.join(cwd, 'stats.csv'), encoding='latin-1', index=False)
    elif lang=='SP':
        df = pd.DataFrame({'Parámetro':['Total pozos', 'Total datos', 'Mínimo Observado (msnm)', 'Máximo observado (msnm)', 'Rango de Observaciones Máx - Min (m)', 'MAE (m)', 'NMAE (%)', 'RMS (m)', 'NRMS (%)', 'KGE'],
                    'Calibración Transiente':[len(df_fit.well.unique()),len(df_fit),min_obs,max_obs,range_obs,mae,100*mae/range_obs,rms,100*rms/range_obs, kge]})
        df.to_csv(os.path.join(cwd, 'estadisticos.csv'), encoding='latin-1', index=False)

def mapped_hydrograms(obs_dir, sim_dir, EPSG, wells_dir, format_date='%d/%m/%Y', lang='EN', grid_dir=None):
    """
    Function to plot water level hydrograms on map. 
    obs_dir: Directory to observation data. Format as John Doherty's Groundwater Utilities.
    sim_dir: Directory to simulated data generated by John Doherty's "mod2smp" utility.
    EPSG: EPSG code to which all coordinated are referenced.
    wells_dir: Directory to table containing wells. Columns must be: "Well_Name" "X_Coordinate" "Y_Coordinate" "Model_Layer"
    scale: Vertical scale (+- from mean values)
    format_date: Date format to build DataFrames. Default is '%d/%m/%Y'
    lang: Language. Can choose between EN and SP. Default is EN.
    grid_dir: (Optional) Directory to model grid to plot on map. Shapefile format. Must be referenced to EPSG.
    """
    # Current working directory
    cwd = os.getcwd()
    
    # Dataframes are loaded
    df_sim = pd.read_csv(sim_dir, sep=r'\s+', header=None)
    df_sim.columns=['well', 'date', 'time', 'water_level']
    df_sim['well'] = df_sim.well.str.upper()
    df_sim['date'] = pd.to_datetime(df_sim.date, format=format_date)

    df_obs = pd.read_csv(obs_dir, sep=r'\s+', header=None)
    df_obs.columns=['well', 'date', 'time', 'water_level']
    df_obs['well'] = df_obs.well.str.upper()
    df_obs['date'] = pd.to_datetime(df_obs.date, format=format_date)

    # Read table with wells coordinates
    wells = pd.read_csv(wells_dir, sep='\t', header=None)
    wells.columns = ['well_name', 'x', 'y', 'model_layer']

    # Convert EPSG to WGS84
    transformer = Transformer.from_crs("EPSG:{}".format(EPSG), "EPSG:4326", always_xy=True)
    def convert_psad56_to_wgs84(easting, northing):
        lon, lat = transformer.transform(easting, northing)
        return lat, lon
    wells[['Lat', 'Lon']] = wells.apply(lambda row: convert_psad56_to_wgs84(row['x'], row['y']), axis=1, result_type='expand')

    # Create map centered con coordinates mean values
    m = folium.Map(location=[wells['Lat'].mean(), wells['Lon'].mean()], zoom_start=12, tiles=None)
    folium.TileLayer('Esri.WorldImagery').add_to(m)

    # Add grid map 
    if grid_dir:
        # Read grid file and convert to WGS84
        gdf = gpd.read_file(grid_dir)
        gdf.crs = EPSG
        gdf.to_crs(epsg=4326)
        
        # Add to map with folium
        folium.GeoJson(
            gdf.dissolve(),
            style_function=lambda x: {
                'color': 'black',       # Boundary color
                'weight': 2,            # Boundary thickness
                'fillColor': 'transparent'  # Transparent fill color
            }
        ).add_to(m)

    # Function to create hydrograms
    def hydrogram(df_sim, df_obs):
        # Scale: Default at 3. Can be modified on map
        means = (df_obs.nivel.mean()+df_sim.nivel.mean())/2
        maxs = max(df_obs.nivel.max(), df_sim.nivel.max())
        mins = min(df_obs.nivel.max(), df_sim.nivel.max())
        maxs = means+(maxs-mins)
        mins = means-(maxs-mins)
        maxs = max(maxs, means+3)
        mins = min(mins, means-3)
        
        fig = go.Figure()
        if lang == 'EN':
            fig.add_trace(go.Scatter(x=df_obs.date, y=df_obs.water_level, mode='markers', name='Observed'))
            fig.add_trace(go.Scatter(x=df_sim.date, y=df_sim.water_level, mode='lines', name='Simulated'))
            
            fig.update_layout(
                    title=f'Well {well}',
                    xaxis_title='Date',
                    yaxis_title='Water level (msnm)',
                    yaxis_range = [mins, maxs],
                )
            return pio.to_html(fig, full_html=False, include_plotlyjs='cdn')
            
        elif lang =='SP':
            fig.add_trace(go.Scatter(x=df_obs.date, y=df_obs.water_level, mode='markers', name='Observado'))
            fig.add_trace(go.Scatter(x=df_sim.date, y=df_sim.water_level, mode='lines', name='Simulado'))
        
            fig.update_layout(
                    title=f'Pozo {well}',
                    xaxis_title='Fecha',
                    yaxis_title='Nivel (msnm)',
                    yaxis_range = [mins, maxs],
                )
            return pio.to_html(fig, full_html=False, include_plotlyjs='cdn')

    # Add each well to map with plot on popup
    for _, row in tqdm(wells.iterrows(), total=len(wells)):
        well = row.well
        df_temp_sim = df_sim.loc[df_sim.well == well]
        df_temp_obs = df_obs.loc[df_obs.well == well]
        html_plot = hydrogram(df_temp_sim, df_temp_obs)
        iframe = folium.IFrame(html=html_plot, width=500, height=300)
        popup = folium.Popup(iframe, max_width=500)
        
        if lang == 'EN':
            folium.CircleMarker(
                location=[row['Lat'], row['Lon']],
                popup=popup,
                tooltip=f"Well {row['well']}",
                radius=3,               # Tamaño del punto
                color='black',          # Color del borde del punto
                fill=True,              # Relleno del punto
                fill_color='black',     # Color de relleno
                fill_opacity=1          # Opacidad del punto
            ).add_to(m)
            
        elif lang == 'SP':
            folium.CircleMarker(
                location=[row['Lat'], row['Lon']],
                popup=popup,
                tooltip=f"Pozo {row['well']}",
                radius=3,               # Tamaño del punto
                color='black',          # Color del borde del punto
                fill=True,              # Relleno del punto
                fill_color='black',     # Color de relleno
                fill_opacity=1          # Opacidad del punto
            ).add_to(m)
    if lang == 'EN':
        m.save('Mapped_Hydrograms.html')
    elif lang == 'SP':
        m.save('Mapa_Hidrogramas.html')