# autogenerated by ssc-gen DO NOT_EDIT
from __future__ import annotations
import re
from typing import List, TypedDict, Union

from parsel import Selector, SelectorList

T_MovieTranslationsPanel_ITEM = TypedDict(
    "T_MovieTranslationsPanel_ITEM",
    {
        "name": str,
        "value": str,
        "data_id": str,
        "data_translation_type": str,
        "data_media_hash": str,
        "data_media_type": str,
        "data_title": str,
    },
)
T_MovieTranslationsPanel = List[T_MovieTranslationsPanel_ITEM]
T_KodikAPIPayload = TypedDict(
    "T_KodikAPIPayload",
    {
        "d": str,
        "d_sign": str,
        "pd": str,
        "pd_sign": str,
        "ref": str,
        "ref_sign": str,
        "type": str,
        "hash": str,
        "id": str,
    },
)
T_KodikPage = TypedDict(
    "T_KodikPage",
    {
        "url_params": str,
        "api_payload": T_KodikAPIPayload,
        "player_js_path": str,
        "movie_translations": T_MovieTranslationsPanel,
    },
)
T_KodikApiPath = TypedDict("T_KodikApiPath", {"path": str})


class MovieTranslationsPanel:
    """Representation available dubbers and params. Useful for switch dubber

    [
        {
            "name": "String",
            "value": "String",
            "data_id": "String",
            "data_translation_type": "String",
            "data_media_hash": "String",
            "data_media_type": "String",
            "data_title": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: Selector) -> SelectorList:
        value1 = value.css(".movie-translations-box")
        value2 = value1.css("option")
        return value2

    def _parse_name(self, value: Selector) -> str:
        value1 = "".join(value.css("::text").getall())
        value2 = value1.strip(" ")
        return value2

    def _parse_value(self, value: Selector) -> str:
        value1 = value.attrib["value"]
        return value1

    def _parse_data_id(self, value: Selector) -> str:
        value1 = value.attrib["data-id"]
        return value1

    def _parse_data_translation_type(self, value: Selector) -> str:
        value1 = value.attrib["data-translation-type"]
        return value1

    def _parse_data_media_hash(self, value: Selector) -> str:
        value1 = value.attrib["data-media-hash"]
        return value1

    def _parse_data_media_type(self, value: Selector) -> str:
        value1 = value.attrib["data-media-type"]
        return value1

    def _parse_data_title(self, value: Selector) -> str:
        value1 = value.attrib["data-title"]
        return value1

    def parse(self) -> T_MovieTranslationsPanel:
        return [
            {
                "name": self._parse_name(e),
                "value": self._parse_value(e),
                "data_id": self._parse_data_id(e),
                "data_translation_type": self._parse_data_translation_type(e),
                "data_media_hash": self._parse_data_media_hash(e),
                "data_media_type": self._parse_data_media_type(e),
                "data_title": self._parse_data_title(e),
            }
            for e in self._split_doc(self._doc)
        ]


class KodikAPIPayload:
    """payload for Kodik API request

    {
        "d": "String",
        "d_sign": "String",
        "pd": "String",
        "pd_sign": "String",
        "ref": "String",
        "ref_sign": "String",
        "type": "String",
        "hash": "String",
        "id": "String"
    }"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_d(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*domain\\s+=\\s+['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_d_sign(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*d_sign\\s+=\\s+['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_pd(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*pd\\s+=\\s+['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_pd_sign(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*pd_sign\\s+=\\s+['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_ref(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*ref\\s+=\\s+['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_ref_sign(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*ref_sign\\s+=\\s+['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_type(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("videoInfo\\.type\\s*=\\s*['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_hash(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("videoInfo\\.hash\\s*=\\s*['\"](.*?)['\"];", value1)[1]
        return value2

    def _parse_id(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("videoInfo\\.id\\s*=\\s*['\"](.*?)['\"];", value1)[1]
        return value2

    def parse(self) -> T_KodikAPIPayload:
        return {
            "d": self._parse_d(self._doc),
            "d_sign": self._parse_d_sign(self._doc),
            "pd": self._parse_pd(self._doc),
            "pd_sign": self._parse_pd_sign(self._doc),
            "ref": self._parse_ref(self._doc),
            "ref_sign": self._parse_ref_sign(self._doc),
            "type": self._parse_type(self._doc),
            "hash": self._parse_hash(self._doc),
            "id": self._parse_id(self._doc),
        }


class KodikPage:
    """this schema used to extract params for next API request

        required next keys for API request:
            - contain in `api_payload` key
        constants:
            - cdn_is_working: true
            - bad_user: false (or true)
            - info: {}

        USAGE:
            1. GET <PLAYER_LINK> (e.g.: https://kodik.info/seria/1133512/04d5f7824ba3563bd78e44a22451bb45/720p)
            2. parse payload (see required pairs upper) (<PAYLOAD>)
            3. extract the API path from player_js_path (<API_PATH>) (encoded in BASE64)
            4. POST https://kodik.info/ + <API_PATH>; data=<PAYLOAD> (<JSON>). next HEADERS required:
                - origin="https://<NETLOC>" // player page
                - referer=<PLAYER_LINK> // FIRST URL player entrypoint
                - accept= "application/json, text/javascript, */*; q=0.01"
            5. extract data from ['links'] key from <JSON> response
            6. urls encoded in ROT_13 + BASE64 ciphers
        ISSUES:
            - kodik maybe have another netloc (e.g.: anivod)
            - 403 Forbidden if request sent not from CIS region
            - 404 DELETED: eg: https://kodik.info/seria/310427/09985563d891b56b1e9b01142ae11872/720p
            - 500 Internal server error: eg: https://kodik.info/seria/1051016/af405efc5e061f5ac344d4811de3bc16/720p ('Cyberpunk: Edgerunners' ep5 Anilibria dub)



    {
        "url_params": "String",
        "api_payload": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "type": "String",
            "hash": "String",
            "id": "String"
        },
        "player_js_path": "String",
        "movie_translations": [
            {
                "name": "String",
                "value": "String",
                "data_id": "String",
                "data_translation_type": "String",
                "data_media_hash": "String",
                "data_media_type": "String",
                "data_title": "String"
            },
            "..."
        ]
    }"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_url_params(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("var\\s*urlParams\\s*=\\s*['\"](\\{.*\\})['\"]", value1)[1]
        return value2

    def _parse_api_payload(self, value: Selector) -> T_KodikAPIPayload:
        value1 = KodikAPIPayload(value).parse()
        return value1

    def _parse_player_js_path(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search('<script\\s*type="text/javascript"\\s*src="(/assets/js/app\\.player_single.*?)">', value1)[1]
        return value2

    def _parse_movie_translations(self, value: Selector) -> T_MovieTranslationsPanel:
        value1 = MovieTranslationsPanel(value).parse()
        return value1

    def parse(self) -> T_KodikPage:
        return {
            "url_params": self._parse_url_params(self._doc),
            "api_payload": self._parse_api_payload(self._doc),
            "player_js_path": self._parse_player_js_path(self._doc),
            "movie_translations": self._parse_movie_translations(self._doc),
        }


class KodikApiPath:
    """Extract the API path from js player source

    {
        "path": "String"
    }"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_path(self, value: Selector) -> str:
        value1 = value.get()
        value2 = re.search("\\$\\.ajax\\([^>]+,url:\\s*atob\\([\"']([\\w=]+)[\"']\\)", value1)[1]
        return value2

    def parse(self) -> T_KodikApiPath:
        return {"path": self._parse_path(self._doc)}
