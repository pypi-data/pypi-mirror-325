import logging
log = logging.getLogger(__name__)

from collections import Counter
from functools import partial

from atom.api import Dict, Float, Int, Typed, Value
from enaml.application import deferred_call
from enaml.core.api import Conditional, d_
from enaml.stdlib.message_box import question
from enaml.widgets.api import Label
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

import numpy as np

from psiaudio.pipeline import concat, coroutine, PipelineData
from psiaudio.queue import InterleavedFIFOSignalQueue
from psiaudio import util

from psi.context.api import (BoolParameter, ContextGroup, ContextRow,
                             EnumParameter, Expression, ImportedSymbol, Parameter)
from psi.controller.api import (
    Blocked, ChannelOutOfRange, ContinuousInput, ControllerManifest, Coroutine,
    EpochInput, ExperimentAction, ExtractEpochs, Synchronized,
    QueuedEpochOutput
)
from psi.core.enaml.api import ExperimentManifest
from psi.experiment.api import StatusItem
from psi.token.primitives import (
    BandlimitedClick, BandlimitedFIRNoise, Chirp, Cos2Envelope, Envelope,
    Repeat
)
from psi.data.api import (
    ChannelPlot, FFTChannelPlot, FFTContainer, TimeContainer, ViewBox
)
from psi.data.sinks.api import BinaryStore, SimpleCounter, TextStore

from psi.data.api import (
    EpochTimeContainer, GroupedEpochAveragePlot, GroupedEpochFFTPlot
)

from .cfts_mixins import CFTSSelector

EXPERIMENT = __name__.rsplit('.', 1)[-1]


def configure_memr(event, duration_attr, iti_attr=None, selector='default'):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')
    data = event.workbench.get_plugin('psi.data')

    counter = data.find_sink('memr_counter')
    probe = controller.get_output('probe')
    elicitor = controller.get_output('elicitor')
    probe.queue = InterleavedFIFOSignalQueue(keep_complete_waveforms=False)
    elicitor.queue = InterleavedFIFOSignalQueue(keep_complete_waveforms=False)

    elicitor_sf = 0
    probe_sf = 0

    bad_settings = {}

    # Special case for handling the swept MEMR which does not use a selector.
    # All stimuli are included in a single "sweep".
    if selector is not None:
        settings = context.iter_settings('default', 1)
    else:
        settings = [context.get_values()]

    for setting in settings:
        for polarity in (1, -1):
            averages = max(1, int(round(setting['trial_n'] / 2)))
            if iti_attr is None:
                iti = 0
            else:
                iti = setting[iti_attr]
            duration = setting[duration_attr] + iti
            setting['elicitor_bandlimited_noise_polarity'] = polarity
            try:
                elicitor_uuid, elicitor_factory = elicitor.add_setting(
                    setting, averages=averages, total_duration=duration)
            except ChannelOutOfRange as e:
                level = setting['elicitor_bandlimited_noise_level']
                bad_settings[level] = e.db
                # Important to continue! We do not want to add the probe to the
                # queue if the elicitor was not queued.
                continue

            # This should come *after* so we don't add a probe with a silent
            # elicitor to the queue.
            try:
                setting['elicitor_uuid'] = elicitor_uuid
                _, probe_factory = probe.add_setting(
                    setting, averages=averages, total_duration=duration)
            except ChannelOutOfRange as e:
                raise ValueError(f'Probe level is {e.db:.1f} dB too high.')

            elicitor_sf = max(elicitor_sf, elicitor_factory.max_amplitude() * 1.1)
            probe_sf = max(probe_sf, probe_factory.max_amplitude() * 1.1)

    probe_atten = util.db(probe_sf, probe.channel.max_range[1])
    elicitor_atten = util.db(elicitor_sf, elicitor.channel.max_range[1])
    log.info('Probe is set to %.2f dB of maximum and elicitor to %.2f dB of maximum', probe_atten, elicitor_atten)
    if len(bad_settings):
        levels = list(sorted(bad_settings.keys()))
        max_level = levels[0] - bad_settings[levels[0]]
        to_remove_text = ', '.join([f'{l}' for l in sorted(levels)])
        mesg = f'Maximum elicitor level is {max_level:.1f} dB. Remove {to_remove_text} and proceed?'
        result = question(None, 'Settings', mesg)
        if result.text == 'Yes':
            pass
        else:
            import sys
            sys.exit()

    if probe.channel == elicitor.channel:
        sf = max(elicitor_sf, probe_sf)
        probe.channel.expected_range = (-sf, sf)
    else:
        probe.channel.expected_range = (-probe_sf, probe_sf)
        elicitor.channel.expected_range = (-elicitor_sf, elicitor_sf)

    counter.requested_n = probe.queue.count_requested_trials()

    for i, k in enumerate(probe.queue._ordering):
        log.info(f'{i}: {k}')


@coroutine
def stack_repeats(repeat_period, target):
    while True:
        new_data = []
        for data in (yield):
            s_repeat = int(round(repeat_period * data.fs))
            data_repeat = np.asarray(data).reshape((-1, data.n_channels, s_repeat))
            for i, d in enumerate(data_repeat):
                new_d = PipelineData(d, fs=data.fs, s0=0, channel=data.channel,
                                     metadata=data.metadata.copy())
                new_d.add_metadata('repeat', i)
                new_d.add_metadata('t0_actual', (i * s_repeat + data.s0) / data.fs)
                new_data.append(new_d)

        new_data = concat(new_data, axis='epoch')
        target(new_data)


class StackRepeats(EpochInput):

    duration = d_(Float()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return stack_repeats(self.duration, cb).send


@coroutine
def extract_repeats(repeats, target):
    log.info('Configured extract_repeats with %r', repeats)
    while True:
        data = (yield)
        subsets = []
        for name, (lb, ub) in repeats.items():
            d = data[lb:ub]
            d.add_metadata('range', name)
            subsets.append(d)
        result = concat(subsets, axis='epoch')
        target(result)


class ExtractRepeats(EpochInput):

    ranges = d_(Dict()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return extract_repeats(self.ranges, cb).send


@coroutine
def extract_stim(lb, ub, target):
    ilb, iub = None, None
    while True:
        data = (yield)
        if iub is None:
            ilb = int(round(lb * data.fs))
            iub = int(round(ub * data.fs))
        target(data[..., ilb:iub])


class ExtractStim(EpochInput):

    lb = d_(Float()).tag(metadata=True)
    ub = d_(Float()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return extract_stim(self.lb, self.ub, cb).send


@coroutine
def process_interleaved_memr(fl, fh, reject_threshold, min_probe_corr,
                             max_turntable_speed, probe_output,
                             elicitor_output, turntable_sink, fs, counter,
                             calibration, status_cb, target):
    '''
    Parameters
    ----------
    fl : float
        Lowest frequency in probe stim
    fh : float
        Highest frequency in probe stim
    reject_threshold : float
        Reject trial if silence RMS is greater than specified threshold in dB
        (remember to factor in noise floor of microphone). The noise level of
        the silent segment is calculated only over the frequency range spanning
        fl to fh.
    min_probe_corr : float
        Reject trial if correlation between probe segments is less than this
        threshold.
    max_turntable_speed : float
        Reject trial if turntable speed exceeds this value in cm/s.
    status_cb : callable
        Callable taking a single argument. True indicates trial was rejected.
        False indicates trial was accepted.
    '''

    while True:
        data = (yield)
        n = data.shape[-1] // 2
        probe = data[..., 0, :n]
        silence = data[..., 0, n:]

        silence_psd = calibration.get_db(util.psd_df(silence, fs))
        probe_psd = calibration.get_db(util.psd_df(probe, fs))
        silence_rms = silence_psd.loc[:, fl:fh].apply(util.rms_rfft_db, axis=1).max()
        probe_rms = probe_psd.loc[:, fl:fh].apply(util.rms_rfft_db, axis=1)

        probe_corr = np.corrcoef(probe).min()
        silence_corr = np.corrcoef(silence).min()

        t0 = data.metadata[0]['t0']
        duration = data.metadata[0]['duration']

        speed = turntable_sink.get_segment(t0, offset=0, duration=duration,
                                           preload=False, allow_partial=True)
        speed_cm_s = np.max(np.abs(speed))

        if (speed_cm_s > max_turntable_speed):
            log.info('Rejecting trial since speed is %.2f cm', speed_cm_s)
            status_cb(True)
        elif (silence_rms > reject_threshold):
            log.info('Rejecting trial since silent period RMS is %.2f', silence_rms)
            status_cb(True)
        elif (probe_corr < min_probe_corr):
            log.info('Rejecting trial since probe corr is %.2f', probe_corr)
            status_cb(True)
        else:
            target(data)
            status_cb(False)
            with probe_output.engine.lock, elicitor_output.engine.lock:
                probe_uuid = data[0].metadata['key']
                elicitor_uuid = data[0].metadata['elicitor_uuid']
                try:
                    probe_output.queue.decrement_key(probe_uuid)
                    elicitor_output.queue.decrement_key(elicitor_uuid)
                except Exception as e:
                    pass

            current_n = probe_output.queue.count_requested_trials() \
                - probe_output.queue.count_trials()
            def update_counter():
                nonlocal current_n
                nonlocal counter
                counter.current_n = current_n
            deferred_call(update_counter)


@coroutine
def process_simultaneous_memr(fl, fh, max_turntable_speed, probe_output,
                              elicitor_output, turntable_sink, fs, counter,
                              calibration, status_cb, target):
    '''
    Parameters
    ----------
    fl : float
        Lowest frequency in probe stim
    fh : float
        Highest frequency in probe stim
    max_turntable_speed : float
        Reject trial if turntable speed exceeds this value in cm/s.
    status_cb : callable
        Callable taking a single argument. True indicates trial was rejected.
        False indicates trial was accepted.
    '''
    while True:
        data = (yield)

        times = np.array([m['t0_actual'] for m in data.metadata])
        duration = np.mean(np.diff(times))
        #speed = turntable_sink.get_segments(times, offset=0, duration=duration,
        #                                    preload=False, allow_partial=True)
        #keep_mask = list(speed.max(axis=1).values < max_turntable_speed)
        #original_ranges = Counter([m['range'] for m in data.metadata])
        #data = data[np.flatnonzero(keep_mask)]
        #valid_ranges = Counter([m['range'] for m in data.metadata])
        #log.info(len(data))
        #log.info(len(data.metadata))
        #log.info(valid_ranges)
        #log.info(original_ranges)

        if False:
            pass
        else:
            target(data)
            status_cb(False)
            with probe_output.engine.lock, elicitor_output.engine.lock:
                probe_uuid = data[0].metadata['key']
                elicitor_uuid = data[0].metadata['elicitor_uuid']
                try:
                    probe_output.queue.decrement_key(probe_uuid)
                    elicitor_output.queue.decrement_key(elicitor_uuid)
                except Exception as e:
                    pass

                current_n = probe_output.queue.count_requested_trials() \
                    - probe_output.queue.count_trials()
                def update_counter():
                    nonlocal current_n
                    nonlocal counter
                    counter.current_n = current_n
                deferred_call(update_counter)


@coroutine
def process_swept_memr(fl, fh, max_turntable_speed, probe_output,
                       elicitor_output, turntable_sink, fs, counter,
                       calibration, status_cb, target):
    '''
    Parameters
    ----------
    fl : float
        Lowest frequency in probe stim
    fh : float
        Highest frequency in probe stim
    max_turntable_speed : float
        Reject trial if turntable speed exceeds this value in cm/s.
    status_cb : callable
        Callable taking a single argument. True indicates trial was rejected.
        False indicates trial was accepted.
    '''
    trial = 0
    while True:
        data = (yield)
        data.add_metadata('trial', trial)
        trial += 1

        times = np.array([m['t0_actual'] for m in data.metadata])
        duration = np.mean(np.diff(times))
        target(data)
        status_cb(False)
        with probe_output.engine.lock, elicitor_output.engine.lock:
            probe_uuid = data[0].metadata['key']
            elicitor_uuid = data[0].metadata['elicitor_uuid']
            try:
                probe_output.queue.decrement_key(probe_uuid)
                elicitor_output.queue.decrement_key(elicitor_uuid)
            except Exception as e:
                pass

            current_n = probe_output.queue.count_requested_trials() \
                - probe_output.queue.count_trials()
            def update_counter():
                nonlocal current_n
                nonlocal counter
                counter.current_n = current_n
            deferred_call(update_counter)


class ProcessMEMR(EpochInput):

    fl = d_(Float())
    fh = d_(Float())
    probe_output = d_(Value())
    elicitor_output = d_(Value())
    counter = d_(Typed(SimpleCounter))
    turntable_sink = d_(Value())
    max_turntable_speed = d_(Float())

    n_reject = d_(Int(0))
    n_trials = d_(Int(0))

    def status_cb(self, reject):
        # True if trial rejected, False otherwise.
        if reject:
            self.n_reject += 1
        self.n_trials += 1


class ProcessInterleavedMEMR(ProcessMEMR):

    reject_threshold = d_(Float())
    min_probe_corr = d_(Float(0.5))

    def configure_callback(self):
        cb = super().configure_callback()
        return process_interleaved_memr(
            fl=self.fl,
            fh=self.fh,
            reject_threshold=self.reject_threshold,
            min_probe_corr=self.min_probe_corr,
            max_turntable_speed=self.max_turntable_speed,
            probe_output=self.probe_output,
            elicitor_output=self.elicitor_output,
            turntable_sink=self.turntable_sink,
            fs=self.fs,
            counter=self.counter,
            calibration=self.calibration,
            status_cb=self.status_cb,
            target=cb).send


class ProcessSimultaneousMEMR(ProcessMEMR):

    def configure_callback(self):
        cb = super().configure_callback()
        return process_simultaneous_memr(
            fl=self.fl,
            fh=self.fh,
            max_turntable_speed=self.max_turntable_speed,
            probe_output=self.probe_output,
            elicitor_output=self.elicitor_output,
            turntable_sink=self.turntable_sink,
            fs=self.fs,
            counter=self.counter,
            calibration=self.calibration,
            status_cb=self.status_cb,
            target=cb).send


class ProcessSweptMEMR(ProcessMEMR):

    def configure_callback(self):
        cb = super().configure_callback()
        return process_swept_memr(
            fl=self.fl,
            fh=self.fh,
            max_turntable_speed=self.max_turntable_speed,
            probe_output=self.probe_output,
            elicitor_output=self.elicitor_output,
            turntable_sink=self.turntable_sink,
            fs=self.fs,
            counter=self.counter,
            calibration=self.calibration,
            status_cb=self.status_cb,
            target=cb).send


class GroupedInterleavedMEMRPlot(GroupedEpochFFTPlot):

    final_probe = d_(Int())

    def _y(self, epoch):
        b = [e for e in epoch if e.metadata['repeat'] == 0]
        r = [e for e in epoch if e.metadata['repeat'] == self.final_probe]
        b = np.array(concat(b, axis='epoch'))[:, self.channel]
        r = np.array(concat(r, axis='epoch'))[:, self.channel]

        r_psd = util.db(util.psd(r, self.source.fs).mean(axis=0))
        b_psd = util.db(util.psd(b, self.source.fs).mean(axis=0))
        return r_psd - b_psd


class GroupedSimultaneousMEMRPlot(GroupedEpochFFTPlot):
    # This is also used for the SweptMEMRPlot

    def _y(self, epoch):
        n = [e for e in epoch if e.metadata['range'] == 'norm']
        e = [e for e in epoch if e.metadata['range'] == 'elicitor']
        n = np.array(concat(n, axis='epoch'))[:, self.channel]
        e = np.array(concat(e, axis='epoch'))[:, self.channel]

        n_psd = util.db(util.psd(n.mean(axis=0), self.source.fs))
        e_psd = util.db(util.psd(e.mean(axis=0), self.source.fs))
        return e_psd - n_psd


enamldef BaseMEMRManifest(ControllerManifest): manifest:

    attr configure_experiment_cb
    attr analyze_memr_cb
    attr probe
    attr selector = 'default'

    attr plot_keys

    Extension:
        id = EXPERIMENT + '.base_context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'hardware_settings'
            label = 'Hardware'

    Extension:
        id = EXPERIMENT + '.io'
        point = 'psi.controller.io'

        ExtractEpochs: extract_probe:
            source_name = 'probe_microphone'
            name = 'memr_probe'

        ExtractEpochs: extract_elicitor:
            source_name = 'elicitor_microphone'
            name = 'memr_elicitor'

        Synchronized:
            name = 'memr_stim'
            QueuedEpochOutput:
                name = 'probe'
                label = 'Probe'
                target_name = 'probe_primary'
                auto_decrement = False
                token = workbench.get_plugin('psi.token').get_token(probe)
                queue ::
                    extract_probe.subscribe_to_queue(self.queue)
            QueuedEpochOutput:
                name = 'elicitor'
                label = 'Elicitor'
                target_name = 'elicitor_secondary'
                auto_decrement = False
                token = workbench.get_plugin('psi.token').get_token('noise')
                queue ::
                    extract_elicitor.subscribe_to_queue(self.queue)

    Extension:
        id = EXPERIMENT + '.context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'memr'
            label = 'MEMR'

            ContextRow:
                name = 'elicitor'
                fmt = ['Elicitor', elicitor_fl, 'to', elicitor_fh,
                       'Hz, eq. up to ±', elicitor_eq_max, 'db, apply',
                       elicitor_audiogram, 'audiogram']

                Parameter: elicitor_fl:
                    name = 'elicitor_fl'
                    default = 8e3
                    scope = 'trial'

                Parameter: elicitor_fh:
                    name = 'elicitor_fh'
                    default = 16e3
                    scope = 'trial'

                Parameter: elicitor_eq_max:
                    name = 'elicitor_max_equalize'
                    default = 20
                    scope = 'trial'

                EnumParameter: elicitor_audiogram:
                    name = 'elicitor_audiogram_weighting'
                    default = 'mouse'
                    choices = {'no': None, 'mouse': "'mouse'"}

            ContextRow:
                name = 'probe'
                fmt = ['Probe', probe_fl, 'to', probe_fh, 'Hz at', probe_level,
                       'dB SPL, eq. up to ±', probe_eq_max, 'db']

                Parameter: probe_fl:
                    name = 'probe_fl'
                    default = 4e3
                    scope = 'trial'

                Parameter: probe_fh:
                    name = 'probe_fh'
                    default = 32e3
                    scope = 'trial'

                Parameter: probe_level:
                    name = 'probe_level'
                    default = 75
                    scope = 'trial'

                Parameter: probe_eq_max:
                    name = 'probe_max_equalize'
                    default = 20
                    scope = 'trial'

    Extension:
        id = EXPERIMENT + '.commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'psi.controller.configure_experiment'
            handler = configure_experiment_cb

    Extension:
        id = EXPERIMENT + '.actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.controller.configure_experiment'
            weight = 11

        ExperimentAction:
            event = 'experiment_initialize'
            command = 'psi.context.initialize'
            kwargs = {'selector': selector, 'cycles': 1}

        ExperimentAction:
            event = 'engines_configured'
            command = 'memr_stim.start'
            kwargs = {'delay': 0.5}

        ExperimentAction:
            event = 'memr_probe_queue_end'
            command = 'psi.controller.stop'

    Extension:
        id = EXPERIMENT + '.data'
        point = 'psi.data.sinks'

        BinaryStore:
            name = 'memr_binary_store'
            continuous_inputs = ['probe_microphone', 'elicitor_microphone']

        TextStore:
            name = 'memr_store'
            epoch_inputs = ['memr_probe']


################################################################################
# Interleaved MEMR
################################################################################
enamldef InterleavedElicitorMixin(ExperimentManifest):

    id = 'interleaved_elicitor_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_elicitor.items'
        point = 'psi.context.items'

        ContextRow:
            name = 'train_timing'
            group_name = 'memr'
            fmt = ['Pulse', elicitor_duration, 'sec elicitor', elicitor_n,
                   'times with', elicitor_iti, 'sec ITI']

            Parameter: elicitor_n:
                name = 'elicitor_n'
                group_name = 'memr'

            Parameter: elicitor_duration:
                name = 'elicitor_duration'
                default = 232e-3
                group_name = 'memr'

            Parameter: elicitor_iti:
                name = 'elicitor_iti'
                default = 140e-3
                group_name = 'memr'

        ContextRow:
            name = 'trial_timing'
            group_name = 'memr'
            fmt = ['Repeat', trial_n, 'times with', trial_iti, 'sec ITI']

            Parameter: trial_n:
                name = 'trial_n'
                label = 'Number of trials'
                default = 2
                group_name = 'memr'

            Parameter: trial_iti:
                name = 'trial_iti'
                label = 'Trial ITI'
                default = 1.14
                group_name = 'memr'

        Parameter:
            name = 'analysis_window'
            label = 'Analysis window'
            default = 46.4e-3
            group_name = 'memr'

        ContextRow:
            name = 'artifact_reject'
            group_name = 'memr'
            fmt = ['Reject if probe. corr <', min_probe_corr,
                   'or silent interval level >', max_silence_db]

            Parameter: max_silence_db:
                name = 'max_silence_db'
                default = 50

            Parameter: min_probe_corr:
                name = 'min_probe_corr'
                default = 0.5

        Parameter:
            name = 'max_turntable_speed'
            label = 'Max speed (cm/s)'
            default = 0.5
            group_name = 'memr'

        Parameter:
            name = 'repeat_period'
            label = 'Stim repeat period'
            group_name = 'memr'

        Parameter:
            name = 'trial_period'
            label = 'Trial repeat period'
            group_name = 'memr'

        Expression:
            parameter = 'repeat_period'
            expression = 'elicitor_duration + elicitor_iti'

        Expression:
            parameter = 'trial_period'
            expression = 'repeat_period * (elicitor_n + 1) + trial_iti'

        Expression:
            parameter = 'elicitor_noise_n'
            expression = 'elicitor_n'

        Expression:
            parameter = 'elicitor_noise_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'elicitor_noise_skip_n'
            expression = '0'

        Expression:
            parameter = 'elicitor_envelope_duration'
            expression = 'elicitor_duration'

        Expression:
            parameter = 'elicitor_envelope_rise_time'
            expression = '5e-3'

        Expression:
            parameter = 'elicitor_envelope_start_time'
            expression = 'repeat_period - elicitor_duration'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fl'
            expression = 'elicitor_fl'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fh'
            expression = 'elicitor_fh'

        Expression:
            parameter = 'elicitor_bandlimited_noise_equalize'
            expression = 'elicitor_max_equalize != 0'

        Expression:
            parameter = 'elicitor_bandlimited_noise_seed'
            expression = '1'

        Expression:
            parameter = 'elicitor_bandlimited_noise_max_correction'
            expression = 'elicitor_max_equalize'

        Expression:
            parameter = 'elicitor_bandlimited_noise_audiogram_weighting'
            expression = 'elicitor_audiogram_weighting'


enamldef InterleavedClickProbeMixin(ExperimentManifest):

    id = 'interleaved_click_probe_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_click_probe.items'
        point = 'psi.context.items'

        Parameter:
            name = 'probe_delay'
            label = 'probe delay'
            group_name = 'memr'

        Parameter: probe_duration:
            name = 'probe_duration'
            group_name = 'memr'

        Expression:
            parameter = f'probe_click_n'
            expression = 'elicitor_n + 1'

        Expression:
            parameter = 'probe_click_skip_n'
            expression = '0'

        Expression:
            parameter = 'probe_click_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'probe_click_delay'
            expression = '11.2e-3 - probe_bandlimited_click_window / 2'

        Expression:
            parameter = 'probe_delay'
            expression = 'probe_click_delay'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_bandlimited_click_window'

        Expression:
            parameter = 'probe_bandlimited_click_flb'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_bandlimited_click_fub'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_bandlimited_click_level'
            expression = 'probe_level'

        Expression:
            parameter = 'probe_bandlimited_click_window'
            expression = '5e-3'

        Expression:
            parameter = 'probe_bandlimited_click_equalize'
            expression = 'probe_max_equalize != 0'

        Expression:
            parameter = 'probe_bandlimited_click_max_correction'
            expression = 'probe_max_equalize'

        Expression:
            parameter = 'probe_bandlimited_click_audiogram_weighting'
            expression = 'None'


enamldef InterleavedChirpProbeMixin(ExperimentManifest):

    id = 'interleaved_chirp_probe_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_chirp_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_chirp_n'
            expression = 'elicitor_n + 1'

        Expression:
            parameter = 'probe_chirp_skip_n'
            expression = '0'

        Expression:
            parameter = 'probe_chirp_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'probe_chirp_delay'
            expression = 'probe_delay'

        Expression:
            parameter = 'probe_chirp_start_frequency'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_chirp_end_frequency'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_chirp_level'
            expression = 'probe_level'

        Parameter:
            name = 'probe_delay'
            label = 'probe delay'
            default = 10e-3
            group_name = 'memr'

        ContextRow:
            fmt = ['Probe', probe_duration, 'sec with', probe_window, 'window']
            group_name = 'memr'

            Parameter: probe_duration:
                name = 'probe_duration'
                default = 2e-3

            EnumParameter: probe_window:
                name = 'probe_window'
                choices = {
                    'hann': '"hann"',
                    'boxcar': '"boxcar"',
                }

        Expression:
            parameter = 'probe_chirp_duration'
            expression = 'probe_duration'

        Expression:
            parameter = 'probe_chirp_window'
            expression = 'probe_window'

        Expression:
            parameter = 'probe_chirp_equalize'
            expression = 'probe_max_equalize != 0'

        Expression:
            parameter = 'probe_chirp_max_correction'
            expression = 'probe_max_equalize'

        Expression:
            parameter = 'probe_chirp_audiogram_weighting'
            expression = 'None'


enamldef InterleavedMEMRManifest(BaseMEMRManifest): manifest:

    # Implements the classic wideband acoustic reflex as described by Keefe.
    configure_experiment_cb = partial(configure_memr,
                                      duration_attr='trial_period',
                                      iti_attr=None,
                                      selector=manifest.selector)

    Extension:
        id = EXPERIMENT + '.interleaved_memr.'
        point = 'psi.experiment.status'

        StatusItem:
            name = 'memr_reject'
            label = 'MEMRs rejected'
            Label:
                text << f'{proc_memr.n_reject} of {proc_memr.n_trials}'

    Extension:
        id = EXPERIMENT + '.selectors'
        point = 'psi.context.selectors'

        CFTSSelector:
            label = 'MEMR stimuli'
            can_manage = ['elicitor_bandlimited_noise_level']
            user_managed = False

    Extension:
        id = EXPERIMENT + '.interleaved_elicitor.tokens'
        point = 'psi.token.tokens'

        Repeat: elicitor:
            name = 'noise'
            hide = ['delay']
            Cos2Envelope:
                BandlimitedFIRNoise:
                    hide = ['polarity']

        Repeat: probe:
            name = 'click'
            hide = ['skip_n']
            BandlimitedClick:
                pass

        Repeat: chirp:
            name = 'chirp'
            hide = ['skip_n']
            Chirp:
                pass

    Extension:
        id = EXPERIMENT + '.interleaved_memr.io'
        point = 'psi.controller.io'

        StackRepeats:
            source_name = 'memr_probe'
            name = 'memr_probe_repeat'
            duration = C.repeat_period

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                lb << C.probe_delay + 0.75e-3
                ub << lb + C.probe_duration * 2

                ProcessInterleavedMEMR: proc_memr:
                    name = 'memr_probe_valid'
                    force_active = True
                    fl = C.probe_fl
                    fh = C.probe_fh
                    reject_threshold = C.max_silence_db
                    min_probe_corr = C.min_probe_corr
                    max_turntable_speed = C.max_turntable_speed
                    probe_output = controller.get_output('probe')
                    elicitor_output = controller.get_output('elicitor')
                    turntable_sink = data.find_sink('turntable_store') \
                        .get_ai_signal('turntable_linear_velocity')
                    counter = counter

                    ExtractStim: probe:
                        name = 'probe'
                        lb << 0
                        ub << C.probe_duration

                    ExtractStim: silence:
                        name = 'silence'
                        lb << probe.ub
                        ub << lb + C.probe_duration

        StackRepeats:
            source_name = 'memr_elicitor'
            name = 'memr_elicitor_repeat'
            duration = C.repeat_period

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                name = 'elicitor'
                lb = C.elicitor_envelope_start_time
                ub = C.elicitor_envelope_start_time + C.elicitor_duration

    Extension:
        id = EXPERIMENT + '.interleaved_sinks'
        point = 'psi.data.sinks'

        SimpleCounter: counter:
            name = 'memr_counter'
            label = 'MEMRs acquired'

    Extension:
        id = EXPERIMENT + '.plots'
        point = 'psi.data.plots'

        EpochTimeContainer: probe_time_container:
            name = 'probe_time_container'
            label = 'Probe waveform'

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_plot.tab_grouping)

            ViewBox: probe_time_vb:
                name = 'probe_time_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochAveragePlot: probe_plot:
                    source_name = 'probe'
                    plot_grouping = ['repeat']
                    plot_keys = [(k,) for k in range(C.elicitor_n + 1)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()
                    fmt_plot_label_cb = lambda x, s: f'Probe {x[0]}'

        FFTContainer: probe_fft_container:
            name = 'probe_fft_container'
            label = 'Probe and Elicitor PSD'
            freq_lb = 0.5e3
            freq_ub = 50e3

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_fft_plot.tab_grouping)

            ViewBox:
                name = 'probe_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochFFTPlot: probe_fft_plot:
                    pen_color_cycle = 'palettable.cartocolors.qualitative.Bold_2_r'
                    source_name = 'probe'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Probe'

                GroupedEpochFFTPlot: probe_fft_plot:
                    pen_color_cycle = 'palettable.cartocolors.qualitative.Bold_2_r'
                    source_name = 'silence'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Silence'

                GroupedEpochFFTPlot: elicitor_fft_plot:
                    pen_color_cycle = 'palettable.cartocolors.qualitative.Bold_2'
                    average_mode = 'FFT'
                    source_name = 'elicitor'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Elicitor'

        FFTContainer:
            name = 'memr_fft_container'
            label = 'MEMR'
            freq_lb = 4e3
            freq_ub = 32e3

            ViewBox:
                name = 'memr_fft_vb'
                y_mode = 'mouse'
                y_min = -5
                y_max = 5

                GroupedInterleavedMEMRPlot:
                    final_probe = C.elicitor_n
                    name = 'memr_fft_plot'
                    source_name = 'probe'
                    plot_grouping << C.get_names()
                    pen_width = 2
                    pen_color_cycle = 'palettable.scientific.sequential.LaJolla_3'


enamldef InterleavedChirpMEMRManifest(InterleavedMEMRManifest):

    probe = 'chirp'


enamldef InterleavedClickMEMRManifest(InterleavedMEMRManifest):

    probe = 'click'


################################################################################
# Simultaneous MEMR
################################################################################
enamldef SimultaneousClickProbeMixin(ExperimentManifest):

    id = 'simultaneous_click_probe_stim'

    Extension:
        id = EXPERIMENT + '.simultaneous_click_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_click_n'
            expression = 'probe_n'

        Expression:
            parameter = 'probe_click_rate'
            expression = 'probe_rate'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_bandlimited_click_window'

        Expression:
            parameter = 'probe_bandlimited_click_flb'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_bandlimited_click_fub'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_bandlimited_click_level'
            expression = 'probe_level'

        Expression:
            parameter = 'probe_bandlimited_click_window'
            expression = '5e-3'


enamldef SimultaneousChirpProbeMixin(ExperimentManifest):

    id = 'simultaneous_chirp_probe_stim'

    Extension:
        id = EXPERIMENT + '.simultaneous_chirp_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = 'probe_chirp_n'
            expression = 'probe_n'

        Expression:
            parameter = 'probe_chirp_rate'
            expression = 'probe_rate'

        Expression:
            parameter = 'probe_chirp_start_frequency'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_chirp_end_frequency'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_chirp_level'
            expression = 'probe_level'

        ContextRow:
            fmt = ['Probe', probe_duration, 'sec with', probe_window, 'window']
            group_name = 'memr'

            Parameter: probe_duration:
                name = 'probe_duration'
                default = 2e-3

            EnumParameter: probe_window:
                name = 'probe_window'
                choices = {
                    'hann': '"hann"',
                    'boxcar': '"boxcar"',
                }

        Expression:
            parameter = 'probe_chirp_duration'
            expression = 'probe_duration'

        Expression:
            parameter = 'probe_chirp_window'
            expression = 'probe_window'

        Expression:
            parameter = 'probe_chirp_equalize'
            expression = 'probe_max_equalize != 0'

        Expression:
            parameter = 'probe_chirp_max_correction'
            expression = 'probe_max_equalize'

        Expression:
            parameter = 'probe_chirp_audiogram_weighting'
            expression = 'None'


enamldef SimultaneousMEMRManifest(BaseMEMRManifest): manifest:

    # Implements the wideband acoustic reflex as described by Valero and Liberman.
    configure_experiment_cb = partial(configure_memr,
                                      duration_attr='trial_duration',
                                      iti_attr='trial_iti',
                                      selector=manifest.selector)

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.sinks'
        point = 'psi.data.sinks'

        SimpleCounter: counter:
            name = 'memr_counter'
            label = 'MEMRs acquired'

    Extension:
        id = EXPERIMENT + '.selectors'
        point = 'psi.context.selectors'

        CFTSSelector:
            label = 'MEMR stimuli'
            can_manage = ['elicitor_bandlimited_noise_level']
            user_managed = False

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.io'
        point = 'psi.controller.io'

        StackRepeats:
            source_name = 'memr_probe'
            name = 'memr_repeat'
            duration = 1 / C.probe_rate

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                name = 'probe'
                lb = 0.75e-3
                ub = lb + C.probe_duration

                ExtractRepeats:
                    name = 'probe_norm_raw'
                    ranges = {
                        'norm': (
                            int(round((C.elicitor_onset - C.norm_window) * C.probe_rate)),
                            int(round(C.elicitor_onset * C.probe_rate)),
                        ),
                        'elicitor': (
                            int(round((C.elicitor_onset + C.elicitor_noise_rise_time) * C.probe_rate)),
                            int(round((C.elicitor_onset + C.elicitor_noise_rise_time + C.norm_window) * C.probe_rate)),
                        )
                    }

                    ProcessSimultaneousMEMR: proc_memr:
                        name = 'probe_norm'
                        force_active = True
                        fl = C.probe_fl
                        fh = C.probe_fh
                        max_turntable_speed = C.max_turntable_speed
                        probe_output = controller.get_output('probe')
                        elicitor_output = controller.get_output('elicitor')
                        counter = counter
                        turntable_sink = data.find_sink('turntable_store') \
                            .get_ai_signal('turntable_linear_velocity')

        ExtractStim:
            source_name = 'memr_elicitor'
            name = 'elicitor'
            lb = C.elicitor_onset + C.elicitor_noise_rise_time
            ub = C.elicitor_onset + C.elicitor_noise_rise_time + C.elicitor_duration - C.elicitor_noise_rise_time

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.tokens'
        point = 'psi.token.tokens'

        Cos2Envelope:
            name = 'noise'
            BandlimitedFIRNoise:
                hide = ['polarity']

        Repeat: probe:
            name = 'click'
            hide = ['skip_n', 'delay']
            BandlimitedClick:
                pass

        Repeat: chirp:
            name = 'chirp'
            hide = ['skip_n', 'delay']
            Chirp:
                pass

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.context'
        point = 'psi.context.items'

        ContextRow:
            name = 'trial_info'
            group_name = 'memr'
            fmt = ['Trial', trial_dur, 'sec every', trial_iti, 'sec']

            Parameter: trial_dur:
                name = 'trial_duration'
                default = 11

            Parameter: trial_iti:
                name = 'trial_iti'
                default = 1

        Parameter:
            name = 'trial_n'
            label = 'Number of trials'
            default = 2
            group_name = 'memr'

        Parameter:
            name = 'probe_rate'
            label = 'Probe rate'
            default = 40
            group_name = 'memr'

        Parameter:
            name = 'elicitor_onset'
            label = 'Elicitor onset'
            default = 6
            group_name = 'memr'

        Parameter:
            name = 'elicitor_duration'
            label = 'Elicitor duration'
            default = 3
            group_name = 'memr'

        Parameter:
            name = 'norm_window'
            label = 'Normalization window'
            default = 1
            group_name = 'memr'

        Parameter:
            name = 'max_turntable_speed'
            label = 'Max speed (cm/s)'
            default = 0.5
            group_name = 'memr'

        Expression:
            parameter = 'probe_n'
            expression = 'trial_duration * probe_rate'

        Expression:
            parameter = 'elicitor_noise_start_time'
            expression = 'elicitor_onset'

        Expression:
            parameter = 'elicitor_noise_duration'
            expression = 'elicitor_duration'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fl'
            expression = 'elicitor_fl'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fh'
            expression = 'elicitor_fh'

        Expression:
            parameter = 'elicitor_bandlimited_noise_equalize'
            expression = 'elicitor_max_equalize != 0'

        Expression:
            parameter = 'elicitor_bandlimited_noise_seed'
            expression = '1'

        Expression:
            parameter = 'elicitor_noise_rise_time'
            expression = '20e-3'

        Expression:
            parameter = 'elicitor_bandlimited_noise_max_correction'
            expression = 'elicitor_max_equalize'

        Expression:
            parameter = 'elicitor_bandlimited_noise_audiogram_weighting'
            expression = 'elicitor_audiogram_weighting'

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.plots'
        point = 'psi.data.plots'

        EpochTimeContainer: probe_time_container:
            name = 'probe_time_container'
            label = 'Probe waveform'

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_plot.tab_grouping)

            ViewBox: probe_time_vb:
                name = 'probe_time_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochAveragePlot: probe_plot:
                    source_name = 'probe_norm'
                    plot_grouping = ['range']
                    plot_keys = [('norm',), ('elicitor',)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()

        FFTContainer: probe_fft_container:
            name = 'probe_fft_container'
            label = 'Probe and Elicitor PSD'
            freq_lb = 0.5e3
            freq_ub = 50e3

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_fft_plot.tab_grouping)

            ViewBox:
                name = 'probe_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochFFTPlot: probe_fft_plot:
                    source_name = 'probe_norm'
                    plot_grouping = ['range']
                    plot_keys = [('norm',), ('elicitor',)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    average_mode = 'time'

                GroupedEpochFFTPlot: elicitor_fft_plot:
                    source_name = 'elicitor'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    pen_color_cycle = ['k']
                    waveform_averages = 10

        FFTContainer:
            name = 'memr_fft_container'
            label = 'MEMR'
            freq_lb = 4e3
            freq_ub = 32e3

            ViewBox:
                name = 'memr_fft_vb'
                y_mode = 'mouse'
                y_min = -3
                y_max = 3

                GroupedSimultaneousMEMRPlot:
                    name = 'memr_fft_plot'
                    source_name = 'probe_norm'
                    plot_grouping << C.get_names()
                    pen_width = 2
                    pen_color_cycle = 'palettable.scientific.sequential.LaJolla_3'


################################################################################
# Swept MEMR
################################################################################
enamldef SweptMEMRManifest(BaseMEMRManifest): manifest:

    attr probe = 'click'
    attr selector = None

    configure_experiment_cb = partial(configure_memr,
                                      duration_attr='trial_duration',
                                      iti_attr='trial_iti',
                                      selector=manifest.selector)

    Extension:
        id = EXPERIMENT + '.swept_memr.tokens'
        point = 'psi.token.tokens'

        Envelope:
            name = 'noise'
            values = {
                'start_time': 0,
                'envelope': 'bartlett',
                'rise_time': None,
            }
            BandlimitedFIRNoise:
                values = {
                    'seed': 1,
                }
                hide = ['polarity']

        Repeat: probe:
            name = 'click'
            values = {
                'skip_n': 0,
            }
            BandlimitedClick:
                values = {
                    'audiogram_weighting': None,
                }

    Extension:
        id = EXPERIMENT + '.swept_memr.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_click_n'
            expression = 'probe_n'

        Expression:
            parameter = 'probe_click_rate'
            expression = 'probe_rate'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_bandlimited_click_window'

        Expression:
            parameter = 'probe_click_delay'
            #expression = '((trial_duration / 2 * probe_rate) % 1) / probe_rate - probe_bandlimited_click_window / 2'
            expression = '0'

        Expression:
            parameter = 'probe_bandlimited_click_flb'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_bandlimited_click_fub'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_bandlimited_click_level'
            expression = 'probe_level'

        Expression:
            parameter = 'probe_bandlimited_click_window'
            expression = '5e-3'

        Expression:
            parameter = 'probe_bandlimited_click_equalize'
            expression = 'probe_max_equalize != 0'

        Expression:
            parameter = 'probe_bandlimited_click_max_correction'
            expression = 'probe_max_equalize'

        ContextRow:
            group_name = 'memr'

            fmt = ['Ramp from', min_level, 'to', max_level, 'db SPL at', ramp_rate,
                   'dB/s, repeat', trial_n, 'times every', trial_iti, 's']

            Parameter: ramp_rate:
                name = 'ramp_rate'
                default = 17.5

            Parameter: min_level:
                name = 'min_level'
                default = 10

            Parameter: max_level:
                name = 'max_level'
                default = 80

            Parameter: trial_n:
                name = 'trial_n'
                default = 2

            Parameter: trial_iti:
                name = 'trial_iti'
                default = 1

        Parameter:
            label = 'Trial plot group (N)'
            name = 'trial_plot_grouping'
            default = 4
            group_name = 'memr'

        Parameter:
            name = 'trial_duration'
            label = 'Trial duration'
            group_name = 'memr'

        Parameter:
            name = 'probe_rate'
            label = 'Probe rate'
            default = 20
            group_name = 'memr'

        Parameter:
            name = 'max_turntable_speed'
            label = 'Max speed (cm/s)'
            default = 0.5
            group_name = 'memr'

        Expression:
            parameter = 'probe_n'
            expression = 'int(trial_duration * probe_rate)'

        Expression:
            parameter = 'elicitor_noise_duration'
            expression = 'trial_duration'

        Expression:
            parameter = 'elicitor_bandlimited_noise_level'
            expression = 'max_level'

        Expression:
            parameter = 'trial_duration'
            expression = '2 * (max_level - min_level) / ramp_rate'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fl'
            expression = 'elicitor_fl'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fh'
            expression = 'elicitor_fh'

        Expression:
            parameter = 'elicitor_bandlimited_noise_equalize'
            expression = 'elicitor_max_equalize != 0'

        Expression:
            parameter = 'elicitor_bandlimited_noise_max_correction'
            expression = 'elicitor_max_equalize'

        Expression:
            parameter = 'elicitor_bandlimited_noise_audiogram_weighting'
            expression = 'elicitor_audiogram_weighting'

        Expression:
            parameter = 'elicitor_noise_transform'
            expression = 'lambda x: dbi((max_level - min_level) * (x - 1))'

    Extension:
        id = EXPERIMENT + '.swept_memr.sinks'
        point = 'psi.data.sinks'

        SimpleCounter: counter:
            name = 'memr_counter'
            label = 'MEMRs acquired'

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.io'
        point = 'psi.controller.io'

        StackRepeats:
            source_name = 'memr_probe'
            name = 'memr_repeat'
            duration = 1 / C.probe_rate

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                name = 'probe'
                lb = 0.75e-3 + C.probe_click_delay
                ub = lb + C.probe_duration

                ExtractRepeats:
                    name = 'probe_norm_raw'
                    ranges = {
                        'norm': (
                            int(round(0 * C.probe_rate)),
                            int(round(1 * C.probe_rate)),
                        ),
                        'elicitor': (
                            int(round((C.trial_duration / 2 - 0.5) * C.probe_rate)),
                            int(round((C.trial_duration / 2 + 0.5) * C.probe_rate)),
                        )
                    }

                    ProcessSweptMEMR: proc_memr:
                        name = 'probe_norm'
                        force_active = True
                        fl = C.probe_fl
                        fh = C.probe_fh
                        max_turntable_speed = C.max_turntable_speed
                        probe_output = controller.get_output('probe')
                        elicitor_output = controller.get_output('elicitor')
                        counter = counter
                        turntable_sink = data.find_sink('turntable_store') \
                            .get_ai_signal('turntable_linear_velocity')

        ExtractStim:
            source_name = 'memr_elicitor'
            name = 'elicitor'
            lb = 0
            ub = C.trial_duration

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.plots'
        point = 'psi.data.plots'

        EpochTimeContainer: probe_time_container:
            name = 'probe_time_container'
            label = 'Probe waveform'

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_plot.tab_grouping)

            ViewBox: probe_time_vb:
                name = 'probe_time_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochAveragePlot: probe_plot:
                    source_name = 'probe_norm'
                    plot_grouping = ['range']
                    plot_keys = [('norm',), ('elicitor',)]
                    autogenerate_keys = 'neither'

        FFTContainer: probe_fft_container:
            name = 'probe_fft_container'
            label = 'Probe and Elicitor PSD'
            freq_lb = 0.5e3
            freq_ub = 50e3

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_fft_plot.tab_grouping)

            ViewBox:
                name = 'probe_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochFFTPlot: probe_fft_plot:
                    source_name = 'probe_norm'
                    plot_grouping = ['range']
                    plot_keys = [('norm',), ('elicitor',)]
                    autogenerate_keys = 'neither'
                    apply_calibration = True
                    average_mode = 'time'

                GroupedEpochFFTPlot: elicitor_fft_plot:
                    source_name = 'elicitor'
                    apply_calibration = True
                    autogenerate_keys = 'neither'
                    pen_color_cycle = ['k']
                    waveform_averages = 10

        FFTContainer:
            name = 'memr_fft_container'
            label = 'MEMR'
            freq_lb = 4e3
            freq_ub = 32e3

            ViewBox:
                name = 'memr_fft_vb'
                y_mode = 'mouse'
                y_min = -3
                y_max = 3

                GroupedSimultaneousMEMRPlot:
                    plot_keys = [(k,) for k in range(C.trial_n // C.trial_plot_grouping)]
                    group_key => (md):
                        return (), (md['trial'] // C.trial_plot_grouping,)

                    autogenerate_keys = 'neither'
                    name = 'memr_fft_plot'
                    source_name = 'probe_norm'
                    pen_width = 2
                    pen_color_cycle = 'palettable.scientific.sequential.LaJolla_3'
