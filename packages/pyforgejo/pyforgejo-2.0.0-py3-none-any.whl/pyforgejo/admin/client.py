# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.cron import Cron
from ..core.pydantic_utilities import parse_obj_as
from ..errors.forbidden_error import ForbiddenError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError as core_api_error_ApiError
from ..core.jsonable_encoder import jsonable_encoder
from ..errors.not_found_error import NotFoundError
from ..types.email import Email
from ..types.hook import Hook
from ..types.create_hook_option_config import CreateHookOptionConfig
from ..types.create_hook_option_type import CreateHookOptionType
from ..types.organization import Organization
from ..types.quota_group_list import QuotaGroupList
from ..types.create_quota_rule_options import CreateQuotaRuleOptions
from ..types.quota_group import QuotaGroup
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..types.api_error import ApiError as types_api_error_ApiError
from ..errors.conflict_error import ConflictError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.user import User
from ..types.quota_rule_info import QuotaRuleInfo
from .types.admin_search_users_request_sort import AdminSearchUsersRequestSort
import datetime as dt
from ..types.public_key import PublicKey
from ..types.create_org_option_visibility import CreateOrgOptionVisibility
from ..types.quota_info import QuotaInfo
from ..types.create_repo_option_object_format_name import (
    CreateRepoOptionObjectFormatName,
)
from ..types.create_repo_option_trust_model import CreateRepoOptionTrustModel
from ..types.repository import Repository
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AdminClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def cron_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Cron]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Cron]
            CronList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.cron_list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/cron",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Cron],
                    parse_obj_as(
                        type_=typing.List[Cron],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def cron_run(
        self, task: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        task : str
            task to run

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.cron_run(
            task="task",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/cron/{jsonable_encoder(task)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_all_emails(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Email]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Email]
            EmailList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_all_emails()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/emails",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Email],
                    parse_obj_as(
                        type_=typing.List[Email],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def search_emails(
        self,
        *,
        q: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Email]:
        """
        Parameters
        ----------
        q : typing.Optional[str]
            keyword

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Email]
            EmailList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.search_emails()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/emails/search",
            method="GET",
            params={
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Email],
                    parse_obj_as(
                        type_=typing.List[Email],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def list_hooks(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Hook]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Hook]
            HookList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.list_hooks()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/hooks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Hook],
                    parse_obj_as(
                        type_=typing.List[Hook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_hook(
        self,
        *,
        config: CreateHookOptionConfig,
        type: CreateHookOptionType,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        config : CreateHookOptionConfig

        type : CreateHookOptionType

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_hook(
            config={"key": "value"},
            type="forgejo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/hooks",
            method="POST",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
                "type": type,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_hook(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Hook:
        """
        Parameters
        ----------
        id : int
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_hook(
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/hooks/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_hook(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        id : int
            id of the hook to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.delete_hook(
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/hooks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def edit_hook(
        self,
        id: int,
        *,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, str]] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        id : int
            id of the hook to update

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        config : typing.Optional[typing.Dict[str, str]]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.edit_hook(
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/hooks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_all_orgs(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Organization]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Organization]
            OrganizationList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_all_orgs()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/orgs",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Organization],
                    parse_obj_as(
                        type_=typing.List[Organization],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def list_quota_groups(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> QuotaGroupList:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaGroupList
            QuotaGroupList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.list_quota_groups()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/quota/groups",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaGroupList,
                    parse_obj_as(
                        type_=QuotaGroupList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_quota_group(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        rules: typing.Optional[typing.Sequence[CreateQuotaRuleOptions]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaGroup:
        """
        Parameters
        ----------
        name : typing.Optional[str]
            Name of the quota group to create

        rules : typing.Optional[typing.Sequence[CreateQuotaRuleOptions]]
            Rules to add to the newly created group.
            If a rule does not exist, it will be created.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaGroup
            QuotaGroup

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_quota_group()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/quota/groups",
            method="POST",
            json={
                "name": name,
                "rules": convert_and_respect_annotation_metadata(
                    object_=rules,
                    annotation=typing.Sequence[CreateQuotaRuleOptions],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaGroup,
                    parse_obj_as(
                        type_=QuotaGroup,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_quota_group(
        self,
        quotagroup: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaGroup:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to query

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaGroup
            QuotaGroup

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_quota_group(
            quotagroup="quotagroup",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaGroup,
                    parse_obj_as(
                        type_=QuotaGroup,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_quota_group(
        self,
        quotagroup: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.delete_quota_group(
            quotagroup="quotagroup",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def add_rule_to_quota_group(
        self,
        quotagroup: str,
        quotarule: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to add a rule to

        quotarule : str
            the name of the quota rule to add to the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.add_rule_to_quota_group(
            quotagroup="quotagroup",
            quotarule="quotarule",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/rules/{jsonable_encoder(quotarule)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def remove_rule_from_quota_group(
        self,
        quotagroup: str,
        quotarule: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to remove a rule from

        quotarule : str
            the name of the quota rule to remove from the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.remove_rule_from_quota_group(
            quotagroup="quotagroup",
            quotarule="quotarule",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/rules/{jsonable_encoder(quotarule)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def list_users_in_quota_group(
        self,
        quotagroup: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to list members of

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.list_users_in_quota_group(
            quotagroup="quotagroup",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/users",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def add_user_to_quota_group(
        self,
        quotagroup: str,
        username: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to add the user to

        username : str
            username of the user to add to the quota group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.add_user_to_quota_group(
            quotagroup="quotagroup",
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/users/{jsonable_encoder(username)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def remove_user_from_quota_group(
        self,
        quotagroup: str,
        username: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to remove a user from

        username : str
            username of the user to remove from the quota group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.remove_user_from_quota_group(
            quotagroup="quotagroup",
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/users/{jsonable_encoder(username)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def list_quota_rules(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[QuotaRuleInfo]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[QuotaRuleInfo]
            QuotaRuleInfoList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.list_quota_rules()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/quota/rules",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[QuotaRuleInfo],
                    parse_obj_as(
                        type_=typing.List[QuotaRuleInfo],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_quota_rule(
        self,
        *,
        limit: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        subjects: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaRuleInfo:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            The limit set by the rule

        name : typing.Optional[str]
            Name of the rule to create

        subjects : typing.Optional[typing.Sequence[str]]
            The subjects affected by the rule

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaRuleInfo
            QuotaRuleInfo

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_quota_rule()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/quota/rules",
            method="POST",
            json={
                "limit": limit,
                "name": name,
                "subjects": subjects,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaRuleInfo,
                    parse_obj_as(
                        type_=QuotaRuleInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_quota_rule(
        self, quotarule: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> QuotaRuleInfo:
        """
        Parameters
        ----------
        quotarule : str
            quota rule to query

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaRuleInfo
            QuotaRuleInfo

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_quota_rule(
            quotarule="quotarule",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/rules/{jsonable_encoder(quotarule)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaRuleInfo,
                    parse_obj_as(
                        type_=QuotaRuleInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def admin_d_elete_quota_rule(
        self, quotarule: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        quotarule : str
            quota rule to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.admin_d_elete_quota_rule(
            quotarule="quotarule",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/rules/{jsonable_encoder(quotarule)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def edit_quota_rule(
        self,
        quotarule: str,
        *,
        limit: typing.Optional[int] = OMIT,
        subjects: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaRuleInfo:
        """
        Parameters
        ----------
        quotarule : str
            Quota rule to change

        limit : typing.Optional[int]
            The limit set by the rule

        subjects : typing.Optional[typing.Sequence[str]]
            The subjects affected by the rule

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaRuleInfo
            QuotaRuleInfo

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.edit_quota_rule(
            quotarule="quotarule",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/quota/rules/{jsonable_encoder(quotarule)}",
            method="PATCH",
            json={
                "limit": limit,
                "subjects": subjects,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaRuleInfo,
                    parse_obj_as(
                        type_=QuotaRuleInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_runner_registration_token(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_runner_registration_token()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/runners/registration-token",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def unadopted_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        pattern: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[str]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        pattern : typing.Optional[str]
            pattern of repositories to search for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[str]
            StringSlice

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.unadopted_list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/unadopted",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "pattern": pattern,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def adopt_repository(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.adopt_repository(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/unadopted/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_unadopted_repository(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.delete_unadopted_repository(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/unadopted/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def search_users(
        self,
        *,
        source_id: typing.Optional[int] = None,
        login_name: typing.Optional[str] = None,
        sort: typing.Optional[AdminSearchUsersRequestSort] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        source_id : typing.Optional[int]
            ID of the user's login source to search for

        login_name : typing.Optional[str]
            user's login name to search for

        sort : typing.Optional[AdminSearchUsersRequestSort]
            sort order of results

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.search_users()
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/users",
            method="GET",
            params={
                "source_id": source_id,
                "login_name": login_name,
                "sort": sort,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_user(
        self,
        *,
        email: str,
        username: str,
        created_at: typing.Optional[dt.datetime] = OMIT,
        full_name: typing.Optional[str] = OMIT,
        login_name: typing.Optional[str] = OMIT,
        must_change_password: typing.Optional[bool] = OMIT,
        password: typing.Optional[str] = OMIT,
        restricted: typing.Optional[bool] = OMIT,
        send_notify: typing.Optional[bool] = OMIT,
        source_id: typing.Optional[int] = OMIT,
        visibility: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> User:
        """
        Parameters
        ----------
        email : str

        username : str

        created_at : typing.Optional[dt.datetime]
            For explicitly setting the user creation timestamp. Useful when users are
            migrated from other systems. When omitted, the user's creation timestamp
            will be set to "now".

        full_name : typing.Optional[str]

        login_name : typing.Optional[str]

        must_change_password : typing.Optional[bool]

        password : typing.Optional[str]

        restricted : typing.Optional[bool]

        send_notify : typing.Optional[bool]

        source_id : typing.Optional[int]

        visibility : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        User
            User

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_user(
            email="email",
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "admin/users",
            method="POST",
            json={
                "created_at": created_at,
                "email": email,
                "full_name": full_name,
                "login_name": login_name,
                "must_change_password": must_change_password,
                "password": password,
                "restricted": restricted,
                "send_notify": send_notify,
                "source_id": source_id,
                "username": username,
                "visibility": visibility,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    User,
                    parse_obj_as(
                        type_=User,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_user(
        self,
        username: str,
        *,
        purge: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            username of user to delete

        purge : typing.Optional[bool]
            purge the user from the system completely

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.delete_user(
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}",
            method="DELETE",
            params={
                "purge": purge,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def edit_user(
        self,
        username: str,
        *,
        active: typing.Optional[bool] = OMIT,
        admin: typing.Optional[bool] = OMIT,
        allow_create_organization: typing.Optional[bool] = OMIT,
        allow_git_hook: typing.Optional[bool] = OMIT,
        allow_import_local: typing.Optional[bool] = OMIT,
        description: typing.Optional[str] = OMIT,
        email: typing.Optional[str] = OMIT,
        full_name: typing.Optional[str] = OMIT,
        location: typing.Optional[str] = OMIT,
        login_name: typing.Optional[str] = OMIT,
        max_repo_creation: typing.Optional[int] = OMIT,
        must_change_password: typing.Optional[bool] = OMIT,
        password: typing.Optional[str] = OMIT,
        prohibit_login: typing.Optional[bool] = OMIT,
        pronouns: typing.Optional[str] = OMIT,
        restricted: typing.Optional[bool] = OMIT,
        source_id: typing.Optional[int] = OMIT,
        visibility: typing.Optional[str] = OMIT,
        website: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> User:
        """
        Parameters
        ----------
        username : str
            username of user to edit

        active : typing.Optional[bool]

        admin : typing.Optional[bool]

        allow_create_organization : typing.Optional[bool]

        allow_git_hook : typing.Optional[bool]

        allow_import_local : typing.Optional[bool]

        description : typing.Optional[str]

        email : typing.Optional[str]

        full_name : typing.Optional[str]

        location : typing.Optional[str]

        login_name : typing.Optional[str]

        max_repo_creation : typing.Optional[int]

        must_change_password : typing.Optional[bool]

        password : typing.Optional[str]

        prohibit_login : typing.Optional[bool]

        pronouns : typing.Optional[str]

        restricted : typing.Optional[bool]

        source_id : typing.Optional[int]

        visibility : typing.Optional[str]

        website : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        User
            User

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.edit_user(
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}",
            method="PATCH",
            json={
                "active": active,
                "admin": admin,
                "allow_create_organization": allow_create_organization,
                "allow_git_hook": allow_git_hook,
                "allow_import_local": allow_import_local,
                "description": description,
                "email": email,
                "full_name": full_name,
                "location": location,
                "login_name": login_name,
                "max_repo_creation": max_repo_creation,
                "must_change_password": must_change_password,
                "password": password,
                "prohibit_login": prohibit_login,
                "pronouns": pronouns,
                "restricted": restricted,
                "source_id": source_id,
                "visibility": visibility,
                "website": website,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    User,
                    parse_obj_as(
                        type_=User,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_public_key(
        self,
        username: str,
        *,
        key: str,
        title: str,
        read_only: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PublicKey:
        """
        Parameters
        ----------
        username : str
            username of the user

        key : str
            An armored SSH key to add

        title : str
            Title of the key to add

        read_only : typing.Optional[bool]
            Describe if the key has only read access or read/write

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PublicKey
            PublicKey

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_public_key(
            username="username",
            key="key",
            title="title",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/keys",
            method="POST",
            json={
                "key": key,
                "read_only": read_only,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PublicKey,
                    parse_obj_as(
                        type_=PublicKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_user_public_key(
        self,
        username: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            username of user

        id : int
            id of the key to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.delete_user_public_key(
            username="username",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/keys/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_org(
        self,
        username_: str,
        *,
        username: str,
        description: typing.Optional[str] = OMIT,
        email: typing.Optional[str] = OMIT,
        full_name: typing.Optional[str] = OMIT,
        location: typing.Optional[str] = OMIT,
        repo_admin_change_team_access: typing.Optional[bool] = OMIT,
        visibility: typing.Optional[CreateOrgOptionVisibility] = OMIT,
        website: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Organization:
        """
        Parameters
        ----------
        username_ : str
            username of the user that will own the created organization

        username : str

        description : typing.Optional[str]

        email : typing.Optional[str]

        full_name : typing.Optional[str]

        location : typing.Optional[str]

        repo_admin_change_team_access : typing.Optional[bool]

        visibility : typing.Optional[CreateOrgOptionVisibility]
            possible values are `public` (default), `limited` or `private`

        website : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Organization
            Organization

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_org(
            username_="username",
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username_)}/orgs",
            method="POST",
            json={
                "description": description,
                "email": email,
                "full_name": full_name,
                "location": location,
                "repo_admin_change_team_access": repo_admin_change_team_access,
                "username": username,
                "visibility": visibility,
                "website": website,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Organization,
                    parse_obj_as(
                        type_=Organization,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_user_quota(
        self, username: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> QuotaInfo:
        """
        Parameters
        ----------
        username : str
            username of user to query

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaInfo
            QuotaInfo

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.get_user_quota(
            username="username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/quota",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaInfo,
                    parse_obj_as(
                        type_=QuotaInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def set_user_quota_groups(
        self,
        username: str,
        *,
        groups: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            username of the user to modify the quota groups from

        groups : typing.Sequence[str]
            Quota groups the user shall have

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.set_user_quota_groups(
            username="username",
            groups=["groups"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/quota/groups",
            method="POST",
            json={
                "groups": groups,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def rename_user(
        self,
        username: str,
        *,
        new_username: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            existing username of user

        new_username : str
            New username for this user. This name cannot be in use yet by any other user.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.rename_user(
            username="username",
            new_username="new_username",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/rename",
            method="POST",
            json={
                "new_username": new_username,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_repo(
        self,
        username: str,
        *,
        name: str,
        auto_init: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        gitignores: typing.Optional[str] = OMIT,
        issue_labels: typing.Optional[str] = OMIT,
        license: typing.Optional[str] = OMIT,
        object_format_name: typing.Optional[CreateRepoOptionObjectFormatName] = OMIT,
        private: typing.Optional[bool] = OMIT,
        readme: typing.Optional[str] = OMIT,
        template: typing.Optional[bool] = OMIT,
        trust_model: typing.Optional[CreateRepoOptionTrustModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        username : str
            username of the user. This user will own the created repository

        name : str
            Name of the repository to create

        auto_init : typing.Optional[bool]
            Whether the repository should be auto-initialized?

        default_branch : typing.Optional[str]
            DefaultBranch of the repository (used when initializes and in template)

        description : typing.Optional[str]
            Description of the repository to create

        gitignores : typing.Optional[str]
            Gitignores to use

        issue_labels : typing.Optional[str]
            Label-Set to use

        license : typing.Optional[str]
            License to use

        object_format_name : typing.Optional[CreateRepoOptionObjectFormatName]
            ObjectFormatName of the underlying git repository

        private : typing.Optional[bool]
            Whether the repository is private

        readme : typing.Optional[str]
            Readme of the repository to create

        template : typing.Optional[bool]
            Whether the repository is template

        trust_model : typing.Optional[CreateRepoOptionTrustModel]
            TrustModel of the repository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.admin.create_repo(
            username="username",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/repos",
            method="POST",
            json={
                "auto_init": auto_init,
                "default_branch": default_branch,
                "description": description,
                "gitignores": gitignores,
                "issue_labels": issue_labels,
                "license": license,
                "name": name,
                "object_format_name": object_format_name,
                "private": private,
                "readme": readme,
                "template": template,
                "trust_model": trust_model,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )


class AsyncAdminClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def cron_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Cron]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Cron]
            CronList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.cron_list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/cron",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Cron],
                    parse_obj_as(
                        type_=typing.List[Cron],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def cron_run(
        self, task: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        task : str
            task to run

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.cron_run(
                task="task",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/cron/{jsonable_encoder(task)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_all_emails(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Email]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Email]
            EmailList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_all_emails()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/emails",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Email],
                    parse_obj_as(
                        type_=typing.List[Email],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def search_emails(
        self,
        *,
        q: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Email]:
        """
        Parameters
        ----------
        q : typing.Optional[str]
            keyword

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Email]
            EmailList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.search_emails()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/emails/search",
            method="GET",
            params={
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Email],
                    parse_obj_as(
                        type_=typing.List[Email],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def list_hooks(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Hook]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Hook]
            HookList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.list_hooks()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/hooks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Hook],
                    parse_obj_as(
                        type_=typing.List[Hook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_hook(
        self,
        *,
        config: CreateHookOptionConfig,
        type: CreateHookOptionType,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        config : CreateHookOptionConfig

        type : CreateHookOptionType

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_hook(
                config={"key": "value"},
                type="forgejo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/hooks",
            method="POST",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
                "type": type,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_hook(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Hook:
        """
        Parameters
        ----------
        id : int
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_hook(
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/hooks/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_hook(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        id : int
            id of the hook to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.delete_hook(
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/hooks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def edit_hook(
        self,
        id: int,
        *,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, str]] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        id : int
            id of the hook to update

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        config : typing.Optional[typing.Dict[str, str]]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.edit_hook(
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/hooks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_all_orgs(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Organization]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Organization]
            OrganizationList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_all_orgs()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/orgs",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Organization],
                    parse_obj_as(
                        type_=typing.List[Organization],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def list_quota_groups(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> QuotaGroupList:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaGroupList
            QuotaGroupList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.list_quota_groups()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/quota/groups",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaGroupList,
                    parse_obj_as(
                        type_=QuotaGroupList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_quota_group(
        self,
        *,
        name: typing.Optional[str] = OMIT,
        rules: typing.Optional[typing.Sequence[CreateQuotaRuleOptions]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaGroup:
        """
        Parameters
        ----------
        name : typing.Optional[str]
            Name of the quota group to create

        rules : typing.Optional[typing.Sequence[CreateQuotaRuleOptions]]
            Rules to add to the newly created group.
            If a rule does not exist, it will be created.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaGroup
            QuotaGroup

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_quota_group()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/quota/groups",
            method="POST",
            json={
                "name": name,
                "rules": convert_and_respect_annotation_metadata(
                    object_=rules,
                    annotation=typing.Sequence[CreateQuotaRuleOptions],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaGroup,
                    parse_obj_as(
                        type_=QuotaGroup,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_quota_group(
        self,
        quotagroup: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaGroup:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to query

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaGroup
            QuotaGroup

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_quota_group(
                quotagroup="quotagroup",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaGroup,
                    parse_obj_as(
                        type_=QuotaGroup,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_quota_group(
        self,
        quotagroup: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.delete_quota_group(
                quotagroup="quotagroup",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def add_rule_to_quota_group(
        self,
        quotagroup: str,
        quotarule: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to add a rule to

        quotarule : str
            the name of the quota rule to add to the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.add_rule_to_quota_group(
                quotagroup="quotagroup",
                quotarule="quotarule",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/rules/{jsonable_encoder(quotarule)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def remove_rule_from_quota_group(
        self,
        quotagroup: str,
        quotarule: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to remove a rule from

        quotarule : str
            the name of the quota rule to remove from the group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.remove_rule_from_quota_group(
                quotagroup="quotagroup",
                quotarule="quotarule",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/rules/{jsonable_encoder(quotarule)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def list_users_in_quota_group(
        self,
        quotagroup: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to list members of

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.list_users_in_quota_group(
                quotagroup="quotagroup",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/users",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def add_user_to_quota_group(
        self,
        quotagroup: str,
        username: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to add the user to

        username : str
            username of the user to add to the quota group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.add_user_to_quota_group(
                quotagroup="quotagroup",
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/users/{jsonable_encoder(username)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def remove_user_from_quota_group(
        self,
        quotagroup: str,
        username: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        quotagroup : str
            quota group to remove a user from

        username : str
            username of the user to remove from the quota group

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.remove_user_from_quota_group(
                quotagroup="quotagroup",
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/groups/{jsonable_encoder(quotagroup)}/users/{jsonable_encoder(username)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def list_quota_rules(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[QuotaRuleInfo]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[QuotaRuleInfo]
            QuotaRuleInfoList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.list_quota_rules()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/quota/rules",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[QuotaRuleInfo],
                    parse_obj_as(
                        type_=typing.List[QuotaRuleInfo],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_quota_rule(
        self,
        *,
        limit: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        subjects: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaRuleInfo:
        """
        Parameters
        ----------
        limit : typing.Optional[int]
            The limit set by the rule

        name : typing.Optional[str]
            Name of the rule to create

        subjects : typing.Optional[typing.Sequence[str]]
            The subjects affected by the rule

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaRuleInfo
            QuotaRuleInfo

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_quota_rule()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/quota/rules",
            method="POST",
            json={
                "limit": limit,
                "name": name,
                "subjects": subjects,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaRuleInfo,
                    parse_obj_as(
                        type_=QuotaRuleInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_quota_rule(
        self, quotarule: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> QuotaRuleInfo:
        """
        Parameters
        ----------
        quotarule : str
            quota rule to query

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaRuleInfo
            QuotaRuleInfo

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_quota_rule(
                quotarule="quotarule",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/rules/{jsonable_encoder(quotarule)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaRuleInfo,
                    parse_obj_as(
                        type_=QuotaRuleInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def admin_d_elete_quota_rule(
        self, quotarule: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        quotarule : str
            quota rule to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.admin_d_elete_quota_rule(
                quotarule="quotarule",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/rules/{jsonable_encoder(quotarule)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def edit_quota_rule(
        self,
        quotarule: str,
        *,
        limit: typing.Optional[int] = OMIT,
        subjects: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QuotaRuleInfo:
        """
        Parameters
        ----------
        quotarule : str
            Quota rule to change

        limit : typing.Optional[int]
            The limit set by the rule

        subjects : typing.Optional[typing.Sequence[str]]
            The subjects affected by the rule

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaRuleInfo
            QuotaRuleInfo

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.edit_quota_rule(
                quotarule="quotarule",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/quota/rules/{jsonable_encoder(quotarule)}",
            method="PATCH",
            json={
                "limit": limit,
                "subjects": subjects,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaRuleInfo,
                    parse_obj_as(
                        type_=QuotaRuleInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_runner_registration_token(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_runner_registration_token()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/runners/registration-token",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def unadopted_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        pattern: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[str]:
        """
        Parameters
        ----------
        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        pattern : typing.Optional[str]
            pattern of repositories to search for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[str]
            StringSlice

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.unadopted_list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/unadopted",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "pattern": pattern,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def adopt_repository(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.adopt_repository(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/unadopted/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_unadopted_repository(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.delete_unadopted_repository(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/unadopted/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def search_users(
        self,
        *,
        source_id: typing.Optional[int] = None,
        login_name: typing.Optional[str] = None,
        sort: typing.Optional[AdminSearchUsersRequestSort] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        source_id : typing.Optional[int]
            ID of the user's login source to search for

        login_name : typing.Optional[str]
            user's login name to search for

        sort : typing.Optional[AdminSearchUsersRequestSort]
            sort order of results

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.search_users()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/users",
            method="GET",
            params={
                "source_id": source_id,
                "login_name": login_name,
                "sort": sort,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_user(
        self,
        *,
        email: str,
        username: str,
        created_at: typing.Optional[dt.datetime] = OMIT,
        full_name: typing.Optional[str] = OMIT,
        login_name: typing.Optional[str] = OMIT,
        must_change_password: typing.Optional[bool] = OMIT,
        password: typing.Optional[str] = OMIT,
        restricted: typing.Optional[bool] = OMIT,
        send_notify: typing.Optional[bool] = OMIT,
        source_id: typing.Optional[int] = OMIT,
        visibility: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> User:
        """
        Parameters
        ----------
        email : str

        username : str

        created_at : typing.Optional[dt.datetime]
            For explicitly setting the user creation timestamp. Useful when users are
            migrated from other systems. When omitted, the user's creation timestamp
            will be set to "now".

        full_name : typing.Optional[str]

        login_name : typing.Optional[str]

        must_change_password : typing.Optional[bool]

        password : typing.Optional[str]

        restricted : typing.Optional[bool]

        send_notify : typing.Optional[bool]

        source_id : typing.Optional[int]

        visibility : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        User
            User

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_user(
                email="email",
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "admin/users",
            method="POST",
            json={
                "created_at": created_at,
                "email": email,
                "full_name": full_name,
                "login_name": login_name,
                "must_change_password": must_change_password,
                "password": password,
                "restricted": restricted,
                "send_notify": send_notify,
                "source_id": source_id,
                "username": username,
                "visibility": visibility,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    User,
                    parse_obj_as(
                        type_=User,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_user(
        self,
        username: str,
        *,
        purge: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            username of user to delete

        purge : typing.Optional[bool]
            purge the user from the system completely

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.delete_user(
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}",
            method="DELETE",
            params={
                "purge": purge,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def edit_user(
        self,
        username: str,
        *,
        active: typing.Optional[bool] = OMIT,
        admin: typing.Optional[bool] = OMIT,
        allow_create_organization: typing.Optional[bool] = OMIT,
        allow_git_hook: typing.Optional[bool] = OMIT,
        allow_import_local: typing.Optional[bool] = OMIT,
        description: typing.Optional[str] = OMIT,
        email: typing.Optional[str] = OMIT,
        full_name: typing.Optional[str] = OMIT,
        location: typing.Optional[str] = OMIT,
        login_name: typing.Optional[str] = OMIT,
        max_repo_creation: typing.Optional[int] = OMIT,
        must_change_password: typing.Optional[bool] = OMIT,
        password: typing.Optional[str] = OMIT,
        prohibit_login: typing.Optional[bool] = OMIT,
        pronouns: typing.Optional[str] = OMIT,
        restricted: typing.Optional[bool] = OMIT,
        source_id: typing.Optional[int] = OMIT,
        visibility: typing.Optional[str] = OMIT,
        website: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> User:
        """
        Parameters
        ----------
        username : str
            username of user to edit

        active : typing.Optional[bool]

        admin : typing.Optional[bool]

        allow_create_organization : typing.Optional[bool]

        allow_git_hook : typing.Optional[bool]

        allow_import_local : typing.Optional[bool]

        description : typing.Optional[str]

        email : typing.Optional[str]

        full_name : typing.Optional[str]

        location : typing.Optional[str]

        login_name : typing.Optional[str]

        max_repo_creation : typing.Optional[int]

        must_change_password : typing.Optional[bool]

        password : typing.Optional[str]

        prohibit_login : typing.Optional[bool]

        pronouns : typing.Optional[str]

        restricted : typing.Optional[bool]

        source_id : typing.Optional[int]

        visibility : typing.Optional[str]

        website : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        User
            User

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.edit_user(
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}",
            method="PATCH",
            json={
                "active": active,
                "admin": admin,
                "allow_create_organization": allow_create_organization,
                "allow_git_hook": allow_git_hook,
                "allow_import_local": allow_import_local,
                "description": description,
                "email": email,
                "full_name": full_name,
                "location": location,
                "login_name": login_name,
                "max_repo_creation": max_repo_creation,
                "must_change_password": must_change_password,
                "password": password,
                "prohibit_login": prohibit_login,
                "pronouns": pronouns,
                "restricted": restricted,
                "source_id": source_id,
                "visibility": visibility,
                "website": website,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    User,
                    parse_obj_as(
                        type_=User,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_public_key(
        self,
        username: str,
        *,
        key: str,
        title: str,
        read_only: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PublicKey:
        """
        Parameters
        ----------
        username : str
            username of the user

        key : str
            An armored SSH key to add

        title : str
            Title of the key to add

        read_only : typing.Optional[bool]
            Describe if the key has only read access or read/write

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PublicKey
            PublicKey

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_public_key(
                username="username",
                key="key",
                title="title",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/keys",
            method="POST",
            json={
                "key": key,
                "read_only": read_only,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PublicKey,
                    parse_obj_as(
                        type_=PublicKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_user_public_key(
        self,
        username: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            username of user

        id : int
            id of the key to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.delete_user_public_key(
                username="username",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/keys/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_org(
        self,
        username_: str,
        *,
        username: str,
        description: typing.Optional[str] = OMIT,
        email: typing.Optional[str] = OMIT,
        full_name: typing.Optional[str] = OMIT,
        location: typing.Optional[str] = OMIT,
        repo_admin_change_team_access: typing.Optional[bool] = OMIT,
        visibility: typing.Optional[CreateOrgOptionVisibility] = OMIT,
        website: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Organization:
        """
        Parameters
        ----------
        username_ : str
            username of the user that will own the created organization

        username : str

        description : typing.Optional[str]

        email : typing.Optional[str]

        full_name : typing.Optional[str]

        location : typing.Optional[str]

        repo_admin_change_team_access : typing.Optional[bool]

        visibility : typing.Optional[CreateOrgOptionVisibility]
            possible values are `public` (default), `limited` or `private`

        website : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Organization
            Organization

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_org(
                username_="username",
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username_)}/orgs",
            method="POST",
            json={
                "description": description,
                "email": email,
                "full_name": full_name,
                "location": location,
                "repo_admin_change_team_access": repo_admin_change_team_access,
                "username": username,
                "visibility": visibility,
                "website": website,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Organization,
                    parse_obj_as(
                        type_=Organization,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_user_quota(
        self, username: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> QuotaInfo:
        """
        Parameters
        ----------
        username : str
            username of user to query

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QuotaInfo
            QuotaInfo

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.get_user_quota(
                username="username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/quota",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    QuotaInfo,
                    parse_obj_as(
                        type_=QuotaInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def set_user_quota_groups(
        self,
        username: str,
        *,
        groups: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            username of the user to modify the quota groups from

        groups : typing.Sequence[str]
            Quota groups the user shall have

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.set_user_quota_groups(
                username="username",
                groups=["groups"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/quota/groups",
            method="POST",
            json={
                "groups": groups,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def rename_user(
        self,
        username: str,
        *,
        new_username: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        username : str
            existing username of user

        new_username : str
            New username for this user. This name cannot be in use yet by any other user.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.rename_user(
                username="username",
                new_username="new_username",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/rename",
            method="POST",
            json={
                "new_username": new_username,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_repo(
        self,
        username: str,
        *,
        name: str,
        auto_init: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        gitignores: typing.Optional[str] = OMIT,
        issue_labels: typing.Optional[str] = OMIT,
        license: typing.Optional[str] = OMIT,
        object_format_name: typing.Optional[CreateRepoOptionObjectFormatName] = OMIT,
        private: typing.Optional[bool] = OMIT,
        readme: typing.Optional[str] = OMIT,
        template: typing.Optional[bool] = OMIT,
        trust_model: typing.Optional[CreateRepoOptionTrustModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        username : str
            username of the user. This user will own the created repository

        name : str
            Name of the repository to create

        auto_init : typing.Optional[bool]
            Whether the repository should be auto-initialized?

        default_branch : typing.Optional[str]
            DefaultBranch of the repository (used when initializes and in template)

        description : typing.Optional[str]
            Description of the repository to create

        gitignores : typing.Optional[str]
            Gitignores to use

        issue_labels : typing.Optional[str]
            Label-Set to use

        license : typing.Optional[str]
            License to use

        object_format_name : typing.Optional[CreateRepoOptionObjectFormatName]
            ObjectFormatName of the underlying git repository

        private : typing.Optional[bool]
            Whether the repository is private

        readme : typing.Optional[str]
            Readme of the repository to create

        template : typing.Optional[bool]
            Whether the repository is template

        trust_model : typing.Optional[CreateRepoOptionTrustModel]
            TrustModel of the repository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.admin.create_repo(
                username="username",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"admin/users/{jsonable_encoder(username)}/repos",
            method="POST",
            json={
                "auto_init": auto_init,
                "default_branch": default_branch,
                "description": description,
                "gitignores": gitignores,
                "issue_labels": issue_labels,
                "license": license,
                "name": name,
                "object_format_name": object_format_name,
                "private": private,
                "readme": readme,
                "template": template,
                "trust_model": trust_model,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )
