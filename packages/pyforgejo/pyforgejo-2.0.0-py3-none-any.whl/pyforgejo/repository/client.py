# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.migrate_repo_options_service import MigrateRepoOptionsService
from ..core.request_options import RequestOptions
from ..types.repository import Repository
from ..core.pydantic_utilities import parse_obj_as
from ..errors.forbidden_error import ForbiddenError
from ..errors.conflict_error import ConflictError
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError as core_api_error_ApiError
from ..types.search_results import SearchResults
from ..core.jsonable_encoder import jsonable_encoder
from ..errors.not_found_error import NotFoundError
from ..types.external_tracker import ExternalTracker
from ..types.external_wiki import ExternalWiki
from ..types.internal_tracker import InternalTracker
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.secret import Secret
from ..errors.bad_request_error import BadRequestError
from ..types.api_error import ApiError as types_api_error_ApiError
from ..types.action_task_response import ActionTaskResponse
from ..types.action_variable import ActionVariable
from ..types.activity import Activity
from ..types.user import User
from ..types.branch_protection import BranchProtection
from ..errors.locked_error import LockedError
from ..types.api_repo_archived_error import ApiRepoArchivedError
from ..types.branch import Branch
from .types.add_collaborator_option_permission import AddCollaboratorOptionPermission
from ..types.repo_collaborator_permission import RepoCollaboratorPermission
from ..types.commit import Commit
from ..types.combined_status import CombinedStatus
from .types.repo_list_statuses_by_ref_request_sort import (
    RepoListStatusesByRefRequestSort,
)
from .types.repo_list_statuses_by_ref_request_state import (
    RepoListStatusesByRefRequestState,
)
from ..types.commit_status import CommitStatus
from ..types.pull_request import PullRequest
from ..types.compare import Compare
from ..types.contents_response import ContentsResponse
from ..types.change_file_operation import ChangeFileOperation
from ..types.identity import Identity
from ..types.commit_date_options import CommitDateOptions
from ..types.files_response import FilesResponse
from ..types.file_response import FileResponse
from ..types.file_delete_response import FileDeleteResponse
from ..types.git_blob_response import GitBlobResponse
from .types.repo_download_commit_diff_or_patch_request_diff_type import (
    RepoDownloadCommitDiffOrPatchRequestDiffType,
)
from ..types.note import Note
from ..types.reference import Reference
from ..types.annotated_tag import AnnotatedTag
from ..types.git_tree_response import GitTreeResponse
from ..types.hook import Hook
from ..types.create_hook_option_config import CreateHookOptionConfig
from ..types.create_hook_option_type import CreateHookOptionType
from ..types.git_hook import GitHook
from ..types.issue_config import IssueConfig
from ..types.issue_config_validation import IssueConfigValidation
from ..types.issue_template import IssueTemplate
from ..types.issue import Issue
from ..types.deploy_key import DeployKey
from ..types.new_issue_pins_allowed import NewIssuePinsAllowed
from .types.repo_list_pull_requests_request_state import (
    RepoListPullRequestsRequestState,
)
from .types.repo_list_pull_requests_request_sort import RepoListPullRequestsRequestSort
from ..errors.internal_server_error import InternalServerError
import datetime as dt
from ..errors.precondition_failed_error import PreconditionFailedError
from .types.repo_download_pull_diff_or_patch_request_diff_type import (
    RepoDownloadPullDiffOrPatchRequestDiffType,
)
from .types.repo_get_pull_request_files_request_whitespace import (
    RepoGetPullRequestFilesRequestWhitespace,
)
from ..types.changed_file import ChangedFile
from .types.merge_pull_request_option_do import MergePullRequestOptionDo
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..types.pull_review import PullReview
from ..types.create_pull_review_comment import CreatePullReviewComment
from ..types.review_state_type import ReviewStateType
from ..types.pull_review_comment import PullReviewComment
from .types.repo_update_pull_request_request_style import (
    RepoUpdatePullRequestRequestStyle,
)
from ..types.push_mirror import PushMirror
from ..types.release import Release
from ..types.attachment import Attachment
from .. import core
from .types.repo_list_statuses_request_sort import RepoListStatusesRequestSort
from .types.repo_list_statuses_request_state import RepoListStatusesRequestState
from ..types.commit_status_state import CommitStatusState
from ..types.watch_info import WatchInfo
from ..types.tag_protection import TagProtection
from ..types.tag import Tag
from ..types.team import Team
from ..types.tracked_time import TrackedTime
from ..core.datetime_utils import serialize_datetime
from ..types.topic_name import TopicName
from ..types.wiki_page import WikiPage
from ..types.wiki_page_meta_data import WikiPageMetaData
from ..types.wiki_commit_list import WikiCommitList
from ..types.topic_response import TopicResponse
from ..types.create_repo_option_object_format_name import (
    CreateRepoOptionObjectFormatName,
)
from ..types.create_repo_option_trust_model import CreateRepoOptionTrustModel
from ..errors.unauthorized_error import UnauthorizedError
from ..types.api_unauthorized_error import ApiUnauthorizedError
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RepositoryClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def repo_migrate(
        self,
        *,
        clone_addr: str,
        repo_name: str,
        auth_password: typing.Optional[str] = OMIT,
        auth_token: typing.Optional[str] = OMIT,
        auth_username: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        issues: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        lfs: typing.Optional[bool] = OMIT,
        lfs_endpoint: typing.Optional[str] = OMIT,
        milestones: typing.Optional[bool] = OMIT,
        mirror: typing.Optional[bool] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        pull_requests: typing.Optional[bool] = OMIT,
        releases: typing.Optional[bool] = OMIT,
        repo_owner: typing.Optional[str] = OMIT,
        service: typing.Optional[MigrateRepoOptionsService] = OMIT,
        uid: typing.Optional[int] = OMIT,
        wiki: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        clone_addr : str

        repo_name : str

        auth_password : typing.Optional[str]

        auth_token : typing.Optional[str]

        auth_username : typing.Optional[str]

        description : typing.Optional[str]

        issues : typing.Optional[bool]

        labels : typing.Optional[bool]

        lfs : typing.Optional[bool]

        lfs_endpoint : typing.Optional[str]

        milestones : typing.Optional[bool]

        mirror : typing.Optional[bool]

        mirror_interval : typing.Optional[str]

        private : typing.Optional[bool]

        pull_requests : typing.Optional[bool]

        releases : typing.Optional[bool]

        repo_owner : typing.Optional[str]
            Name of User or Organisation who will own Repo after migration

        service : typing.Optional[MigrateRepoOptionsService]

        uid : typing.Optional[int]
            deprecated (only for backwards compatibility)

        wiki : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_migrate(
            clone_addr="clone_addr",
            repo_name="repo_name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "repos/migrate",
            method="POST",
            json={
                "auth_password": auth_password,
                "auth_token": auth_token,
                "auth_username": auth_username,
                "clone_addr": clone_addr,
                "description": description,
                "issues": issues,
                "labels": labels,
                "lfs": lfs,
                "lfs_endpoint": lfs_endpoint,
                "milestones": milestones,
                "mirror": mirror,
                "mirror_interval": mirror_interval,
                "private": private,
                "pull_requests": pull_requests,
                "releases": releases,
                "repo_name": repo_name,
                "repo_owner": repo_owner,
                "service": service,
                "uid": uid,
                "wiki": wiki,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_search(
        self,
        *,
        q: typing.Optional[str] = None,
        topic: typing.Optional[bool] = None,
        include_desc: typing.Optional[bool] = None,
        uid: typing.Optional[int] = None,
        priority_owner_id: typing.Optional[int] = None,
        team_id: typing.Optional[int] = None,
        starred_by: typing.Optional[int] = None,
        private: typing.Optional[bool] = None,
        is_private: typing.Optional[bool] = None,
        template: typing.Optional[bool] = None,
        archived: typing.Optional[bool] = None,
        mode: typing.Optional[str] = None,
        exclusive: typing.Optional[bool] = None,
        sort: typing.Optional[str] = None,
        order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SearchResults:
        """
        Parameters
        ----------
        q : typing.Optional[str]
            keyword

        topic : typing.Optional[bool]
            Limit search to repositories with keyword as topic

        include_desc : typing.Optional[bool]
            include search of keyword within repository description

        uid : typing.Optional[int]
            search only for repos that the user with the given id owns or contributes to

        priority_owner_id : typing.Optional[int]
            repo owner to prioritize in the results

        team_id : typing.Optional[int]
            search only for repos that belong to the given team id

        starred_by : typing.Optional[int]
            search only for repos that the user with the given id has starred

        private : typing.Optional[bool]
            include private repositories this user has access to (defaults to true)

        is_private : typing.Optional[bool]
            show only pubic, private or all repositories (defaults to all)

        template : typing.Optional[bool]
            include template repositories this user has access to (defaults to true)

        archived : typing.Optional[bool]
            show only archived, non-archived or all repositories (defaults to all)

        mode : typing.Optional[str]
            type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative"

        exclusive : typing.Optional[bool]
            if `uid` is given, search only for repos that the user owns

        sort : typing.Optional[str]
            sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha"

        order : typing.Optional[str]
            sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SearchResults
            SearchResults

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_search()
        """
        _response = self._client_wrapper.httpx_client.request(
            "repos/search",
            method="GET",
            params={
                "q": q,
                "topic": topic,
                "includeDesc": include_desc,
                "uid": uid,
                "priority_owner_id": priority_owner_id,
                "team_id": team_id,
                "starredBy": starred_by,
                "private": private,
                "is_private": is_private,
                "template": template,
                "archived": archived,
                "mode": mode,
                "exclusive": exclusive,
                "sort": sort,
                "order": order,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SearchResults,
                    parse_obj_as(
                        type_=SearchResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to delete

        repo : str
            name of the repo to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit(
        self,
        owner: str,
        repo: str,
        *,
        allow_fast_forward_only_merge: typing.Optional[bool] = OMIT,
        allow_manual_merge: typing.Optional[bool] = OMIT,
        allow_merge_commits: typing.Optional[bool] = OMIT,
        allow_rebase: typing.Optional[bool] = OMIT,
        allow_rebase_explicit: typing.Optional[bool] = OMIT,
        allow_rebase_update: typing.Optional[bool] = OMIT,
        allow_squash_merge: typing.Optional[bool] = OMIT,
        archived: typing.Optional[bool] = OMIT,
        autodetect_manual_merge: typing.Optional[bool] = OMIT,
        default_allow_maintainer_edit: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        default_delete_branch_after_merge: typing.Optional[bool] = OMIT,
        default_merge_style: typing.Optional[str] = OMIT,
        default_update_style: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        enable_prune: typing.Optional[bool] = OMIT,
        external_tracker: typing.Optional[ExternalTracker] = OMIT,
        external_wiki: typing.Optional[ExternalWiki] = OMIT,
        globally_editable_wiki: typing.Optional[bool] = OMIT,
        has_actions: typing.Optional[bool] = OMIT,
        has_issues: typing.Optional[bool] = OMIT,
        has_packages: typing.Optional[bool] = OMIT,
        has_projects: typing.Optional[bool] = OMIT,
        has_pull_requests: typing.Optional[bool] = OMIT,
        has_releases: typing.Optional[bool] = OMIT,
        has_wiki: typing.Optional[bool] = OMIT,
        ignore_whitespace_conflicts: typing.Optional[bool] = OMIT,
        internal_tracker: typing.Optional[InternalTracker] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        template: typing.Optional[bool] = OMIT,
        website: typing.Optional[str] = OMIT,
        wiki_branch: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to edit

        repo : str
            name of the repo to edit

        allow_fast_forward_only_merge : typing.Optional[bool]
            either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging.

        allow_manual_merge : typing.Optional[bool]
            either `true` to allow mark pr as merged manually, or `false` to prevent it.

        allow_merge_commits : typing.Optional[bool]
            either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.

        allow_rebase : typing.Optional[bool]
            either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.

        allow_rebase_explicit : typing.Optional[bool]
            either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.

        allow_rebase_update : typing.Optional[bool]
            either `true` to allow updating pull request branch by rebase, or `false` to prevent it.

        allow_squash_merge : typing.Optional[bool]
            either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.

        archived : typing.Optional[bool]
            set to `true` to archive this repository.

        autodetect_manual_merge : typing.Optional[bool]
            either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.

        default_allow_maintainer_edit : typing.Optional[bool]
            set to `true` to allow edits from maintainers by default

        default_branch : typing.Optional[str]
            sets the default branch for this repository.

        default_delete_branch_after_merge : typing.Optional[bool]
            set to `true` to delete pr branch after merge by default

        default_merge_style : typing.Optional[str]
            set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", or "fast-forward-only".

        default_update_style : typing.Optional[str]
            set to a update style to be used by this repository: "rebase" or "merge"

        description : typing.Optional[str]
            a short description of the repository.

        enable_prune : typing.Optional[bool]
            enable prune - remove obsolete remote-tracking references when mirroring

        external_tracker : typing.Optional[ExternalTracker]

        external_wiki : typing.Optional[ExternalWiki]

        globally_editable_wiki : typing.Optional[bool]
            set the globally editable state of the wiki

        has_actions : typing.Optional[bool]
            either `true` to enable actions unit, or `false` to disable them.

        has_issues : typing.Optional[bool]
            either `true` to enable issues for this repository or `false` to disable them.

        has_packages : typing.Optional[bool]
            either `true` to enable packages unit, or `false` to disable them.

        has_projects : typing.Optional[bool]
            either `true` to enable project unit, or `false` to disable them.

        has_pull_requests : typing.Optional[bool]
            either `true` to allow pull requests, or `false` to prevent pull request.

        has_releases : typing.Optional[bool]
            either `true` to enable releases unit, or `false` to disable them.

        has_wiki : typing.Optional[bool]
            either `true` to enable the wiki for this repository or `false` to disable it.

        ignore_whitespace_conflicts : typing.Optional[bool]
            either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.

        internal_tracker : typing.Optional[InternalTracker]

        mirror_interval : typing.Optional[str]
            set to a string like `8h30m0s` to set the mirror interval time

        name : typing.Optional[str]
            name of the repository

        private : typing.Optional[bool]
            either `true` to make the repository private or `false` to make it public.
            Note: you will get a 422 error if the organization restricts changing repository visibility to organization
            owners and a non-owner tries to change the value of private.

        template : typing.Optional[bool]
            either `true` to make this repository a template or `false` to make it a normal repository

        website : typing.Optional[str]
            a URL with more information about the repository.

        wiki_branch : typing.Optional[str]
            sets the branch used for this repository's wiki.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="PATCH",
            json={
                "allow_fast_forward_only_merge": allow_fast_forward_only_merge,
                "allow_manual_merge": allow_manual_merge,
                "allow_merge_commits": allow_merge_commits,
                "allow_rebase": allow_rebase,
                "allow_rebase_explicit": allow_rebase_explicit,
                "allow_rebase_update": allow_rebase_update,
                "allow_squash_merge": allow_squash_merge,
                "archived": archived,
                "autodetect_manual_merge": autodetect_manual_merge,
                "default_allow_maintainer_edit": default_allow_maintainer_edit,
                "default_branch": default_branch,
                "default_delete_branch_after_merge": default_delete_branch_after_merge,
                "default_merge_style": default_merge_style,
                "default_update_style": default_update_style,
                "description": description,
                "enable_prune": enable_prune,
                "external_tracker": convert_and_respect_annotation_metadata(
                    object_=external_tracker,
                    annotation=ExternalTracker,
                    direction="write",
                ),
                "external_wiki": convert_and_respect_annotation_metadata(
                    object_=external_wiki, annotation=ExternalWiki, direction="write"
                ),
                "globally_editable_wiki": globally_editable_wiki,
                "has_actions": has_actions,
                "has_issues": has_issues,
                "has_packages": has_packages,
                "has_projects": has_projects,
                "has_pull_requests": has_pull_requests,
                "has_releases": has_releases,
                "has_wiki": has_wiki,
                "ignore_whitespace_conflicts": ignore_whitespace_conflicts,
                "internal_tracker": convert_and_respect_annotation_metadata(
                    object_=internal_tracker,
                    annotation=InternalTracker,
                    direction="write",
                ),
                "mirror_interval": mirror_interval,
                "name": name,
                "private": private,
                "template": template,
                "website": website,
                "wiki_branch": wiki_branch,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_runner_registration_token(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_runner_registration_token(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runners/registration-token",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_actions_secrets(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Secret]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Secret]
            SecretList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_actions_secrets(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Secret],
                    parse_obj_as(
                        type_=typing.List[Secret],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def update_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        data: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        data : str
            Data of the secret to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.update_repo_secret(
            owner="owner",
            repo="repo",
            secretname="secretname",
            data="data",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="PUT",
            json={
                "data": data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.delete_repo_secret(
            owner="owner",
            repo="repo",
            secretname="secretname",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def list_action_tasks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActionTaskResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActionTaskResponse
            TasksList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.list_action_tasks(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/tasks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActionTaskResponse,
                    parse_obj_as(
                        type_=ActionTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_repo_variables_list(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ActionVariable]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ActionVariable]
            VariableList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.get_repo_variables_list(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ActionVariable],
                    parse_obj_as(
                        type_=typing.List[ActionVariable],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActionVariable:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActionVariable
            ActionVariable

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.get_repo_variable(
            owner="owner",
            repo="repo",
            variablename="variablename",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActionVariable,
                    parse_obj_as(
                        type_=ActionVariable,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to create

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.create_repo_variable(
            owner="owner",
            repo="repo",
            variablename="variablename",
            value="value",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="POST",
            json={
                "value": value,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def update_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to update

        name : typing.Optional[str]
            New name for the variable. If the field is empty, the variable name won't be updated.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.update_repo_variable(
            owner="owner",
            repo="repo",
            variablename="variablename",
            value="value",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="PUT",
            json={
                "name": name,
                "value": value,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def delete_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActionVariable:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActionVariable
            ActionVariable

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.delete_repo_variable(
            owner="owner",
            repo="repo",
            variablename="variablename",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActionVariable,
                    parse_obj_as(
                        type_=ActionVariable,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def dispatch_workflow(
        self,
        owner: str,
        repo: str,
        workflowname: str,
        *,
        ref: str,
        inputs: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        workflowname : str
            name of the workflow

        ref : str
            Git reference for the workflow

        inputs : typing.Optional[typing.Dict[str, str]]
            Input keys and values configured in the workflow file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.dispatch_workflow(
            owner="owner",
            repo="repo",
            workflowname="workflowname",
            ref="ref",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/workflows/{jsonable_encoder(workflowname)}/dispatches",
            method="POST",
            json={
                "inputs": inputs,
                "ref": ref,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_activity_feeds(
        self,
        owner: str,
        repo: str,
        *,
        date: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Activity]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        date : typing.Optional[str]
            the date of the activities to be found

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Activity]
            ActivityFeedsList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_activity_feeds(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/activities/feeds",
            method="GET",
            params={
                "date": date,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Activity],
                    parse_obj_as(
                        type_=typing.List[Activity],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_archive(
        self,
        owner: str,
        repo: str,
        archive: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        archive : str
            the git reference for download with attached archive format (e.g. master.zip)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_archive(
            owner="owner",
            repo="repo",
            archive="archive",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/archive/{jsonable_encoder(archive)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_assignees(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_assignees(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/assignees",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_update_avatar(
        self,
        owner: str,
        repo: str,
        *,
        image: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        image : typing.Optional[str]
            image must be base64 encoded

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_update_avatar(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="POST",
            json={
                "image": image,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_avatar(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_avatar(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[BranchProtection]
            BranchProtectionList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_branch_protection(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[BranchProtection],
                    parse_obj_as(
                        type_=typing.List[BranchProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        branch_name: typing.Optional[str] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        rule_name: typing.Optional[str] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BranchProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        branch_name : typing.Optional[str]
            Deprecated: true

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        rule_name : typing.Optional[str]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BranchProtection
            BranchProtection

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_branch_protection(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="POST",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "branch_name": branch_name,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "rule_name": rule_name,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BranchProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BranchProtection
            BranchProtection

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_branch_protection(
            owner="owner",
            repo="repo",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_branch_protection(
            owner="owner",
            repo="repo",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BranchProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BranchProtection
            BranchProtection

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_branch_protection(
            owner="owner",
            repo="repo",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="PATCH",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_branches(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Branch]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Branch]
            BranchList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_branches(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Branch],
                    parse_obj_as(
                        type_=typing.List[Branch],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_branch(
        self,
        owner: str,
        repo: str,
        *,
        new_branch_name: str,
        old_branch_name: typing.Optional[str] = OMIT,
        old_ref_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Branch:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        new_branch_name : str
            Name of the branch to create

        old_branch_name : typing.Optional[str]
            Deprecated: true
            Name of the old branch to create from

        old_ref_name : typing.Optional[str]
            Name of the old branch/tag/commit to create from

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Branch
            Branch

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_branch(
            owner="owner",
            repo="repo",
            new_branch_name="new_branch_name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="POST",
            json={
                "new_branch_name": new_branch_name,
                "old_branch_name": old_branch_name,
                "old_ref_name": old_ref_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Branch:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Branch
            Branch

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_branch(
            owner="owner",
            repo="repo",
            branch="branch",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_branch(
            owner="owner",
            repo="repo",
            branch="branch",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_update_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            name of the branch

        name : str
            New branch name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_update_branch(
            owner="owner",
            repo="repo",
            branch="branch",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="PATCH",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_collaborators(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_collaborators(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_check_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_check_collaborator(
            owner="owner",
            repo="repo",
            collaborator="collaborator",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_add_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        permission: typing.Optional[AddCollaboratorOptionPermission] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to add

        permission : typing.Optional[AddCollaboratorOptionPermission]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_add_collaborator(
            owner="owner",
            repo="repo",
            collaborator="collaborator",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="PUT",
            json={
                "permission": permission,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_collaborator(
            owner="owner",
            repo="repo",
            collaborator="collaborator",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_repo_permissions(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RepoCollaboratorPermission:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RepoCollaboratorPermission
            RepoCollaboratorPermission

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_repo_permissions(
            owner="owner",
            repo="repo",
            collaborator="collaborator",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}/permission",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RepoCollaboratorPermission,
                    parse_obj_as(
                        type_=RepoCollaboratorPermission,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_all_commits(
        self,
        owner: str,
        repo: str,
        *,
        sha: typing.Optional[str] = None,
        path: typing.Optional[str] = None,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        not_: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Commit]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : typing.Optional[str]
            SHA or branch to start listing commits from (usually 'master')

        path : typing.Optional[str]
            filepath of a file/dir

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results (ignored if used with 'path')

        not_ : typing.Optional[str]
            commits that match the given specifier will not be listed.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Commit]
            CommitList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_all_commits(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits",
            method="GET",
            params={
                "sha": sha,
                "path": path,
                "stat": stat,
                "verification": verification,
                "files": files,
                "page": page,
                "limit": limit,
                "not": not_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_combined_status_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CombinedStatus:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CombinedStatus
            CombinedStatus

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_combined_status_by_ref(
            owner="owner",
            repo="repo",
            ref="ref",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/status",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CombinedStatus,
                    parse_obj_as(
                        type_=CombinedStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_statuses_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        sort: typing.Optional[RepoListStatusesByRefRequestSort] = None,
        state: typing.Optional[RepoListStatusesByRefRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[CommitStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        sort : typing.Optional[RepoListStatusesByRefRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesByRefRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[CommitStatus]
            CommitStatusList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_statuses_by_ref(
            owner="owner",
            repo="repo",
            ref="ref",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/statuses",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_commit_pull_request(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_commit_pull_request(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(sha)}/pull",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_compare_diff(
        self,
        owner: str,
        repo: str,
        basehead: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Compare:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        basehead : str
            compare two branches or commits

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Compare


        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_compare_diff(
            owner="owner",
            repo="repo",
            basehead="basehead",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/compare/{jsonable_encoder(basehead)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Compare,
                    parse_obj_as(
                        type_=Compare,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_contents_list(
        self,
        owner: str,
        repo: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ContentsResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ContentsResponse]
            ContentsListResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_contents_list(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ContentsResponse],
                    parse_obj_as(
                        type_=typing.List[ContentsResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_change_files(
        self,
        owner: str,
        repo: str,
        *,
        files: typing.Sequence[ChangeFileOperation],
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FilesResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        files : typing.Sequence[ChangeFileOperation]
            list of file operations

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FilesResponse
            FilesResponse

        Examples
        --------
        from pyforgejo import ChangeFileOperation, PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_change_files(
            owner="owner",
            repo="repo",
            files=[
                ChangeFileOperation(
                    operation="create",
                    path="path",
                )
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[ChangeFileOperation],
                    direction="write",
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FilesResponse,
                    parse_obj_as(
                        type_=FilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_contents(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ContentsResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the dir, file, symlink or submodule in the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ContentsResponse
            ContentsResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_contents(
            owner="owner",
            repo="repo",
            filepath="filepath",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ContentsResponse,
                    parse_obj_as(
                        type_=ContentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to create

        content : str
            content must be base64 encoded

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            FileResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_file(
            owner="owner",
            repo="repo",
            filepath="filepath",
            content="content",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_update_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to update

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            FileResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_update_file(
            owner="owner",
            repo="repo",
            filepath="filepath",
            content="content",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="PUT",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileDeleteResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to delete

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileDeleteResponse
            FileDeleteResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_file(
            owner="owner",
            repo="repo",
            filepath="filepath",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="DELETE",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileDeleteResponse,
                    parse_obj_as(
                        type_=FileDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_apply_diff_patch(
        self,
        owner: str,
        repo: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            FileResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_apply_diff_patch(
            owner="owner",
            repo="repo",
            content="content",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/diffpatch",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_editor_config(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_editor_config(
            owner="owner",
            repo="repo",
            filepath="filepath",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/editorconfig/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[str]
            StringSlice

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_flags(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_replace_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        flags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flags : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_replace_all_flags(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="PUT",
            json={
                "flags": flags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_all_flags(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_check_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_check_flag(
            owner="owner",
            repo="repo",
            flag="flag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_add_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_add_flag(
            owner="owner",
            repo="repo",
            flag="flag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_flag(
            owner="owner",
            repo="repo",
            flag="flag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def list_forks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Repository]
            RepositoryList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.list_forks(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Repository],
                    parse_obj_as(
                        type_=typing.List[Repository],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_fork(
        self,
        owner: str,
        repo: str,
        *,
        name: typing.Optional[str] = OMIT,
        organization: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to fork

        repo : str
            name of the repo to fork

        name : typing.Optional[str]
            name of the forked repository

        organization : typing.Optional[str]
            organization name, if forking into an organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.create_fork(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="POST",
            json={
                "name": name,
                "organization": organization,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_blob(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitBlobResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitBlobResponse
            GitBlobResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.get_blob(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/blobs/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitBlobResponse,
                    parse_obj_as(
                        type_=GitBlobResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_single_commit(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Commit:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Commit
            Commit

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_single_commit(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "stat": stat,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Commit,
                    parse_obj_as(
                        type_=Commit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_download_commit_diff_or_patch(
        self,
        owner: str,
        repo: str,
        sha: str,
        diff_type: RepoDownloadCommitDiffOrPatchRequestDiffType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> str:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        diff_type : RepoDownloadCommitDiffOrPatchRequestDiffType
            whether the output is diff or patch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        str
            APIString is a string response

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_download_commit_diff_or_patch(
            owner="owner",
            repo="repo",
            sha="sha",
            diff_type="diff",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}.{jsonable_encoder(diff_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Note:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Note
            Note

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_note(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_set_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        message: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Note:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        message : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Note
            Note

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_set_note(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "message": message,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_remove_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_remove_note(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_all_git_refs(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Reference]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Reference]
            ReferenceList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_all_git_refs(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_git_refs(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Reference]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            part or full name of the ref

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Reference]
            ReferenceList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_git_refs(
            owner="owner",
            repo="repo",
            ref="ref",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs/{jsonable_encoder(ref)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_annotated_tag(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AnnotatedTag:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AnnotatedTag
            AnnotatedTag

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.get_annotated_tag(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/tags/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AnnotatedTag,
                    parse_obj_as(
                        type_=AnnotatedTag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def get_tree(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        recursive: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitTreeResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        recursive : typing.Optional[bool]
            show all directories and files

        page : typing.Optional[int]
            page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page

        per_page : typing.Optional[int]
            number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitTreeResponse
            GitTreeResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.get_tree(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/trees/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "recursive": recursive,
                "page": page,
                "per_page": per_page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitTreeResponse,
                    parse_obj_as(
                        type_=GitTreeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_hooks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Hook]
            HookList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_hooks(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Hook],
                    parse_obj_as(
                        type_=typing.List[Hook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_hook(
        self,
        owner: str,
        repo: str,
        *,
        config: CreateHookOptionConfig,
        type: CreateHookOptionType,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        config : CreateHookOptionConfig

        type : CreateHookOptionType

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_hook(
            owner="owner",
            repo="repo",
            config={"key": "value"},
            type="forgejo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="POST",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
                "type": type,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_git_hooks(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[GitHook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[GitHook]
            GitHookList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_git_hooks(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[GitHook],
                    parse_obj_as(
                        type_=typing.List[GitHook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitHook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitHook
            GitHook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_git_hook(
            owner="owner",
            repo="repo",
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_git_hook(
            owner="owner",
            repo="repo",
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitHook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitHook
            GitHook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_git_hook(
            owner="owner",
            repo="repo",
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_hook(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_hook(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, str]] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            index of the hook

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        config : typing.Optional[typing.Dict[str, str]]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_hook(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_test_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to test

        ref : typing.Optional[str]
            The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_test_hook(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}/tests",
            method="POST",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> IssueConfig:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IssueConfig
            RepoIssueConfig

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_issue_config(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    IssueConfig,
                    parse_obj_as(
                        type_=IssueConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_validate_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> IssueConfigValidation:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IssueConfigValidation
            RepoIssueConfigValidation

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_validate_issue_config(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config/validate",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    IssueConfigValidation,
                    parse_obj_as(
                        type_=IssueConfigValidation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_issue_templates(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[IssueTemplate]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[IssueTemplate]
            IssueTemplates

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_issue_templates(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_templates",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[IssueTemplate],
                    parse_obj_as(
                        type_=typing.List[IssueTemplate],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_pinned_issues(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Issue]
            IssueList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_pinned_issues(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_keys(
        self,
        owner: str,
        repo: str,
        *,
        key_id: typing.Optional[int] = None,
        fingerprint: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[DeployKey]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key_id : typing.Optional[int]
            the key_id to search for

        fingerprint : typing.Optional[str]
            fingerprint of the key

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[DeployKey]
            DeployKeyList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_keys(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="GET",
            params={
                "key_id": key_id,
                "fingerprint": fingerprint,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[DeployKey],
                    parse_obj_as(
                        type_=typing.List[DeployKey],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_key(
        self,
        owner: str,
        repo: str,
        *,
        key: str,
        title: str,
        read_only: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeployKey:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key : str
            An armored SSH key to add

        title : str
            Title of the key to add

        read_only : typing.Optional[bool]
            Describe if the key has only read access or read/write

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeployKey
            DeployKey

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_key(
            owner="owner",
            repo="repo",
            key="key",
            title="title",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="POST",
            json={
                "key": key,
                "read_only": read_only,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeployKey:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeployKey
            DeployKey

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_key(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_key(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_languages(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, int]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, int]
            LanguageStatistics

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_languages(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/languages",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, int],
                    parse_obj_as(
                        type_=typing.Dict[str, int],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_raw_file_or_lfs(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]
            Returns raw file content.
        """
        with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/media/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = (
                        request_options.get("chunk_size", None)
                        if request_options is not None
                        else None
                    )
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise core_api_error_ApiError(
                    status_code=_response.status_code, body=_response.text
                )
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response_json
            )

    def repo_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_mirror_sync(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/mirror-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_new_pin_allowed(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> NewIssuePinsAllowed:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NewIssuePinsAllowed
            RepoNewIssuePinsAllowed

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_new_pin_allowed(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/new_pin_allowed",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    NewIssuePinsAllowed,
                    parse_obj_as(
                        type_=NewIssuePinsAllowed,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[RepoListPullRequestsRequestState] = None,
        sort: typing.Optional[RepoListPullRequestsRequestSort] = None,
        milestone: typing.Optional[int] = None,
        labels: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        poster: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            Owner of the repo

        repo : str
            Name of the repo

        state : typing.Optional[RepoListPullRequestsRequestState]
            State of pull request

        sort : typing.Optional[RepoListPullRequestsRequestSort]
            Type of sort

        milestone : typing.Optional[int]
            ID of the milestone

        labels : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Label IDs

        poster : typing.Optional[str]
            Filter by pull request author

        page : typing.Optional[int]
            Page number of results to return (1-based)

        limit : typing.Optional[int]
            Page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullRequest]
            PullRequestList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_pull_requests(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="GET",
            params={
                "state": state,
                "sort": sort,
                "milestone": milestone,
                "labels": labels,
                "poster": poster,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_pull_request(
        self,
        owner: str,
        repo: str,
        *,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        head: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        head : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_pull_request(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="POST",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "head": head,
                "labels": labels,
                "milestone": milestone,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_pinned_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullRequest]
            PullRequestList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_pinned_pull_requests(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_request_by_base_head(
        self,
        owner: str,
        repo: str,
        base: str,
        head: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        base : str
            base of the pull request to get

        head : str
            head of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_request_by_base_head(
            owner="owner",
            repo="repo",
            base="base",
            head="head",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(base)}/{jsonable_encoder(head)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_request(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        allow_maintainer_edit: typing.Optional[bool] = OMIT,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        unset_due_date: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to edit

        allow_maintainer_edit : typing.Optional[bool]

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        state : typing.Optional[str]

        title : typing.Optional[str]

        unset_due_date : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_pull_request(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="PATCH",
            json={
                "allow_maintainer_edit": allow_maintainer_edit,
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "labels": labels,
                "milestone": milestone,
                "state": state,
                "title": title,
                "unset_due_date": unset_due_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_download_pull_diff_or_patch(
        self,
        owner: str,
        repo: str,
        index: int,
        diff_type: RepoDownloadPullDiffOrPatchRequestDiffType,
        *,
        binary: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> str:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        diff_type : RepoDownloadPullDiffOrPatchRequestDiffType
            whether the output is diff or patch

        binary : typing.Optional[bool]
            whether to include binary file changes. if true, the diff is applicable with `git apply`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        str
            APIString is a string response

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_download_pull_diff_or_patch(
            owner="owner",
            repo="repo",
            index=1000000,
            diff_type="diff",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}.{jsonable_encoder(diff_type)}",
            method="GET",
            params={
                "binary": binary,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_request_commits(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Commit]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Commit]
            CommitList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_request_commits(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/commits",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_request_files(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        skip_to: typing.Optional[str] = None,
        whitespace: typing.Optional[RepoGetPullRequestFilesRequestWhitespace] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ChangedFile]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        skip_to : typing.Optional[str]
            skip to given file

        whitespace : typing.Optional[RepoGetPullRequestFilesRequestWhitespace]
            whitespace behavior

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ChangedFile]
            ChangedFileList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_request_files(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/files",
            method="GET",
            params={
                "skip-to": skip_to,
                "whitespace": whitespace,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ChangedFile],
                    parse_obj_as(
                        type_=typing.List[ChangedFile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_pull_request_is_merged(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_pull_request_is_merged(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_merge_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        do: MergePullRequestOptionDo,
        merge_commit_id: typing.Optional[str] = OMIT,
        merge_message_field: typing.Optional[str] = OMIT,
        merge_title_field: typing.Optional[str] = OMIT,
        delete_branch_after_merge: typing.Optional[bool] = OMIT,
        force_merge: typing.Optional[bool] = OMIT,
        head_commit_id: typing.Optional[str] = OMIT,
        merge_when_checks_succeed: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        do : MergePullRequestOptionDo

        merge_commit_id : typing.Optional[str]

        merge_message_field : typing.Optional[str]

        merge_title_field : typing.Optional[str]

        delete_branch_after_merge : typing.Optional[bool]

        force_merge : typing.Optional[bool]

        head_commit_id : typing.Optional[str]

        merge_when_checks_succeed : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_merge_pull_request(
            owner="owner",
            repo="repo",
            index=1000000,
            do="merge",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="POST",
            json={
                "Do": do,
                "MergeCommitID": merge_commit_id,
                "MergeMessageField": merge_message_field,
                "MergeTitleField": merge_title_field,
                "delete_branch_after_merge": delete_branch_after_merge,
                "force_merge": force_merge,
                "head_commit_id": head_commit_id,
                "merge_when_checks_succeed": merge_when_checks_succeed,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_cancel_scheduled_auto_merge(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_cancel_scheduled_auto_merge(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullReview]
            PullReviewList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_pull_review_requests(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="POST",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_pull_review_requests(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="DELETE",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_pull_reviews(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullReview]
            PullReviewList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_pull_reviews(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        body: typing.Optional[str] = OMIT,
        comments: typing.Optional[typing.Sequence[CreatePullReviewComment]] = OMIT,
        commit_id: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        body : typing.Optional[str]

        comments : typing.Optional[typing.Sequence[CreatePullReviewComment]]

        commit_id : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_pull_review(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="POST",
            json={
                "body": body,
                "comments": convert_and_respect_annotation_metadata(
                    object_=comments,
                    annotation=typing.Sequence[CreatePullReviewComment],
                    direction="write",
                ),
                "commit_id": commit_id,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_review(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_submit_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_submit_pull_review(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="POST",
            json={
                "body": body,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_pull_review(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_review_comments(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullReviewComment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullReviewComment]
            PullCommentList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_review_comments(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullReviewComment],
                    parse_obj_as(
                        type_=typing.List[PullReviewComment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        new_position: typing.Optional[int] = OMIT,
        old_position: typing.Optional[int] = OMIT,
        path: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReviewComment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        new_position : typing.Optional[int]
            if comment to new file line or 0

        old_position : typing.Optional[int]
            if comment to old file line or 0

        path : typing.Optional[str]
            the tree path

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReviewComment
            PullComment

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_pull_review_comment(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="POST",
            json={
                "body": body,
                "new_position": new_position,
                "old_position": old_position,
                "path": path,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReviewComment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReviewComment
            PullComment

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_pull_review_comment(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
            comment=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_pull_review_comment(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
            comment=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        message: typing.Optional[str] = OMIT,
        priors: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        message : typing.Optional[str]

        priors : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_dismiss_pull_review(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/dismissals",
            method="POST",
            json={
                "message": message,
                "priors": priors,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_un_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_un_dismiss_pull_review(
            owner="owner",
            repo="repo",
            index=1000000,
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/undismissals",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_update_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        style: typing.Optional[RepoUpdatePullRequestRequestStyle] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        style : typing.Optional[RepoUpdatePullRequestRequestStyle]
            how to update pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_update_pull_request(
            owner="owner",
            repo="repo",
            index=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/update",
            method="POST",
            params={
                "style": style,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_push_mirrors(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PushMirror]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PushMirror]
            PushMirrorList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_push_mirrors(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PushMirror],
                    parse_obj_as(
                        type_=typing.List[PushMirror],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_add_push_mirror(
        self,
        owner: str,
        repo: str,
        *,
        interval: typing.Optional[str] = OMIT,
        remote_address: typing.Optional[str] = OMIT,
        remote_password: typing.Optional[str] = OMIT,
        remote_username: typing.Optional[str] = OMIT,
        sync_on_commit: typing.Optional[bool] = OMIT,
        use_ssh: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PushMirror:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        interval : typing.Optional[str]

        remote_address : typing.Optional[str]

        remote_password : typing.Optional[str]

        remote_username : typing.Optional[str]

        sync_on_commit : typing.Optional[bool]

        use_ssh : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PushMirror
            PushMirror

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_add_push_mirror(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="POST",
            json={
                "interval": interval,
                "remote_address": remote_address,
                "remote_password": remote_password,
                "remote_username": remote_username,
                "sync_on_commit": sync_on_commit,
                "use_ssh": use_ssh,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_push_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_push_mirror_sync(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_push_mirror_by_remote_name(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PushMirror:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of push mirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PushMirror
            PushMirror

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_push_mirror_by_remote_name(
            owner="owner",
            repo="repo",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_push_mirror(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of the pushMirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_push_mirror(
            owner="owner",
            repo="repo",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_raw_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]
            Returns raw file content.
        """
        with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/raw/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = (
                        request_options.get("chunk_size", None)
                        if request_options is not None
                        else None
                    )
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise core_api_error_ApiError(
                    status_code=_response.status_code, body=_response.text
                )
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response_json
            )

    def repo_list_releases(
        self,
        owner: str,
        repo: str,
        *,
        draft: typing.Optional[bool] = None,
        pre_release: typing.Optional[bool] = None,
        q: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        draft : typing.Optional[bool]
            filter (exclude / include) drafts, if you dont have repo write access none will show

        pre_release : typing.Optional[bool]
            filter (exclude / include) pre-releases

        q : typing.Optional[str]
            Search string

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Release]
            ReleaseList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_releases(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="GET",
            params={
                "draft": draft,
                "pre-release": pre_release,
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Release],
                    parse_obj_as(
                        type_=typing.List[Release],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_release(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_release(
            owner="owner",
            repo="repo",
            tag_name="tag_name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="POST",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_latest_release(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_latest_release(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/latest",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_release_by_tag(
            owner="owner",
            repo="repo",
            tag="tag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_release_by_tag(
            owner="owner",
            repo="repo",
            tag="tag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_release(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_release(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        tag_name: typing.Optional[str] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to edit

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        tag_name : typing.Optional[str]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_release(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_release_attachments(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Attachment]
            AttachmentList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_release_attachments(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        name: typing.Optional[str] = None,
        attachment: typing.Optional[core.File] = OMIT,
        external_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Attachment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        name : typing.Optional[str]
            name of the attachment

        attachment : typing.Optional[core.File]
            See core.File for more documentation

        external_url : typing.Optional[str]
            url to external asset (this parameter is incompatible with `attachment`)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Attachment
            Attachment

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_release_attachment(
            owner="owner",
            repo="repo",
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="POST",
            params={
                "name": name,
            },
            data={
                "external_url": external_url,
            },
            files={
                "attachment": attachment,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Attachment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Attachment
            Attachment

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_release_attachment(
            owner="owner",
            repo="repo",
            id=1000000,
            attachment_id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_release_attachment(
            owner="owner",
            repo="repo",
            id=1000000,
            attachment_id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Attachment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Attachment
            Attachment

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_release_attachment(
            owner="owner",
            repo="repo",
            id=1000000,
            attachment_id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_reviewers(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_reviewers(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/reviewers",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_signing_key(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> str:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        str
            GPG armored public key

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_signing_key(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/signing-key.gpg",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return _response.text  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_stargazers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_stargazers(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/stargazers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_statuses(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        sort: typing.Optional[RepoListStatusesRequestSort] = None,
        state: typing.Optional[RepoListStatusesRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[CommitStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        sort : typing.Optional[RepoListStatusesRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[CommitStatus]
            CommitStatusList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_statuses(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_status(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        context: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        state: typing.Optional[CommitStatusState] = OMIT,
        target_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommitStatus:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        context : typing.Optional[str]

        description : typing.Optional[str]

        state : typing.Optional[CommitStatusState]

        target_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommitStatus
            CommitStatus

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_status(
            owner="owner",
            repo="repo",
            sha="sha",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "context": context,
                "description": description,
                "state": state,
                "target_url": target_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CommitStatus,
                    parse_obj_as(
                        type_=CommitStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_subscribers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_subscribers(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscribers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def user_current_check_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WatchInfo:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WatchInfo
            WatchInfo

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.user_current_check_subscription(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def user_current_put_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WatchInfo:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WatchInfo
            WatchInfo

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.user_current_put_subscription(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def user_current_delete_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.user_current_delete_subscription(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TagProtection]
            TagProtectionList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_tag_protection(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TagProtection],
                    parse_obj_as(
                        type_=typing.List[TagProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TagProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TagProtection
            TagProtection

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_tag_protection(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="POST",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TagProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the tag protect to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TagProtection
            TagProtection

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_tag_protection(
            owner="owner",
            repo="repo",
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_tag_protection(
            owner="owner",
            repo="repo",
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TagProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TagProtection
            TagProtection

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_tag_protection(
            owner="owner",
            repo="repo",
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_tags(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Tag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Tag]
            TagList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_tags(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Tag],
                    parse_obj_as(
                        type_=typing.List[Tag],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_tag(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        message: typing.Optional[str] = OMIT,
        target: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Tag:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        message : typing.Optional[str]

        target : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Tag
            Tag

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_tag(
            owner="owner",
            repo="repo",
            tag_name="tag_name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="POST",
            json={
                "message": message,
                "tag_name": tag_name,
                "target": target,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Tag:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Tag
            Tag

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_tag(
            owner="owner",
            repo="repo",
            tag="tag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_tag(
            owner="owner",
            repo="repo",
            tag="tag",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_teams(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Team]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Team]
            TeamList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_teams(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Team],
                    parse_obj_as(
                        type_=typing.List[Team],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_check_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Team:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Team
            Team

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_check_team(
            owner="owner",
            repo="repo",
            team="team",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Team,
                    parse_obj_as(
                        type_=Team,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_add_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_add_team(
            owner="owner",
            repo="repo",
            team="team",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_team(
            owner="owner",
            repo="repo",
            team="team",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_tracked_times(
        self,
        owner: str,
        repo: str,
        *,
        user: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TrackedTime]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : typing.Optional[str]
            optional filter by user (available for issue managers)

        since : typing.Optional[dt.datetime]
            Only show times updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show times updated before the given time. This is a timestamp in RFC 3339 format

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TrackedTime]
            TrackedTimeList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_tracked_times(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times",
            method="GET",
            params={
                "user": user,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def user_tracked_times(
        self,
        owner: str,
        repo: str,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TrackedTime]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : str
            username of user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TrackedTime]
            TrackedTimeList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.user_tracked_times(
            owner="owner",
            repo="repo",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times/{jsonable_encoder(user)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_list_topics(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TopicName:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TopicName
            TopicNames

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_list_topics(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TopicName,
                    parse_obj_as(
                        type_=TopicName,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_update_topics(
        self,
        owner: str,
        repo: str,
        *,
        topics: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topics : typing.Optional[typing.Sequence[str]]
            list of topic names

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_update_topics(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="PUT",
            json={
                "topics": topics,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_add_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to add

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_add_topic(
            owner="owner",
            repo="repo",
            topic="topic",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_topic(
            owner="owner",
            repo="repo",
            topic="topic",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        new_owner: str,
        team_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        new_owner : str

        team_ids : typing.Optional[typing.Sequence[int]]
            ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_transfer(
            owner="owner",
            repo="repo",
            new_owner="new_owner",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer",
            method="POST",
            json={
                "new_owner": new_owner,
                "team_ids": team_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def accept_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.accept_repo_transfer(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/accept",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def reject_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.reject_repo_transfer(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/reject",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_create_wiki_page(
        self,
        owner: str,
        repo: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiPage:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiPage
            WikiPage

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_create_wiki_page(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/new",
            method="POST",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiPage:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiPage
            WikiPage

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_wiki_page(
            owner="owner",
            repo="repo",
            page_name="pageName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_delete_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_delete_wiki_page(
            owner="owner",
            repo="repo",
            page_name="pageName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_edit_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiPage:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiPage
            WikiPage

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_edit_wiki_page(
            owner="owner",
            repo="repo",
            page_name="pageName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="PATCH",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_wiki_pages(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WikiPageMetaData]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WikiPageMetaData]
            WikiPageList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_wiki_pages(
            owner="owner",
            repo="repo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/pages",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WikiPageMetaData],
                    parse_obj_as(
                        type_=typing.List[WikiPageMetaData],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_wiki_page_revisions(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiCommitList:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        page : typing.Optional[int]
            page number of results to return (1-based)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiCommitList
            WikiCommitList

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_wiki_page_revisions(
            owner="owner",
            repo="repo",
            page_name="pageName",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/revisions/{jsonable_encoder(page_name)}",
            method="GET",
            params={
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiCommitList,
                    parse_obj_as(
                        type_=WikiCommitList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def generate_repo(
        self,
        template_owner: str,
        template_repo: str,
        *,
        name: str,
        owner: str,
        avatar: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        git_content: typing.Optional[bool] = OMIT,
        git_hooks: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        private: typing.Optional[bool] = OMIT,
        protected_branch: typing.Optional[bool] = OMIT,
        topics: typing.Optional[bool] = OMIT,
        webhooks: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        template_owner : str
            name of the template repository owner

        template_repo : str
            name of the template repository

        name : str
            Name of the repository to create

        owner : str
            The organization or person who will own the new repository

        avatar : typing.Optional[bool]
            include avatar of the template repo

        default_branch : typing.Optional[str]
            Default branch of the new repository

        description : typing.Optional[str]
            Description of the repository to create

        git_content : typing.Optional[bool]
            include git content of default branch in template repo

        git_hooks : typing.Optional[bool]
            include git hooks in template repo

        labels : typing.Optional[bool]
            include labels in template repo

        private : typing.Optional[bool]
            Whether the repository is private

        protected_branch : typing.Optional[bool]
            include protected branches in template repo

        topics : typing.Optional[bool]
            include topics in template repo

        webhooks : typing.Optional[bool]
            include webhooks in template repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.generate_repo(
            template_owner="template_owner",
            template_repo="template_repo",
            name="name",
            owner="owner",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(template_owner)}/{jsonable_encoder(template_repo)}/generate",
            method="POST",
            json={
                "avatar": avatar,
                "default_branch": default_branch,
                "description": description,
                "git_content": git_content,
                "git_hooks": git_hooks,
                "labels": labels,
                "name": name,
                "owner": owner,
                "private": private,
                "protected_branch": protected_branch,
                "topics": topics,
                "webhooks": webhooks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def repo_get_by_id(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Repository:
        """
        Parameters
        ----------
        id : int
            id of the repo to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.repo_get_by_id(
            id=1000000,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repositories/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def topic_search(
        self,
        *,
        q: str,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TopicResponse]:
        """
        Parameters
        ----------
        q : str
            keywords to search

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TopicResponse]
            TopicListResponse

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.topic_search(
            q="q",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "topics/search",
            method="GET",
            params={
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TopicResponse],
                    parse_obj_as(
                        type_=typing.List[TopicResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    def create_current_user_repo(
        self,
        *,
        name: str,
        auto_init: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        gitignores: typing.Optional[str] = OMIT,
        issue_labels: typing.Optional[str] = OMIT,
        license: typing.Optional[str] = OMIT,
        object_format_name: typing.Optional[CreateRepoOptionObjectFormatName] = OMIT,
        private: typing.Optional[bool] = OMIT,
        readme: typing.Optional[str] = OMIT,
        template: typing.Optional[bool] = OMIT,
        trust_model: typing.Optional[CreateRepoOptionTrustModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        name : str
            Name of the repository to create

        auto_init : typing.Optional[bool]
            Whether the repository should be auto-initialized?

        default_branch : typing.Optional[str]
            DefaultBranch of the repository (used when initializes and in template)

        description : typing.Optional[str]
            Description of the repository to create

        gitignores : typing.Optional[str]
            Gitignores to use

        issue_labels : typing.Optional[str]
            Label-Set to use

        license : typing.Optional[str]
            License to use

        object_format_name : typing.Optional[CreateRepoOptionObjectFormatName]
            ObjectFormatName of the underlying git repository

        private : typing.Optional[bool]
            Whether the repository is private

        readme : typing.Optional[str]
            Readme of the repository to create

        template : typing.Optional[bool]
            Whether the repository is template

        trust_model : typing.Optional[CreateRepoOptionTrustModel]
            TrustModel of the repository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        from pyforgejo import PyforgejoApi

        client = PyforgejoApi(
            api_key="YOUR_API_KEY",
        )
        client.repository.create_current_user_repo(
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "user/repos",
            method="POST",
            json={
                "auto_init": auto_init,
                "default_branch": default_branch,
                "description": description,
                "gitignores": gitignores,
                "issue_labels": issue_labels,
                "license": license,
                "name": name,
                "object_format_name": object_format_name,
                "private": private,
                "readme": readme,
                "template": template,
                "trust_model": trust_model,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        ApiUnauthorizedError,
                        parse_obj_as(
                            type_=ApiUnauthorizedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )


class AsyncRepositoryClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def repo_migrate(
        self,
        *,
        clone_addr: str,
        repo_name: str,
        auth_password: typing.Optional[str] = OMIT,
        auth_token: typing.Optional[str] = OMIT,
        auth_username: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        issues: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        lfs: typing.Optional[bool] = OMIT,
        lfs_endpoint: typing.Optional[str] = OMIT,
        milestones: typing.Optional[bool] = OMIT,
        mirror: typing.Optional[bool] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        pull_requests: typing.Optional[bool] = OMIT,
        releases: typing.Optional[bool] = OMIT,
        repo_owner: typing.Optional[str] = OMIT,
        service: typing.Optional[MigrateRepoOptionsService] = OMIT,
        uid: typing.Optional[int] = OMIT,
        wiki: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        clone_addr : str

        repo_name : str

        auth_password : typing.Optional[str]

        auth_token : typing.Optional[str]

        auth_username : typing.Optional[str]

        description : typing.Optional[str]

        issues : typing.Optional[bool]

        labels : typing.Optional[bool]

        lfs : typing.Optional[bool]

        lfs_endpoint : typing.Optional[str]

        milestones : typing.Optional[bool]

        mirror : typing.Optional[bool]

        mirror_interval : typing.Optional[str]

        private : typing.Optional[bool]

        pull_requests : typing.Optional[bool]

        releases : typing.Optional[bool]

        repo_owner : typing.Optional[str]
            Name of User or Organisation who will own Repo after migration

        service : typing.Optional[MigrateRepoOptionsService]

        uid : typing.Optional[int]
            deprecated (only for backwards compatibility)

        wiki : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_migrate(
                clone_addr="clone_addr",
                repo_name="repo_name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "repos/migrate",
            method="POST",
            json={
                "auth_password": auth_password,
                "auth_token": auth_token,
                "auth_username": auth_username,
                "clone_addr": clone_addr,
                "description": description,
                "issues": issues,
                "labels": labels,
                "lfs": lfs,
                "lfs_endpoint": lfs_endpoint,
                "milestones": milestones,
                "mirror": mirror,
                "mirror_interval": mirror_interval,
                "private": private,
                "pull_requests": pull_requests,
                "releases": releases,
                "repo_name": repo_name,
                "repo_owner": repo_owner,
                "service": service,
                "uid": uid,
                "wiki": wiki,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_search(
        self,
        *,
        q: typing.Optional[str] = None,
        topic: typing.Optional[bool] = None,
        include_desc: typing.Optional[bool] = None,
        uid: typing.Optional[int] = None,
        priority_owner_id: typing.Optional[int] = None,
        team_id: typing.Optional[int] = None,
        starred_by: typing.Optional[int] = None,
        private: typing.Optional[bool] = None,
        is_private: typing.Optional[bool] = None,
        template: typing.Optional[bool] = None,
        archived: typing.Optional[bool] = None,
        mode: typing.Optional[str] = None,
        exclusive: typing.Optional[bool] = None,
        sort: typing.Optional[str] = None,
        order: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SearchResults:
        """
        Parameters
        ----------
        q : typing.Optional[str]
            keyword

        topic : typing.Optional[bool]
            Limit search to repositories with keyword as topic

        include_desc : typing.Optional[bool]
            include search of keyword within repository description

        uid : typing.Optional[int]
            search only for repos that the user with the given id owns or contributes to

        priority_owner_id : typing.Optional[int]
            repo owner to prioritize in the results

        team_id : typing.Optional[int]
            search only for repos that belong to the given team id

        starred_by : typing.Optional[int]
            search only for repos that the user with the given id has starred

        private : typing.Optional[bool]
            include private repositories this user has access to (defaults to true)

        is_private : typing.Optional[bool]
            show only pubic, private or all repositories (defaults to all)

        template : typing.Optional[bool]
            include template repositories this user has access to (defaults to true)

        archived : typing.Optional[bool]
            show only archived, non-archived or all repositories (defaults to all)

        mode : typing.Optional[str]
            type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative"

        exclusive : typing.Optional[bool]
            if `uid` is given, search only for repos that the user owns

        sort : typing.Optional[str]
            sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha"

        order : typing.Optional[str]
            sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SearchResults
            SearchResults

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_search()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "repos/search",
            method="GET",
            params={
                "q": q,
                "topic": topic,
                "includeDesc": include_desc,
                "uid": uid,
                "priority_owner_id": priority_owner_id,
                "team_id": team_id,
                "starredBy": starred_by,
                "private": private,
                "is_private": is_private,
                "template": template,
                "archived": archived,
                "mode": mode,
                "exclusive": exclusive,
                "sort": sort,
                "order": order,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SearchResults,
                    parse_obj_as(
                        type_=SearchResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to delete

        repo : str
            name of the repo to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit(
        self,
        owner: str,
        repo: str,
        *,
        allow_fast_forward_only_merge: typing.Optional[bool] = OMIT,
        allow_manual_merge: typing.Optional[bool] = OMIT,
        allow_merge_commits: typing.Optional[bool] = OMIT,
        allow_rebase: typing.Optional[bool] = OMIT,
        allow_rebase_explicit: typing.Optional[bool] = OMIT,
        allow_rebase_update: typing.Optional[bool] = OMIT,
        allow_squash_merge: typing.Optional[bool] = OMIT,
        archived: typing.Optional[bool] = OMIT,
        autodetect_manual_merge: typing.Optional[bool] = OMIT,
        default_allow_maintainer_edit: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        default_delete_branch_after_merge: typing.Optional[bool] = OMIT,
        default_merge_style: typing.Optional[str] = OMIT,
        default_update_style: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        enable_prune: typing.Optional[bool] = OMIT,
        external_tracker: typing.Optional[ExternalTracker] = OMIT,
        external_wiki: typing.Optional[ExternalWiki] = OMIT,
        globally_editable_wiki: typing.Optional[bool] = OMIT,
        has_actions: typing.Optional[bool] = OMIT,
        has_issues: typing.Optional[bool] = OMIT,
        has_packages: typing.Optional[bool] = OMIT,
        has_projects: typing.Optional[bool] = OMIT,
        has_pull_requests: typing.Optional[bool] = OMIT,
        has_releases: typing.Optional[bool] = OMIT,
        has_wiki: typing.Optional[bool] = OMIT,
        ignore_whitespace_conflicts: typing.Optional[bool] = OMIT,
        internal_tracker: typing.Optional[InternalTracker] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        template: typing.Optional[bool] = OMIT,
        website: typing.Optional[str] = OMIT,
        wiki_branch: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to edit

        repo : str
            name of the repo to edit

        allow_fast_forward_only_merge : typing.Optional[bool]
            either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging.

        allow_manual_merge : typing.Optional[bool]
            either `true` to allow mark pr as merged manually, or `false` to prevent it.

        allow_merge_commits : typing.Optional[bool]
            either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.

        allow_rebase : typing.Optional[bool]
            either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.

        allow_rebase_explicit : typing.Optional[bool]
            either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.

        allow_rebase_update : typing.Optional[bool]
            either `true` to allow updating pull request branch by rebase, or `false` to prevent it.

        allow_squash_merge : typing.Optional[bool]
            either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.

        archived : typing.Optional[bool]
            set to `true` to archive this repository.

        autodetect_manual_merge : typing.Optional[bool]
            either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.

        default_allow_maintainer_edit : typing.Optional[bool]
            set to `true` to allow edits from maintainers by default

        default_branch : typing.Optional[str]
            sets the default branch for this repository.

        default_delete_branch_after_merge : typing.Optional[bool]
            set to `true` to delete pr branch after merge by default

        default_merge_style : typing.Optional[str]
            set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", or "fast-forward-only".

        default_update_style : typing.Optional[str]
            set to a update style to be used by this repository: "rebase" or "merge"

        description : typing.Optional[str]
            a short description of the repository.

        enable_prune : typing.Optional[bool]
            enable prune - remove obsolete remote-tracking references when mirroring

        external_tracker : typing.Optional[ExternalTracker]

        external_wiki : typing.Optional[ExternalWiki]

        globally_editable_wiki : typing.Optional[bool]
            set the globally editable state of the wiki

        has_actions : typing.Optional[bool]
            either `true` to enable actions unit, or `false` to disable them.

        has_issues : typing.Optional[bool]
            either `true` to enable issues for this repository or `false` to disable them.

        has_packages : typing.Optional[bool]
            either `true` to enable packages unit, or `false` to disable them.

        has_projects : typing.Optional[bool]
            either `true` to enable project unit, or `false` to disable them.

        has_pull_requests : typing.Optional[bool]
            either `true` to allow pull requests, or `false` to prevent pull request.

        has_releases : typing.Optional[bool]
            either `true` to enable releases unit, or `false` to disable them.

        has_wiki : typing.Optional[bool]
            either `true` to enable the wiki for this repository or `false` to disable it.

        ignore_whitespace_conflicts : typing.Optional[bool]
            either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.

        internal_tracker : typing.Optional[InternalTracker]

        mirror_interval : typing.Optional[str]
            set to a string like `8h30m0s` to set the mirror interval time

        name : typing.Optional[str]
            name of the repository

        private : typing.Optional[bool]
            either `true` to make the repository private or `false` to make it public.
            Note: you will get a 422 error if the organization restricts changing repository visibility to organization
            owners and a non-owner tries to change the value of private.

        template : typing.Optional[bool]
            either `true` to make this repository a template or `false` to make it a normal repository

        website : typing.Optional[str]
            a URL with more information about the repository.

        wiki_branch : typing.Optional[str]
            sets the branch used for this repository's wiki.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="PATCH",
            json={
                "allow_fast_forward_only_merge": allow_fast_forward_only_merge,
                "allow_manual_merge": allow_manual_merge,
                "allow_merge_commits": allow_merge_commits,
                "allow_rebase": allow_rebase,
                "allow_rebase_explicit": allow_rebase_explicit,
                "allow_rebase_update": allow_rebase_update,
                "allow_squash_merge": allow_squash_merge,
                "archived": archived,
                "autodetect_manual_merge": autodetect_manual_merge,
                "default_allow_maintainer_edit": default_allow_maintainer_edit,
                "default_branch": default_branch,
                "default_delete_branch_after_merge": default_delete_branch_after_merge,
                "default_merge_style": default_merge_style,
                "default_update_style": default_update_style,
                "description": description,
                "enable_prune": enable_prune,
                "external_tracker": convert_and_respect_annotation_metadata(
                    object_=external_tracker,
                    annotation=ExternalTracker,
                    direction="write",
                ),
                "external_wiki": convert_and_respect_annotation_metadata(
                    object_=external_wiki, annotation=ExternalWiki, direction="write"
                ),
                "globally_editable_wiki": globally_editable_wiki,
                "has_actions": has_actions,
                "has_issues": has_issues,
                "has_packages": has_packages,
                "has_projects": has_projects,
                "has_pull_requests": has_pull_requests,
                "has_releases": has_releases,
                "has_wiki": has_wiki,
                "ignore_whitespace_conflicts": ignore_whitespace_conflicts,
                "internal_tracker": convert_and_respect_annotation_metadata(
                    object_=internal_tracker,
                    annotation=InternalTracker,
                    direction="write",
                ),
                "mirror_interval": mirror_interval,
                "name": name,
                "private": private,
                "template": template,
                "website": website,
                "wiki_branch": wiki_branch,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_runner_registration_token(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_runner_registration_token(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runners/registration-token",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_actions_secrets(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Secret]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Secret]
            SecretList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_actions_secrets(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Secret],
                    parse_obj_as(
                        type_=typing.List[Secret],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def update_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        data: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        data : str
            Data of the secret to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.update_repo_secret(
                owner="owner",
                repo="repo",
                secretname="secretname",
                data="data",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="PUT",
            json={
                "data": data,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.delete_repo_secret(
                owner="owner",
                repo="repo",
                secretname="secretname",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def list_action_tasks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActionTaskResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActionTaskResponse
            TasksList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.list_action_tasks(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/tasks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActionTaskResponse,
                    parse_obj_as(
                        type_=ActionTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_repo_variables_list(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ActionVariable]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ActionVariable]
            VariableList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.get_repo_variables_list(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ActionVariable],
                    parse_obj_as(
                        type_=typing.List[ActionVariable],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActionVariable:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActionVariable
            ActionVariable

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.get_repo_variable(
                owner="owner",
                repo="repo",
                variablename="variablename",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActionVariable,
                    parse_obj_as(
                        type_=ActionVariable,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to create

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.create_repo_variable(
                owner="owner",
                repo="repo",
                variablename="variablename",
                value="value",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="POST",
            json={
                "value": value,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def update_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to update

        name : typing.Optional[str]
            New name for the variable. If the field is empty, the variable name won't be updated.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.update_repo_variable(
                owner="owner",
                repo="repo",
                variablename="variablename",
                value="value",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="PUT",
            json={
                "name": name,
                "value": value,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def delete_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ActionVariable:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActionVariable
            ActionVariable

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.delete_repo_variable(
                owner="owner",
                repo="repo",
                variablename="variablename",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActionVariable,
                    parse_obj_as(
                        type_=ActionVariable,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def dispatch_workflow(
        self,
        owner: str,
        repo: str,
        workflowname: str,
        *,
        ref: str,
        inputs: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        workflowname : str
            name of the workflow

        ref : str
            Git reference for the workflow

        inputs : typing.Optional[typing.Dict[str, str]]
            Input keys and values configured in the workflow file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.dispatch_workflow(
                owner="owner",
                repo="repo",
                workflowname="workflowname",
                ref="ref",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/workflows/{jsonable_encoder(workflowname)}/dispatches",
            method="POST",
            json={
                "inputs": inputs,
                "ref": ref,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_activity_feeds(
        self,
        owner: str,
        repo: str,
        *,
        date: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Activity]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        date : typing.Optional[str]
            the date of the activities to be found

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Activity]
            ActivityFeedsList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_activity_feeds(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/activities/feeds",
            method="GET",
            params={
                "date": date,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Activity],
                    parse_obj_as(
                        type_=typing.List[Activity],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_archive(
        self,
        owner: str,
        repo: str,
        archive: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        archive : str
            the git reference for download with attached archive format (e.g. master.zip)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_archive(
                owner="owner",
                repo="repo",
                archive="archive",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/archive/{jsonable_encoder(archive)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_assignees(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_assignees(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/assignees",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_update_avatar(
        self,
        owner: str,
        repo: str,
        *,
        image: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        image : typing.Optional[str]
            image must be base64 encoded

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_update_avatar(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="POST",
            json={
                "image": image,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_avatar(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_avatar(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[BranchProtection]
            BranchProtectionList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_branch_protection(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[BranchProtection],
                    parse_obj_as(
                        type_=typing.List[BranchProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        branch_name: typing.Optional[str] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        rule_name: typing.Optional[str] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BranchProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        branch_name : typing.Optional[str]
            Deprecated: true

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        rule_name : typing.Optional[str]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BranchProtection
            BranchProtection

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_branch_protection(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="POST",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "branch_name": branch_name,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "rule_name": rule_name,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BranchProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BranchProtection
            BranchProtection

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_branch_protection(
                owner="owner",
                repo="repo",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_branch_protection(
                owner="owner",
                repo="repo",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BranchProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BranchProtection
            BranchProtection

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_branch_protection(
                owner="owner",
                repo="repo",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="PATCH",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_branches(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Branch]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Branch]
            BranchList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_branches(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Branch],
                    parse_obj_as(
                        type_=typing.List[Branch],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_branch(
        self,
        owner: str,
        repo: str,
        *,
        new_branch_name: str,
        old_branch_name: typing.Optional[str] = OMIT,
        old_ref_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Branch:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        new_branch_name : str
            Name of the branch to create

        old_branch_name : typing.Optional[str]
            Deprecated: true
            Name of the old branch to create from

        old_ref_name : typing.Optional[str]
            Name of the old branch/tag/commit to create from

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Branch
            Branch

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_branch(
                owner="owner",
                repo="repo",
                new_branch_name="new_branch_name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="POST",
            json={
                "new_branch_name": new_branch_name,
                "old_branch_name": old_branch_name,
                "old_ref_name": old_ref_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Branch:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Branch
            Branch

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_branch(
                owner="owner",
                repo="repo",
                branch="branch",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_branch(
                owner="owner",
                repo="repo",
                branch="branch",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_update_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            name of the branch

        name : str
            New branch name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_update_branch(
                owner="owner",
                repo="repo",
                branch="branch",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="PATCH",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_collaborators(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_collaborators(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_check_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_check_collaborator(
                owner="owner",
                repo="repo",
                collaborator="collaborator",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_add_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        permission: typing.Optional[AddCollaboratorOptionPermission] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to add

        permission : typing.Optional[AddCollaboratorOptionPermission]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_add_collaborator(
                owner="owner",
                repo="repo",
                collaborator="collaborator",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="PUT",
            json={
                "permission": permission,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_collaborator(
                owner="owner",
                repo="repo",
                collaborator="collaborator",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_repo_permissions(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RepoCollaboratorPermission:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RepoCollaboratorPermission
            RepoCollaboratorPermission

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_repo_permissions(
                owner="owner",
                repo="repo",
                collaborator="collaborator",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}/permission",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RepoCollaboratorPermission,
                    parse_obj_as(
                        type_=RepoCollaboratorPermission,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_all_commits(
        self,
        owner: str,
        repo: str,
        *,
        sha: typing.Optional[str] = None,
        path: typing.Optional[str] = None,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        not_: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Commit]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : typing.Optional[str]
            SHA or branch to start listing commits from (usually 'master')

        path : typing.Optional[str]
            filepath of a file/dir

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results (ignored if used with 'path')

        not_ : typing.Optional[str]
            commits that match the given specifier will not be listed.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Commit]
            CommitList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_all_commits(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits",
            method="GET",
            params={
                "sha": sha,
                "path": path,
                "stat": stat,
                "verification": verification,
                "files": files,
                "page": page,
                "limit": limit,
                "not": not_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_combined_status_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CombinedStatus:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CombinedStatus
            CombinedStatus

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_combined_status_by_ref(
                owner="owner",
                repo="repo",
                ref="ref",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/status",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CombinedStatus,
                    parse_obj_as(
                        type_=CombinedStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_statuses_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        sort: typing.Optional[RepoListStatusesByRefRequestSort] = None,
        state: typing.Optional[RepoListStatusesByRefRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[CommitStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        sort : typing.Optional[RepoListStatusesByRefRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesByRefRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[CommitStatus]
            CommitStatusList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_statuses_by_ref(
                owner="owner",
                repo="repo",
                ref="ref",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/statuses",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_commit_pull_request(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_commit_pull_request(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(sha)}/pull",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_compare_diff(
        self,
        owner: str,
        repo: str,
        basehead: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Compare:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        basehead : str
            compare two branches or commits

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Compare


        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_compare_diff(
                owner="owner",
                repo="repo",
                basehead="basehead",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/compare/{jsonable_encoder(basehead)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Compare,
                    parse_obj_as(
                        type_=Compare,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_contents_list(
        self,
        owner: str,
        repo: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ContentsResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ContentsResponse]
            ContentsListResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_contents_list(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ContentsResponse],
                    parse_obj_as(
                        type_=typing.List[ContentsResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_change_files(
        self,
        owner: str,
        repo: str,
        *,
        files: typing.Sequence[ChangeFileOperation],
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FilesResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        files : typing.Sequence[ChangeFileOperation]
            list of file operations

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FilesResponse
            FilesResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi, ChangeFileOperation

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_change_files(
                owner="owner",
                repo="repo",
                files=[
                    ChangeFileOperation(
                        operation="create",
                        path="path",
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[ChangeFileOperation],
                    direction="write",
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FilesResponse,
                    parse_obj_as(
                        type_=FilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_contents(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ContentsResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the dir, file, symlink or submodule in the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ContentsResponse
            ContentsResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_contents(
                owner="owner",
                repo="repo",
                filepath="filepath",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ContentsResponse,
                    parse_obj_as(
                        type_=ContentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to create

        content : str
            content must be base64 encoded

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            FileResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_file(
                owner="owner",
                repo="repo",
                filepath="filepath",
                content="content",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_update_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to update

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            FileResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_update_file(
                owner="owner",
                repo="repo",
                filepath="filepath",
                content="content",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="PUT",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileDeleteResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to delete

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileDeleteResponse
            FileDeleteResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_file(
                owner="owner",
                repo="repo",
                filepath="filepath",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="DELETE",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileDeleteResponse,
                    parse_obj_as(
                        type_=FileDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_apply_diff_patch(
        self,
        owner: str,
        repo: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileResponse
            FileResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_apply_diff_patch(
                owner="owner",
                repo="repo",
                content="content",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/diffpatch",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_editor_config(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_editor_config(
                owner="owner",
                repo="repo",
                filepath="filepath",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/editorconfig/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[str]
            StringSlice

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_flags(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_replace_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        flags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flags : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_replace_all_flags(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="PUT",
            json={
                "flags": flags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_all_flags(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_check_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_check_flag(
                owner="owner",
                repo="repo",
                flag="flag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_add_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_add_flag(
                owner="owner",
                repo="repo",
                flag="flag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_flag(
                owner="owner",
                repo="repo",
                flag="flag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def list_forks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Repository]
            RepositoryList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.list_forks(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Repository],
                    parse_obj_as(
                        type_=typing.List[Repository],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_fork(
        self,
        owner: str,
        repo: str,
        *,
        name: typing.Optional[str] = OMIT,
        organization: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to fork

        repo : str
            name of the repo to fork

        name : typing.Optional[str]
            name of the forked repository

        organization : typing.Optional[str]
            organization name, if forking into an organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.create_fork(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="POST",
            json={
                "name": name,
                "organization": organization,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_blob(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitBlobResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitBlobResponse
            GitBlobResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.get_blob(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/blobs/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitBlobResponse,
                    parse_obj_as(
                        type_=GitBlobResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_single_commit(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Commit:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Commit
            Commit

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_single_commit(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "stat": stat,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Commit,
                    parse_obj_as(
                        type_=Commit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_download_commit_diff_or_patch(
        self,
        owner: str,
        repo: str,
        sha: str,
        diff_type: RepoDownloadCommitDiffOrPatchRequestDiffType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> str:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        diff_type : RepoDownloadCommitDiffOrPatchRequestDiffType
            whether the output is diff or patch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        str
            APIString is a string response

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_download_commit_diff_or_patch(
                owner="owner",
                repo="repo",
                sha="sha",
                diff_type="diff",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}.{jsonable_encoder(diff_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Note:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Note
            Note

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_note(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_set_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        message: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Note:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        message : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Note
            Note

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_set_note(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "message": message,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_remove_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_remove_note(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_all_git_refs(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Reference]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Reference]
            ReferenceList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_all_git_refs(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_git_refs(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Reference]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            part or full name of the ref

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Reference]
            ReferenceList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_git_refs(
                owner="owner",
                repo="repo",
                ref="ref",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs/{jsonable_encoder(ref)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_annotated_tag(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AnnotatedTag:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AnnotatedTag
            AnnotatedTag

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.get_annotated_tag(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/tags/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AnnotatedTag,
                    parse_obj_as(
                        type_=AnnotatedTag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def get_tree(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        recursive: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitTreeResponse:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        recursive : typing.Optional[bool]
            show all directories and files

        page : typing.Optional[int]
            page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page

        per_page : typing.Optional[int]
            number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitTreeResponse
            GitTreeResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.get_tree(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/trees/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "recursive": recursive,
                "page": page,
                "per_page": per_page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitTreeResponse,
                    parse_obj_as(
                        type_=GitTreeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_hooks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Hook]
            HookList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_hooks(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Hook],
                    parse_obj_as(
                        type_=typing.List[Hook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_hook(
        self,
        owner: str,
        repo: str,
        *,
        config: CreateHookOptionConfig,
        type: CreateHookOptionType,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        config : CreateHookOptionConfig

        type : CreateHookOptionType

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_hook(
                owner="owner",
                repo="repo",
                config={"key": "value"},
                type="forgejo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="POST",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
                "type": type,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_git_hooks(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[GitHook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[GitHook]
            GitHookList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_git_hooks(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[GitHook],
                    parse_obj_as(
                        type_=typing.List[GitHook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitHook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitHook
            GitHook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_git_hook(
                owner="owner",
                repo="repo",
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_git_hook(
                owner="owner",
                repo="repo",
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GitHook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GitHook
            GitHook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_git_hook(
                owner="owner",
                repo="repo",
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_hook(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_hook(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, str]] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Hook:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            index of the hook

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        config : typing.Optional[typing.Dict[str, str]]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Hook
            Hook

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_hook(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_test_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to test

        ref : typing.Optional[str]
            The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_test_hook(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}/tests",
            method="POST",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> IssueConfig:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IssueConfig
            RepoIssueConfig

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_issue_config(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    IssueConfig,
                    parse_obj_as(
                        type_=IssueConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_validate_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> IssueConfigValidation:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IssueConfigValidation
            RepoIssueConfigValidation

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_validate_issue_config(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config/validate",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    IssueConfigValidation,
                    parse_obj_as(
                        type_=IssueConfigValidation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_issue_templates(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[IssueTemplate]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[IssueTemplate]
            IssueTemplates

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_issue_templates(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_templates",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[IssueTemplate],
                    parse_obj_as(
                        type_=typing.List[IssueTemplate],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_pinned_issues(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Issue]
            IssueList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_pinned_issues(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_keys(
        self,
        owner: str,
        repo: str,
        *,
        key_id: typing.Optional[int] = None,
        fingerprint: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[DeployKey]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key_id : typing.Optional[int]
            the key_id to search for

        fingerprint : typing.Optional[str]
            fingerprint of the key

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[DeployKey]
            DeployKeyList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_keys(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="GET",
            params={
                "key_id": key_id,
                "fingerprint": fingerprint,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[DeployKey],
                    parse_obj_as(
                        type_=typing.List[DeployKey],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_key(
        self,
        owner: str,
        repo: str,
        *,
        key: str,
        title: str,
        read_only: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeployKey:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key : str
            An armored SSH key to add

        title : str
            Title of the key to add

        read_only : typing.Optional[bool]
            Describe if the key has only read access or read/write

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeployKey
            DeployKey

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_key(
                owner="owner",
                repo="repo",
                key="key",
                title="title",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="POST",
            json={
                "key": key,
                "read_only": read_only,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeployKey:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeployKey
            DeployKey

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_key(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_key(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_languages(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, int]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, int]
            LanguageStatistics

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_languages(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/languages",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Dict[str, int],
                    parse_obj_as(
                        type_=typing.Dict[str, int],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_raw_file_or_lfs(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]
            Returns raw file content.
        """
        async with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/media/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = (
                        request_options.get("chunk_size", None)
                        if request_options is not None
                        else None
                    )
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise core_api_error_ApiError(
                    status_code=_response.status_code, body=_response.text
                )
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response_json
            )

    async def repo_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_mirror_sync(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/mirror-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_new_pin_allowed(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> NewIssuePinsAllowed:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        NewIssuePinsAllowed
            RepoNewIssuePinsAllowed

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_new_pin_allowed(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/new_pin_allowed",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    NewIssuePinsAllowed,
                    parse_obj_as(
                        type_=NewIssuePinsAllowed,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[RepoListPullRequestsRequestState] = None,
        sort: typing.Optional[RepoListPullRequestsRequestSort] = None,
        milestone: typing.Optional[int] = None,
        labels: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        poster: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            Owner of the repo

        repo : str
            Name of the repo

        state : typing.Optional[RepoListPullRequestsRequestState]
            State of pull request

        sort : typing.Optional[RepoListPullRequestsRequestSort]
            Type of sort

        milestone : typing.Optional[int]
            ID of the milestone

        labels : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Label IDs

        poster : typing.Optional[str]
            Filter by pull request author

        page : typing.Optional[int]
            Page number of results to return (1-based)

        limit : typing.Optional[int]
            Page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullRequest]
            PullRequestList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_pull_requests(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="GET",
            params={
                "state": state,
                "sort": sort,
                "milestone": milestone,
                "labels": labels,
                "poster": poster,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_pull_request(
        self,
        owner: str,
        repo: str,
        *,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        head: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        head : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_pull_request(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="POST",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "head": head,
                "labels": labels,
                "milestone": milestone,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_pinned_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullRequest]
            PullRequestList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_pinned_pull_requests(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_request_by_base_head(
        self,
        owner: str,
        repo: str,
        base: str,
        head: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        base : str
            base of the pull request to get

        head : str
            head of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_request_by_base_head(
                owner="owner",
                repo="repo",
                base="base",
                head="head",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(base)}/{jsonable_encoder(head)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_request(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        allow_maintainer_edit: typing.Optional[bool] = OMIT,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        unset_due_date: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullRequest:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to edit

        allow_maintainer_edit : typing.Optional[bool]

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        state : typing.Optional[str]

        title : typing.Optional[str]

        unset_due_date : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullRequest
            PullRequest

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_pull_request(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="PATCH",
            json={
                "allow_maintainer_edit": allow_maintainer_edit,
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "labels": labels,
                "milestone": milestone,
                "state": state,
                "title": title,
                "unset_due_date": unset_due_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_download_pull_diff_or_patch(
        self,
        owner: str,
        repo: str,
        index: int,
        diff_type: RepoDownloadPullDiffOrPatchRequestDiffType,
        *,
        binary: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> str:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        diff_type : RepoDownloadPullDiffOrPatchRequestDiffType
            whether the output is diff or patch

        binary : typing.Optional[bool]
            whether to include binary file changes. if true, the diff is applicable with `git apply`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        str
            APIString is a string response

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_download_pull_diff_or_patch(
                owner="owner",
                repo="repo",
                index=1000000,
                diff_type="diff",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}.{jsonable_encoder(diff_type)}",
            method="GET",
            params={
                "binary": binary,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_request_commits(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Commit]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Commit]
            CommitList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_request_commits(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/commits",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_request_files(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        skip_to: typing.Optional[str] = None,
        whitespace: typing.Optional[RepoGetPullRequestFilesRequestWhitespace] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ChangedFile]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        skip_to : typing.Optional[str]
            skip to given file

        whitespace : typing.Optional[RepoGetPullRequestFilesRequestWhitespace]
            whitespace behavior

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ChangedFile]
            ChangedFileList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_request_files(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/files",
            method="GET",
            params={
                "skip-to": skip_to,
                "whitespace": whitespace,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ChangedFile],
                    parse_obj_as(
                        type_=typing.List[ChangedFile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_pull_request_is_merged(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_pull_request_is_merged(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_merge_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        do: MergePullRequestOptionDo,
        merge_commit_id: typing.Optional[str] = OMIT,
        merge_message_field: typing.Optional[str] = OMIT,
        merge_title_field: typing.Optional[str] = OMIT,
        delete_branch_after_merge: typing.Optional[bool] = OMIT,
        force_merge: typing.Optional[bool] = OMIT,
        head_commit_id: typing.Optional[str] = OMIT,
        merge_when_checks_succeed: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        do : MergePullRequestOptionDo

        merge_commit_id : typing.Optional[str]

        merge_message_field : typing.Optional[str]

        merge_title_field : typing.Optional[str]

        delete_branch_after_merge : typing.Optional[bool]

        force_merge : typing.Optional[bool]

        head_commit_id : typing.Optional[str]

        merge_when_checks_succeed : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_merge_pull_request(
                owner="owner",
                repo="repo",
                index=1000000,
                do="merge",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="POST",
            json={
                "Do": do,
                "MergeCommitID": merge_commit_id,
                "MergeMessageField": merge_message_field,
                "MergeTitleField": merge_title_field,
                "delete_branch_after_merge": delete_branch_after_merge,
                "force_merge": force_merge,
                "head_commit_id": head_commit_id,
                "merge_when_checks_succeed": merge_when_checks_succeed,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_cancel_scheduled_auto_merge(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_cancel_scheduled_auto_merge(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullReview]
            PullReviewList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_pull_review_requests(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="POST",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_pull_review_requests(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="DELETE",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_pull_reviews(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullReview]
            PullReviewList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_pull_reviews(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        body: typing.Optional[str] = OMIT,
        comments: typing.Optional[typing.Sequence[CreatePullReviewComment]] = OMIT,
        commit_id: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        body : typing.Optional[str]

        comments : typing.Optional[typing.Sequence[CreatePullReviewComment]]

        commit_id : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_pull_review(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="POST",
            json={
                "body": body,
                "comments": convert_and_respect_annotation_metadata(
                    object_=comments,
                    annotation=typing.Sequence[CreatePullReviewComment],
                    direction="write",
                ),
                "commit_id": commit_id,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_review(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_submit_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_submit_pull_review(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="POST",
            json={
                "body": body,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_pull_review(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_review_comments(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PullReviewComment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PullReviewComment]
            PullCommentList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_review_comments(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PullReviewComment],
                    parse_obj_as(
                        type_=typing.List[PullReviewComment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        new_position: typing.Optional[int] = OMIT,
        old_position: typing.Optional[int] = OMIT,
        path: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReviewComment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        new_position : typing.Optional[int]
            if comment to new file line or 0

        old_position : typing.Optional[int]
            if comment to old file line or 0

        path : typing.Optional[str]
            the tree path

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReviewComment
            PullComment

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_pull_review_comment(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="POST",
            json={
                "body": body,
                "new_position": new_position,
                "old_position": old_position,
                "path": path,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReviewComment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReviewComment
            PullComment

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_pull_review_comment(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
                comment=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_pull_review_comment(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
                comment=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        message: typing.Optional[str] = OMIT,
        priors: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        message : typing.Optional[str]

        priors : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_dismiss_pull_review(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/dismissals",
            method="POST",
            json={
                "message": message,
                "priors": priors,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_un_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PullReview:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PullReview
            PullReview

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_un_dismiss_pull_review(
                owner="owner",
                repo="repo",
                index=1000000,
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/undismissals",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_update_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        style: typing.Optional[RepoUpdatePullRequestRequestStyle] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        style : typing.Optional[RepoUpdatePullRequestRequestStyle]
            how to update pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_update_pull_request(
                owner="owner",
                repo="repo",
                index=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/update",
            method="POST",
            params={
                "style": style,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_push_mirrors(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[PushMirror]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PushMirror]
            PushMirrorList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_push_mirrors(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PushMirror],
                    parse_obj_as(
                        type_=typing.List[PushMirror],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_add_push_mirror(
        self,
        owner: str,
        repo: str,
        *,
        interval: typing.Optional[str] = OMIT,
        remote_address: typing.Optional[str] = OMIT,
        remote_password: typing.Optional[str] = OMIT,
        remote_username: typing.Optional[str] = OMIT,
        sync_on_commit: typing.Optional[bool] = OMIT,
        use_ssh: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PushMirror:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        interval : typing.Optional[str]

        remote_address : typing.Optional[str]

        remote_password : typing.Optional[str]

        remote_username : typing.Optional[str]

        sync_on_commit : typing.Optional[bool]

        use_ssh : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PushMirror
            PushMirror

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_add_push_mirror(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="POST",
            json={
                "interval": interval,
                "remote_address": remote_address,
                "remote_password": remote_password,
                "remote_username": remote_username,
                "sync_on_commit": sync_on_commit,
                "use_ssh": use_ssh,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_push_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_push_mirror_sync(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_push_mirror_by_remote_name(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PushMirror:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of push mirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PushMirror
            PushMirror

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_push_mirror_by_remote_name(
                owner="owner",
                repo="repo",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_push_mirror(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of the pushMirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_push_mirror(
                owner="owner",
                repo="repo",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_raw_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]
            Returns raw file content.
        """
        async with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/raw/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = (
                        request_options.get("chunk_size", None)
                        if request_options is not None
                        else None
                    )
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise core_api_error_ApiError(
                    status_code=_response.status_code, body=_response.text
                )
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response_json
            )

    async def repo_list_releases(
        self,
        owner: str,
        repo: str,
        *,
        draft: typing.Optional[bool] = None,
        pre_release: typing.Optional[bool] = None,
        q: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        draft : typing.Optional[bool]
            filter (exclude / include) drafts, if you dont have repo write access none will show

        pre_release : typing.Optional[bool]
            filter (exclude / include) pre-releases

        q : typing.Optional[str]
            Search string

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Release]
            ReleaseList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_releases(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="GET",
            params={
                "draft": draft,
                "pre-release": pre_release,
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Release],
                    parse_obj_as(
                        type_=typing.List[Release],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_release(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_release(
                owner="owner",
                repo="repo",
                tag_name="tag_name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="POST",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_latest_release(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_latest_release(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/latest",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_release_by_tag(
                owner="owner",
                repo="repo",
                tag="tag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_release_by_tag(
                owner="owner",
                repo="repo",
                tag="tag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_release(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_release(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        tag_name: typing.Optional[str] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Release:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to edit

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        tag_name : typing.Optional[str]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Release
            Release

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_release(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_release_attachments(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Attachment]
            AttachmentList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_release_attachments(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        name: typing.Optional[str] = None,
        attachment: typing.Optional[core.File] = OMIT,
        external_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Attachment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        name : typing.Optional[str]
            name of the attachment

        attachment : typing.Optional[core.File]
            See core.File for more documentation

        external_url : typing.Optional[str]
            url to external asset (this parameter is incompatible with `attachment`)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Attachment
            Attachment

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_release_attachment(
                owner="owner",
                repo="repo",
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="POST",
            params={
                "name": name,
            },
            data={
                "external_url": external_url,
            },
            files={
                "attachment": attachment,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Attachment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Attachment
            Attachment

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_release_attachment(
                owner="owner",
                repo="repo",
                id=1000000,
                attachment_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_release_attachment(
                owner="owner",
                repo="repo",
                id=1000000,
                attachment_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Attachment:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Attachment
            Attachment

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_release_attachment(
                owner="owner",
                repo="repo",
                id=1000000,
                attachment_id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_reviewers(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_reviewers(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/reviewers",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_signing_key(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> str:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        str
            GPG armored public key

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_signing_key(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/signing-key.gpg",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return _response.text  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_stargazers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_stargazers(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/stargazers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_statuses(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        sort: typing.Optional[RepoListStatusesRequestSort] = None,
        state: typing.Optional[RepoListStatusesRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[CommitStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        sort : typing.Optional[RepoListStatusesRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[CommitStatus]
            CommitStatusList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_statuses(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_status(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        context: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        state: typing.Optional[CommitStatusState] = OMIT,
        target_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommitStatus:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        context : typing.Optional[str]

        description : typing.Optional[str]

        state : typing.Optional[CommitStatusState]

        target_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommitStatus
            CommitStatus

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_status(
                owner="owner",
                repo="repo",
                sha="sha",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "context": context,
                "description": description,
                "state": state,
                "target_url": target_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CommitStatus,
                    parse_obj_as(
                        type_=CommitStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_subscribers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[User]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[User]
            UserList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_subscribers(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscribers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def user_current_check_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WatchInfo:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WatchInfo
            WatchInfo

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.user_current_check_subscription(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def user_current_put_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WatchInfo:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WatchInfo
            WatchInfo

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.user_current_put_subscription(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def user_current_delete_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.user_current_delete_subscription(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TagProtection]
            TagProtectionList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_tag_protection(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TagProtection],
                    parse_obj_as(
                        type_=typing.List[TagProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TagProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TagProtection
            TagProtection

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_tag_protection(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="POST",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TagProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the tag protect to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TagProtection
            TagProtection

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_tag_protection(
                owner="owner",
                repo="repo",
                id=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_tag_protection(
                owner="owner",
                repo="repo",
                id=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TagProtection:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TagProtection
            TagProtection

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_tag_protection(
                owner="owner",
                repo="repo",
                id=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_tags(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Tag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Tag]
            TagList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_tags(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Tag],
                    parse_obj_as(
                        type_=typing.List[Tag],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_tag(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        message: typing.Optional[str] = OMIT,
        target: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Tag:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        message : typing.Optional[str]

        target : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Tag
            Tag

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_tag(
                owner="owner",
                repo="repo",
                tag_name="tag_name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="POST",
            json={
                "message": message,
                "tag_name": tag_name,
                "target": target,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Tag:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Tag
            Tag

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_tag(
                owner="owner",
                repo="repo",
                tag="tag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_tag(
                owner="owner",
                repo="repo",
                tag="tag",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_teams(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[Team]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Team]
            TeamList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_teams(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Team],
                    parse_obj_as(
                        type_=typing.List[Team],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_check_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Team:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Team
            Team

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_check_team(
                owner="owner",
                repo="repo",
                team="team",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Team,
                    parse_obj_as(
                        type_=Team,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_add_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_add_team(
                owner="owner",
                repo="repo",
                team="team",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_team(
                owner="owner",
                repo="repo",
                team="team",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_tracked_times(
        self,
        owner: str,
        repo: str,
        *,
        user: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TrackedTime]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : typing.Optional[str]
            optional filter by user (available for issue managers)

        since : typing.Optional[dt.datetime]
            Only show times updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show times updated before the given time. This is a timestamp in RFC 3339 format

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TrackedTime]
            TrackedTimeList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_tracked_times(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times",
            method="GET",
            params={
                "user": user,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def user_tracked_times(
        self,
        owner: str,
        repo: str,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TrackedTime]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : str
            username of user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TrackedTime]
            TrackedTimeList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.user_tracked_times(
                owner="owner",
                repo="repo",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times/{jsonable_encoder(user)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_list_topics(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TopicName:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TopicName
            TopicNames

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_list_topics(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TopicName,
                    parse_obj_as(
                        type_=TopicName,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_update_topics(
        self,
        owner: str,
        repo: str,
        *,
        topics: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topics : typing.Optional[typing.Sequence[str]]
            list of topic names

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_update_topics(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="PUT",
            json={
                "topics": topics,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_add_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to add

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_add_topic(
                owner="owner",
                repo="repo",
                topic="topic",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_topic(
                owner="owner",
                repo="repo",
                topic="topic",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        new_owner: str,
        team_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        new_owner : str

        team_ids : typing.Optional[typing.Sequence[int]]
            ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_transfer(
                owner="owner",
                repo="repo",
                new_owner="new_owner",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer",
            method="POST",
            json={
                "new_owner": new_owner,
                "team_ids": team_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def accept_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.accept_repo_transfer(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/accept",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def reject_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.reject_repo_transfer(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/reject",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_create_wiki_page(
        self,
        owner: str,
        repo: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiPage:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiPage
            WikiPage

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_create_wiki_page(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/new",
            method="POST",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiPage:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiPage
            WikiPage

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_wiki_page(
                owner="owner",
                repo="repo",
                page_name="pageName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_delete_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_delete_wiki_page(
                owner="owner",
                repo="repo",
                page_name="pageName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_edit_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiPage:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiPage
            WikiPage

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_edit_wiki_page(
                owner="owner",
                repo="repo",
                page_name="pageName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="PATCH",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 423:
                raise LockedError(
                    typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_wiki_pages(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WikiPageMetaData]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WikiPageMetaData]
            WikiPageList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_wiki_pages(
                owner="owner",
                repo="repo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/pages",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WikiPageMetaData],
                    parse_obj_as(
                        type_=typing.List[WikiPageMetaData],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_wiki_page_revisions(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WikiCommitList:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        page : typing.Optional[int]
            page number of results to return (1-based)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WikiCommitList
            WikiCommitList

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_wiki_page_revisions(
                owner="owner",
                repo="repo",
                page_name="pageName",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/revisions/{jsonable_encoder(page_name)}",
            method="GET",
            params={
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WikiCommitList,
                    parse_obj_as(
                        type_=WikiCommitList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def generate_repo(
        self,
        template_owner: str,
        template_repo: str,
        *,
        name: str,
        owner: str,
        avatar: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        git_content: typing.Optional[bool] = OMIT,
        git_hooks: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        private: typing.Optional[bool] = OMIT,
        protected_branch: typing.Optional[bool] = OMIT,
        topics: typing.Optional[bool] = OMIT,
        webhooks: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        template_owner : str
            name of the template repository owner

        template_repo : str
            name of the template repository

        name : str
            Name of the repository to create

        owner : str
            The organization or person who will own the new repository

        avatar : typing.Optional[bool]
            include avatar of the template repo

        default_branch : typing.Optional[str]
            Default branch of the new repository

        description : typing.Optional[str]
            Description of the repository to create

        git_content : typing.Optional[bool]
            include git content of default branch in template repo

        git_hooks : typing.Optional[bool]
            include git hooks in template repo

        labels : typing.Optional[bool]
            include labels in template repo

        private : typing.Optional[bool]
            Whether the repository is private

        protected_branch : typing.Optional[bool]
            include protected branches in template repo

        topics : typing.Optional[bool]
            include topics in template repo

        webhooks : typing.Optional[bool]
            include webhooks in template repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.generate_repo(
                template_owner="template_owner",
                template_repo="template_repo",
                name="name",
                owner="owner",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(template_owner)}/{jsonable_encoder(template_repo)}/generate",
            method="POST",
            json={
                "avatar": avatar,
                "default_branch": default_branch,
                "description": description,
                "git_content": git_content,
                "git_hooks": git_hooks,
                "labels": labels,
                "name": name,
                "owner": owner,
                "private": private,
                "protected_branch": protected_branch,
                "topics": topics,
                "webhooks": webhooks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def repo_get_by_id(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Repository:
        """
        Parameters
        ----------
        id : int
            id of the repo to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.repo_get_by_id(
                id=1000000,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repositories/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def topic_search(
        self,
        *,
        q: str,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TopicResponse]:
        """
        Parameters
        ----------
        q : str
            keywords to search

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TopicResponse]
            TopicListResponse

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.topic_search(
                q="q",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "topics/search",
            method="GET",
            params={
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TopicResponse],
                    parse_obj_as(
                        type_=typing.List[TopicResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )

    async def create_current_user_repo(
        self,
        *,
        name: str,
        auto_init: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        gitignores: typing.Optional[str] = OMIT,
        issue_labels: typing.Optional[str] = OMIT,
        license: typing.Optional[str] = OMIT,
        object_format_name: typing.Optional[CreateRepoOptionObjectFormatName] = OMIT,
        private: typing.Optional[bool] = OMIT,
        readme: typing.Optional[str] = OMIT,
        template: typing.Optional[bool] = OMIT,
        trust_model: typing.Optional[CreateRepoOptionTrustModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Repository:
        """
        Parameters
        ----------
        name : str
            Name of the repository to create

        auto_init : typing.Optional[bool]
            Whether the repository should be auto-initialized?

        default_branch : typing.Optional[str]
            DefaultBranch of the repository (used when initializes and in template)

        description : typing.Optional[str]
            Description of the repository to create

        gitignores : typing.Optional[str]
            Gitignores to use

        issue_labels : typing.Optional[str]
            Label-Set to use

        license : typing.Optional[str]
            License to use

        object_format_name : typing.Optional[CreateRepoOptionObjectFormatName]
            ObjectFormatName of the underlying git repository

        private : typing.Optional[bool]
            Whether the repository is private

        readme : typing.Optional[str]
            Readme of the repository to create

        template : typing.Optional[bool]
            Whether the repository is template

        trust_model : typing.Optional[CreateRepoOptionTrustModel]
            TrustModel of the repository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Repository
            Repository

        Examples
        --------
        import asyncio

        from pyforgejo import AsyncPyforgejoApi

        client = AsyncPyforgejoApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.repository.create_current_user_repo(
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user/repos",
            method="POST",
            json={
                "auto_init": auto_init,
                "default_branch": default_branch,
                "description": description,
                "gitignores": gitignores,
                "issue_labels": issue_labels,
                "license": license,
                "name": name,
                "object_format_name": object_format_name,
                "private": private,
                "readme": readme,
                "template": template,
                "trust_model": trust_model,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        ApiUnauthorizedError,
                        parse_obj_as(
                            type_=ApiUnauthorizedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, body=_response_json
        )
