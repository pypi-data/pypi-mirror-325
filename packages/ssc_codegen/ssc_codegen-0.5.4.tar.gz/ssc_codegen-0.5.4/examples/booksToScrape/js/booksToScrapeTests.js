// autogenerated by ssc-gen DO NOT_EDIT
/**
 * Schema for extracting a list of books.
 *
 * [
 *     {
 *         "name": "String",
 *         "image_url": "String",
 *         "url": "String",
 *         "rating": "Int",
 *         "price": "Float"
 *     },
 *     "..."
 * ]
 */
class Books {
    constructor(doc) {
        this._doc = typeof document === 'string' ? new DOMParser().parseFromString(doc, 'text/html') : doc;
    }

    _splitDoc(value) {
        let value1 = Array.from(value.querySelectorAll('.product_pod'));
        return value1;
    }

    _parseName(value) {
        let value1 = value.querySelector('h3 > a');
        let value2 = value1.getAttribute('title');
        return value2;
    }

    _parseImageUrl(value) {
        let value1 = value.querySelector('.thumbnail');
        let value2 = value1.getAttribute('src');
        let value3 = (function (str, chars) {
            return str.replace(new RegExp(`^[${chars}]+`, 'g'), '');
        })(value2, '../');
        let value4 = `https://books.toscrape.com/${value3}`;
        return value4;
    }

    _parseUrl(value) {
        let value1 = value.querySelector('h3 > a');
        let value2 = value1.getAttribute('href');
        let value3 = `https://books.toscrape.com/catalogue/${value2}`;
        return value3;
    }

    _parseRating(value) {
        let value1 = value.querySelector('.star-rating');
        let value2 = value1.getAttribute('class');
        let value3 = value2.match(/star-rating (\w+)/g)[0];
        let value4 = value3.replace(/\bOne\b/g, '1');
        let value5 = value4.replace(/\bTwo\b/g, '2');
        let value6 = value5.replace(/\bThree\b/g, '3');
        let value7 = value6.replace(/\bFour\b/g, '4');
        let value8 = value7.replace(/\bFive\b/g, '5');
        let value9 = parseInt(value8, 10);
        return value9;
    }

    _parsePrice(value) {
        let value1 = value.querySelector('.price_color');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        let value3 = value2.match(/(\d+\.\d+)/g)[0];
        let value4 = parseFloat(value3, 64);
        return value4;
    }

    parse() {
        let items = [];
        Array.from(this._splitDoc(this._doc)).forEach((e) => {
            items.push({
                name: this._parseName(e),
                image_url: this._parseImageUrl(e),
                url: this._parseUrl(e),
                rating: this._parseRating(e),
                price: this._parsePrice(e)
            });
        });
        return items;
    }
}

/**
 * Schema for extracting pagination details.
 *
 * {
 *     "showing_start": "Int",
 *     "showing_end": "Int",
 *     "current_page": "Int",
 *     "total_page": "Int",
 *     "next_page_url": "String",
 *     "previous_page_url": "String"
 * }
 */
class Pagination {
    constructor(doc) {
        this._doc = typeof document === 'string' ? new DOMParser().parseFromString(doc, 'text/html') : doc;
    }

    _parseShowingStart(value) {
        let value1 = value.querySelector('.form-horizontal');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        let value3 = value2.match(/results \- showing (\d+) to \d+/g)[0];
        let value4 = parseInt(value3, 10);
        return value4;
    }

    _parseShowingEnd(value) {
        let value1 = value.querySelector('.form-horizontal');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        let value3 = value2.match(/results \- showing \d+ to (\d+)/g)[0];
        let value4 = parseInt(value3, 10);
        return value4;
    }

    _parseCurrentPage(value) {
        let value1 = value.querySelector('.current');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        let value3 = value2.match(/Page (\d+) of \d+/g)[0];
        let value4 = parseInt(value3, 10);
        return value4;
    }

    _parseTotalPage(value) {
        let value1 = value.querySelector('.current');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        let value3 = value2.match(/Page \d+ of (\d+)/g)[0];
        let value4 = parseInt(value3, 10);
        return value4;
    }

    _parseNextPageUrl(value) {
        try {
            let value2 = value1.querySelector('.next > a');
            let value3 = value2.getAttribute('href');
            let value4 = `https://books.toscrape.com/catalogue/${value3}`;
            return value5;
        } catch (Error) {
            return null;
        }
    }

    _parsePreviousPageUrl(value) {
        try {
            let value2 = value1.querySelector('.previous > a');
            let value3 = value2.getAttribute('href');
            let value4 = `https://books.toscrape.com/catalogue/${value3}`;
            return value5;
        } catch (Error) {
            return null;
        }
    }

    parse() {
        let item = {
            showing_start: this._parseShowingStart(this._doc),
            showing_end: this._parseShowingEnd(this._doc),
            current_page: this._parseCurrentPage(this._doc),
            total_page: this._parseTotalPage(this._doc),
            next_page_url: this._parseNextPageUrl(this._doc),
            previous_page_url: this._parsePreviousPageUrl(this._doc)
        };
        return item;
    }
}

/**
 *
 *
 * {
 *     "all_urls": "Array<String>",
 *     "all_names": "Array<String>"
 * }
 */
class BooksAll {
    constructor(doc) {
        this._doc = typeof document === 'string' ? new DOMParser().parseFromString(doc, 'text/html') : doc;
    }

    _parseAllUrls(value) {
        if (!value.querySelector('.product_pod')) throw new Error('');
        let value1 = value;
        let value2 = Array.from(value1.querySelectorAll('.product_pod > h3 > a'));
        let value3 = value2.map(e => e.getAttribute('href'));
        let value4 = value3.map(e => `https://books.toscrape.com/${e}`);
        return value4;
    }

    _parseAllNames(value) {
        if (!value.querySelector('.product_pod')) throw new Error('');
        let value1 = value;
        let value2 = Array.from(value1.querySelectorAll('.product_pod > h3 > a'));
        let value3 = value2.map(e => e.textContent);
        return value3;
    }

    parse() {
        let item = {all_urls: this._parseAllUrls(this._doc), all_names: this._parseAllNames(this._doc)};
        return item;
    }
}

/**
 *
 *
 * [
 *     "String",
 *     "..."
 * ]
 */
class BooksFlatNames {
    constructor(doc) {
        this._doc = typeof document === 'string' ? new DOMParser().parseFromString(doc, 'text/html') : doc;
    }

    _splitDoc(value) {
        let value1 = Array.from(value.querySelectorAll('.product_pod > h3 > a'));
        return value1;
    }

    _parseItem(value) {
        let value1 = typeof document.textContent === "undefined" ? value.body.textContent : value.textContent;
        return value1;
    }

    parse() {
        let items = Array.from(this._splitDoc(this._doc)).map((e) => this._parseItem(e));
        return items;
    }
}

/**
 *
 *
 * {
 *     "<K>": [
 *         {
 *             "name": "String",
 *             "image_url": "String",
 *             "url": "String",
 *             "rating": "Int",
 *             "price": "Float"
 *         },
 *         "..."
 *     ],
 *     "<KN>": "..."
 * }
 */
class BooksDict {
    constructor(doc) {
        this._doc = typeof document === 'string' ? new DOMParser().parseFromString(doc, 'text/html') : doc;
    }

    _splitDoc(value) {
        let value1 = Array.from(value.querySelectorAll('.product_pod'));
        return value1;
    }

    _parseKey(value) {
        let value1 = value.querySelector('h3 > a');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        return value2;
    }

    _parseValue(value) {
        let value1 = (new Books(value)).parse();
        return value1;
    }

    parse() {
        let item = {};
        Array.from(this._splitDoc(this._doc)).forEach((e) => {
            let k = this._parseKey(e);
            item[k] = this._parseValue(e);
        });
        return item;
    }
}

/**
 * Schema for extracting the entire catalogue page with nested schemas.
 *
 * {
 *     "title": "String",
 *     "pagination": {
 *         "showing_start": "Int",
 *         "showing_end": "Int",
 *         "current_page": "Int",
 *         "total_page": "Int",
 *         "next_page_url": "Any",
 *         "previous_page_url": "Any"
 *     },
 *     "books": [
 *         {
 *             "name": "String",
 *             "image_url": "String",
 *             "url": "String",
 *             "rating": "Int",
 *             "price": "Float"
 *         },
 *         "..."
 *     ],
 *     "books_all": {
 *         "all_urls": "Array<String>",
 *         "all_names": "Array<String>"
 *     },
 *     "books_all_names": [
 *         "String",
 *         "..."
 *     ],
 *     "books_dict": {
 *         "<K>": [
 *             {
 *                 "name": "String",
 *                 "image_url": "String",
 *                 "url": "String",
 *                 "rating": "Int",
 *                 "price": "Float"
 *             },
 *             "..."
 *         ],
 *         "<KN>": "..."
 *     },
 *     "books_list": [
 *         "String",
 *         "..."
 *     ]
 * }
 */
class CataloguePage {
    constructor(doc) {
        this._doc = typeof document === 'string' ? new DOMParser().parseFromString(doc, 'text/html') : doc;
    }

    _preValidate(value) {
        if (!value.querySelector('title')) throw new Error('');
        let value1 = value;
        let value2 = value1.querySelector('title');
        let value3 = typeof document.textContent === "undefined" ? value2.body.textContent : value2.textContent;
        if (value3.match(/Books to Scrape/) === null) throw new Error('');
        return null;
    }

    _parseTitle(value) {
        let value1 = value.querySelector('title');
        let value2 = typeof document.textContent === "undefined" ? value1.body.textContent : value1.textContent;
        let value3 = value2.replace(/^\s*/g, '');
        let value4 = value3.replace(/\s*$/g, '');
        return value4;
    }

    _parsePagination(value) {
        let value1 = (new Pagination(value)).parse();
        return value1;
    }

    _parseBooks(value) {
        let value1 = (new Books(value)).parse();
        return value1;
    }

    _parseBooksAll(value) {
        let value1 = (new BooksAll(value)).parse();
        return value1;
    }

    _parseBooksAllNames(value) {
        let value1 = (new BooksFlatNames(value)).parse();
        return value1;
    }

    _parseBooksDict(value) {
        let value1 = (new BooksDict(value)).parse();
        return value1;
    }

    _parseBooksList(value) {
        let value1 = (new BooksFlatNames(value)).parse();
        return value1;
    }

    parse() {
        this._preValidate(this._doc);
        let item = {
            title: this._parseTitle(this._doc),
            pagination: this._parsePagination(this._doc),
            books: this._parseBooks(this._doc),
            books_all: this._parseBooksAll(this._doc),
            books_all_names: this._parseBooksAllNames(this._doc),
            books_dict: this._parseBooksDict(this._doc),
            books_list: this._parseBooksList(this._doc)
        };
        return item;
    }
}