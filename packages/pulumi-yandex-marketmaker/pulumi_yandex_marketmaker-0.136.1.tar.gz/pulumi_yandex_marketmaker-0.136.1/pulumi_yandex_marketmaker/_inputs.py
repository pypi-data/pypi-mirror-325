# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AlbBackendGroupGrpcBackendArgs',
    'AlbBackendGroupGrpcBackendArgsDict',
    'AlbBackendGroupGrpcBackendHealthcheckArgs',
    'AlbBackendGroupGrpcBackendHealthcheckArgsDict',
    'AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs',
    'AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict',
    'AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs',
    'AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict',
    'AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs',
    'AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict',
    'AlbBackendGroupGrpcBackendLoadBalancingConfigArgs',
    'AlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict',
    'AlbBackendGroupGrpcBackendTlsArgs',
    'AlbBackendGroupGrpcBackendTlsArgsDict',
    'AlbBackendGroupGrpcBackendTlsValidationContextArgs',
    'AlbBackendGroupGrpcBackendTlsValidationContextArgsDict',
    'AlbBackendGroupHttpBackendArgs',
    'AlbBackendGroupHttpBackendArgsDict',
    'AlbBackendGroupHttpBackendHealthcheckArgs',
    'AlbBackendGroupHttpBackendHealthcheckArgsDict',
    'AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs',
    'AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict',
    'AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs',
    'AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict',
    'AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs',
    'AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict',
    'AlbBackendGroupHttpBackendLoadBalancingConfigArgs',
    'AlbBackendGroupHttpBackendLoadBalancingConfigArgsDict',
    'AlbBackendGroupHttpBackendTlsArgs',
    'AlbBackendGroupHttpBackendTlsArgsDict',
    'AlbBackendGroupHttpBackendTlsValidationContextArgs',
    'AlbBackendGroupHttpBackendTlsValidationContextArgsDict',
    'AlbBackendGroupSessionAffinityArgs',
    'AlbBackendGroupSessionAffinityArgsDict',
    'AlbBackendGroupSessionAffinityConnectionArgs',
    'AlbBackendGroupSessionAffinityConnectionArgsDict',
    'AlbBackendGroupSessionAffinityCookieArgs',
    'AlbBackendGroupSessionAffinityCookieArgsDict',
    'AlbBackendGroupSessionAffinityHeaderArgs',
    'AlbBackendGroupSessionAffinityHeaderArgsDict',
    'AlbBackendGroupStreamBackendArgs',
    'AlbBackendGroupStreamBackendArgsDict',
    'AlbBackendGroupStreamBackendHealthcheckArgs',
    'AlbBackendGroupStreamBackendHealthcheckArgsDict',
    'AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs',
    'AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict',
    'AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs',
    'AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict',
    'AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs',
    'AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict',
    'AlbBackendGroupStreamBackendLoadBalancingConfigArgs',
    'AlbBackendGroupStreamBackendLoadBalancingConfigArgsDict',
    'AlbBackendGroupStreamBackendTlsArgs',
    'AlbBackendGroupStreamBackendTlsArgsDict',
    'AlbBackendGroupStreamBackendTlsValidationContextArgs',
    'AlbBackendGroupStreamBackendTlsValidationContextArgsDict',
    'AlbHttpRouterRouteOptionsArgs',
    'AlbHttpRouterRouteOptionsArgsDict',
    'AlbHttpRouterRouteOptionsRbacArgs',
    'AlbHttpRouterRouteOptionsRbacArgsDict',
    'AlbHttpRouterRouteOptionsRbacPrincipalArgs',
    'AlbHttpRouterRouteOptionsRbacPrincipalArgsDict',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgs',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgsDict',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgs',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict',
    'AlbLoadBalancerAllocationPolicyArgs',
    'AlbLoadBalancerAllocationPolicyArgsDict',
    'AlbLoadBalancerAllocationPolicyLocationArgs',
    'AlbLoadBalancerAllocationPolicyLocationArgsDict',
    'AlbLoadBalancerListenerArgs',
    'AlbLoadBalancerListenerArgsDict',
    'AlbLoadBalancerListenerEndpointArgs',
    'AlbLoadBalancerListenerEndpointArgsDict',
    'AlbLoadBalancerListenerEndpointAddressArgs',
    'AlbLoadBalancerListenerEndpointAddressArgsDict',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgsDict',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgsDict',
    'AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs',
    'AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgsDict',
    'AlbLoadBalancerListenerHttpArgs',
    'AlbLoadBalancerListenerHttpArgsDict',
    'AlbLoadBalancerListenerHttpHandlerArgs',
    'AlbLoadBalancerListenerHttpHandlerArgsDict',
    'AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs',
    'AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgsDict',
    'AlbLoadBalancerListenerHttpRedirectsArgs',
    'AlbLoadBalancerListenerHttpRedirectsArgsDict',
    'AlbLoadBalancerListenerStreamArgs',
    'AlbLoadBalancerListenerStreamArgsDict',
    'AlbLoadBalancerListenerStreamHandlerArgs',
    'AlbLoadBalancerListenerStreamHandlerArgsDict',
    'AlbLoadBalancerListenerTlsArgs',
    'AlbLoadBalancerListenerTlsArgsDict',
    'AlbLoadBalancerListenerTlsDefaultHandlerArgs',
    'AlbLoadBalancerListenerTlsDefaultHandlerArgsDict',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgsDict',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgsDict',
    'AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs',
    'AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgsDict',
    'AlbLoadBalancerListenerTlsSniHandlerArgs',
    'AlbLoadBalancerListenerTlsSniHandlerArgsDict',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerArgs',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerArgsDict',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgsDict',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgsDict',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgsDict',
    'AlbLoadBalancerLogOptionsArgs',
    'AlbLoadBalancerLogOptionsArgsDict',
    'AlbLoadBalancerLogOptionsDiscardRuleArgs',
    'AlbLoadBalancerLogOptionsDiscardRuleArgsDict',
    'AlbTargetGroupTargetArgs',
    'AlbTargetGroupTargetArgsDict',
    'AlbVirtualHostModifyRequestHeaderArgs',
    'AlbVirtualHostModifyRequestHeaderArgsDict',
    'AlbVirtualHostModifyResponseHeaderArgs',
    'AlbVirtualHostModifyResponseHeaderArgsDict',
    'AlbVirtualHostRateLimitArgs',
    'AlbVirtualHostRateLimitArgsDict',
    'AlbVirtualHostRateLimitAllRequestsArgs',
    'AlbVirtualHostRateLimitAllRequestsArgsDict',
    'AlbVirtualHostRateLimitRequestsPerIpArgs',
    'AlbVirtualHostRateLimitRequestsPerIpArgsDict',
    'AlbVirtualHostRouteArgs',
    'AlbVirtualHostRouteArgsDict',
    'AlbVirtualHostRouteGrpcRouteArgs',
    'AlbVirtualHostRouteGrpcRouteArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcMatchArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcMatchArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgsDict',
    'AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs',
    'AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgsDict',
    'AlbVirtualHostRouteHttpRouteArgs',
    'AlbVirtualHostRouteHttpRouteArgsDict',
    'AlbVirtualHostRouteHttpRouteDirectResponseActionArgs',
    'AlbVirtualHostRouteHttpRouteDirectResponseActionArgsDict',
    'AlbVirtualHostRouteHttpRouteHttpMatchArgs',
    'AlbVirtualHostRouteHttpRouteHttpMatchArgsDict',
    'AlbVirtualHostRouteHttpRouteHttpMatchPathArgs',
    'AlbVirtualHostRouteHttpRouteHttpMatchPathArgsDict',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionArgs',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionArgsDict',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgsDict',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgsDict',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgsDict',
    'AlbVirtualHostRouteHttpRouteRedirectActionArgs',
    'AlbVirtualHostRouteHttpRouteRedirectActionArgsDict',
    'AlbVirtualHostRouteOptionsArgs',
    'AlbVirtualHostRouteOptionsArgsDict',
    'AlbVirtualHostRouteOptionsRbacArgs',
    'AlbVirtualHostRouteOptionsRbacArgsDict',
    'AlbVirtualHostRouteOptionsRbacPrincipalArgs',
    'AlbVirtualHostRouteOptionsRbacPrincipalArgsDict',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgs',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgsDict',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgs',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict',
    'AlbVirtualHostRouteRouteOptionsArgs',
    'AlbVirtualHostRouteRouteOptionsArgsDict',
    'AlbVirtualHostRouteRouteOptionsRbacArgs',
    'AlbVirtualHostRouteRouteOptionsRbacArgsDict',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalArgs',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalArgsDict',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgs',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgsDict',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgs',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict',
    'ApiGatewayCanaryArgs',
    'ApiGatewayCanaryArgsDict',
    'ApiGatewayConnectivityArgs',
    'ApiGatewayConnectivityArgsDict',
    'ApiGatewayCustomDomainArgs',
    'ApiGatewayCustomDomainArgsDict',
    'ApiGatewayLogOptionsArgs',
    'ApiGatewayLogOptionsArgsDict',
    'AuditTrailsTrailDataStreamDestinationArgs',
    'AuditTrailsTrailDataStreamDestinationArgsDict',
    'AuditTrailsTrailFilterArgs',
    'AuditTrailsTrailFilterArgsDict',
    'AuditTrailsTrailFilterEventFilterArgs',
    'AuditTrailsTrailFilterEventFilterArgsDict',
    'AuditTrailsTrailFilterEventFilterCategoryArgs',
    'AuditTrailsTrailFilterEventFilterCategoryArgsDict',
    'AuditTrailsTrailFilterEventFilterPathFilterArgs',
    'AuditTrailsTrailFilterEventFilterPathFilterArgsDict',
    'AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs',
    'AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgsDict',
    'AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs',
    'AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgsDict',
    'AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs',
    'AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgsDict',
    'AuditTrailsTrailFilterPathFilterArgs',
    'AuditTrailsTrailFilterPathFilterArgsDict',
    'AuditTrailsTrailFilterPathFilterAnyFilterArgs',
    'AuditTrailsTrailFilterPathFilterAnyFilterArgsDict',
    'AuditTrailsTrailFilterPathFilterSomeFilterArgs',
    'AuditTrailsTrailFilterPathFilterSomeFilterArgsDict',
    'AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs',
    'AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgsDict',
    'AuditTrailsTrailFilteringPolicyArgs',
    'AuditTrailsTrailFilteringPolicyArgsDict',
    'AuditTrailsTrailFilteringPolicyDataEventsFilterArgs',
    'AuditTrailsTrailFilteringPolicyDataEventsFilterArgsDict',
    'AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs',
    'AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgsDict',
    'AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs',
    'AuditTrailsTrailFilteringPolicyManagementEventsFilterArgsDict',
    'AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs',
    'AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgsDict',
    'AuditTrailsTrailLoggingDestinationArgs',
    'AuditTrailsTrailLoggingDestinationArgsDict',
    'AuditTrailsTrailStorageDestinationArgs',
    'AuditTrailsTrailStorageDestinationArgsDict',
    'BackupPolicyReattemptsArgs',
    'BackupPolicyReattemptsArgsDict',
    'BackupPolicyRetentionArgs',
    'BackupPolicyRetentionArgsDict',
    'BackupPolicyRetentionRuleArgs',
    'BackupPolicyRetentionRuleArgsDict',
    'BackupPolicySchedulingArgs',
    'BackupPolicySchedulingArgsDict',
    'BackupPolicySchedulingBackupSetArgs',
    'BackupPolicySchedulingBackupSetArgsDict',
    'BackupPolicySchedulingBackupSetExecuteByTimeArgs',
    'BackupPolicySchedulingBackupSetExecuteByTimeArgsDict',
    'BackupPolicySchedulingExecuteByTimeArgs',
    'BackupPolicySchedulingExecuteByTimeArgsDict',
    'BackupPolicyVmSnapshotReattemptsArgs',
    'BackupPolicyVmSnapshotReattemptsArgsDict',
    'CdnOriginGroupOriginArgs',
    'CdnOriginGroupOriginArgsDict',
    'CdnResourceOptionsArgs',
    'CdnResourceOptionsArgsDict',
    'CdnResourceOptionsIpAddressAclArgs',
    'CdnResourceOptionsIpAddressAclArgsDict',
    'CdnResourceSslCertificateArgs',
    'CdnResourceSslCertificateArgsDict',
    'CmCertificateChallengeArgs',
    'CmCertificateChallengeArgsDict',
    'CmCertificateManagedArgs',
    'CmCertificateManagedArgsDict',
    'CmCertificateSelfManagedArgs',
    'CmCertificateSelfManagedArgsDict',
    'CmCertificateSelfManagedPrivateKeyLockboxSecretArgs',
    'CmCertificateSelfManagedPrivateKeyLockboxSecretArgsDict',
    'ComputeDiskDiskPlacementPolicyArgs',
    'ComputeDiskDiskPlacementPolicyArgsDict',
    'ComputeDiskHardwareGenerationArgs',
    'ComputeDiskHardwareGenerationArgsDict',
    'ComputeDiskHardwareGenerationGeneration2FeaturesArgs',
    'ComputeDiskHardwareGenerationGeneration2FeaturesArgsDict',
    'ComputeDiskHardwareGenerationLegacyFeaturesArgs',
    'ComputeDiskHardwareGenerationLegacyFeaturesArgsDict',
    'ComputeImageHardwareGenerationArgs',
    'ComputeImageHardwareGenerationArgsDict',
    'ComputeImageHardwareGenerationGeneration2FeaturesArgs',
    'ComputeImageHardwareGenerationGeneration2FeaturesArgsDict',
    'ComputeImageHardwareGenerationLegacyFeaturesArgs',
    'ComputeImageHardwareGenerationLegacyFeaturesArgsDict',
    'ComputeInstanceBootDiskArgs',
    'ComputeInstanceBootDiskArgsDict',
    'ComputeInstanceBootDiskInitializeParamsArgs',
    'ComputeInstanceBootDiskInitializeParamsArgsDict',
    'ComputeInstanceFilesystemArgs',
    'ComputeInstanceFilesystemArgsDict',
    'ComputeInstanceGroupAllocationPolicyArgs',
    'ComputeInstanceGroupAllocationPolicyArgsDict',
    'ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs',
    'ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgsDict',
    'ComputeInstanceGroupApplicationLoadBalancerArgs',
    'ComputeInstanceGroupApplicationLoadBalancerArgsDict',
    'ComputeInstanceGroupDeployPolicyArgs',
    'ComputeInstanceGroupDeployPolicyArgsDict',
    'ComputeInstanceGroupHealthCheckArgs',
    'ComputeInstanceGroupHealthCheckArgsDict',
    'ComputeInstanceGroupHealthCheckHttpOptionsArgs',
    'ComputeInstanceGroupHealthCheckHttpOptionsArgsDict',
    'ComputeInstanceGroupHealthCheckTcpOptionsArgs',
    'ComputeInstanceGroupHealthCheckTcpOptionsArgsDict',
    'ComputeInstanceGroupInstanceArgs',
    'ComputeInstanceGroupInstanceArgsDict',
    'ComputeInstanceGroupInstanceNetworkInterfaceArgs',
    'ComputeInstanceGroupInstanceNetworkInterfaceArgsDict',
    'ComputeInstanceGroupInstanceTemplateArgs',
    'ComputeInstanceGroupInstanceTemplateArgsDict',
    'ComputeInstanceGroupInstanceTemplateBootDiskArgs',
    'ComputeInstanceGroupInstanceTemplateBootDiskArgsDict',
    'ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs',
    'ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgsDict',
    'ComputeInstanceGroupInstanceTemplateFilesystemArgs',
    'ComputeInstanceGroupInstanceTemplateFilesystemArgsDict',
    'ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs',
    'ComputeInstanceGroupInstanceTemplateMetadataOptionsArgsDict',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgsDict',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgsDict',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgsDict',
    'ComputeInstanceGroupInstanceTemplateNetworkSettingArgs',
    'ComputeInstanceGroupInstanceTemplateNetworkSettingArgsDict',
    'ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs',
    'ComputeInstanceGroupInstanceTemplatePlacementPolicyArgsDict',
    'ComputeInstanceGroupInstanceTemplateResourcesArgs',
    'ComputeInstanceGroupInstanceTemplateResourcesArgsDict',
    'ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs',
    'ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgsDict',
    'ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs',
    'ComputeInstanceGroupInstanceTemplateSecondaryDiskArgsDict',
    'ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs',
    'ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgsDict',
    'ComputeInstanceGroupLoadBalancerArgs',
    'ComputeInstanceGroupLoadBalancerArgsDict',
    'ComputeInstanceGroupScalePolicyArgs',
    'ComputeInstanceGroupScalePolicyArgsDict',
    'ComputeInstanceGroupScalePolicyAutoScaleArgs',
    'ComputeInstanceGroupScalePolicyAutoScaleArgsDict',
    'ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs',
    'ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgsDict',
    'ComputeInstanceGroupScalePolicyFixedScaleArgs',
    'ComputeInstanceGroupScalePolicyFixedScaleArgsDict',
    'ComputeInstanceGroupScalePolicyTestAutoScaleArgs',
    'ComputeInstanceGroupScalePolicyTestAutoScaleArgsDict',
    'ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs',
    'ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgsDict',
    'ComputeInstanceHardwareGenerationArgs',
    'ComputeInstanceHardwareGenerationArgsDict',
    'ComputeInstanceHardwareGenerationGeneration2FeatureArgs',
    'ComputeInstanceHardwareGenerationGeneration2FeatureArgsDict',
    'ComputeInstanceHardwareGenerationLegacyFeatureArgs',
    'ComputeInstanceHardwareGenerationLegacyFeatureArgsDict',
    'ComputeInstanceLocalDiskArgs',
    'ComputeInstanceLocalDiskArgsDict',
    'ComputeInstanceMetadataOptionsArgs',
    'ComputeInstanceMetadataOptionsArgsDict',
    'ComputeInstanceNetworkInterfaceArgs',
    'ComputeInstanceNetworkInterfaceArgsDict',
    'ComputeInstanceNetworkInterfaceDnsRecordArgs',
    'ComputeInstanceNetworkInterfaceDnsRecordArgsDict',
    'ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs',
    'ComputeInstanceNetworkInterfaceIpv6DnsRecordArgsDict',
    'ComputeInstanceNetworkInterfaceNatDnsRecordArgs',
    'ComputeInstanceNetworkInterfaceNatDnsRecordArgsDict',
    'ComputeInstancePlacementPolicyArgs',
    'ComputeInstancePlacementPolicyArgsDict',
    'ComputeInstancePlacementPolicyHostAffinityRuleArgs',
    'ComputeInstancePlacementPolicyHostAffinityRuleArgsDict',
    'ComputeInstanceResourcesArgs',
    'ComputeInstanceResourcesArgsDict',
    'ComputeInstanceSchedulingPolicyArgs',
    'ComputeInstanceSchedulingPolicyArgsDict',
    'ComputeInstanceSecondaryDiskArgs',
    'ComputeInstanceSecondaryDiskArgsDict',
    'ComputeSnapshotHardwareGenerationArgs',
    'ComputeSnapshotHardwareGenerationArgsDict',
    'ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs',
    'ComputeSnapshotHardwareGenerationGeneration2FeaturesArgsDict',
    'ComputeSnapshotHardwareGenerationLegacyFeaturesArgs',
    'ComputeSnapshotHardwareGenerationLegacyFeaturesArgsDict',
    'ComputeSnapshotScheduleSchedulePolicyArgs',
    'ComputeSnapshotScheduleSchedulePolicyArgsDict',
    'ComputeSnapshotScheduleSnapshotSpecArgs',
    'ComputeSnapshotScheduleSnapshotSpecArgsDict',
    'ContainerRepositoryLifecyclePolicyRuleArgs',
    'ContainerRepositoryLifecyclePolicyRuleArgsDict',
    'DataprocClusterClusterConfigArgs',
    'DataprocClusterClusterConfigArgsDict',
    'DataprocClusterClusterConfigHadoopArgs',
    'DataprocClusterClusterConfigHadoopArgsDict',
    'DataprocClusterClusterConfigHadoopInitializationActionArgs',
    'DataprocClusterClusterConfigHadoopInitializationActionArgsDict',
    'DataprocClusterClusterConfigSubclusterSpecArgs',
    'DataprocClusterClusterConfigSubclusterSpecArgsDict',
    'DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs',
    'DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgsDict',
    'DataprocClusterClusterConfigSubclusterSpecResourcesArgs',
    'DataprocClusterClusterConfigSubclusterSpecResourcesArgsDict',
    'DatatransferEndpointSettingsArgs',
    'DatatransferEndpointSettingsArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceArgs',
    'DatatransferEndpointSettingsClickhouseSourceArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgs',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetArgs',
    'DatatransferEndpointSettingsClickhouseTargetArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetAltNameArgs',
    'DatatransferEndpointSettingsClickhouseTargetAltNameArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgsDict',
    'DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs',
    'DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgsDict',
    'DatatransferEndpointSettingsKafkaSourceArgs',
    'DatatransferEndpointSettingsKafkaSourceArgsDict',
    'DatatransferEndpointSettingsKafkaSourceAuthArgs',
    'DatatransferEndpointSettingsKafkaSourceAuthArgsDict',
    'DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgs',
    'DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgsDict',
    'DatatransferEndpointSettingsKafkaSourceAuthSaslArgs',
    'DatatransferEndpointSettingsKafkaSourceAuthSaslArgsDict',
    'DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgs',
    'DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgsDict',
    'DatatransferEndpointSettingsKafkaSourceConnectionArgs',
    'DatatransferEndpointSettingsKafkaSourceConnectionArgsDict',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgs',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgsDict',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserArgs',
    'DatatransferEndpointSettingsKafkaSourceParserArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs',
    'DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs',
    'DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgs',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgsDict',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgs',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgsDict',
    'DatatransferEndpointSettingsKafkaSourceTransformerArgs',
    'DatatransferEndpointSettingsKafkaSourceTransformerArgsDict',
    'DatatransferEndpointSettingsKafkaTargetArgs',
    'DatatransferEndpointSettingsKafkaTargetArgsDict',
    'DatatransferEndpointSettingsKafkaTargetAuthArgs',
    'DatatransferEndpointSettingsKafkaTargetAuthArgsDict',
    'DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs',
    'DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgsDict',
    'DatatransferEndpointSettingsKafkaTargetAuthSaslArgs',
    'DatatransferEndpointSettingsKafkaTargetAuthSaslArgsDict',
    'DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgs',
    'DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgsDict',
    'DatatransferEndpointSettingsKafkaTargetConnectionArgs',
    'DatatransferEndpointSettingsKafkaTargetConnectionArgsDict',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgsDict',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsKafkaTargetSerializerArgs',
    'DatatransferEndpointSettingsKafkaTargetSerializerArgsDict',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgsDict',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgsDict',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgsDict',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgsDict',
    'DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs',
    'DatatransferEndpointSettingsKafkaTargetTopicSettingsArgsDict',
    'DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs',
    'DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgsDict',
    'DatatransferEndpointSettingsMetrikaSourceArgs',
    'DatatransferEndpointSettingsMetrikaSourceArgsDict',
    'DatatransferEndpointSettingsMetrikaSourceStreamArgs',
    'DatatransferEndpointSettingsMetrikaSourceStreamArgsDict',
    'DatatransferEndpointSettingsMetrikaSourceTokenArgs',
    'DatatransferEndpointSettingsMetrikaSourceTokenArgsDict',
    'DatatransferEndpointSettingsMongoSourceArgs',
    'DatatransferEndpointSettingsMongoSourceArgsDict',
    'DatatransferEndpointSettingsMongoSourceCollectionArgs',
    'DatatransferEndpointSettingsMongoSourceCollectionArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgs',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgsDict',
    'DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs',
    'DatatransferEndpointSettingsMongoSourceExcludedCollectionArgsDict',
    'DatatransferEndpointSettingsMongoTargetArgs',
    'DatatransferEndpointSettingsMongoTargetArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgsDict',
    'DatatransferEndpointSettingsMysqlSourceArgs',
    'DatatransferEndpointSettingsMysqlSourceArgsDict',
    'DatatransferEndpointSettingsMysqlSourceConnectionArgs',
    'DatatransferEndpointSettingsMysqlSourceConnectionArgsDict',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgsDict',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs',
    'DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgsDict',
    'DatatransferEndpointSettingsMysqlSourcePasswordArgs',
    'DatatransferEndpointSettingsMysqlSourcePasswordArgsDict',
    'DatatransferEndpointSettingsMysqlTargetArgs',
    'DatatransferEndpointSettingsMysqlTargetArgsDict',
    'DatatransferEndpointSettingsMysqlTargetConnectionArgs',
    'DatatransferEndpointSettingsMysqlTargetConnectionArgsDict',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgsDict',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsMysqlTargetPasswordArgs',
    'DatatransferEndpointSettingsMysqlTargetPasswordArgsDict',
    'DatatransferEndpointSettingsPostgresSourceArgs',
    'DatatransferEndpointSettingsPostgresSourceArgsDict',
    'DatatransferEndpointSettingsPostgresSourceConnectionArgs',
    'DatatransferEndpointSettingsPostgresSourceConnectionArgsDict',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgsDict',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs',
    'DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgsDict',
    'DatatransferEndpointSettingsPostgresSourcePasswordArgs',
    'DatatransferEndpointSettingsPostgresSourcePasswordArgsDict',
    'DatatransferEndpointSettingsPostgresTargetArgs',
    'DatatransferEndpointSettingsPostgresTargetArgsDict',
    'DatatransferEndpointSettingsPostgresTargetConnectionArgs',
    'DatatransferEndpointSettingsPostgresTargetConnectionArgsDict',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgsDict',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgsDict',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgsDict',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgsDict',
    'DatatransferEndpointSettingsPostgresTargetPasswordArgs',
    'DatatransferEndpointSettingsPostgresTargetPasswordArgsDict',
    'DatatransferEndpointSettingsYdbSourceArgs',
    'DatatransferEndpointSettingsYdbSourceArgsDict',
    'DatatransferEndpointSettingsYdbTargetArgs',
    'DatatransferEndpointSettingsYdbTargetArgsDict',
    'DatatransferEndpointSettingsYdsSourceArgs',
    'DatatransferEndpointSettingsYdsSourceArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserArgs',
    'DatatransferEndpointSettingsYdsSourceParserArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs',
    'DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs',
    'DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserArgs',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserArgs',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgs',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgs',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgsDict',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgs',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgsDict',
    'DatatransferEndpointSettingsYdsTargetArgs',
    'DatatransferEndpointSettingsYdsTargetArgsDict',
    'DatatransferEndpointSettingsYdsTargetSerializerArgs',
    'DatatransferEndpointSettingsYdsTargetSerializerArgsDict',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgsDict',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgsDict',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgsDict',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgsDict',
    'DatatransferTransferRuntimeArgs',
    'DatatransferTransferRuntimeArgsDict',
    'DatatransferTransferRuntimeYcRuntimeArgs',
    'DatatransferTransferRuntimeYcRuntimeArgsDict',
    'DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs',
    'DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgsDict',
    'DatatransferTransferTransformationArgs',
    'DatatransferTransferTransformationArgsDict',
    'DatatransferTransferTransformationTransformerArgs',
    'DatatransferTransferTransformationTransformerArgsDict',
    'DatatransferTransferTransformationTransformerConvertToStringArgs',
    'DatatransferTransferTransformationTransformerConvertToStringArgsDict',
    'DatatransferTransferTransformationTransformerConvertToStringColumnsArgs',
    'DatatransferTransferTransformationTransformerConvertToStringColumnsArgsDict',
    'DatatransferTransferTransformationTransformerConvertToStringTablesArgs',
    'DatatransferTransferTransformationTransformerConvertToStringTablesArgsDict',
    'DatatransferTransferTransformationTransformerFilterColumnsArgs',
    'DatatransferTransferTransformationTransformerFilterColumnsArgsDict',
    'DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs',
    'DatatransferTransferTransformationTransformerFilterColumnsColumnsArgsDict',
    'DatatransferTransferTransformationTransformerFilterColumnsTablesArgs',
    'DatatransferTransferTransformationTransformerFilterColumnsTablesArgsDict',
    'DatatransferTransferTransformationTransformerFilterRowsArgs',
    'DatatransferTransferTransformationTransformerFilterRowsArgsDict',
    'DatatransferTransferTransformationTransformerFilterRowsTablesArgs',
    'DatatransferTransferTransformationTransformerFilterRowsTablesArgsDict',
    'DatatransferTransferTransformationTransformerMaskFieldArgs',
    'DatatransferTransferTransformationTransformerMaskFieldArgsDict',
    'DatatransferTransferTransformationTransformerMaskFieldFunctionArgs',
    'DatatransferTransferTransformationTransformerMaskFieldFunctionArgsDict',
    'DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs',
    'DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgsDict',
    'DatatransferTransferTransformationTransformerMaskFieldTablesArgs',
    'DatatransferTransferTransformationTransformerMaskFieldTablesArgsDict',
    'DatatransferTransferTransformationTransformerRenameTablesArgs',
    'DatatransferTransferTransformationTransformerRenameTablesArgsDict',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableArgsDict',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgsDict',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgsDict',
    'DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs',
    'DatatransferTransferTransformationTransformerReplacePrimaryKeyArgsDict',
    'DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs',
    'DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgsDict',
    'DatatransferTransferTransformationTransformerSharderTransformerArgs',
    'DatatransferTransferTransformationTransformerSharderTransformerArgsDict',
    'DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs',
    'DatatransferTransferTransformationTransformerSharderTransformerColumnsArgsDict',
    'DatatransferTransferTransformationTransformerSharderTransformerTablesArgs',
    'DatatransferTransferTransformationTransformerSharderTransformerTablesArgsDict',
    'DatatransferTransferTransformationTransformerTableSplitterTransformerArgs',
    'DatatransferTransferTransformationTransformerTableSplitterTransformerArgsDict',
    'DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs',
    'DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgsDict',
    'FunctionAsyncInvocationArgs',
    'FunctionAsyncInvocationArgsDict',
    'FunctionAsyncInvocationYmqFailureTargetArgs',
    'FunctionAsyncInvocationYmqFailureTargetArgsDict',
    'FunctionAsyncInvocationYmqSuccessTargetArgs',
    'FunctionAsyncInvocationYmqSuccessTargetArgsDict',
    'FunctionConnectivityArgs',
    'FunctionConnectivityArgsDict',
    'FunctionContentArgs',
    'FunctionContentArgsDict',
    'FunctionLogOptionsArgs',
    'FunctionLogOptionsArgsDict',
    'FunctionMountArgs',
    'FunctionMountArgsDict',
    'FunctionMountEphemeralDiskArgs',
    'FunctionMountEphemeralDiskArgsDict',
    'FunctionMountObjectStorageArgs',
    'FunctionMountObjectStorageArgsDict',
    'FunctionPackageArgs',
    'FunctionPackageArgsDict',
    'FunctionScalingPolicyPolicyArgs',
    'FunctionScalingPolicyPolicyArgsDict',
    'FunctionSecretArgs',
    'FunctionSecretArgsDict',
    'FunctionStorageMountArgs',
    'FunctionStorageMountArgsDict',
    'FunctionTriggerContainerArgs',
    'FunctionTriggerContainerArgsDict',
    'FunctionTriggerContainerRegistryArgs',
    'FunctionTriggerContainerRegistryArgsDict',
    'FunctionTriggerDataStreamsArgs',
    'FunctionTriggerDataStreamsArgsDict',
    'FunctionTriggerDlqArgs',
    'FunctionTriggerDlqArgsDict',
    'FunctionTriggerFunctionArgs',
    'FunctionTriggerFunctionArgsDict',
    'FunctionTriggerIotArgs',
    'FunctionTriggerIotArgsDict',
    'FunctionTriggerLogGroupArgs',
    'FunctionTriggerLogGroupArgsDict',
    'FunctionTriggerLoggingArgs',
    'FunctionTriggerLoggingArgsDict',
    'FunctionTriggerMailArgs',
    'FunctionTriggerMailArgsDict',
    'FunctionTriggerMessageQueueArgs',
    'FunctionTriggerMessageQueueArgsDict',
    'FunctionTriggerObjectStorageArgs',
    'FunctionTriggerObjectStorageArgsDict',
    'FunctionTriggerTimerArgs',
    'FunctionTriggerTimerArgsDict',
    'IamServiceAccountApiKeyOutputToLockboxArgs',
    'IamServiceAccountApiKeyOutputToLockboxArgsDict',
    'IamServiceAccountKeyOutputToLockboxArgs',
    'IamServiceAccountKeyOutputToLockboxArgsDict',
    'IamServiceAccountStaticAccessKeyOutputToLockboxArgs',
    'IamServiceAccountStaticAccessKeyOutputToLockboxArgsDict',
    'IotCoreBrokerLogOptionsArgs',
    'IotCoreBrokerLogOptionsArgsDict',
    'IotCoreRegistryLogOptionsArgs',
    'IotCoreRegistryLogOptionsArgsDict',
    'KubernetesClusterKmsProviderArgs',
    'KubernetesClusterKmsProviderArgsDict',
    'KubernetesClusterMasterArgs',
    'KubernetesClusterMasterArgsDict',
    'KubernetesClusterMasterMaintenancePolicyArgs',
    'KubernetesClusterMasterMaintenancePolicyArgsDict',
    'KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs',
    'KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgsDict',
    'KubernetesClusterMasterMasterLocationArgs',
    'KubernetesClusterMasterMasterLocationArgsDict',
    'KubernetesClusterMasterMasterLoggingArgs',
    'KubernetesClusterMasterMasterLoggingArgsDict',
    'KubernetesClusterMasterRegionalArgs',
    'KubernetesClusterMasterRegionalArgsDict',
    'KubernetesClusterMasterRegionalLocationArgs',
    'KubernetesClusterMasterRegionalLocationArgsDict',
    'KubernetesClusterMasterVersionInfoArgs',
    'KubernetesClusterMasterVersionInfoArgsDict',
    'KubernetesClusterMasterZonalArgs',
    'KubernetesClusterMasterZonalArgsDict',
    'KubernetesClusterNetworkImplementationArgs',
    'KubernetesClusterNetworkImplementationArgsDict',
    'KubernetesClusterNetworkImplementationCiliumArgs',
    'KubernetesClusterNetworkImplementationCiliumArgsDict',
    'KubernetesNodeGroupAllocationPolicyArgs',
    'KubernetesNodeGroupAllocationPolicyArgsDict',
    'KubernetesNodeGroupAllocationPolicyLocationArgs',
    'KubernetesNodeGroupAllocationPolicyLocationArgsDict',
    'KubernetesNodeGroupDeployPolicyArgs',
    'KubernetesNodeGroupDeployPolicyArgsDict',
    'KubernetesNodeGroupInstanceTemplateArgs',
    'KubernetesNodeGroupInstanceTemplateArgsDict',
    'KubernetesNodeGroupInstanceTemplateBootDiskArgs',
    'KubernetesNodeGroupInstanceTemplateBootDiskArgsDict',
    'KubernetesNodeGroupInstanceTemplateContainerNetworkArgs',
    'KubernetesNodeGroupInstanceTemplateContainerNetworkArgsDict',
    'KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs',
    'KubernetesNodeGroupInstanceTemplateContainerRuntimeArgsDict',
    'KubernetesNodeGroupInstanceTemplateGpuSettingsArgs',
    'KubernetesNodeGroupInstanceTemplateGpuSettingsArgsDict',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgsDict',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgsDict',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict',
    'KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs',
    'KubernetesNodeGroupInstanceTemplatePlacementPolicyArgsDict',
    'KubernetesNodeGroupInstanceTemplateResourcesArgs',
    'KubernetesNodeGroupInstanceTemplateResourcesArgsDict',
    'KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs',
    'KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgsDict',
    'KubernetesNodeGroupMaintenancePolicyArgs',
    'KubernetesNodeGroupMaintenancePolicyArgsDict',
    'KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs',
    'KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgsDict',
    'KubernetesNodeGroupScalePolicyArgs',
    'KubernetesNodeGroupScalePolicyArgsDict',
    'KubernetesNodeGroupScalePolicyAutoScaleArgs',
    'KubernetesNodeGroupScalePolicyAutoScaleArgsDict',
    'KubernetesNodeGroupScalePolicyFixedScaleArgs',
    'KubernetesNodeGroupScalePolicyFixedScaleArgsDict',
    'KubernetesNodeGroupVersionInfoArgs',
    'KubernetesNodeGroupVersionInfoArgsDict',
    'LbNetworkLoadBalancerAttachedTargetGroupArgs',
    'LbNetworkLoadBalancerAttachedTargetGroupArgsDict',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgsDict',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgsDict',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgsDict',
    'LbNetworkLoadBalancerListenerArgs',
    'LbNetworkLoadBalancerListenerArgsDict',
    'LbNetworkLoadBalancerListenerExternalAddressSpecArgs',
    'LbNetworkLoadBalancerListenerExternalAddressSpecArgsDict',
    'LbNetworkLoadBalancerListenerInternalAddressSpecArgs',
    'LbNetworkLoadBalancerListenerInternalAddressSpecArgsDict',
    'LbTargetGroupTargetArgs',
    'LbTargetGroupTargetArgsDict',
    'LoadtestingAgentComputeInstanceArgs',
    'LoadtestingAgentComputeInstanceArgsDict',
    'LoadtestingAgentComputeInstanceBootDiskArgs',
    'LoadtestingAgentComputeInstanceBootDiskArgsDict',
    'LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs',
    'LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgsDict',
    'LoadtestingAgentComputeInstanceNetworkInterfaceArgs',
    'LoadtestingAgentComputeInstanceNetworkInterfaceArgsDict',
    'LoadtestingAgentComputeInstanceResourcesArgs',
    'LoadtestingAgentComputeInstanceResourcesArgsDict',
    'LoadtestingAgentLogSettingsArgs',
    'LoadtestingAgentLogSettingsArgsDict',
    'LockboxSecretPasswordPayloadSpecificationArgs',
    'LockboxSecretPasswordPayloadSpecificationArgsDict',
    'LockboxSecretVersionEntryArgs',
    'LockboxSecretVersionEntryArgsDict',
    'LockboxSecretVersionEntryCommandArgs',
    'LockboxSecretVersionEntryCommandArgsDict',
    'MdbClickhouseClusterAccessArgs',
    'MdbClickhouseClusterAccessArgsDict',
    'MdbClickhouseClusterBackupWindowStartArgs',
    'MdbClickhouseClusterBackupWindowStartArgsDict',
    'MdbClickhouseClusterClickhouseArgs',
    'MdbClickhouseClusterClickhouseArgsDict',
    'MdbClickhouseClusterClickhouseConfigArgs',
    'MdbClickhouseClusterClickhouseConfigArgsDict',
    'MdbClickhouseClusterClickhouseConfigCompressionArgs',
    'MdbClickhouseClusterClickhouseConfigCompressionArgsDict',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict',
    'MdbClickhouseClusterClickhouseConfigKafkaArgs',
    'MdbClickhouseClusterClickhouseConfigKafkaArgsDict',
    'MdbClickhouseClusterClickhouseConfigKafkaTopicArgs',
    'MdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict',
    'MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs',
    'MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict',
    'MdbClickhouseClusterClickhouseConfigMergeTreeArgs',
    'MdbClickhouseClusterClickhouseConfigMergeTreeArgsDict',
    'MdbClickhouseClusterClickhouseConfigQueryCacheArgs',
    'MdbClickhouseClusterClickhouseConfigQueryCacheArgsDict',
    'MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs',
    'MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict',
    'MdbClickhouseClusterClickhouseConfigRabbitmqArgs',
    'MdbClickhouseClusterClickhouseConfigRabbitmqArgsDict',
    'MdbClickhouseClusterClickhouseResourcesArgs',
    'MdbClickhouseClusterClickhouseResourcesArgsDict',
    'MdbClickhouseClusterCloudStorageArgs',
    'MdbClickhouseClusterCloudStorageArgsDict',
    'MdbClickhouseClusterDatabaseArgs',
    'MdbClickhouseClusterDatabaseArgsDict',
    'MdbClickhouseClusterFormatSchemaArgs',
    'MdbClickhouseClusterFormatSchemaArgsDict',
    'MdbClickhouseClusterHostArgs',
    'MdbClickhouseClusterHostArgsDict',
    'MdbClickhouseClusterMaintenanceWindowArgs',
    'MdbClickhouseClusterMaintenanceWindowArgsDict',
    'MdbClickhouseClusterMlModelArgs',
    'MdbClickhouseClusterMlModelArgsDict',
    'MdbClickhouseClusterShardArgs',
    'MdbClickhouseClusterShardArgsDict',
    'MdbClickhouseClusterShardGroupArgs',
    'MdbClickhouseClusterShardGroupArgsDict',
    'MdbClickhouseClusterShardResourcesArgs',
    'MdbClickhouseClusterShardResourcesArgsDict',
    'MdbClickhouseClusterUserArgs',
    'MdbClickhouseClusterUserArgsDict',
    'MdbClickhouseClusterUserPermissionArgs',
    'MdbClickhouseClusterUserPermissionArgsDict',
    'MdbClickhouseClusterUserQuotaArgs',
    'MdbClickhouseClusterUserQuotaArgsDict',
    'MdbClickhouseClusterUserSettingsArgs',
    'MdbClickhouseClusterUserSettingsArgsDict',
    'MdbClickhouseClusterZookeeperArgs',
    'MdbClickhouseClusterZookeeperArgsDict',
    'MdbClickhouseClusterZookeeperResourcesArgs',
    'MdbClickhouseClusterZookeeperResourcesArgsDict',
    'MdbElasticsearchClusterConfigArgs',
    'MdbElasticsearchClusterConfigArgsDict',
    'MdbElasticsearchClusterConfigDataNodeArgs',
    'MdbElasticsearchClusterConfigDataNodeArgsDict',
    'MdbElasticsearchClusterConfigDataNodeResourcesArgs',
    'MdbElasticsearchClusterConfigDataNodeResourcesArgsDict',
    'MdbElasticsearchClusterConfigMasterNodeArgs',
    'MdbElasticsearchClusterConfigMasterNodeArgsDict',
    'MdbElasticsearchClusterConfigMasterNodeResourcesArgs',
    'MdbElasticsearchClusterConfigMasterNodeResourcesArgsDict',
    'MdbElasticsearchClusterHostArgs',
    'MdbElasticsearchClusterHostArgsDict',
    'MdbElasticsearchClusterMaintenanceWindowArgs',
    'MdbElasticsearchClusterMaintenanceWindowArgsDict',
    'MdbGreenplumClusterAccessArgs',
    'MdbGreenplumClusterAccessArgsDict',
    'MdbGreenplumClusterBackgroundActivityArgs',
    'MdbGreenplumClusterBackgroundActivityArgsDict',
    'MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs',
    'MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict',
    'MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs',
    'MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict',
    'MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs',
    'MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict',
    'MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs',
    'MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict',
    'MdbGreenplumClusterBackupWindowStartArgs',
    'MdbGreenplumClusterBackupWindowStartArgsDict',
    'MdbGreenplumClusterCloudStorageArgs',
    'MdbGreenplumClusterCloudStorageArgsDict',
    'MdbGreenplumClusterMaintenanceWindowArgs',
    'MdbGreenplumClusterMaintenanceWindowArgsDict',
    'MdbGreenplumClusterMasterHostArgs',
    'MdbGreenplumClusterMasterHostArgsDict',
    'MdbGreenplumClusterMasterSubclusterArgs',
    'MdbGreenplumClusterMasterSubclusterArgsDict',
    'MdbGreenplumClusterMasterSubclusterResourcesArgs',
    'MdbGreenplumClusterMasterSubclusterResourcesArgsDict',
    'MdbGreenplumClusterPoolerConfigArgs',
    'MdbGreenplumClusterPoolerConfigArgsDict',
    'MdbGreenplumClusterPxfConfigArgs',
    'MdbGreenplumClusterPxfConfigArgsDict',
    'MdbGreenplumClusterSegmentHostArgs',
    'MdbGreenplumClusterSegmentHostArgsDict',
    'MdbGreenplumClusterSegmentSubclusterArgs',
    'MdbGreenplumClusterSegmentSubclusterArgsDict',
    'MdbGreenplumClusterSegmentSubclusterResourcesArgs',
    'MdbGreenplumClusterSegmentSubclusterResourcesArgsDict',
    'MdbKafkaClusterConfigArgs',
    'MdbKafkaClusterConfigArgsDict',
    'MdbKafkaClusterConfigAccessArgs',
    'MdbKafkaClusterConfigAccessArgsDict',
    'MdbKafkaClusterConfigDiskSizeAutoscalingArgs',
    'MdbKafkaClusterConfigDiskSizeAutoscalingArgsDict',
    'MdbKafkaClusterConfigKafkaArgs',
    'MdbKafkaClusterConfigKafkaArgsDict',
    'MdbKafkaClusterConfigKafkaKafkaConfigArgs',
    'MdbKafkaClusterConfigKafkaKafkaConfigArgsDict',
    'MdbKafkaClusterConfigKafkaResourcesArgs',
    'MdbKafkaClusterConfigKafkaResourcesArgsDict',
    'MdbKafkaClusterConfigKraftArgs',
    'MdbKafkaClusterConfigKraftArgsDict',
    'MdbKafkaClusterConfigKraftResourcesArgs',
    'MdbKafkaClusterConfigKraftResourcesArgsDict',
    'MdbKafkaClusterConfigZookeeperArgs',
    'MdbKafkaClusterConfigZookeeperArgsDict',
    'MdbKafkaClusterConfigZookeeperResourcesArgs',
    'MdbKafkaClusterConfigZookeeperResourcesArgsDict',
    'MdbKafkaClusterHostArgs',
    'MdbKafkaClusterHostArgsDict',
    'MdbKafkaClusterMaintenanceWindowArgs',
    'MdbKafkaClusterMaintenanceWindowArgsDict',
    'MdbKafkaClusterTopicArgs',
    'MdbKafkaClusterTopicArgsDict',
    'MdbKafkaClusterTopicTopicConfigArgs',
    'MdbKafkaClusterTopicTopicConfigArgsDict',
    'MdbKafkaClusterUserArgs',
    'MdbKafkaClusterUserArgsDict',
    'MdbKafkaClusterUserPermissionArgs',
    'MdbKafkaClusterUserPermissionArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgsDict',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgsDict',
    'MdbKafkaConnectorConnectorConfigS3SinkArgs',
    'MdbKafkaConnectorConnectorConfigS3SinkArgsDict',
    'MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs',
    'MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgsDict',
    'MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args',
    'MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3ArgsDict',
    'MdbKafkaTopicTopicConfigArgs',
    'MdbKafkaTopicTopicConfigArgsDict',
    'MdbKafkaUserPermissionArgs',
    'MdbKafkaUserPermissionArgsDict',
    'MdbMongodbClusterClusterConfigArgs',
    'MdbMongodbClusterClusterConfigArgsDict',
    'MdbMongodbClusterClusterConfigAccessArgs',
    'MdbMongodbClusterClusterConfigAccessArgsDict',
    'MdbMongodbClusterClusterConfigBackupWindowStartArgs',
    'MdbMongodbClusterClusterConfigBackupWindowStartArgsDict',
    'MdbMongodbClusterClusterConfigMongocfgArgs',
    'MdbMongodbClusterClusterConfigMongocfgArgsDict',
    'MdbMongodbClusterClusterConfigMongocfgNetArgs',
    'MdbMongodbClusterClusterConfigMongocfgNetArgsDict',
    'MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs',
    'MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict',
    'MdbMongodbClusterClusterConfigMongocfgStorageArgs',
    'MdbMongodbClusterClusterConfigMongocfgStorageArgsDict',
    'MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs',
    'MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict',
    'MdbMongodbClusterClusterConfigMongodArgs',
    'MdbMongodbClusterClusterConfigMongodArgsDict',
    'MdbMongodbClusterClusterConfigMongodAuditLogArgs',
    'MdbMongodbClusterClusterConfigMongodAuditLogArgsDict',
    'MdbMongodbClusterClusterConfigMongodNetArgs',
    'MdbMongodbClusterClusterConfigMongodNetArgsDict',
    'MdbMongodbClusterClusterConfigMongodOperationProfilingArgs',
    'MdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict',
    'MdbMongodbClusterClusterConfigMongodSecurityArgs',
    'MdbMongodbClusterClusterConfigMongodSecurityArgsDict',
    'MdbMongodbClusterClusterConfigMongodSecurityKmipArgs',
    'MdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict',
    'MdbMongodbClusterClusterConfigMongodSetParameterArgs',
    'MdbMongodbClusterClusterConfigMongodSetParameterArgsDict',
    'MdbMongodbClusterClusterConfigMongodStorageArgs',
    'MdbMongodbClusterClusterConfigMongodStorageArgsDict',
    'MdbMongodbClusterClusterConfigMongodStorageJournalArgs',
    'MdbMongodbClusterClusterConfigMongodStorageJournalArgsDict',
    'MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs',
    'MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict',
    'MdbMongodbClusterClusterConfigMongosArgs',
    'MdbMongodbClusterClusterConfigMongosArgsDict',
    'MdbMongodbClusterClusterConfigMongosNetArgs',
    'MdbMongodbClusterClusterConfigMongosNetArgsDict',
    'MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs',
    'MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict',
    'MdbMongodbClusterDatabaseArgs',
    'MdbMongodbClusterDatabaseArgsDict',
    'MdbMongodbClusterDiskSizeAutoscalingMongocfgArgs',
    'MdbMongodbClusterDiskSizeAutoscalingMongocfgArgsDict',
    'MdbMongodbClusterDiskSizeAutoscalingMongodArgs',
    'MdbMongodbClusterDiskSizeAutoscalingMongodArgsDict',
    'MdbMongodbClusterDiskSizeAutoscalingMongoinfraArgs',
    'MdbMongodbClusterDiskSizeAutoscalingMongoinfraArgsDict',
    'MdbMongodbClusterDiskSizeAutoscalingMongosArgs',
    'MdbMongodbClusterDiskSizeAutoscalingMongosArgsDict',
    'MdbMongodbClusterHostArgs',
    'MdbMongodbClusterHostArgsDict',
    'MdbMongodbClusterHostHostParametersArgs',
    'MdbMongodbClusterHostHostParametersArgsDict',
    'MdbMongodbClusterMaintenanceWindowArgs',
    'MdbMongodbClusterMaintenanceWindowArgsDict',
    'MdbMongodbClusterResourcesArgs',
    'MdbMongodbClusterResourcesArgsDict',
    'MdbMongodbClusterResourcesMongocfgArgs',
    'MdbMongodbClusterResourcesMongocfgArgsDict',
    'MdbMongodbClusterResourcesMongodArgs',
    'MdbMongodbClusterResourcesMongodArgsDict',
    'MdbMongodbClusterResourcesMongoinfraArgs',
    'MdbMongodbClusterResourcesMongoinfraArgsDict',
    'MdbMongodbClusterResourcesMongosArgs',
    'MdbMongodbClusterResourcesMongosArgsDict',
    'MdbMongodbClusterRestoreArgs',
    'MdbMongodbClusterRestoreArgsDict',
    'MdbMongodbClusterUserArgs',
    'MdbMongodbClusterUserArgsDict',
    'MdbMongodbClusterUserPermissionArgs',
    'MdbMongodbClusterUserPermissionArgsDict',
    'MdbMysqlClusterAccessArgs',
    'MdbMysqlClusterAccessArgsDict',
    'MdbMysqlClusterBackupWindowStartArgs',
    'MdbMysqlClusterBackupWindowStartArgsDict',
    'MdbMysqlClusterDatabaseArgs',
    'MdbMysqlClusterDatabaseArgsDict',
    'MdbMysqlClusterHostArgs',
    'MdbMysqlClusterHostArgsDict',
    'MdbMysqlClusterMaintenanceWindowArgs',
    'MdbMysqlClusterMaintenanceWindowArgsDict',
    'MdbMysqlClusterPerformanceDiagnosticsArgs',
    'MdbMysqlClusterPerformanceDiagnosticsArgsDict',
    'MdbMysqlClusterResourcesArgs',
    'MdbMysqlClusterResourcesArgsDict',
    'MdbMysqlClusterRestoreArgs',
    'MdbMysqlClusterRestoreArgsDict',
    'MdbMysqlClusterUserArgs',
    'MdbMysqlClusterUserArgsDict',
    'MdbMysqlClusterUserConnectionLimitsArgs',
    'MdbMysqlClusterUserConnectionLimitsArgsDict',
    'MdbMysqlClusterUserPermissionArgs',
    'MdbMysqlClusterUserPermissionArgsDict',
    'MdbMysqlUserConnectionLimitsArgs',
    'MdbMysqlUserConnectionLimitsArgsDict',
    'MdbMysqlUserPermissionArgs',
    'MdbMysqlUserPermissionArgsDict',
    'MdbPostgresqlClusterConfigArgs',
    'MdbPostgresqlClusterConfigArgsDict',
    'MdbPostgresqlClusterConfigAccessArgs',
    'MdbPostgresqlClusterConfigAccessArgsDict',
    'MdbPostgresqlClusterConfigBackupWindowStartArgs',
    'MdbPostgresqlClusterConfigBackupWindowStartArgsDict',
    'MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs',
    'MdbPostgresqlClusterConfigDiskSizeAutoscalingArgsDict',
    'MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs',
    'MdbPostgresqlClusterConfigPerformanceDiagnosticsArgsDict',
    'MdbPostgresqlClusterConfigPoolerConfigArgs',
    'MdbPostgresqlClusterConfigPoolerConfigArgsDict',
    'MdbPostgresqlClusterConfigResourcesArgs',
    'MdbPostgresqlClusterConfigResourcesArgsDict',
    'MdbPostgresqlClusterDatabaseArgs',
    'MdbPostgresqlClusterDatabaseArgsDict',
    'MdbPostgresqlClusterDatabaseExtensionArgs',
    'MdbPostgresqlClusterDatabaseExtensionArgsDict',
    'MdbPostgresqlClusterHostArgs',
    'MdbPostgresqlClusterHostArgsDict',
    'MdbPostgresqlClusterMaintenanceWindowArgs',
    'MdbPostgresqlClusterMaintenanceWindowArgsDict',
    'MdbPostgresqlClusterRestoreArgs',
    'MdbPostgresqlClusterRestoreArgsDict',
    'MdbPostgresqlClusterUserArgs',
    'MdbPostgresqlClusterUserArgsDict',
    'MdbPostgresqlClusterUserPermissionArgs',
    'MdbPostgresqlClusterUserPermissionArgsDict',
    'MdbPostgresqlDatabaseExtensionArgs',
    'MdbPostgresqlDatabaseExtensionArgsDict',
    'MdbPostgresqlUserPermissionArgs',
    'MdbPostgresqlUserPermissionArgsDict',
    'MdbRedisClusterAccessArgs',
    'MdbRedisClusterAccessArgsDict',
    'MdbRedisClusterConfigArgs',
    'MdbRedisClusterConfigArgsDict',
    'MdbRedisClusterConfigBackupWindowStartArgs',
    'MdbRedisClusterConfigBackupWindowStartArgsDict',
    'MdbRedisClusterDiskSizeAutoscalingArgs',
    'MdbRedisClusterDiskSizeAutoscalingArgsDict',
    'MdbRedisClusterHostArgs',
    'MdbRedisClusterHostArgsDict',
    'MdbRedisClusterMaintenanceWindowArgs',
    'MdbRedisClusterMaintenanceWindowArgsDict',
    'MdbRedisClusterResourcesArgs',
    'MdbRedisClusterResourcesArgsDict',
    'MdbSqlserverClusterBackupWindowStartArgs',
    'MdbSqlserverClusterBackupWindowStartArgsDict',
    'MdbSqlserverClusterDatabaseArgs',
    'MdbSqlserverClusterDatabaseArgsDict',
    'MdbSqlserverClusterHostArgs',
    'MdbSqlserverClusterHostArgsDict',
    'MdbSqlserverClusterResourcesArgs',
    'MdbSqlserverClusterResourcesArgsDict',
    'MdbSqlserverClusterUserArgs',
    'MdbSqlserverClusterUserArgsDict',
    'MdbSqlserverClusterUserPermissionArgs',
    'MdbSqlserverClusterUserPermissionArgsDict',
    'MonitoringDashboardParametrizationArgs',
    'MonitoringDashboardParametrizationArgsDict',
    'MonitoringDashboardParametrizationParameterArgs',
    'MonitoringDashboardParametrizationParameterArgsDict',
    'MonitoringDashboardParametrizationParameterCustomArgs',
    'MonitoringDashboardParametrizationParameterCustomArgsDict',
    'MonitoringDashboardParametrizationParameterLabelValueArgs',
    'MonitoringDashboardParametrizationParameterLabelValueArgsDict',
    'MonitoringDashboardParametrizationParameterTextArgs',
    'MonitoringDashboardParametrizationParameterTextArgsDict',
    'MonitoringDashboardWidgetArgs',
    'MonitoringDashboardWidgetArgsDict',
    'MonitoringDashboardWidgetChartArgs',
    'MonitoringDashboardWidgetChartArgsDict',
    'MonitoringDashboardWidgetChartNameHidingSettingArgs',
    'MonitoringDashboardWidgetChartNameHidingSettingArgsDict',
    'MonitoringDashboardWidgetChartQueryArgs',
    'MonitoringDashboardWidgetChartQueryArgsDict',
    'MonitoringDashboardWidgetChartQueryDownsamplingArgs',
    'MonitoringDashboardWidgetChartQueryDownsamplingArgsDict',
    'MonitoringDashboardWidgetChartQueryTargetArgs',
    'MonitoringDashboardWidgetChartQueryTargetArgsDict',
    'MonitoringDashboardWidgetChartSeriesOverrideArgs',
    'MonitoringDashboardWidgetChartSeriesOverrideArgsDict',
    'MonitoringDashboardWidgetChartSeriesOverrideSettingArgs',
    'MonitoringDashboardWidgetChartSeriesOverrideSettingArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgsDict',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgsDict',
    'MonitoringDashboardWidgetPositionArgs',
    'MonitoringDashboardWidgetPositionArgsDict',
    'MonitoringDashboardWidgetTextArgs',
    'MonitoringDashboardWidgetTextArgsDict',
    'MonitoringDashboardWidgetTitleArgs',
    'MonitoringDashboardWidgetTitleArgsDict',
    'OrganizationmanagerOsLoginSettingsSshCertificateSettingsArgs',
    'OrganizationmanagerOsLoginSettingsSshCertificateSettingsArgsDict',
    'OrganizationmanagerOsLoginSettingsUserSshKeySettingsArgs',
    'OrganizationmanagerOsLoginSettingsUserSshKeySettingsArgsDict',
    'OrganizationmanagerSamlFederationSecuritySettingsArgs',
    'OrganizationmanagerSamlFederationSecuritySettingsArgsDict',
    'ServerlessContainerConnectivityArgs',
    'ServerlessContainerConnectivityArgsDict',
    'ServerlessContainerImageArgs',
    'ServerlessContainerImageArgsDict',
    'ServerlessContainerLogOptionsArgs',
    'ServerlessContainerLogOptionsArgsDict',
    'ServerlessContainerMountArgs',
    'ServerlessContainerMountArgsDict',
    'ServerlessContainerMountEphemeralDiskArgs',
    'ServerlessContainerMountEphemeralDiskArgsDict',
    'ServerlessContainerMountObjectStorageArgs',
    'ServerlessContainerMountObjectStorageArgsDict',
    'ServerlessContainerProvisionPolicyArgs',
    'ServerlessContainerProvisionPolicyArgsDict',
    'ServerlessContainerRuntimeArgs',
    'ServerlessContainerRuntimeArgsDict',
    'ServerlessContainerSecretArgs',
    'ServerlessContainerSecretArgsDict',
    'ServerlessContainerStorageMountArgs',
    'ServerlessContainerStorageMountArgsDict',
    'ServerlessEventrouterConnectorYdArgs',
    'ServerlessEventrouterConnectorYdArgsDict',
    'ServerlessEventrouterConnectorYmqArgs',
    'ServerlessEventrouterConnectorYmqArgsDict',
    'ServerlessEventrouterRuleContainerArgs',
    'ServerlessEventrouterRuleContainerArgsDict',
    'ServerlessEventrouterRuleContainerBatchSettingsArgs',
    'ServerlessEventrouterRuleContainerBatchSettingsArgsDict',
    'ServerlessEventrouterRuleFunctionArgs',
    'ServerlessEventrouterRuleFunctionArgsDict',
    'ServerlessEventrouterRuleFunctionBatchSettingsArgs',
    'ServerlessEventrouterRuleFunctionBatchSettingsArgsDict',
    'ServerlessEventrouterRuleGatewayWebsocketBroadcastArgs',
    'ServerlessEventrouterRuleGatewayWebsocketBroadcastArgsDict',
    'ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs',
    'ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgsDict',
    'ServerlessEventrouterRuleLoggingArgs',
    'ServerlessEventrouterRuleLoggingArgsDict',
    'ServerlessEventrouterRuleWorkflowArgs',
    'ServerlessEventrouterRuleWorkflowArgsDict',
    'ServerlessEventrouterRuleWorkflowBatchSettingsArgs',
    'ServerlessEventrouterRuleWorkflowBatchSettingsArgsDict',
    'ServerlessEventrouterRuleYdArgs',
    'ServerlessEventrouterRuleYdArgsDict',
    'ServerlessEventrouterRuleYmqArgs',
    'ServerlessEventrouterRuleYmqArgsDict',
    'SmartcaptchaCaptchaOverrideVariantArgs',
    'SmartcaptchaCaptchaOverrideVariantArgsDict',
    'SmartcaptchaCaptchaSecurityRuleArgs',
    'SmartcaptchaCaptchaSecurityRuleArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionHeaderArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionHeaderArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionHostArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionHostArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionHostHostArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionHostHostArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionUriArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionUriArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionUriPathArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionUriPathArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgsDict',
    'SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgs',
    'SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgsDict',
    'StorageBucketAnonymousAccessFlagsArgs',
    'StorageBucketAnonymousAccessFlagsArgsDict',
    'StorageBucketCorsRuleArgs',
    'StorageBucketCorsRuleArgsDict',
    'StorageBucketGrantArgs',
    'StorageBucketGrantArgsDict',
    'StorageBucketHttpsArgs',
    'StorageBucketHttpsArgsDict',
    'StorageBucketLifecycleRuleArgs',
    'StorageBucketLifecycleRuleArgsDict',
    'StorageBucketLifecycleRuleExpirationArgs',
    'StorageBucketLifecycleRuleExpirationArgsDict',
    'StorageBucketLifecycleRuleFilterArgs',
    'StorageBucketLifecycleRuleFilterArgsDict',
    'StorageBucketLifecycleRuleFilterAndArgs',
    'StorageBucketLifecycleRuleFilterAndArgsDict',
    'StorageBucketLifecycleRuleFilterTagArgs',
    'StorageBucketLifecycleRuleFilterTagArgsDict',
    'StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'StorageBucketLifecycleRuleNoncurrentVersionExpirationArgsDict',
    'StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs',
    'StorageBucketLifecycleRuleNoncurrentVersionTransitionArgsDict',
    'StorageBucketLifecycleRuleTransitionArgs',
    'StorageBucketLifecycleRuleTransitionArgsDict',
    'StorageBucketLoggingArgs',
    'StorageBucketLoggingArgsDict',
    'StorageBucketObjectLockConfigurationArgs',
    'StorageBucketObjectLockConfigurationArgsDict',
    'StorageBucketObjectLockConfigurationRuleArgs',
    'StorageBucketObjectLockConfigurationRuleArgsDict',
    'StorageBucketObjectLockConfigurationRuleDefaultRetentionArgs',
    'StorageBucketObjectLockConfigurationRuleDefaultRetentionArgsDict',
    'StorageBucketServerSideEncryptionConfigurationArgs',
    'StorageBucketServerSideEncryptionConfigurationArgsDict',
    'StorageBucketServerSideEncryptionConfigurationRuleArgs',
    'StorageBucketServerSideEncryptionConfigurationRuleArgsDict',
    'StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs',
    'StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict',
    'StorageBucketVersioningArgs',
    'StorageBucketVersioningArgsDict',
    'StorageBucketWebsiteArgs',
    'StorageBucketWebsiteArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgsDict',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgs',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgsDict',
    'SwsSecurityProfileSecurityRuleArgs',
    'SwsSecurityProfileSecurityRuleArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgsDict',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgs',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgsDict',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgs',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgsDict',
    'SwsSecurityProfileSecurityRuleWafArgs',
    'SwsSecurityProfileSecurityRuleWafArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionArgs',
    'SwsSecurityProfileSecurityRuleWafConditionArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionAuthorityArgs',
    'SwsSecurityProfileSecurityRuleWafConditionAuthorityArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgs',
    'SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionHeaderArgs',
    'SwsSecurityProfileSecurityRuleWafConditionHeaderArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgs',
    'SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgs',
    'SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgs',
    'SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriArgs',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgs',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgs',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgs',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpArgs',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgs',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgs',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgs',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgsDict',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgs',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgsDict',
    'SwsWafProfileAnalyzeRequestBodyArgs',
    'SwsWafProfileAnalyzeRequestBodyArgsDict',
    'SwsWafProfileCoreRuleSetArgs',
    'SwsWafProfileCoreRuleSetArgsDict',
    'SwsWafProfileCoreRuleSetRuleSetArgs',
    'SwsWafProfileCoreRuleSetRuleSetArgsDict',
    'SwsWafProfileExclusionRuleArgs',
    'SwsWafProfileExclusionRuleArgsDict',
    'SwsWafProfileExclusionRuleConditionArgs',
    'SwsWafProfileExclusionRuleConditionArgsDict',
    'SwsWafProfileExclusionRuleConditionAuthorityArgs',
    'SwsWafProfileExclusionRuleConditionAuthorityArgsDict',
    'SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgs',
    'SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgsDict',
    'SwsWafProfileExclusionRuleConditionHeaderArgs',
    'SwsWafProfileExclusionRuleConditionHeaderArgsDict',
    'SwsWafProfileExclusionRuleConditionHeaderValueArgs',
    'SwsWafProfileExclusionRuleConditionHeaderValueArgsDict',
    'SwsWafProfileExclusionRuleConditionHttpMethodArgs',
    'SwsWafProfileExclusionRuleConditionHttpMethodArgsDict',
    'SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgs',
    'SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgsDict',
    'SwsWafProfileExclusionRuleConditionRequestUriArgs',
    'SwsWafProfileExclusionRuleConditionRequestUriArgsDict',
    'SwsWafProfileExclusionRuleConditionRequestUriPathArgs',
    'SwsWafProfileExclusionRuleConditionRequestUriPathArgsDict',
    'SwsWafProfileExclusionRuleConditionRequestUriQueryArgs',
    'SwsWafProfileExclusionRuleConditionRequestUriQueryArgsDict',
    'SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgs',
    'SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgsDict',
    'SwsWafProfileExclusionRuleConditionSourceIpArgs',
    'SwsWafProfileExclusionRuleConditionSourceIpArgsDict',
    'SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs',
    'SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgsDict',
    'SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs',
    'SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgsDict',
    'SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs',
    'SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgsDict',
    'SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs',
    'SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgsDict',
    'SwsWafProfileExclusionRuleExcludeRulesArgs',
    'SwsWafProfileExclusionRuleExcludeRulesArgsDict',
    'SwsWafProfileRuleArgs',
    'SwsWafProfileRuleArgsDict',
    'VpcAddressDnsRecordArgs',
    'VpcAddressDnsRecordArgsDict',
    'VpcAddressExternalIpv4AddressArgs',
    'VpcAddressExternalIpv4AddressArgsDict',
    'VpcDefaultSecurityGroupEgressArgs',
    'VpcDefaultSecurityGroupEgressArgsDict',
    'VpcDefaultSecurityGroupIngressArgs',
    'VpcDefaultSecurityGroupIngressArgsDict',
    'VpcGatewaySharedEgressGatewayArgs',
    'VpcGatewaySharedEgressGatewayArgsDict',
    'VpcPrivateEndpointDnsOptionsArgs',
    'VpcPrivateEndpointDnsOptionsArgsDict',
    'VpcPrivateEndpointEndpointAddressArgs',
    'VpcPrivateEndpointEndpointAddressArgsDict',
    'VpcPrivateEndpointObjectStorageArgs',
    'VpcPrivateEndpointObjectStorageArgsDict',
    'VpcRouteTableStaticRouteArgs',
    'VpcRouteTableStaticRouteArgsDict',
    'VpcSecurityGroupEgressArgs',
    'VpcSecurityGroupEgressArgsDict',
    'VpcSecurityGroupIngressArgs',
    'VpcSecurityGroupIngressArgsDict',
    'VpcSubnetDhcpOptionsArgs',
    'VpcSubnetDhcpOptionsArgsDict',
    'YdbDatabaseDedicatedLocationArgs',
    'YdbDatabaseDedicatedLocationArgsDict',
    'YdbDatabaseDedicatedLocationRegionArgs',
    'YdbDatabaseDedicatedLocationRegionArgsDict',
    'YdbDatabaseDedicatedScalePolicyArgs',
    'YdbDatabaseDedicatedScalePolicyArgsDict',
    'YdbDatabaseDedicatedScalePolicyFixedScaleArgs',
    'YdbDatabaseDedicatedScalePolicyFixedScaleArgsDict',
    'YdbDatabaseDedicatedStorageConfigArgs',
    'YdbDatabaseDedicatedStorageConfigArgsDict',
    'YdbDatabaseServerlessServerlessDatabaseArgs',
    'YdbDatabaseServerlessServerlessDatabaseArgsDict',
    'YdbTableChangefeedConsumerArgs',
    'YdbTableChangefeedConsumerArgsDict',
    'YdbTableColumnArgs',
    'YdbTableColumnArgsDict',
    'YdbTableFamilyArgs',
    'YdbTableFamilyArgsDict',
    'YdbTablePartitioningSettingsArgs',
    'YdbTablePartitioningSettingsArgsDict',
    'YdbTablePartitioningSettingsPartitionAtKeyArgs',
    'YdbTablePartitioningSettingsPartitionAtKeyArgsDict',
    'YdbTableTtlArgs',
    'YdbTableTtlArgsDict',
    'YdbTopicConsumerArgs',
    'YdbTopicConsumerArgsDict',
    'GetAlbBackendGroupGrpcBackendArgs',
    'GetAlbBackendGroupGrpcBackendArgsDict',
    'GetAlbBackendGroupGrpcBackendHealthcheckArgs',
    'GetAlbBackendGroupGrpcBackendHealthcheckArgsDict',
    'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs',
    'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict',
    'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs',
    'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict',
    'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs',
    'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict',
    'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs',
    'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict',
    'GetAlbBackendGroupGrpcBackendTlsArgs',
    'GetAlbBackendGroupGrpcBackendTlsArgsDict',
    'GetAlbBackendGroupGrpcBackendTlsValidationContextArgs',
    'GetAlbBackendGroupGrpcBackendTlsValidationContextArgsDict',
    'GetAlbBackendGroupHttpBackendArgs',
    'GetAlbBackendGroupHttpBackendArgsDict',
    'GetAlbBackendGroupHttpBackendHealthcheckArgs',
    'GetAlbBackendGroupHttpBackendHealthcheckArgsDict',
    'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs',
    'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict',
    'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs',
    'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict',
    'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs',
    'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict',
    'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs',
    'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgsDict',
    'GetAlbBackendGroupHttpBackendTlsArgs',
    'GetAlbBackendGroupHttpBackendTlsArgsDict',
    'GetAlbBackendGroupHttpBackendTlsValidationContextArgs',
    'GetAlbBackendGroupHttpBackendTlsValidationContextArgsDict',
    'GetAlbBackendGroupSessionAffinityArgs',
    'GetAlbBackendGroupSessionAffinityArgsDict',
    'GetAlbBackendGroupSessionAffinityConnectionArgs',
    'GetAlbBackendGroupSessionAffinityConnectionArgsDict',
    'GetAlbBackendGroupSessionAffinityCookieArgs',
    'GetAlbBackendGroupSessionAffinityCookieArgsDict',
    'GetAlbBackendGroupSessionAffinityHeaderArgs',
    'GetAlbBackendGroupSessionAffinityHeaderArgsDict',
    'GetAlbBackendGroupStreamBackendArgs',
    'GetAlbBackendGroupStreamBackendArgsDict',
    'GetAlbBackendGroupStreamBackendHealthcheckArgs',
    'GetAlbBackendGroupStreamBackendHealthcheckArgsDict',
    'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs',
    'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict',
    'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs',
    'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict',
    'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs',
    'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict',
    'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs',
    'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgsDict',
    'GetAlbBackendGroupStreamBackendTlsArgs',
    'GetAlbBackendGroupStreamBackendTlsArgsDict',
    'GetAlbBackendGroupStreamBackendTlsValidationContextArgs',
    'GetAlbBackendGroupStreamBackendTlsValidationContextArgsDict',
    'GetApiGatewayCanaryArgs',
    'GetApiGatewayCanaryArgsDict',
    'GetApiGatewayConnectivityArgs',
    'GetApiGatewayConnectivityArgsDict',
    'GetApiGatewayCustomDomainArgs',
    'GetApiGatewayCustomDomainArgsDict',
    'GetCdnResourceOptionsArgs',
    'GetCdnResourceOptionsArgsDict',
    'GetCdnResourceOptionsIpAddressAclArgs',
    'GetCdnResourceOptionsIpAddressAclArgsDict',
    'GetCdnResourceSslCertificateArgs',
    'GetCdnResourceSslCertificateArgsDict',
    'GetComputeDiskDiskPlacementPolicyArgs',
    'GetComputeDiskDiskPlacementPolicyArgsDict',
    'GetComputeInstanceFilesystemArgs',
    'GetComputeInstanceFilesystemArgsDict',
    'GetComputeInstanceLocalDiskArgs',
    'GetComputeInstanceLocalDiskArgsDict',
    'GetComputeInstanceMetadataOptionsArgs',
    'GetComputeInstanceMetadataOptionsArgsDict',
    'GetComputeInstancePlacementPolicyArgs',
    'GetComputeInstancePlacementPolicyArgsDict',
    'GetComputeInstancePlacementPolicyHostAffinityRuleArgs',
    'GetComputeInstancePlacementPolicyHostAffinityRuleArgsDict',
    'GetComputeSnapshotScheduleSchedulePolicyArgs',
    'GetComputeSnapshotScheduleSchedulePolicyArgsDict',
    'GetComputeSnapshotScheduleSnapshotSpecArgs',
    'GetComputeSnapshotScheduleSnapshotSpecArgsDict',
    'GetFunctionConnectivityArgs',
    'GetFunctionConnectivityArgsDict',
    'GetFunctionMountArgs',
    'GetFunctionMountArgsDict',
    'GetFunctionMountEphemeralDiskArgs',
    'GetFunctionMountEphemeralDiskArgsDict',
    'GetFunctionMountObjectStorageArgs',
    'GetFunctionMountObjectStorageArgsDict',
    'GetFunctionScalingPolicyPolicyArgs',
    'GetFunctionScalingPolicyPolicyArgsDict',
    'GetFunctionSecretArgs',
    'GetFunctionSecretArgsDict',
    'GetFunctionStorageMountArgs',
    'GetFunctionStorageMountArgsDict',
    'GetIamPolicyBindingArgs',
    'GetIamPolicyBindingArgsDict',
    'GetLoadtestingAgentLogSettingsArgs',
    'GetLoadtestingAgentLogSettingsArgsDict',
    'GetMdbClickhouseClusterAccessArgs',
    'GetMdbClickhouseClusterAccessArgsDict',
    'GetMdbClickhouseClusterBackupWindowStartArgs',
    'GetMdbClickhouseClusterBackupWindowStartArgsDict',
    'GetMdbClickhouseClusterClickhouseArgs',
    'GetMdbClickhouseClusterClickhouseArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigArgs',
    'GetMdbClickhouseClusterClickhouseConfigArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigCompressionArgs',
    'GetMdbClickhouseClusterClickhouseConfigCompressionArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigKafkaArgs',
    'GetMdbClickhouseClusterClickhouseConfigKafkaArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs',
    'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs',
    'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs',
    'GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict',
    'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs',
    'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgsDict',
    'GetMdbClickhouseClusterClickhouseResourcesArgs',
    'GetMdbClickhouseClusterClickhouseResourcesArgsDict',
    'GetMdbClickhouseClusterCloudStorageArgs',
    'GetMdbClickhouseClusterCloudStorageArgsDict',
    'GetMdbClickhouseClusterDatabaseArgs',
    'GetMdbClickhouseClusterDatabaseArgsDict',
    'GetMdbClickhouseClusterFormatSchemaArgs',
    'GetMdbClickhouseClusterFormatSchemaArgsDict',
    'GetMdbClickhouseClusterHostArgs',
    'GetMdbClickhouseClusterHostArgsDict',
    'GetMdbClickhouseClusterMaintenanceWindowArgs',
    'GetMdbClickhouseClusterMaintenanceWindowArgsDict',
    'GetMdbClickhouseClusterMlModelArgs',
    'GetMdbClickhouseClusterMlModelArgsDict',
    'GetMdbClickhouseClusterShardArgs',
    'GetMdbClickhouseClusterShardArgsDict',
    'GetMdbClickhouseClusterShardGroupArgs',
    'GetMdbClickhouseClusterShardGroupArgsDict',
    'GetMdbClickhouseClusterShardResourcesArgs',
    'GetMdbClickhouseClusterShardResourcesArgsDict',
    'GetMdbClickhouseClusterUserArgs',
    'GetMdbClickhouseClusterUserArgsDict',
    'GetMdbClickhouseClusterUserPermissionArgs',
    'GetMdbClickhouseClusterUserPermissionArgsDict',
    'GetMdbClickhouseClusterUserQuotaArgs',
    'GetMdbClickhouseClusterUserQuotaArgsDict',
    'GetMdbClickhouseClusterUserSettingsArgs',
    'GetMdbClickhouseClusterUserSettingsArgsDict',
    'GetMdbClickhouseClusterZookeeperArgs',
    'GetMdbClickhouseClusterZookeeperArgsDict',
    'GetMdbClickhouseClusterZookeeperResourcesArgs',
    'GetMdbClickhouseClusterZookeeperResourcesArgsDict',
    'GetMdbGreenplumClusterBackgroundActivityArgs',
    'GetMdbGreenplumClusterBackgroundActivityArgsDict',
    'GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs',
    'GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict',
    'GetMdbGreenplumClusterPoolerConfigArgs',
    'GetMdbGreenplumClusterPoolerConfigArgsDict',
    'GetMdbGreenplumClusterPxfConfigArgs',
    'GetMdbGreenplumClusterPxfConfigArgsDict',
    'GetMdbKafkaClusterConfigArgs',
    'GetMdbKafkaClusterConfigArgsDict',
    'GetMdbKafkaClusterConfigAccessArgs',
    'GetMdbKafkaClusterConfigAccessArgsDict',
    'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs',
    'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgsDict',
    'GetMdbKafkaClusterConfigKafkaArgs',
    'GetMdbKafkaClusterConfigKafkaArgsDict',
    'GetMdbKafkaClusterConfigKafkaKafkaConfigArgs',
    'GetMdbKafkaClusterConfigKafkaKafkaConfigArgsDict',
    'GetMdbKafkaClusterConfigKafkaResourcesArgs',
    'GetMdbKafkaClusterConfigKafkaResourcesArgsDict',
    'GetMdbKafkaClusterConfigKraftArgs',
    'GetMdbKafkaClusterConfigKraftArgsDict',
    'GetMdbKafkaClusterConfigKraftResourcesArgs',
    'GetMdbKafkaClusterConfigKraftResourcesArgsDict',
    'GetMdbKafkaClusterConfigZookeeperArgs',
    'GetMdbKafkaClusterConfigZookeeperArgsDict',
    'GetMdbKafkaClusterConfigZookeeperResourcesArgs',
    'GetMdbKafkaClusterConfigZookeeperResourcesArgsDict',
    'GetMdbKafkaClusterTopicArgs',
    'GetMdbKafkaClusterTopicArgsDict',
    'GetMdbKafkaClusterTopicTopicConfigArgs',
    'GetMdbKafkaClusterTopicTopicConfigArgsDict',
    'GetMdbKafkaClusterUserArgs',
    'GetMdbKafkaClusterUserArgsDict',
    'GetMdbKafkaClusterUserPermissionArgs',
    'GetMdbKafkaClusterUserPermissionArgsDict',
    'GetMdbMongodbClusterClusterConfigArgs',
    'GetMdbMongodbClusterClusterConfigArgsDict',
    'GetMdbMongodbClusterClusterConfigAccessArgs',
    'GetMdbMongodbClusterClusterConfigAccessArgsDict',
    'GetMdbMongodbClusterClusterConfigBackupWindowStartArgs',
    'GetMdbMongodbClusterClusterConfigBackupWindowStartArgsDict',
    'GetMdbMongodbClusterClusterConfigMongocfgArgs',
    'GetMdbMongodbClusterClusterConfigMongocfgArgsDict',
    'GetMdbMongodbClusterClusterConfigMongocfgNetArgs',
    'GetMdbMongodbClusterClusterConfigMongocfgNetArgsDict',
    'GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs',
    'GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict',
    'GetMdbMongodbClusterClusterConfigMongocfgStorageArgs',
    'GetMdbMongodbClusterClusterConfigMongocfgStorageArgsDict',
    'GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs',
    'GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodArgs',
    'GetMdbMongodbClusterClusterConfigMongodArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodAuditLogArgs',
    'GetMdbMongodbClusterClusterConfigMongodAuditLogArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodNetArgs',
    'GetMdbMongodbClusterClusterConfigMongodNetArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgs',
    'GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodSecurityArgs',
    'GetMdbMongodbClusterClusterConfigMongodSecurityArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs',
    'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodSetParameterArgs',
    'GetMdbMongodbClusterClusterConfigMongodSetParameterArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodStorageArgs',
    'GetMdbMongodbClusterClusterConfigMongodStorageArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodStorageJournalArgs',
    'GetMdbMongodbClusterClusterConfigMongodStorageJournalArgsDict',
    'GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs',
    'GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict',
    'GetMdbMongodbClusterClusterConfigMongosArgs',
    'GetMdbMongodbClusterClusterConfigMongosArgsDict',
    'GetMdbMongodbClusterClusterConfigMongosNetArgs',
    'GetMdbMongodbClusterClusterConfigMongosNetArgsDict',
    'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs',
    'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict',
    'GetMdbMongodbClusterDatabaseArgs',
    'GetMdbMongodbClusterDatabaseArgsDict',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongocfgArgs',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongocfgArgsDict',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongodArgs',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongodArgsDict',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraArgs',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraArgsDict',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongosArgs',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongosArgsDict',
    'GetMdbMongodbClusterHostArgs',
    'GetMdbMongodbClusterHostArgsDict',
    'GetMdbMongodbClusterHostHostParametersArgs',
    'GetMdbMongodbClusterHostHostParametersArgsDict',
    'GetMdbMongodbClusterMaintenanceWindowArgs',
    'GetMdbMongodbClusterMaintenanceWindowArgsDict',
    'GetMdbMongodbClusterResourcesArgs',
    'GetMdbMongodbClusterResourcesArgsDict',
    'GetMdbMongodbClusterResourcesMongocfgArgs',
    'GetMdbMongodbClusterResourcesMongocfgArgsDict',
    'GetMdbMongodbClusterResourcesMongodArgs',
    'GetMdbMongodbClusterResourcesMongodArgsDict',
    'GetMdbMongodbClusterResourcesMongoinfraArgs',
    'GetMdbMongodbClusterResourcesMongoinfraArgsDict',
    'GetMdbMongodbClusterResourcesMongosArgs',
    'GetMdbMongodbClusterResourcesMongosArgsDict',
    'GetMdbMongodbClusterRestoreArgs',
    'GetMdbMongodbClusterRestoreArgsDict',
    'GetMdbMongodbClusterUserArgs',
    'GetMdbMongodbClusterUserArgsDict',
    'GetMdbMongodbClusterUserPermissionArgs',
    'GetMdbMongodbClusterUserPermissionArgsDict',
    'GetMdbMysqlClusterAccessArgs',
    'GetMdbMysqlClusterAccessArgsDict',
    'GetMdbMysqlUserPermissionArgs',
    'GetMdbMysqlUserPermissionArgsDict',
    'GetMdbPostgresqlDatabaseExtensionArgs',
    'GetMdbPostgresqlDatabaseExtensionArgsDict',
    'GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsArgs',
    'GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsArgsDict',
    'GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsArgs',
    'GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsArgsDict',
    'GetServerlessContainerConnectivityArgs',
    'GetServerlessContainerConnectivityArgsDict',
    'GetServerlessContainerMountArgs',
    'GetServerlessContainerMountArgsDict',
    'GetServerlessContainerMountEphemeralDiskArgs',
    'GetServerlessContainerMountEphemeralDiskArgsDict',
    'GetServerlessContainerMountObjectStorageArgs',
    'GetServerlessContainerMountObjectStorageArgsDict',
    'GetServerlessContainerRuntimeArgs',
    'GetServerlessContainerRuntimeArgsDict',
    'GetServerlessContainerSecretArgs',
    'GetServerlessContainerSecretArgsDict',
    'GetServerlessContainerStorageMountArgs',
    'GetServerlessContainerStorageMountArgsDict',
    'GetVpcGatewaySharedEgressGatewayArgs',
    'GetVpcGatewaySharedEgressGatewayArgsDict',
    'GetVpcPrivateEndpointObjectStorageArgs',
    'GetVpcPrivateEndpointObjectStorageArgsDict',
    'GetYdbDatabaseServerlessServerlessDatabaseArgs',
    'GetYdbDatabaseServerlessServerlessDatabaseArgsDict',
]

MYPY = False

if not MYPY:
    class AlbBackendGroupGrpcBackendArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the backend.
        """
        target_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        References target groups for the backend.
        """
        healthcheck: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckArgsDict']]
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        load_balancing_config: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict']]
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for incoming traffic.
        """
        tls: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendTlsArgsDict']]
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
elif False:
    AlbBackendGroupGrpcBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 target_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 healthcheck: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckArgs']] = None,
                 load_balancing_config: Optional[pulumi.Input['AlbBackendGroupGrpcBackendLoadBalancingConfigArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 tls: Optional[pulumi.Input['AlbBackendGroupGrpcBackendTlsArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Name of the backend.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_group_ids: References target groups for the backend.
        :param pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckArgs'] healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input['AlbBackendGroupGrpcBackendLoadBalancingConfigArgs'] load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[int] port: Port for incoming traffic.
        :param pulumi.Input['AlbBackendGroupGrpcBackendTlsArgs'] tls: Tls specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[int] weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @target_group_ids.setter
    def target_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_group_ids", value)

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckArgs']]:
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckArgs']]):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendLoadBalancingConfigArgs']]:
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @load_balancing_config.setter
    def load_balancing_config(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendLoadBalancingConfigArgs']]):
        pulumi.set(self, "load_balancing_config", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendTlsArgs']]:
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendHealthcheckArgsDict(TypedDict):
        interval: pulumi.Input[str]
        """
        Interval between health checks.
        """
        timeout: pulumi.Input[str]
        """
        Time to wait for a health check response.
        """
        grpc_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict']]
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.

        > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        """
        healthcheck_port: NotRequired[pulumi.Input[int]]
        """
        Optional alternative port for health checking.
        """
        healthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        http_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict']]
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        interval_jitter_percent: NotRequired[pulumi.Input[float]]
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        stream_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict']]
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
elif False:
    AlbBackendGroupGrpcBackendHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendHealthcheckArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 grpc_healthcheck: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs']] = None,
                 healthcheck_port: Optional[pulumi.Input[int]] = None,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 http_healthcheck: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs']] = None,
                 interval_jitter_percent: Optional[pulumi.Input[float]] = None,
                 stream_healthcheck: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs']] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] interval: Interval between health checks.
        :param pulumi.Input[str] timeout: Time to wait for a health check response.
        :param pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs'] grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
               
               > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        :param pulumi.Input[int] healthcheck_port: Optional alternative port for health checking.
        :param pulumi.Input[int] healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs'] http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param pulumi.Input[float] interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs'] stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param pulumi.Input[int] unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs']]:
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.

        > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @grpc_healthcheck.setter
    def grpc_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs']]):
        pulumi.set(self, "grpc_healthcheck", value)

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[pulumi.Input[int]]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @healthcheck_port.setter
    def healthcheck_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthcheck_port", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs']]:
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @http_healthcheck.setter
    def http_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs']]):
        pulumi.set(self, "http_healthcheck", value)

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[pulumi.Input[float]]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @interval_jitter_percent.setter
    def interval_jitter_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval_jitter_percent", value)

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs']]:
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @stream_healthcheck.setter
    def stream_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs']]):
        pulumi.set(self, "stream_healthcheck", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict(TypedDict):
        service_name: NotRequired[pulumi.Input[str]]
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
elif False:
    AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs:
    def __init__(__self__, *,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_name: Service name for grpc.health.v1.HealthCheckRequest message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        HTTP path.
        """
        expected_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        A list of HTTP response statuses considered healthy.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        "Host" HTTP header value.
        """
        http2: NotRequired[pulumi.Input[bool]]
        """
        If set, health checks will use HTTP2.
        """
elif False:
    AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 expected_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: HTTP path.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] expected_statuses: A list of HTTP response statuses considered healthy.
        :param pulumi.Input[str] host: "Host" HTTP header value.
        :param pulumi.Input[bool] http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if expected_statuses is not None:
            pulumi.set(__self__, "expected_statuses", expected_statuses)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @expected_statuses.setter
    def expected_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "expected_statuses", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict(TypedDict):
        receive: NotRequired[pulumi.Input[str]]
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        send: NotRequired[pulumi.Input[str]]
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
elif False:
    AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs:
    def __init__(__self__, *,
                 receive: Optional[pulumi.Input[str]] = None,
                 send: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param pulumi.Input[str] send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> Optional[pulumi.Input[str]]:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "receive", value)

    @property
    @pulumi.getter
    def send(self) -> Optional[pulumi.Input[str]]:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "send", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict(TypedDict):
        locality_aware_routing_percent: NotRequired[pulumi.Input[int]]
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        """
        panic_threshold: NotRequired[pulumi.Input[int]]
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        strict_locality: NotRequired[pulumi.Input[bool]]
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
elif False:
    AlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendLoadBalancingConfigArgs:
    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 panic_threshold: Optional[pulumi.Input[int]] = None,
                 strict_locality: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param pulumi.Input[str] mode: Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        :param pulumi.Input[int] panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param pulumi.Input[bool] strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @locality_aware_routing_percent.setter
    def locality_aware_routing_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "locality_aware_routing_percent", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @panic_threshold.setter
    def panic_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "panic_threshold", value)

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")

    @strict_locality.setter
    def strict_locality(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_locality", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendTlsArgsDict(TypedDict):
        sni: NotRequired[pulumi.Input[str]]
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        validation_context: NotRequired[pulumi.Input['AlbBackendGroupGrpcBackendTlsValidationContextArgsDict']]
elif False:
    AlbBackendGroupGrpcBackendTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendTlsArgs:
    def __init__(__self__, *,
                 sni: Optional[pulumi.Input[str]] = None,
                 validation_context: Optional[pulumi.Input['AlbBackendGroupGrpcBackendTlsValidationContextArgs']] = None):
        """
        :param pulumi.Input[str] sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
               
               > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional[pulumi.Input['AlbBackendGroupGrpcBackendTlsValidationContextArgs']]:
        return pulumi.get(self, "validation_context")

    @validation_context.setter
    def validation_context(self, value: Optional[pulumi.Input['AlbBackendGroupGrpcBackendTlsValidationContextArgs']]):
        pulumi.set(self, "validation_context", value)


if not MYPY:
    class AlbBackendGroupGrpcBackendTlsValidationContextArgsDict(TypedDict):
        trusted_ca_bytes: NotRequired[pulumi.Input[str]]
        trusted_ca_id: NotRequired[pulumi.Input[str]]
elif False:
    AlbBackendGroupGrpcBackendTlsValidationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupGrpcBackendTlsValidationContextArgs:
    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[pulumi.Input[str]] = None,
                 trusted_ca_id: Optional[pulumi.Input[str]] = None):
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trusted_ca_bytes")

    @trusted_ca_bytes.setter
    def trusted_ca_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_bytes", value)

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trusted_ca_id")

    @trusted_ca_id.setter
    def trusted_ca_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_id", value)


if not MYPY:
    class AlbBackendGroupHttpBackendArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the backend.
        """
        healthcheck: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckArgsDict']]
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        http2: NotRequired[pulumi.Input[bool]]
        """
        Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        """
        load_balancing_config: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendLoadBalancingConfigArgsDict']]
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for incoming traffic.
        """
        storage_bucket: NotRequired[pulumi.Input[str]]
        """
        Name of bucket which should be used as a backend.

        > Only one of `target_group_ids` or `storage_bucket` should be specified.
        """
        target_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        References target groups for the backend.
        """
        tls: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendTlsArgsDict']]
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
elif False:
    AlbBackendGroupHttpBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 healthcheck: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckArgs']] = None,
                 http2: Optional[pulumi.Input[bool]] = None,
                 load_balancing_config: Optional[pulumi.Input['AlbBackendGroupHttpBackendLoadBalancingConfigArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 storage_bucket: Optional[pulumi.Input[str]] = None,
                 target_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tls: Optional[pulumi.Input['AlbBackendGroupHttpBackendTlsArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Name of the backend.
        :param pulumi.Input['AlbBackendGroupHttpBackendHealthcheckArgs'] healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[bool] http2: Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        :param pulumi.Input['AlbBackendGroupHttpBackendLoadBalancingConfigArgs'] load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[int] port: Port for incoming traffic.
        :param pulumi.Input[str] storage_bucket: Name of bucket which should be used as a backend.
               
               > Only one of `target_group_ids` or `storage_bucket` should be specified.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_group_ids: References target groups for the backend.
        :param pulumi.Input['AlbBackendGroupHttpBackendTlsArgs'] tls: Tls specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[int] weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if storage_bucket is not None:
            pulumi.set(__self__, "storage_bucket", storage_bucket)
        if target_group_ids is not None:
            pulumi.set(__self__, "target_group_ids", target_group_ids)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckArgs']]:
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckArgs']]):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendLoadBalancingConfigArgs']]:
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @load_balancing_config.setter
    def load_balancing_config(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendLoadBalancingConfigArgs']]):
        pulumi.set(self, "load_balancing_config", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="storageBucket")
    def storage_bucket(self) -> Optional[pulumi.Input[str]]:
        """
        Name of bucket which should be used as a backend.

        > Only one of `target_group_ids` or `storage_bucket` should be specified.
        """
        return pulumi.get(self, "storage_bucket")

    @storage_bucket.setter
    def storage_bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_bucket", value)

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @target_group_ids.setter
    def target_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_group_ids", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendTlsArgs']]:
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class AlbBackendGroupHttpBackendHealthcheckArgsDict(TypedDict):
        interval: pulumi.Input[str]
        """
        Interval between health checks.
        """
        timeout: pulumi.Input[str]
        """
        Time to wait for a health check response.
        """
        grpc_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict']]
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.

        > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        """
        healthcheck_port: NotRequired[pulumi.Input[int]]
        """
        Optional alternative port for health checking.
        """
        healthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        http_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict']]
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        interval_jitter_percent: NotRequired[pulumi.Input[float]]
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        stream_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict']]
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
elif False:
    AlbBackendGroupHttpBackendHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendHealthcheckArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 grpc_healthcheck: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs']] = None,
                 healthcheck_port: Optional[pulumi.Input[int]] = None,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 http_healthcheck: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs']] = None,
                 interval_jitter_percent: Optional[pulumi.Input[float]] = None,
                 stream_healthcheck: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs']] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] interval: Interval between health checks.
        :param pulumi.Input[str] timeout: Time to wait for a health check response.
        :param pulumi.Input['AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs'] grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
               
               > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        :param pulumi.Input[int] healthcheck_port: Optional alternative port for health checking.
        :param pulumi.Input[int] healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param pulumi.Input['AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs'] http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param pulumi.Input[float] interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param pulumi.Input['AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs'] stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param pulumi.Input[int] unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs']]:
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.

        > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @grpc_healthcheck.setter
    def grpc_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs']]):
        pulumi.set(self, "grpc_healthcheck", value)

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[pulumi.Input[int]]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @healthcheck_port.setter
    def healthcheck_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthcheck_port", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs']]:
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @http_healthcheck.setter
    def http_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs']]):
        pulumi.set(self, "http_healthcheck", value)

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[pulumi.Input[float]]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @interval_jitter_percent.setter
    def interval_jitter_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval_jitter_percent", value)

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs']]:
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @stream_healthcheck.setter
    def stream_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs']]):
        pulumi.set(self, "stream_healthcheck", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict(TypedDict):
        service_name: NotRequired[pulumi.Input[str]]
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
elif False:
    AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs:
    def __init__(__self__, *,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_name: Service name for grpc.health.v1.HealthCheckRequest message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        HTTP path.
        """
        expected_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        A list of HTTP response statuses considered healthy.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        "Host" HTTP header value.
        """
        http2: NotRequired[pulumi.Input[bool]]
        """
        If set, health checks will use HTTP2.
        """
elif False:
    AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 expected_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: HTTP path.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] expected_statuses: A list of HTTP response statuses considered healthy.
        :param pulumi.Input[str] host: "Host" HTTP header value.
        :param pulumi.Input[bool] http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if expected_statuses is not None:
            pulumi.set(__self__, "expected_statuses", expected_statuses)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @expected_statuses.setter
    def expected_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "expected_statuses", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2", value)


if not MYPY:
    class AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict(TypedDict):
        receive: NotRequired[pulumi.Input[str]]
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        send: NotRequired[pulumi.Input[str]]
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
elif False:
    AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs:
    def __init__(__self__, *,
                 receive: Optional[pulumi.Input[str]] = None,
                 send: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param pulumi.Input[str] send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> Optional[pulumi.Input[str]]:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "receive", value)

    @property
    @pulumi.getter
    def send(self) -> Optional[pulumi.Input[str]]:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "send", value)


if not MYPY:
    class AlbBackendGroupHttpBackendLoadBalancingConfigArgsDict(TypedDict):
        locality_aware_routing_percent: NotRequired[pulumi.Input[int]]
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        """
        panic_threshold: NotRequired[pulumi.Input[int]]
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        strict_locality: NotRequired[pulumi.Input[bool]]
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
elif False:
    AlbBackendGroupHttpBackendLoadBalancingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendLoadBalancingConfigArgs:
    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 panic_threshold: Optional[pulumi.Input[int]] = None,
                 strict_locality: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param pulumi.Input[str] mode: Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        :param pulumi.Input[int] panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param pulumi.Input[bool] strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @locality_aware_routing_percent.setter
    def locality_aware_routing_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "locality_aware_routing_percent", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @panic_threshold.setter
    def panic_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "panic_threshold", value)

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")

    @strict_locality.setter
    def strict_locality(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_locality", value)


if not MYPY:
    class AlbBackendGroupHttpBackendTlsArgsDict(TypedDict):
        sni: NotRequired[pulumi.Input[str]]
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        validation_context: NotRequired[pulumi.Input['AlbBackendGroupHttpBackendTlsValidationContextArgsDict']]
elif False:
    AlbBackendGroupHttpBackendTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendTlsArgs:
    def __init__(__self__, *,
                 sni: Optional[pulumi.Input[str]] = None,
                 validation_context: Optional[pulumi.Input['AlbBackendGroupHttpBackendTlsValidationContextArgs']] = None):
        """
        :param pulumi.Input[str] sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
               
               > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional[pulumi.Input['AlbBackendGroupHttpBackendTlsValidationContextArgs']]:
        return pulumi.get(self, "validation_context")

    @validation_context.setter
    def validation_context(self, value: Optional[pulumi.Input['AlbBackendGroupHttpBackendTlsValidationContextArgs']]):
        pulumi.set(self, "validation_context", value)


if not MYPY:
    class AlbBackendGroupHttpBackendTlsValidationContextArgsDict(TypedDict):
        trusted_ca_bytes: NotRequired[pulumi.Input[str]]
        trusted_ca_id: NotRequired[pulumi.Input[str]]
elif False:
    AlbBackendGroupHttpBackendTlsValidationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupHttpBackendTlsValidationContextArgs:
    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[pulumi.Input[str]] = None,
                 trusted_ca_id: Optional[pulumi.Input[str]] = None):
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trusted_ca_bytes")

    @trusted_ca_bytes.setter
    def trusted_ca_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_bytes", value)

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trusted_ca_id")

    @trusted_ca_id.setter
    def trusted_ca_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_id", value)


if not MYPY:
    class AlbBackendGroupSessionAffinityArgsDict(TypedDict):
        connection: NotRequired[pulumi.Input['AlbBackendGroupSessionAffinityConnectionArgsDict']]
        """
        Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
        """
        cookie: NotRequired[pulumi.Input['AlbBackendGroupSessionAffinityCookieArgsDict']]
        """
        Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
        header: NotRequired[pulumi.Input['AlbBackendGroupSessionAffinityHeaderArgsDict']]
        """
        Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.

        > Only one type( `connection` or `cookie` or `header` ) of session affinity should be specified.
        """
elif False:
    AlbBackendGroupSessionAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupSessionAffinityArgs:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input['AlbBackendGroupSessionAffinityConnectionArgs']] = None,
                 cookie: Optional[pulumi.Input['AlbBackendGroupSessionAffinityCookieArgs']] = None,
                 header: Optional[pulumi.Input['AlbBackendGroupSessionAffinityHeaderArgs']] = None):
        """
        :param pulumi.Input['AlbBackendGroupSessionAffinityConnectionArgs'] connection: Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
        :param pulumi.Input['AlbBackendGroupSessionAffinityCookieArgs'] cookie: Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        :param pulumi.Input['AlbBackendGroupSessionAffinityHeaderArgs'] header: Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
               
               > Only one type( `connection` or `cookie` or `header` ) of session affinity should be specified.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['AlbBackendGroupSessionAffinityConnectionArgs']]:
        """
        Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['AlbBackendGroupSessionAffinityConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['AlbBackendGroupSessionAffinityCookieArgs']]:
        """
        Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['AlbBackendGroupSessionAffinityCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['AlbBackendGroupSessionAffinityHeaderArgs']]:
        """
        Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.

        > Only one type( `connection` or `cookie` or `header` ) of session affinity should be specified.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['AlbBackendGroupSessionAffinityHeaderArgs']]):
        pulumi.set(self, "header", value)


if not MYPY:
    class AlbBackendGroupSessionAffinityConnectionArgsDict(TypedDict):
        source_ip: NotRequired[pulumi.Input[bool]]
        """
        Source IP address to use with affinity.
        """
elif False:
    AlbBackendGroupSessionAffinityConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupSessionAffinityConnectionArgs:
    def __init__(__self__, *,
                 source_ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] source_ip: Source IP address to use with affinity.
        """
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Source IP address to use with affinity.
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class AlbBackendGroupSessionAffinityCookieArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the HTTP cookie to use with affinity.
        """
        ttl: NotRequired[pulumi.Input[str]]
        """
        TTL for the cookie (if not set, session cookie will be used)
        """
elif False:
    AlbBackendGroupSessionAffinityCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupSessionAffinityCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 ttl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the HTTP cookie to use with affinity.
        :param pulumi.Input[str] ttl: TTL for the cookie (if not set, session cookie will be used)
        """
        pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP cookie to use with affinity.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[str]]:
        """
        TTL for the cookie (if not set, session cookie will be used)
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class AlbBackendGroupSessionAffinityHeaderArgsDict(TypedDict):
        header_name: pulumi.Input[str]
        """
        The name of the request header that will be used with affinity.
        """
elif False:
    AlbBackendGroupSessionAffinityHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupSessionAffinityHeaderArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] header_name: The name of the request header that will be used with affinity.
        """
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the request header that will be used with affinity.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class AlbBackendGroupStreamBackendArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the backend.
        """
        target_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        References target groups for the backend.
        """
        enable_proxy_protocol: NotRequired[pulumi.Input[bool]]
        healthcheck: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckArgsDict']]
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        keep_connections_on_host_health_failure: NotRequired[pulumi.Input[bool]]
        """
        If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        load_balancing_config: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendLoadBalancingConfigArgsDict']]
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for incoming traffic.
        """
        tls: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendTlsArgsDict']]
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
elif False:
    AlbBackendGroupStreamBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 target_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 enable_proxy_protocol: Optional[pulumi.Input[bool]] = None,
                 healthcheck: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckArgs']] = None,
                 keep_connections_on_host_health_failure: Optional[pulumi.Input[bool]] = None,
                 load_balancing_config: Optional[pulumi.Input['AlbBackendGroupStreamBackendLoadBalancingConfigArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 tls: Optional[pulumi.Input['AlbBackendGroupStreamBackendTlsArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Name of the backend.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_group_ids: References target groups for the backend.
        :param pulumi.Input['AlbBackendGroupStreamBackendHealthcheckArgs'] healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[bool] keep_connections_on_host_health_failure: If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        :param pulumi.Input['AlbBackendGroupStreamBackendLoadBalancingConfigArgs'] load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[int] port: Port for incoming traffic.
        :param pulumi.Input['AlbBackendGroupStreamBackendTlsArgs'] tls: Tls specification that will be used by this backend. Structure is documented below.
        :param pulumi.Input[int] weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if enable_proxy_protocol is not None:
            pulumi.set(__self__, "enable_proxy_protocol", enable_proxy_protocol)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if keep_connections_on_host_health_failure is not None:
            pulumi.set(__self__, "keep_connections_on_host_health_failure", keep_connections_on_host_health_failure)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @target_group_ids.setter
    def target_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_group_ids", value)

    @property
    @pulumi.getter(name="enableProxyProtocol")
    def enable_proxy_protocol(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_proxy_protocol")

    @enable_proxy_protocol.setter
    def enable_proxy_protocol(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_proxy_protocol", value)

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckArgs']]:
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckArgs']]):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter(name="keepConnectionsOnHostHealthFailure")
    def keep_connections_on_host_health_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        return pulumi.get(self, "keep_connections_on_host_health_failure")

    @keep_connections_on_host_health_failure.setter
    def keep_connections_on_host_health_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_connections_on_host_health_failure", value)

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendLoadBalancingConfigArgs']]:
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @load_balancing_config.setter
    def load_balancing_config(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendLoadBalancingConfigArgs']]):
        pulumi.set(self, "load_balancing_config", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendTlsArgs']]:
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class AlbBackendGroupStreamBackendHealthcheckArgsDict(TypedDict):
        interval: pulumi.Input[str]
        """
        Interval between health checks.
        """
        timeout: pulumi.Input[str]
        """
        Time to wait for a health check response.
        """
        grpc_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict']]
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.

        > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        """
        healthcheck_port: NotRequired[pulumi.Input[int]]
        """
        Optional alternative port for health checking.
        """
        healthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        http_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict']]
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        interval_jitter_percent: NotRequired[pulumi.Input[float]]
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        stream_healthcheck: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict']]
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
elif False:
    AlbBackendGroupStreamBackendHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendHealthcheckArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 grpc_healthcheck: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs']] = None,
                 healthcheck_port: Optional[pulumi.Input[int]] = None,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 http_healthcheck: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs']] = None,
                 interval_jitter_percent: Optional[pulumi.Input[float]] = None,
                 stream_healthcheck: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs']] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] interval: Interval between health checks.
        :param pulumi.Input[str] timeout: Time to wait for a health check response.
        :param pulumi.Input['AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs'] grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
               
               > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        :param pulumi.Input[int] healthcheck_port: Optional alternative port for health checking.
        :param pulumi.Input[int] healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param pulumi.Input['AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs'] http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param pulumi.Input[float] interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param pulumi.Input['AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs'] stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param pulumi.Input[int] unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs']]:
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.

        > Only one of `stream_healthcheck` or `http_healthcheck` or `grpc_healthcheck` should be specified.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @grpc_healthcheck.setter
    def grpc_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs']]):
        pulumi.set(self, "grpc_healthcheck", value)

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[pulumi.Input[int]]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @healthcheck_port.setter
    def healthcheck_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthcheck_port", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs']]:
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @http_healthcheck.setter
    def http_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs']]):
        pulumi.set(self, "http_healthcheck", value)

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[pulumi.Input[float]]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @interval_jitter_percent.setter
    def interval_jitter_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval_jitter_percent", value)

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs']]:
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @stream_healthcheck.setter
    def stream_healthcheck(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs']]):
        pulumi.set(self, "stream_healthcheck", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict(TypedDict):
        service_name: NotRequired[pulumi.Input[str]]
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
elif False:
    AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs:
    def __init__(__self__, *,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_name: Service name for grpc.health.v1.HealthCheckRequest message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        HTTP path.
        """
        expected_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        A list of HTTP response statuses considered healthy.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        "Host" HTTP header value.
        """
        http2: NotRequired[pulumi.Input[bool]]
        """
        If set, health checks will use HTTP2.
        """
elif False:
    AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 expected_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: HTTP path.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] expected_statuses: A list of HTTP response statuses considered healthy.
        :param pulumi.Input[str] host: "Host" HTTP header value.
        :param pulumi.Input[bool] http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if expected_statuses is not None:
            pulumi.set(__self__, "expected_statuses", expected_statuses)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @expected_statuses.setter
    def expected_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "expected_statuses", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2", value)


if not MYPY:
    class AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict(TypedDict):
        receive: NotRequired[pulumi.Input[str]]
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        send: NotRequired[pulumi.Input[str]]
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
elif False:
    AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs:
    def __init__(__self__, *,
                 receive: Optional[pulumi.Input[str]] = None,
                 send: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param pulumi.Input[str] send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> Optional[pulumi.Input[str]]:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "receive", value)

    @property
    @pulumi.getter
    def send(self) -> Optional[pulumi.Input[str]]:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "send", value)


if not MYPY:
    class AlbBackendGroupStreamBackendLoadBalancingConfigArgsDict(TypedDict):
        locality_aware_routing_percent: NotRequired[pulumi.Input[int]]
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        """
        panic_threshold: NotRequired[pulumi.Input[int]]
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        strict_locality: NotRequired[pulumi.Input[bool]]
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
elif False:
    AlbBackendGroupStreamBackendLoadBalancingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendLoadBalancingConfigArgs:
    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 panic_threshold: Optional[pulumi.Input[int]] = None,
                 strict_locality: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param pulumi.Input[str] mode: Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        :param pulumi.Input[int] panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param pulumi.Input[bool] strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @locality_aware_routing_percent.setter
    def locality_aware_routing_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "locality_aware_routing_percent", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancing mode for the backend. Possible values: "ROUND_ROBIN", "RANDOM", "LEAST_REQUEST", "MAGLEV_HASH".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @panic_threshold.setter
    def panic_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "panic_threshold", value)

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")

    @strict_locality.setter
    def strict_locality(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_locality", value)


if not MYPY:
    class AlbBackendGroupStreamBackendTlsArgsDict(TypedDict):
        sni: NotRequired[pulumi.Input[str]]
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        validation_context: NotRequired[pulumi.Input['AlbBackendGroupStreamBackendTlsValidationContextArgsDict']]
elif False:
    AlbBackendGroupStreamBackendTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendTlsArgs:
    def __init__(__self__, *,
                 sni: Optional[pulumi.Input[str]] = None,
                 validation_context: Optional[pulumi.Input['AlbBackendGroupStreamBackendTlsValidationContextArgs']] = None):
        """
        :param pulumi.Input[str] sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
               
               > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional[pulumi.Input['AlbBackendGroupStreamBackendTlsValidationContextArgs']]:
        return pulumi.get(self, "validation_context")

    @validation_context.setter
    def validation_context(self, value: Optional[pulumi.Input['AlbBackendGroupStreamBackendTlsValidationContextArgs']]):
        pulumi.set(self, "validation_context", value)


if not MYPY:
    class AlbBackendGroupStreamBackendTlsValidationContextArgsDict(TypedDict):
        trusted_ca_bytes: NotRequired[pulumi.Input[str]]
        trusted_ca_id: NotRequired[pulumi.Input[str]]
elif False:
    AlbBackendGroupStreamBackendTlsValidationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbBackendGroupStreamBackendTlsValidationContextArgs:
    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[pulumi.Input[str]] = None,
                 trusted_ca_id: Optional[pulumi.Input[str]] = None):
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trusted_ca_bytes")

    @trusted_ca_bytes.setter
    def trusted_ca_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_bytes", value)

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trusted_ca_id")

    @trusted_ca_id.setter
    def trusted_ca_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_id", value)


if not MYPY:
    class AlbHttpRouterRouteOptionsArgsDict(TypedDict):
        rbac: NotRequired[pulumi.Input['AlbHttpRouterRouteOptionsRbacArgsDict']]
        security_profile_id: NotRequired[pulumi.Input[str]]
elif False:
    AlbHttpRouterRouteOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbHttpRouterRouteOptionsArgs:
    def __init__(__self__, *,
                 rbac: Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacArgs']] = None,
                 security_profile_id: Optional[pulumi.Input[str]] = None):
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @property
    @pulumi.getter
    def rbac(self) -> Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacArgs']]:
        return pulumi.get(self, "rbac")

    @rbac.setter
    def rbac(self, value: Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacArgs']]):
        pulumi.set(self, "rbac", value)

    @property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_profile_id")

    @security_profile_id.setter
    def security_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_profile_id", value)


if not MYPY:
    class AlbHttpRouterRouteOptionsRbacArgsDict(TypedDict):
        principals: pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalArgsDict']]]
        action: NotRequired[pulumi.Input[str]]
elif False:
    AlbHttpRouterRouteOptionsRbacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbHttpRouterRouteOptionsRbacArgs:
    def __init__(__self__, *,
                 principals: pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalArgs']]],
                 action: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "principals", principals)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def principals(self) -> pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalArgs']]]:
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalArgs']]]):
        pulumi.set(self, "principals", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class AlbHttpRouterRouteOptionsRbacPrincipalArgsDict(TypedDict):
        and_principals: pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgsDict']]]
elif False:
    AlbHttpRouterRouteOptionsRbacPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbHttpRouterRouteOptionsRbacPrincipalArgs:
    def __init__(__self__, *,
                 and_principals: pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgs']]]):
        pulumi.set(__self__, "and_principals", and_principals)

    @property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgs']]]:
        return pulumi.get(self, "and_principals")

    @and_principals.setter
    def and_principals(self, value: pulumi.Input[Sequence[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgs']]]):
        pulumi.set(self, "and_principals", value)


if not MYPY:
    class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgsDict(TypedDict):
        any: NotRequired[pulumi.Input[bool]]
        header: NotRequired[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict']]
        remote_ip: NotRequired[pulumi.Input[str]]
elif False:
    AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input[bool]] = None,
                 header: Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']] = None,
                 remote_ip: Optional[pulumi.Input[str]] = None):
        if any is not None:
            pulumi.set(__self__, "any", any)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if remote_ip is not None:
            pulumi.set(__self__, "remote_ip", remote_ip)

    @property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_ip")

    @remote_ip.setter
    def remote_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ip", value)


if not MYPY:
    class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the HTTP Router. Provided by the client when the HTTP Router is created.
        """
        value: NotRequired[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict']]
elif False:
    AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the HTTP Router. Provided by the client when the HTTP Router is created.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP Router. Provided by the client when the HTTP Router is created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        prefix: NotRequired[pulumi.Input[str]]
        regex: NotRequired[pulumi.Input[str]]
elif False:
    AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AlbLoadBalancerAllocationPolicyArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerAllocationPolicyLocationArgsDict']]]
        """
        Unique set of locations. The structure is documented below.
        """
elif False:
    AlbLoadBalancerAllocationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerAllocationPolicyArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerAllocationPolicyLocationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerAllocationPolicyLocationArgs']]] locations: Unique set of locations. The structure is documented below.
        """
        pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerAllocationPolicyLocationArgs']]]:
        """
        Unique set of locations. The structure is documented below.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerAllocationPolicyLocationArgs']]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class AlbLoadBalancerAllocationPolicyLocationArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        ID of the subnet that location is located at.
        """
        zone_id: pulumi.Input[str]
        """
        ID of the zone that location is located at.
        """
        disable_traffic: NotRequired[pulumi.Input[bool]]
        """
        If set, will disable all L7 instances in the zone for request handling.
        """
elif False:
    AlbLoadBalancerAllocationPolicyLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerAllocationPolicyLocationArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 zone_id: pulumi.Input[str],
                 disable_traffic: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: ID of the subnet that location is located at.
        :param pulumi.Input[str] zone_id: ID of the zone that location is located at.
        :param pulumi.Input[bool] disable_traffic: If set, will disable all L7 instances in the zone for request handling.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if disable_traffic is not None:
            pulumi.set(__self__, "disable_traffic", disable_traffic)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        ID of the subnet that location is located at.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> pulumi.Input[str]:
        """
        ID of the zone that location is located at.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="disableTraffic")
    def disable_traffic(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will disable all L7 instances in the zone for request handling.
        """
        return pulumi.get(self, "disable_traffic")

    @disable_traffic.setter
    def disable_traffic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_traffic", value)


if not MYPY:
    class AlbLoadBalancerListenerArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        name of the listener.
        """
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointArgsDict']]]]
        """
        Network endpoints (addresses and ports) of the listener. The structure is documented below.
        """
        http: NotRequired[pulumi.Input['AlbLoadBalancerListenerHttpArgsDict']]
        """
        HTTP listener resource. The structure is documented below.
        """
        stream: NotRequired[pulumi.Input['AlbLoadBalancerListenerStreamArgsDict']]
        """
        Stream listener resource. The structure is documented below.
        """
        tls: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsArgsDict']]
        """
        TLS listener resource. The structure is documented below.

        > Exactly one listener type: `http` or `tls` or `stream` should be specified.
        """
elif False:
    AlbLoadBalancerListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointArgs']]]] = None,
                 http: Optional[pulumi.Input['AlbLoadBalancerListenerHttpArgs']] = None,
                 stream: Optional[pulumi.Input['AlbLoadBalancerListenerStreamArgs']] = None,
                 tls: Optional[pulumi.Input['AlbLoadBalancerListenerTlsArgs']] = None):
        """
        :param pulumi.Input[str] name: name of the listener.
        :param pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointArgs']]] endpoints: Network endpoints (addresses and ports) of the listener. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerHttpArgs'] http: HTTP listener resource. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerStreamArgs'] stream: Stream listener resource. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerTlsArgs'] tls: TLS listener resource. The structure is documented below.
               
               > Exactly one listener type: `http` or `tls` or `stream` should be specified.
        """
        pulumi.set(__self__, "name", name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of the listener.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointArgs']]]]:
        """
        Network endpoints (addresses and ports) of the listener. The structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerHttpArgs']]:
        """
        HTTP listener resource. The structure is documented below.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def stream(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerStreamArgs']]:
        """
        Stream listener resource. The structure is documented below.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerStreamArgs']]):
        pulumi.set(self, "stream", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsArgs']]:
        """
        TLS listener resource. The structure is documented below.

        > Exactly one listener type: `http` or `tls` or `stream` should be specified.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class AlbLoadBalancerListenerEndpointArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointAddressArgsDict']]]
        """
        One or more addresses to listen on. The structure is documented below.
        """
        ports: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        One or more ports to listen on.
        """
elif False:
    AlbLoadBalancerListenerEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerEndpointArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointAddressArgs']]],
                 ports: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointAddressArgs']]] addresses: One or more addresses to listen on. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: One or more ports to listen on.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointAddressArgs']]]:
        """
        One or more addresses to listen on. The structure is documented below.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerEndpointAddressArgs']]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        One or more ports to listen on.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class AlbLoadBalancerListenerEndpointAddressArgsDict(TypedDict):
        external_ipv4_address: NotRequired[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgsDict']]
        """
        External IPv4 address. The structure is documented below.
        """
        external_ipv6_address: NotRequired[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgsDict']]
        """
        External IPv6 address. The structure is documented below.

        > Exactly one type of addresses `external_ipv4_address` or `internal_ipv4_address` or `external_ipv6_address` should be specified.
        """
        internal_ipv4_address: NotRequired[pulumi.Input['AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgsDict']]
        """
        Internal IPv4 address. The structure is documented below.
        """
elif False:
    AlbLoadBalancerListenerEndpointAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerEndpointAddressArgs:
    def __init__(__self__, *,
                 external_ipv4_address: Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs']] = None,
                 external_ipv6_address: Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs']] = None,
                 internal_ipv4_address: Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs']] = None):
        """
        :param pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs'] external_ipv4_address: External IPv4 address. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs'] external_ipv6_address: External IPv6 address. The structure is documented below.
               
               > Exactly one type of addresses `external_ipv4_address` or `internal_ipv4_address` or `external_ipv6_address` should be specified.
        :param pulumi.Input['AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs'] internal_ipv4_address: Internal IPv4 address. The structure is documented below.
        """
        if external_ipv4_address is not None:
            pulumi.set(__self__, "external_ipv4_address", external_ipv4_address)
        if external_ipv6_address is not None:
            pulumi.set(__self__, "external_ipv6_address", external_ipv6_address)
        if internal_ipv4_address is not None:
            pulumi.set(__self__, "internal_ipv4_address", internal_ipv4_address)

    @property
    @pulumi.getter(name="externalIpv4Address")
    def external_ipv4_address(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs']]:
        """
        External IPv4 address. The structure is documented below.
        """
        return pulumi.get(self, "external_ipv4_address")

    @external_ipv4_address.setter
    def external_ipv4_address(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs']]):
        pulumi.set(self, "external_ipv4_address", value)

    @property
    @pulumi.getter(name="externalIpv6Address")
    def external_ipv6_address(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs']]:
        """
        External IPv6 address. The structure is documented below.

        > Exactly one type of addresses `external_ipv4_address` or `internal_ipv4_address` or `external_ipv6_address` should be specified.
        """
        return pulumi.get(self, "external_ipv6_address")

    @external_ipv6_address.setter
    def external_ipv6_address(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs']]):
        pulumi.set(self, "external_ipv6_address", value)

    @property
    @pulumi.getter(name="internalIpv4Address")
    def internal_ipv4_address(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs']]:
        """
        Internal IPv4 address. The structure is documented below.
        """
        return pulumi.get(self, "internal_ipv4_address")

    @internal_ipv4_address.setter
    def internal_ipv4_address(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs']]):
        pulumi.set(self, "internal_ipv4_address", value)


if not MYPY:
    class AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
elif False:
    AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)


if not MYPY:
    class AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
elif False:
    AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)


if not MYPY:
    class AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        subnet_id: NotRequired[pulumi.Input[str]]
elif False:
    AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class AlbLoadBalancerListenerHttpArgsDict(TypedDict):
        handler: NotRequired[pulumi.Input['AlbLoadBalancerListenerHttpHandlerArgsDict']]
        """
        HTTP handler that sets plaintext HTTP router. The structure is documented below.
        """
        redirects: NotRequired[pulumi.Input['AlbLoadBalancerListenerHttpRedirectsArgsDict']]
        """
        Shortcut for adding http > https redirects. The structure is documented below.

        > Only one type of fields `handler` or `redirects` should be specified.
        """
elif False:
    AlbLoadBalancerListenerHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerHttpArgs:
    def __init__(__self__, *,
                 handler: Optional[pulumi.Input['AlbLoadBalancerListenerHttpHandlerArgs']] = None,
                 redirects: Optional[pulumi.Input['AlbLoadBalancerListenerHttpRedirectsArgs']] = None):
        """
        :param pulumi.Input['AlbLoadBalancerListenerHttpHandlerArgs'] handler: HTTP handler that sets plaintext HTTP router. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerHttpRedirectsArgs'] redirects: Shortcut for adding http > https redirects. The structure is documented below.
               
               > Only one type of fields `handler` or `redirects` should be specified.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerHttpHandlerArgs']]:
        """
        HTTP handler that sets plaintext HTTP router. The structure is documented below.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerHttpHandlerArgs']]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerHttpRedirectsArgs']]:
        """
        Shortcut for adding http > https redirects. The structure is documented below.

        > Only one type of fields `handler` or `redirects` should be specified.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerHttpRedirectsArgs']]):
        pulumi.set(self, "redirects", value)


if not MYPY:
    class AlbLoadBalancerListenerHttpHandlerArgsDict(TypedDict):
        allow_http10: NotRequired[pulumi.Input[bool]]
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.

        > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        """
        http2_options: NotRequired[pulumi.Input['AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgsDict']]
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        http_router_id: NotRequired[pulumi.Input[str]]
        """
        HTTP router id.
        """
        rewrite_request_id: NotRequired[pulumi.Input[bool]]
        """
        When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
elif False:
    AlbLoadBalancerListenerHttpHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerHttpHandlerArgs:
    def __init__(__self__, *,
                 allow_http10: Optional[pulumi.Input[bool]] = None,
                 http2_options: Optional[pulumi.Input['AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs']] = None,
                 http_router_id: Optional[pulumi.Input[str]] = None,
                 rewrite_request_id: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
               
               > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        :param pulumi.Input['AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs'] http2_options: If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        :param pulumi.Input[str] http_router_id: HTTP router id.
        :param pulumi.Input[bool] rewrite_request_id: When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)
        if rewrite_request_id is not None:
            pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.

        > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        """
        return pulumi.get(self, "allow_http10")

    @allow_http10.setter
    def allow_http10(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_http10", value)

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs']]:
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        return pulumi.get(self, "http2_options")

    @http2_options.setter
    def http2_options(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs']]):
        pulumi.set(self, "http2_options", value)

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @http_router_id.setter
    def http_router_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_router_id", value)

    @property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> Optional[pulumi.Input[bool]]:
        """
        When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")

    @rewrite_request_id.setter
    def rewrite_request_id(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rewrite_request_id", value)


if not MYPY:
    class AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgsDict(TypedDict):
        max_concurrent_streams: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent streams.
        """
elif False:
    AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs:
    def __init__(__self__, *,
                 max_concurrent_streams: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")

    @max_concurrent_streams.setter
    def max_concurrent_streams(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_streams", value)


if not MYPY:
    class AlbLoadBalancerListenerHttpRedirectsArgsDict(TypedDict):
        http_to_https: NotRequired[pulumi.Input[bool]]
        """
        If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
elif False:
    AlbLoadBalancerListenerHttpRedirectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerHttpRedirectsArgs:
    def __init__(__self__, *,
                 http_to_https: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] http_to_https: If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
        if http_to_https is not None:
            pulumi.set(__self__, "http_to_https", http_to_https)

    @property
    @pulumi.getter(name="httpToHttps")
    def http_to_https(self) -> Optional[pulumi.Input[bool]]:
        """
        If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
        return pulumi.get(self, "http_to_https")

    @http_to_https.setter
    def http_to_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_to_https", value)


if not MYPY:
    class AlbLoadBalancerListenerStreamArgsDict(TypedDict):
        handler: NotRequired[pulumi.Input['AlbLoadBalancerListenerStreamHandlerArgsDict']]
        """
        Stream handler that sets plaintext Stream backend group. The structure is documented below.
        """
elif False:
    AlbLoadBalancerListenerStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerStreamArgs:
    def __init__(__self__, *,
                 handler: Optional[pulumi.Input['AlbLoadBalancerListenerStreamHandlerArgs']] = None):
        """
        :param pulumi.Input['AlbLoadBalancerListenerStreamHandlerArgs'] handler: Stream handler that sets plaintext Stream backend group. The structure is documented below.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerStreamHandlerArgs']]:
        """
        Stream handler that sets plaintext Stream backend group. The structure is documented below.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerStreamHandlerArgs']]):
        pulumi.set(self, "handler", value)


if not MYPY:
    class AlbLoadBalancerListenerStreamHandlerArgsDict(TypedDict):
        backend_group_id: NotRequired[pulumi.Input[str]]
        """
        Backend group id.
        """
        idle_timeout: NotRequired[pulumi.Input[str]]
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
elif False:
    AlbLoadBalancerListenerStreamHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerStreamHandlerArgs:
    def __init__(__self__, *,
                 backend_group_id: Optional[pulumi.Input[str]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_group_id: Backend group id.
        :param pulumi.Input[str] idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Backend group id.
        """
        return pulumi.get(self, "backend_group_id")

    @backend_group_id.setter
    def backend_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_group_id", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsArgsDict(TypedDict):
        default_handler: pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerArgsDict']
        """
        TLS handler resource. The structure is documented below.
        """
        sni_handlers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerArgsDict']]]]
        """
        SNI match resource. The structure is documented below.
        """
elif False:
    AlbLoadBalancerListenerTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsArgs:
    def __init__(__self__, *,
                 default_handler: pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerArgs'],
                 sni_handlers: Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerArgs']]]] = None):
        """
        :param pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerArgs'] default_handler: TLS handler resource. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerArgs']]] sni_handlers: SNI match resource. The structure is documented below.
        """
        pulumi.set(__self__, "default_handler", default_handler)
        if sni_handlers is not None:
            pulumi.set(__self__, "sni_handlers", sni_handlers)

    @property
    @pulumi.getter(name="defaultHandler")
    def default_handler(self) -> pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerArgs']:
        """
        TLS handler resource. The structure is documented below.
        """
        return pulumi.get(self, "default_handler")

    @default_handler.setter
    def default_handler(self, value: pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerArgs']):
        pulumi.set(self, "default_handler", value)

    @property
    @pulumi.getter(name="sniHandlers")
    def sni_handlers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerArgs']]]]:
        """
        SNI match resource. The structure is documented below.
        """
        return pulumi.get(self, "sni_handlers")

    @sni_handlers.setter
    def sni_handlers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerArgs']]]]):
        pulumi.set(self, "sni_handlers", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsDefaultHandlerArgsDict(TypedDict):
        certificate_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.

        > Exactly one handler type `http_handler` or `stream_handler` should be specified.
        """
        http_handler: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgsDict']]
        """
        HTTP handler resource. The structure is documented below.
        """
        stream_handler: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgsDict']]
        """
        Stream handler resource. The structure is documented below.
        """
elif False:
    AlbLoadBalancerListenerTlsDefaultHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsDefaultHandlerArgs:
    def __init__(__self__, *,
                 certificate_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 http_handler: Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs']] = None,
                 stream_handler: Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
               
               > Exactly one handler type `http_handler` or `stream_handler` should be specified.
        :param pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs'] http_handler: HTTP handler resource. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs'] stream_handler: Stream handler resource. The structure is documented below.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handler is not None:
            pulumi.set(__self__, "http_handler", http_handler)
        if stream_handler is not None:
            pulumi.set(__self__, "stream_handler", stream_handler)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.

        > Exactly one handler type `http_handler` or `stream_handler` should be specified.
        """
        return pulumi.get(self, "certificate_ids")

    @certificate_ids.setter
    def certificate_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "certificate_ids", value)

    @property
    @pulumi.getter(name="httpHandler")
    def http_handler(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs']]:
        """
        HTTP handler resource. The structure is documented below.
        """
        return pulumi.get(self, "http_handler")

    @http_handler.setter
    def http_handler(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs']]):
        pulumi.set(self, "http_handler", value)

    @property
    @pulumi.getter(name="streamHandler")
    def stream_handler(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs']]:
        """
        Stream handler resource. The structure is documented below.
        """
        return pulumi.get(self, "stream_handler")

    @stream_handler.setter
    def stream_handler(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs']]):
        pulumi.set(self, "stream_handler", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgsDict(TypedDict):
        allow_http10: NotRequired[pulumi.Input[bool]]
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.

        > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        """
        http2_options: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgsDict']]
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        http_router_id: NotRequired[pulumi.Input[str]]
        """
        HTTP router id.
        """
        rewrite_request_id: NotRequired[pulumi.Input[bool]]
        """
        When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
elif False:
    AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs:
    def __init__(__self__, *,
                 allow_http10: Optional[pulumi.Input[bool]] = None,
                 http2_options: Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs']] = None,
                 http_router_id: Optional[pulumi.Input[str]] = None,
                 rewrite_request_id: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
               
               > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        :param pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs'] http2_options: If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        :param pulumi.Input[str] http_router_id: HTTP router id.
        :param pulumi.Input[bool] rewrite_request_id: When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)
        if rewrite_request_id is not None:
            pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.

        > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        """
        return pulumi.get(self, "allow_http10")

    @allow_http10.setter
    def allow_http10(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_http10", value)

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs']]:
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        return pulumi.get(self, "http2_options")

    @http2_options.setter
    def http2_options(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs']]):
        pulumi.set(self, "http2_options", value)

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @http_router_id.setter
    def http_router_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_router_id", value)

    @property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> Optional[pulumi.Input[bool]]:
        """
        When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")

    @rewrite_request_id.setter
    def rewrite_request_id(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rewrite_request_id", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgsDict(TypedDict):
        max_concurrent_streams: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent streams.
        """
elif False:
    AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs:
    def __init__(__self__, *,
                 max_concurrent_streams: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")

    @max_concurrent_streams.setter
    def max_concurrent_streams(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_streams", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgsDict(TypedDict):
        backend_group_id: NotRequired[pulumi.Input[str]]
        """
        Backend group id.
        """
        idle_timeout: NotRequired[pulumi.Input[str]]
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
elif False:
    AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs:
    def __init__(__self__, *,
                 backend_group_id: Optional[pulumi.Input[str]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_group_id: Backend group id.
        :param pulumi.Input[str] idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Backend group id.
        """
        return pulumi.get(self, "backend_group_id")

    @backend_group_id.setter
    def backend_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_group_id", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsSniHandlerArgsDict(TypedDict):
        handler: pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerArgsDict']
        """
        TLS handler resource. The structure is documented below.
        """
        name: pulumi.Input[str]
        """
        name of SNI match.
        """
        server_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A set of server names.
        """
elif False:
    AlbLoadBalancerListenerTlsSniHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsSniHandlerArgs:
    def __init__(__self__, *,
                 handler: pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerArgs'],
                 name: pulumi.Input[str],
                 server_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerArgs'] handler: TLS handler resource. The structure is documented below.
        :param pulumi.Input[str] name: name of SNI match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_names: A set of server names.
        """
        pulumi.set(__self__, "handler", handler)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_names", server_names)

    @property
    @pulumi.getter
    def handler(self) -> pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerArgs']:
        """
        TLS handler resource. The structure is documented below.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerArgs']):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of SNI match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serverNames")
    def server_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of server names.
        """
        return pulumi.get(self, "server_names")

    @server_names.setter
    def server_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "server_names", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsSniHandlerHandlerArgsDict(TypedDict):
        certificate_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.

        > Exactly one handler type `http_handler` or `stream_handler` should be specified.
        """
        http_handler: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgsDict']]
        """
        HTTP handler resource. The structure is documented below.
        """
        stream_handler: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgsDict']]
        """
        Stream handler resource. The structure is documented below.
        """
elif False:
    AlbLoadBalancerListenerTlsSniHandlerHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerArgs:
    def __init__(__self__, *,
                 certificate_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 http_handler: Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs']] = None,
                 stream_handler: Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
               
               > Exactly one handler type `http_handler` or `stream_handler` should be specified.
        :param pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs'] http_handler: HTTP handler resource. The structure is documented below.
        :param pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs'] stream_handler: Stream handler resource. The structure is documented below.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handler is not None:
            pulumi.set(__self__, "http_handler", http_handler)
        if stream_handler is not None:
            pulumi.set(__self__, "stream_handler", stream_handler)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.

        > Exactly one handler type `http_handler` or `stream_handler` should be specified.
        """
        return pulumi.get(self, "certificate_ids")

    @certificate_ids.setter
    def certificate_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "certificate_ids", value)

    @property
    @pulumi.getter(name="httpHandler")
    def http_handler(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs']]:
        """
        HTTP handler resource. The structure is documented below.
        """
        return pulumi.get(self, "http_handler")

    @http_handler.setter
    def http_handler(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs']]):
        pulumi.set(self, "http_handler", value)

    @property
    @pulumi.getter(name="streamHandler")
    def stream_handler(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs']]:
        """
        Stream handler resource. The structure is documented below.
        """
        return pulumi.get(self, "stream_handler")

    @stream_handler.setter
    def stream_handler(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs']]):
        pulumi.set(self, "stream_handler", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgsDict(TypedDict):
        allow_http10: NotRequired[pulumi.Input[bool]]
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.

        > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        """
        http2_options: NotRequired[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgsDict']]
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        http_router_id: NotRequired[pulumi.Input[str]]
        """
        HTTP router id.
        """
        rewrite_request_id: NotRequired[pulumi.Input[bool]]
        """
        When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
elif False:
    AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs:
    def __init__(__self__, *,
                 allow_http10: Optional[pulumi.Input[bool]] = None,
                 http2_options: Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs']] = None,
                 http_router_id: Optional[pulumi.Input[str]] = None,
                 rewrite_request_id: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
               
               > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        :param pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs'] http2_options: If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        :param pulumi.Input[str] http_router_id: HTTP router id.
        :param pulumi.Input[bool] rewrite_request_id: When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)
        if rewrite_request_id is not None:
            pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.

        > Only one type of protocol settings `http2_options` or `allow_http10` should be specified.
        """
        return pulumi.get(self, "allow_http10")

    @allow_http10.setter
    def allow_http10(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_http10", value)

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs']]:
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        return pulumi.get(self, "http2_options")

    @http2_options.setter
    def http2_options(self, value: Optional[pulumi.Input['AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs']]):
        pulumi.set(self, "http2_options", value)

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @http_router_id.setter
    def http_router_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_router_id", value)

    @property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> Optional[pulumi.Input[bool]]:
        """
        When unset, will preserve the incoming x-request-id header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")

    @rewrite_request_id.setter
    def rewrite_request_id(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rewrite_request_id", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgsDict(TypedDict):
        max_concurrent_streams: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent streams.
        """
elif False:
    AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs:
    def __init__(__self__, *,
                 max_concurrent_streams: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")

    @max_concurrent_streams.setter
    def max_concurrent_streams(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_streams", value)


if not MYPY:
    class AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgsDict(TypedDict):
        backend_group_id: NotRequired[pulumi.Input[str]]
        """
        Backend group id.
        """
        idle_timeout: NotRequired[pulumi.Input[str]]
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
elif False:
    AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs:
    def __init__(__self__, *,
                 backend_group_id: Optional[pulumi.Input[str]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_group_id: Backend group id.
        :param pulumi.Input[str] idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Backend group id.
        """
        return pulumi.get(self, "backend_group_id")

    @backend_group_id.setter
    def backend_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_group_id", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)


if not MYPY:
    class AlbLoadBalancerLogOptionsArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        Set to true to disable Cloud Logging for the balancer
        """
        discard_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerLogOptionsDiscardRuleArgsDict']]]]
        """
        List of rules to discard a fraction of logs. The structure is documented below.
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
elif False:
    AlbLoadBalancerLogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerLogOptionsArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 discard_rules: Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerLogOptionsDiscardRuleArgs']]]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable: Set to true to disable Cloud Logging for the balancer
        :param pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerLogOptionsDiscardRuleArgs']]] discard_rules: List of rules to discard a fraction of logs. The structure is documented below.
        :param pulumi.Input[str] log_group_id: Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if discard_rules is not None:
            pulumi.set(__self__, "discard_rules", discard_rules)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to disable Cloud Logging for the balancer
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter(name="discardRules")
    def discard_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerLogOptionsDiscardRuleArgs']]]]:
        """
        List of rules to discard a fraction of logs. The structure is documented below.
        """
        return pulumi.get(self, "discard_rules")

    @discard_rules.setter
    def discard_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlbLoadBalancerLogOptionsDiscardRuleArgs']]]]):
        pulumi.set(self, "discard_rules", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)


if not MYPY:
    class AlbLoadBalancerLogOptionsDiscardRuleArgsDict(TypedDict):
        discard_percent: NotRequired[pulumi.Input[int]]
        grpc_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of grpc codes by name, e.g, *["NOT_FOUND", "RESOURCE_EXHAUSTED"]*
        """
        http_code_intervals: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of http code intervals *1XX*-*5XX* or *ALL*
        """
        http_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        list of http codes *100*-*599*
        """
elif False:
    AlbLoadBalancerLogOptionsDiscardRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbLoadBalancerLogOptionsDiscardRuleArgs:
    def __init__(__self__, *,
                 discard_percent: Optional[pulumi.Input[int]] = None,
                 grpc_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_code_intervals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_codes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] grpc_codes: list of grpc codes by name, e.g, *["NOT_FOUND", "RESOURCE_EXHAUSTED"]*
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_code_intervals: list of http code intervals *1XX*-*5XX* or *ALL*
        :param pulumi.Input[Sequence[pulumi.Input[int]]] http_codes: list of http codes *100*-*599*
        """
        if discard_percent is not None:
            pulumi.set(__self__, "discard_percent", discard_percent)
        if grpc_codes is not None:
            pulumi.set(__self__, "grpc_codes", grpc_codes)
        if http_code_intervals is not None:
            pulumi.set(__self__, "http_code_intervals", http_code_intervals)
        if http_codes is not None:
            pulumi.set(__self__, "http_codes", http_codes)

    @property
    @pulumi.getter(name="discardPercent")
    def discard_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "discard_percent")

    @discard_percent.setter
    def discard_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "discard_percent", value)

    @property
    @pulumi.getter(name="grpcCodes")
    def grpc_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of grpc codes by name, e.g, *["NOT_FOUND", "RESOURCE_EXHAUSTED"]*
        """
        return pulumi.get(self, "grpc_codes")

    @grpc_codes.setter
    def grpc_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grpc_codes", value)

    @property
    @pulumi.getter(name="httpCodeIntervals")
    def http_code_intervals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of http code intervals *1XX*-*5XX* or *ALL*
        """
        return pulumi.get(self, "http_code_intervals")

    @http_code_intervals.setter
    def http_code_intervals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_code_intervals", value)

    @property
    @pulumi.getter(name="httpCodes")
    def http_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        list of http codes *100*-*599*
        """
        return pulumi.get(self, "http_codes")

    @http_codes.setter
    def http_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "http_codes", value)


if not MYPY:
    class AlbTargetGroupTargetArgsDict(TypedDict):
        ip_address: pulumi.Input[str]
        """
        IP address of the target.
        """
        private_ipv4_address: NotRequired[pulumi.Input[bool]]
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
elif False:
    AlbTargetGroupTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbTargetGroupTargetArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[str],
                 private_ipv4_address: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_address: IP address of the target.
        :param pulumi.Input[str] subnet_id: ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if private_ipv4_address is not None:
            pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        IP address of the target.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "private_ipv4_address")

    @private_ipv4_address.setter
    def private_ipv4_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_ipv4_address", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class AlbVirtualHostModifyRequestHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        name of the header to modify.
        """
        append: NotRequired[pulumi.Input[str]]
        """
        Append string to the header value.
        """
        remove: NotRequired[pulumi.Input[bool]]
        """
        If set, remove the header.

        > Only one type of actions `append` or `replace` or `remove` should be specified.
        """
        replace: NotRequired[pulumi.Input[str]]
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
elif False:
    AlbVirtualHostModifyRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostModifyRequestHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 append: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[bool]] = None,
                 replace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: name of the header to modify.
        :param pulumi.Input[str] append: Append string to the header value.
        :param pulumi.Input[bool] remove: If set, remove the header.
               
               > Only one type of actions `append` or `replace` or `remove` should be specified.
        :param pulumi.Input[str] replace: New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "name", name)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of the header to modify.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def append(self) -> Optional[pulumi.Input[str]]:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @append.setter
    def append(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "append", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, remove the header.

        > Only one type of actions `append` or `replace` or `remove` should be specified.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[str]]:
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace", value)


if not MYPY:
    class AlbVirtualHostModifyResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        name of the header to modify.
        """
        append: NotRequired[pulumi.Input[str]]
        """
        Append string to the header value.
        """
        remove: NotRequired[pulumi.Input[bool]]
        """
        If set, remove the header.

        > Only one type of actions `append` or `replace` or `remove` should be specified.
        """
        replace: NotRequired[pulumi.Input[str]]
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
elif False:
    AlbVirtualHostModifyResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostModifyResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 append: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[bool]] = None,
                 replace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: name of the header to modify.
        :param pulumi.Input[str] append: Append string to the header value.
        :param pulumi.Input[bool] remove: If set, remove the header.
               
               > Only one type of actions `append` or `replace` or `remove` should be specified.
        :param pulumi.Input[str] replace: New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "name", name)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of the header to modify.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def append(self) -> Optional[pulumi.Input[str]]:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @append.setter
    def append(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "append", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, remove the header.

        > Only one type of actions `append` or `replace` or `remove` should be specified.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[str]]:
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace", value)


if not MYPY:
    class AlbVirtualHostRateLimitArgsDict(TypedDict):
        all_requests: NotRequired[pulumi.Input['AlbVirtualHostRateLimitAllRequestsArgsDict']]
        """
        Rate limit configuration applied to all incoming requests
        """
        requests_per_ip: NotRequired[pulumi.Input['AlbVirtualHostRateLimitRequestsPerIpArgsDict']]
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
elif False:
    AlbVirtualHostRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRateLimitArgs:
    def __init__(__self__, *,
                 all_requests: Optional[pulumi.Input['AlbVirtualHostRateLimitAllRequestsArgs']] = None,
                 requests_per_ip: Optional[pulumi.Input['AlbVirtualHostRateLimitRequestsPerIpArgs']] = None):
        """
        :param pulumi.Input['AlbVirtualHostRateLimitAllRequestsArgs'] all_requests: Rate limit configuration applied to all incoming requests
        :param pulumi.Input['AlbVirtualHostRateLimitRequestsPerIpArgs'] requests_per_ip: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        if all_requests is not None:
            pulumi.set(__self__, "all_requests", all_requests)
        if requests_per_ip is not None:
            pulumi.set(__self__, "requests_per_ip", requests_per_ip)

    @property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Optional[pulumi.Input['AlbVirtualHostRateLimitAllRequestsArgs']]:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @all_requests.setter
    def all_requests(self, value: Optional[pulumi.Input['AlbVirtualHostRateLimitAllRequestsArgs']]):
        pulumi.set(self, "all_requests", value)

    @property
    @pulumi.getter(name="requestsPerIp")
    def requests_per_ip(self) -> Optional[pulumi.Input['AlbVirtualHostRateLimitRequestsPerIpArgs']]:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ip")

    @requests_per_ip.setter
    def requests_per_ip(self, value: Optional[pulumi.Input['AlbVirtualHostRateLimitRequestsPerIpArgs']]):
        pulumi.set(self, "requests_per_ip", value)


if not MYPY:
    class AlbVirtualHostRateLimitAllRequestsArgsDict(TypedDict):
        per_minute: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per minute time unit
        """
        per_second: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per second time unit
        """
elif False:
    AlbVirtualHostRateLimitAllRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRateLimitAllRequestsArgs:
    def __init__(__self__, *,
                 per_minute: Optional[pulumi.Input[int]] = None,
                 per_second: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] per_minute: Limit value specified with per minute time unit
        :param pulumi.Input[int] per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @per_minute.setter
    def per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_minute", value)

    @property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")

    @per_second.setter
    def per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_second", value)


if not MYPY:
    class AlbVirtualHostRateLimitRequestsPerIpArgsDict(TypedDict):
        per_minute: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per minute time unit
        """
        per_second: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per second time unit
        """
elif False:
    AlbVirtualHostRateLimitRequestsPerIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRateLimitRequestsPerIpArgs:
    def __init__(__self__, *,
                 per_minute: Optional[pulumi.Input[int]] = None,
                 per_second: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] per_minute: Limit value specified with per minute time unit
        :param pulumi.Input[int] per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @per_minute.setter
    def per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_minute", value)

    @property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")

    @per_second.setter
    def per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_second", value)


if not MYPY:
    class AlbVirtualHostRouteArgsDict(TypedDict):
        grpc_route: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteArgsDict']]
        """
        GRPC route resource. The structure is documented below.

        > Exactly one type of routes `http_route` or `grpc_route` should be specified.
        """
        http_route: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteArgsDict']]
        """
        HTTP route resource. The structure is documented below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        name of the route.
        """
        route_options: NotRequired[pulumi.Input['AlbVirtualHostRouteRouteOptionsArgsDict']]
        """
        Route options for the virtual host. The structure is documented below.
        """
elif False:
    AlbVirtualHostRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteArgs:
    def __init__(__self__, *,
                 grpc_route: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteArgs']] = None,
                 http_route: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 route_options: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsArgs']] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteArgs'] grpc_route: GRPC route resource. The structure is documented below.
               
               > Exactly one type of routes `http_route` or `grpc_route` should be specified.
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteArgs'] http_route: HTTP route resource. The structure is documented below.
        :param pulumi.Input[str] name: name of the route.
        :param pulumi.Input['AlbVirtualHostRouteRouteOptionsArgs'] route_options: Route options for the virtual host. The structure is documented below.
        """
        if grpc_route is not None:
            pulumi.set(__self__, "grpc_route", grpc_route)
        if http_route is not None:
            pulumi.set(__self__, "http_route", http_route)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if route_options is not None:
            pulumi.set(__self__, "route_options", route_options)

    @property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteArgs']]:
        """
        GRPC route resource. The structure is documented below.

        > Exactly one type of routes `http_route` or `grpc_route` should be specified.
        """
        return pulumi.get(self, "grpc_route")

    @grpc_route.setter
    def grpc_route(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteArgs']]):
        pulumi.set(self, "grpc_route", value)

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteArgs']]:
        """
        HTTP route resource. The structure is documented below.
        """
        return pulumi.get(self, "http_route")

    @http_route.setter
    def http_route(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteArgs']]):
        pulumi.set(self, "http_route", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routeOptions")
    def route_options(self) -> Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsArgs']]:
        """
        Route options for the virtual host. The structure is documented below.
        """
        return pulumi.get(self, "route_options")

    @route_options.setter
    def route_options(self, value: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsArgs']]):
        pulumi.set(self, "route_options", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteArgsDict(TypedDict):
        grpc_matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchArgsDict']]]]
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        grpc_route_action: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgsDict']]
        """
        GRPC route action resource. The structure is documented below.
        """
        grpc_status_response_action: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgsDict']]
        """
        GRPC status response action resource. The structure is documented below.

        > Exactly one type of actions `grpc_route_action` or `grpc_status_response_action` should be specified.
        """
elif False:
    AlbVirtualHostRouteGrpcRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteArgs:
    def __init__(__self__, *,
                 grpc_matches: Optional[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchArgs']]]] = None,
                 grpc_route_action: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs']] = None,
                 grpc_status_response_action: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchArgs']]] grpc_matches: Checks "/" prefix by default. The structure is documented below.
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs'] grpc_route_action: GRPC route action resource. The structure is documented below.
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs'] grpc_status_response_action: GRPC status response action resource. The structure is documented below.
               
               > Exactly one type of actions `grpc_route_action` or `grpc_status_response_action` should be specified.
        """
        if grpc_matches is not None:
            pulumi.set(__self__, "grpc_matches", grpc_matches)
        if grpc_route_action is not None:
            pulumi.set(__self__, "grpc_route_action", grpc_route_action)
        if grpc_status_response_action is not None:
            pulumi.set(__self__, "grpc_status_response_action", grpc_status_response_action)

    @property
    @pulumi.getter(name="grpcMatches")
    def grpc_matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchArgs']]]]:
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        return pulumi.get(self, "grpc_matches")

    @grpc_matches.setter
    def grpc_matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchArgs']]]]):
        pulumi.set(self, "grpc_matches", value)

    @property
    @pulumi.getter(name="grpcRouteAction")
    def grpc_route_action(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs']]:
        """
        GRPC route action resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_route_action")

    @grpc_route_action.setter
    def grpc_route_action(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs']]):
        pulumi.set(self, "grpc_route_action", value)

    @property
    @pulumi.getter(name="grpcStatusResponseAction")
    def grpc_status_response_action(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs']]:
        """
        GRPC status response action resource. The structure is documented below.

        > Exactly one type of actions `grpc_route_action` or `grpc_status_response_action` should be specified.
        """
        return pulumi.get(self, "grpc_status_response_action")

    @grpc_status_response_action.setter
    def grpc_status_response_action(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs']]):
        pulumi.set(self, "grpc_status_response_action", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcMatchArgsDict(TypedDict):
        fqmn: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgsDict']]
        """
        If not set, all services/methods are assumed. The structure is documented below.
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcMatchArgs:
    def __init__(__self__, *,
                 fqmn: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs']] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs'] fqmn: If not set, all services/methods are assumed. The structure is documented below.
        """
        if fqmn is not None:
            pulumi.set(__self__, "fqmn", fqmn)

    @property
    @pulumi.getter
    def fqmn(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs']]:
        """
        If not set, all services/methods are assumed. The structure is documented below.
        """
        return pulumi.get(self, "fqmn")

    @fqmn.setter
    def fqmn(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs']]):
        pulumi.set(self, "fqmn", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Match exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Match prefix.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Match exactly.
        :param pulumi.Input[str] prefix: Match prefix.
        :param pulumi.Input[str] regex: Match regex.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgsDict(TypedDict):
        backend_group_id: pulumi.Input[str]
        """
        Backend group to route requests.
        """
        auto_host_rewrite: NotRequired[pulumi.Input[bool]]
        """
        If set, will automatically rewrite host.

        > Only one type of host rewrite specifiers `host_rewrite` or `auto_host_rewrite` should be specified.
        """
        host_rewrite: NotRequired[pulumi.Input[str]]
        """
        Host rewrite specifier.
        """
        idle_timeout: NotRequired[pulumi.Input[str]]
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        max_timeout: NotRequired[pulumi.Input[str]]
        """
        Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        """
        rate_limit: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgsDict']]
        """
        Rate limit configuration applied for a whole virtual host
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs:
    def __init__(__self__, *,
                 backend_group_id: pulumi.Input[str],
                 auto_host_rewrite: Optional[pulumi.Input[bool]] = None,
                 host_rewrite: Optional[pulumi.Input[str]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 max_timeout: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs']] = None):
        """
        :param pulumi.Input[str] backend_group_id: Backend group to route requests.
        :param pulumi.Input[bool] auto_host_rewrite: If set, will automatically rewrite host.
               
               > Only one type of host rewrite specifiers `host_rewrite` or `auto_host_rewrite` should be specified.
        :param pulumi.Input[str] host_rewrite: Host rewrite specifier.
        :param pulumi.Input[str] idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param pulumi.Input[str] max_timeout: Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs'] rate_limit: Rate limit configuration applied for a whole virtual host
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        if auto_host_rewrite is not None:
            pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_timeout is not None:
            pulumi.set(__self__, "max_timeout", max_timeout)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> pulumi.Input[str]:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @backend_group_id.setter
    def backend_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_group_id", value)

    @property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will automatically rewrite host.

        > Only one type of host rewrite specifiers `host_rewrite` or `auto_host_rewrite` should be specified.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @auto_host_rewrite.setter
    def auto_host_rewrite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_host_rewrite", value)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[pulumi.Input[str]]:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @host_rewrite.setter
    def host_rewrite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_rewrite", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="maxTimeout")
    def max_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        """
        return pulumi.get(self, "max_timeout")

    @max_timeout.setter
    def max_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_timeout", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs']]:
        """
        Rate limit configuration applied for a whole virtual host
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs']]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgsDict(TypedDict):
        all_requests: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgsDict']]
        """
        Rate limit configuration applied to all incoming requests
        """
        requests_per_ip: NotRequired[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgsDict']]
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs:
    def __init__(__self__, *,
                 all_requests: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs']] = None,
                 requests_per_ip: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs']] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs'] all_requests: Rate limit configuration applied to all incoming requests
        :param pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs'] requests_per_ip: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        if all_requests is not None:
            pulumi.set(__self__, "all_requests", all_requests)
        if requests_per_ip is not None:
            pulumi.set(__self__, "requests_per_ip", requests_per_ip)

    @property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs']]:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @all_requests.setter
    def all_requests(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs']]):
        pulumi.set(self, "all_requests", value)

    @property
    @pulumi.getter(name="requestsPerIp")
    def requests_per_ip(self) -> Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs']]:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ip")

    @requests_per_ip.setter
    def requests_per_ip(self, value: Optional[pulumi.Input['AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs']]):
        pulumi.set(self, "requests_per_ip", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgsDict(TypedDict):
        per_minute: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per minute time unit
        """
        per_second: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per second time unit
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs:
    def __init__(__self__, *,
                 per_minute: Optional[pulumi.Input[int]] = None,
                 per_second: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] per_minute: Limit value specified with per minute time unit
        :param pulumi.Input[int] per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @per_minute.setter
    def per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_minute", value)

    @property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")

    @per_second.setter
    def per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_second", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgsDict(TypedDict):
        per_minute: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per minute time unit
        """
        per_second: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per second time unit
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs:
    def __init__(__self__, *,
                 per_minute: Optional[pulumi.Input[int]] = None,
                 per_second: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] per_minute: Limit value specified with per minute time unit
        :param pulumi.Input[int] per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @per_minute.setter
    def per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_minute", value)

    @property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")

    @per_second.setter
    def per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_second", value)


if not MYPY:
    class AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
elif False:
    AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteArgsDict(TypedDict):
        direct_response_action: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteDirectResponseActionArgsDict']]
        """
        Direct response action resource. The structure is documented below.

        > Exactly one type of actions `http_route_action` or `redirect_action` or `direct_response_action` should be specified.
        """
        http_matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchArgsDict']]]]
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        http_route_action: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionArgsDict']]
        """
        HTTP route action resource. The structure is documented below.
        """
        redirect_action: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteRedirectActionArgsDict']]
        """
        Redirect action resource. The structure is documented below.
        """
elif False:
    AlbVirtualHostRouteHttpRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteArgs:
    def __init__(__self__, *,
                 direct_response_action: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteDirectResponseActionArgs']] = None,
                 http_matches: Optional[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchArgs']]]] = None,
                 http_route_action: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionArgs']] = None,
                 redirect_action: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteRedirectActionArgs']] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteDirectResponseActionArgs'] direct_response_action: Direct response action resource. The structure is documented below.
               
               > Exactly one type of actions `http_route_action` or `redirect_action` or `direct_response_action` should be specified.
        :param pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchArgs']]] http_matches: Checks "/" prefix by default. The structure is documented below.
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionArgs'] http_route_action: HTTP route action resource. The structure is documented below.
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteRedirectActionArgs'] redirect_action: Redirect action resource. The structure is documented below.
        """
        if direct_response_action is not None:
            pulumi.set(__self__, "direct_response_action", direct_response_action)
        if http_matches is not None:
            pulumi.set(__self__, "http_matches", http_matches)
        if http_route_action is not None:
            pulumi.set(__self__, "http_route_action", http_route_action)
        if redirect_action is not None:
            pulumi.set(__self__, "redirect_action", redirect_action)

    @property
    @pulumi.getter(name="directResponseAction")
    def direct_response_action(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteDirectResponseActionArgs']]:
        """
        Direct response action resource. The structure is documented below.

        > Exactly one type of actions `http_route_action` or `redirect_action` or `direct_response_action` should be specified.
        """
        return pulumi.get(self, "direct_response_action")

    @direct_response_action.setter
    def direct_response_action(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteDirectResponseActionArgs']]):
        pulumi.set(self, "direct_response_action", value)

    @property
    @pulumi.getter(name="httpMatches")
    def http_matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchArgs']]]]:
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        return pulumi.get(self, "http_matches")

    @http_matches.setter
    def http_matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchArgs']]]]):
        pulumi.set(self, "http_matches", value)

    @property
    @pulumi.getter(name="httpRouteAction")
    def http_route_action(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionArgs']]:
        """
        HTTP route action resource. The structure is documented below.
        """
        return pulumi.get(self, "http_route_action")

    @http_route_action.setter
    def http_route_action(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionArgs']]):
        pulumi.set(self, "http_route_action", value)

    @property
    @pulumi.getter(name="redirectAction")
    def redirect_action(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteRedirectActionArgs']]:
        """
        Redirect action resource. The structure is documented below.
        """
        return pulumi.get(self, "redirect_action")

    @redirect_action.setter
    def redirect_action(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteRedirectActionArgs']]):
        pulumi.set(self, "redirect_action", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteDirectResponseActionArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[str]]
        """
        Response body text.
        """
        status: NotRequired[pulumi.Input[int]]
        """
        HTTP response status. Should be between 100 and 599.
        """
elif False:
    AlbVirtualHostRouteHttpRouteDirectResponseActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteDirectResponseActionArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] body: Response body text.
        :param pulumi.Input[int] status: HTTP response status. Should be between 100 and 599.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        Response body text.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP response status. Should be between 100 and 599.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteHttpMatchArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of methods(strings).
        """
        path: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchPathArgsDict']]
        """
        If not set, '/' is assumed. The structure is documented below.
        """
elif False:
    AlbVirtualHostRouteHttpRouteHttpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteHttpMatchArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchPathArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_methods: List of methods(strings).
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchPathArgs'] path: If not set, '/' is assumed. The structure is documented below.
        """
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of methods(strings).
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_methods", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchPathArgs']]:
        """
        If not set, '/' is assumed. The structure is documented below.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpMatchPathArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteHttpMatchPathArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Match exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Match prefix.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
elif False:
    AlbVirtualHostRouteHttpRouteHttpMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteHttpMatchPathArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Match exactly.
        :param pulumi.Input[str] prefix: Match prefix.
        :param pulumi.Input[str] regex: Match regex.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteHttpRouteActionArgsDict(TypedDict):
        backend_group_id: pulumi.Input[str]
        """
        Backend group to route requests.
        """
        auto_host_rewrite: NotRequired[pulumi.Input[bool]]
        """
        If set, will automatically rewrite host.
        """
        host_rewrite: NotRequired[pulumi.Input[str]]
        """
        Host rewrite specifier.
        """
        idle_timeout: NotRequired[pulumi.Input[str]]
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        prefix_rewrite: NotRequired[pulumi.Input[str]]
        """
        If not empty, matched path prefix will be replaced by this value.
        """
        rate_limit: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgsDict']]
        """
        Rate limit configuration applied for a whole virtual host
        """
        timeout: NotRequired[pulumi.Input[str]]
        """
        Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        """
        upgrade_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of upgrade types. Only specified upgrade types will be allowed. For example, "websocket".

        > Only one type of host rewrite specifiers `host_rewrite` or `auto_host_rewrite` should be specified.
        """
elif False:
    AlbVirtualHostRouteHttpRouteHttpRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionArgs:
    def __init__(__self__, *,
                 backend_group_id: pulumi.Input[str],
                 auto_host_rewrite: Optional[pulumi.Input[bool]] = None,
                 host_rewrite: Optional[pulumi.Input[str]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 prefix_rewrite: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs']] = None,
                 timeout: Optional[pulumi.Input[str]] = None,
                 upgrade_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] backend_group_id: Backend group to route requests.
        :param pulumi.Input[bool] auto_host_rewrite: If set, will automatically rewrite host.
        :param pulumi.Input[str] host_rewrite: Host rewrite specifier.
        :param pulumi.Input[str] idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param pulumi.Input[str] prefix_rewrite: If not empty, matched path prefix will be replaced by this value.
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs'] rate_limit: Rate limit configuration applied for a whole virtual host
        :param pulumi.Input[str] timeout: Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] upgrade_types: List of upgrade types. Only specified upgrade types will be allowed. For example, "websocket".
               
               > Only one type of host rewrite specifiers `host_rewrite` or `auto_host_rewrite` should be specified.
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        if auto_host_rewrite is not None:
            pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if prefix_rewrite is not None:
            pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if upgrade_types is not None:
            pulumi.set(__self__, "upgrade_types", upgrade_types)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> pulumi.Input[str]:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @backend_group_id.setter
    def backend_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_group_id", value)

    @property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @auto_host_rewrite.setter
    def auto_host_rewrite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_host_rewrite", value)

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[pulumi.Input[str]]:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @host_rewrite.setter
    def host_rewrite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_rewrite", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> Optional[pulumi.Input[str]]:
        """
        If not empty, matched path prefix will be replaced by this value.
        """
        return pulumi.get(self, "prefix_rewrite")

    @prefix_rewrite.setter
    def prefix_rewrite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_rewrite", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs']]:
        """
        Rate limit configuration applied for a whole virtual host
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs']]):
        pulumi.set(self, "rate_limit", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="upgradeTypes")
    def upgrade_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of upgrade types. Only specified upgrade types will be allowed. For example, "websocket".

        > Only one type of host rewrite specifiers `host_rewrite` or `auto_host_rewrite` should be specified.
        """
        return pulumi.get(self, "upgrade_types")

    @upgrade_types.setter
    def upgrade_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "upgrade_types", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgsDict(TypedDict):
        all_requests: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgsDict']]
        """
        Rate limit configuration applied to all incoming requests
        """
        requests_per_ip: NotRequired[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgsDict']]
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
elif False:
    AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs:
    def __init__(__self__, *,
                 all_requests: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs']] = None,
                 requests_per_ip: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs']] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs'] all_requests: Rate limit configuration applied to all incoming requests
        :param pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs'] requests_per_ip: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        if all_requests is not None:
            pulumi.set(__self__, "all_requests", all_requests)
        if requests_per_ip is not None:
            pulumi.set(__self__, "requests_per_ip", requests_per_ip)

    @property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs']]:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @all_requests.setter
    def all_requests(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs']]):
        pulumi.set(self, "all_requests", value)

    @property
    @pulumi.getter(name="requestsPerIp")
    def requests_per_ip(self) -> Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs']]:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ip")

    @requests_per_ip.setter
    def requests_per_ip(self, value: Optional[pulumi.Input['AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs']]):
        pulumi.set(self, "requests_per_ip", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgsDict(TypedDict):
        per_minute: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per minute time unit
        """
        per_second: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per second time unit
        """
elif False:
    AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs:
    def __init__(__self__, *,
                 per_minute: Optional[pulumi.Input[int]] = None,
                 per_second: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] per_minute: Limit value specified with per minute time unit
        :param pulumi.Input[int] per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @per_minute.setter
    def per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_minute", value)

    @property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")

    @per_second.setter
    def per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_second", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgsDict(TypedDict):
        per_minute: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per minute time unit
        """
        per_second: NotRequired[pulumi.Input[int]]
        """
        Limit value specified with per second time unit
        """
elif False:
    AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs:
    def __init__(__self__, *,
                 per_minute: Optional[pulumi.Input[int]] = None,
                 per_second: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] per_minute: Limit value specified with per minute time unit
        :param pulumi.Input[int] per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @per_minute.setter
    def per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_minute", value)

    @property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")

    @per_second.setter
    def per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_second", value)


if not MYPY:
    class AlbVirtualHostRouteHttpRouteRedirectActionArgsDict(TypedDict):
        remove_query: NotRequired[pulumi.Input[bool]]
        """
        If set, remove query part.
        """
        replace_host: NotRequired[pulumi.Input[str]]
        """
        Replaces hostname.
        """
        replace_path: NotRequired[pulumi.Input[str]]
        """
        Replace path.
        """
        replace_port: NotRequired[pulumi.Input[int]]
        """
        Replaces port.
        """
        replace_prefix: NotRequired[pulumi.Input[str]]
        """
        Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/> redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        """
        replace_scheme: NotRequired[pulumi.Input[str]]
        """
        Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        """
        response_code: NotRequired[pulumi.Input[str]]
        """
        The HTTP status code to use in the redirect response. Supported values are: moved_permanently, found, see_other, temporary_redirect, permanent_redirect.

        > Only one type of paths `replace_path` or `replace_prefix` should be specified.
        """
elif False:
    AlbVirtualHostRouteHttpRouteRedirectActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteHttpRouteRedirectActionArgs:
    def __init__(__self__, *,
                 remove_query: Optional[pulumi.Input[bool]] = None,
                 replace_host: Optional[pulumi.Input[str]] = None,
                 replace_path: Optional[pulumi.Input[str]] = None,
                 replace_port: Optional[pulumi.Input[int]] = None,
                 replace_prefix: Optional[pulumi.Input[str]] = None,
                 replace_scheme: Optional[pulumi.Input[str]] = None,
                 response_code: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] remove_query: If set, remove query part.
        :param pulumi.Input[str] replace_host: Replaces hostname.
        :param pulumi.Input[str] replace_path: Replace path.
        :param pulumi.Input[int] replace_port: Replaces port.
        :param pulumi.Input[str] replace_prefix: Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/> redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        :param pulumi.Input[str] replace_scheme: Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        :param pulumi.Input[str] response_code: The HTTP status code to use in the redirect response. Supported values are: moved_permanently, found, see_other, temporary_redirect, permanent_redirect.
               
               > Only one type of paths `replace_path` or `replace_prefix` should be specified.
        """
        if remove_query is not None:
            pulumi.set(__self__, "remove_query", remove_query)
        if replace_host is not None:
            pulumi.set(__self__, "replace_host", replace_host)
        if replace_path is not None:
            pulumi.set(__self__, "replace_path", replace_path)
        if replace_port is not None:
            pulumi.set(__self__, "replace_port", replace_port)
        if replace_prefix is not None:
            pulumi.set(__self__, "replace_prefix", replace_prefix)
        if replace_scheme is not None:
            pulumi.set(__self__, "replace_scheme", replace_scheme)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)

    @property
    @pulumi.getter(name="removeQuery")
    def remove_query(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, remove query part.
        """
        return pulumi.get(self, "remove_query")

    @remove_query.setter
    def remove_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove_query", value)

    @property
    @pulumi.getter(name="replaceHost")
    def replace_host(self) -> Optional[pulumi.Input[str]]:
        """
        Replaces hostname.
        """
        return pulumi.get(self, "replace_host")

    @replace_host.setter
    def replace_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_host", value)

    @property
    @pulumi.getter(name="replacePath")
    def replace_path(self) -> Optional[pulumi.Input[str]]:
        """
        Replace path.
        """
        return pulumi.get(self, "replace_path")

    @replace_path.setter
    def replace_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_path", value)

    @property
    @pulumi.getter(name="replacePort")
    def replace_port(self) -> Optional[pulumi.Input[int]]:
        """
        Replaces port.
        """
        return pulumi.get(self, "replace_port")

    @replace_port.setter
    def replace_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replace_port", value)

    @property
    @pulumi.getter(name="replacePrefix")
    def replace_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/> redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        """
        return pulumi.get(self, "replace_prefix")

    @replace_prefix.setter
    def replace_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix", value)

    @property
    @pulumi.getter(name="replaceScheme")
    def replace_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        """
        return pulumi.get(self, "replace_scheme")

    @replace_scheme.setter
    def replace_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_scheme", value)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP status code to use in the redirect response. Supported values are: moved_permanently, found, see_other, temporary_redirect, permanent_redirect.

        > Only one type of paths `replace_path` or `replace_prefix` should be specified.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_code", value)


if not MYPY:
    class AlbVirtualHostRouteOptionsArgsDict(TypedDict):
        rbac: NotRequired[pulumi.Input['AlbVirtualHostRouteOptionsRbacArgsDict']]
        """
        RBAC configuration.
        """
        security_profile_id: NotRequired[pulumi.Input[str]]
        """
        SWS profile ID.
        """
elif False:
    AlbVirtualHostRouteOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteOptionsArgs:
    def __init__(__self__, *,
                 rbac: Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacArgs']] = None,
                 security_profile_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteOptionsRbacArgs'] rbac: RBAC configuration.
        :param pulumi.Input[str] security_profile_id: SWS profile ID.
        """
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @property
    @pulumi.getter
    def rbac(self) -> Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacArgs']]:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbac")

    @rbac.setter
    def rbac(self, value: Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacArgs']]):
        pulumi.set(self, "rbac", value)

    @property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")

    @security_profile_id.setter
    def security_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_profile_id", value)


if not MYPY:
    class AlbVirtualHostRouteOptionsRbacArgsDict(TypedDict):
        principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalArgsDict']]]
        action: NotRequired[pulumi.Input[str]]
elif False:
    AlbVirtualHostRouteOptionsRbacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteOptionsRbacArgs:
    def __init__(__self__, *,
                 principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalArgs']]],
                 action: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "principals", principals)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def principals(self) -> pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalArgs']]]:
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalArgs']]]):
        pulumi.set(self, "principals", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class AlbVirtualHostRouteOptionsRbacPrincipalArgsDict(TypedDict):
        and_principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgsDict']]]
elif False:
    AlbVirtualHostRouteOptionsRbacPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteOptionsRbacPrincipalArgs:
    def __init__(__self__, *,
                 and_principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgs']]]):
        pulumi.set(__self__, "and_principals", and_principals)

    @property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgs']]]:
        return pulumi.get(self, "and_principals")

    @and_principals.setter
    def and_principals(self, value: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgs']]]):
        pulumi.set(self, "and_principals", value)


if not MYPY:
    class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgsDict(TypedDict):
        any: NotRequired[pulumi.Input[bool]]
        header: NotRequired[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict']]
        remote_ip: NotRequired[pulumi.Input[str]]
elif False:
    AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input[bool]] = None,
                 header: Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']] = None,
                 remote_ip: Optional[pulumi.Input[str]] = None):
        if any is not None:
            pulumi.set(__self__, "any", any)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if remote_ip is not None:
            pulumi.set(__self__, "remote_ip", remote_ip)

    @property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_ip")

    @remote_ip.setter
    def remote_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ip", value)


if not MYPY:
    class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        name of the header to modify.
        """
        value: NotRequired[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict']]
elif False:
    AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']] = None):
        """
        :param pulumi.Input[str] name: name of the header to modify.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of the header to modify.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Match exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Match prefix.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
elif False:
    AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Match exactly.
        :param pulumi.Input[str] prefix: Match prefix.
        :param pulumi.Input[str] regex: Match regex.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AlbVirtualHostRouteRouteOptionsArgsDict(TypedDict):
        rbac: NotRequired[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacArgsDict']]
        """
        RBAC configuration.
        """
        security_profile_id: NotRequired[pulumi.Input[str]]
        """
        SWS profile ID.
        """
elif False:
    AlbVirtualHostRouteRouteOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteRouteOptionsArgs:
    def __init__(__self__, *,
                 rbac: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacArgs']] = None,
                 security_profile_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacArgs'] rbac: RBAC configuration.
        :param pulumi.Input[str] security_profile_id: SWS profile ID.
        """
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @property
    @pulumi.getter
    def rbac(self) -> Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacArgs']]:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbac")

    @rbac.setter
    def rbac(self, value: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacArgs']]):
        pulumi.set(self, "rbac", value)

    @property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")

    @security_profile_id.setter
    def security_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_profile_id", value)


if not MYPY:
    class AlbVirtualHostRouteRouteOptionsRbacArgsDict(TypedDict):
        principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalArgsDict']]]
        action: NotRequired[pulumi.Input[str]]
elif False:
    AlbVirtualHostRouteRouteOptionsRbacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteRouteOptionsRbacArgs:
    def __init__(__self__, *,
                 principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalArgs']]],
                 action: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "principals", principals)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def principals(self) -> pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalArgs']]]:
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalArgs']]]):
        pulumi.set(self, "principals", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class AlbVirtualHostRouteRouteOptionsRbacPrincipalArgsDict(TypedDict):
        and_principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgsDict']]]
elif False:
    AlbVirtualHostRouteRouteOptionsRbacPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalArgs:
    def __init__(__self__, *,
                 and_principals: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgs']]]):
        pulumi.set(__self__, "and_principals", and_principals)

    @property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgs']]]:
        return pulumi.get(self, "and_principals")

    @and_principals.setter
    def and_principals(self, value: pulumi.Input[Sequence[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgs']]]):
        pulumi.set(self, "and_principals", value)


if not MYPY:
    class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgsDict(TypedDict):
        any: NotRequired[pulumi.Input[bool]]
        header: NotRequired[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict']]
        remote_ip: NotRequired[pulumi.Input[str]]
elif False:
    AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input[bool]] = None,
                 header: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']] = None,
                 remote_ip: Optional[pulumi.Input[str]] = None):
        if any is not None:
            pulumi.set(__self__, "any", any)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if remote_ip is not None:
            pulumi.set(__self__, "remote_ip", remote_ip)

    @property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_ip")

    @remote_ip.setter
    def remote_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ip", value)


if not MYPY:
    class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        name of the header to modify.
        """
        value: NotRequired[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict']]
elif False:
    AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']] = None):
        """
        :param pulumi.Input[str] name: name of the header to modify.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of the header to modify.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Match exactly.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Match prefix.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
elif False:
    AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Match exactly.
        :param pulumi.Input[str] prefix: Match prefix.
        :param pulumi.Input[str] regex: Match regex.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Match regex.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class ApiGatewayCanaryArgsDict(TypedDict):
        variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of values for variables in gateway specification.
        """
        weight: NotRequired[pulumi.Input[int]]
elif False:
    ApiGatewayCanaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayCanaryArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] variables: A set of values for variables in gateway specification.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of values for variables in gateway specification.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "variables", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ApiGatewayConnectivityArgsDict(TypedDict):
        network_id: pulumi.Input[str]
elif False:
    ApiGatewayConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayConnectivityArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[str]):
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class ApiGatewayCustomDomainArgsDict(TypedDict):
        certificate_id: pulumi.Input[str]
        fqdn: pulumi.Input[str]
        domain_id: NotRequired[pulumi.Input[str]]
elif False:
    ApiGatewayCustomDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayCustomDomainArgs:
    def __init__(__self__, *,
                 certificate_id: pulumi.Input[str],
                 fqdn: pulumi.Input[str],
                 domain_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "fqdn", fqdn)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)


if not MYPY:
    class ApiGatewayLogOptionsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Is logging from API Gateway disabled
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Folder ID for the Yandex Cloud API Gateway. If it is not provided, the default provider folder is used.
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to specified log group
        """
        min_level: NotRequired[pulumi.Input[str]]
        """
        Minimum log entry level
        """
elif False:
    ApiGatewayLogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayLogOptionsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 min_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: Is logging from API Gateway disabled
        :param pulumi.Input[str] folder_id: Folder ID for the Yandex Cloud API Gateway. If it is not provided, the default provider folder is used.
        :param pulumi.Input[str] log_group_id: Log entries are written to specified log group
        :param pulumi.Input[str] min_level: Minimum log entry level
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is logging from API Gateway disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Folder ID for the Yandex Cloud API Gateway. If it is not provided, the default provider folder is used.
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to specified log group
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum log entry level
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)


if not MYPY:
    class AuditTrailsTrailDataStreamDestinationArgsDict(TypedDict):
        database_id: pulumi.Input[str]
        """
        ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        """
        stream_name: pulumi.Input[str]
        """
        Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
elif False:
    AuditTrailsTrailDataStreamDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailDataStreamDestinationArgs:
    def __init__(__self__, *,
                 database_id: pulumi.Input[str],
                 stream_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_id: ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        :param pulumi.Input[str] stream_name: Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> pulumi.Input[str]:
        """
        ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class AuditTrailsTrailFilterArgsDict(TypedDict):
        event_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterArgsDict']]]]
        """
        Structure describing filtering process for the service-specific data plane events.
        """
        path_filter: NotRequired[pulumi.Input['AuditTrailsTrailFilterPathFilterArgsDict']]
        """
        Structure describing filtering process for default control plane events. If omitted, the trail will not deliver this category.
        """
elif False:
    AuditTrailsTrailFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterArgs:
    def __init__(__self__, *,
                 event_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterArgs']]]] = None,
                 path_filter: Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterArgs']]] event_filters: Structure describing filtering process for the service-specific data plane events.
        :param pulumi.Input['AuditTrailsTrailFilterPathFilterArgs'] path_filter: Structure describing filtering process for default control plane events. If omitted, the trail will not deliver this category.
        """
        if event_filters is not None:
            pulumi.set(__self__, "event_filters", event_filters)
        if path_filter is not None:
            pulumi.set(__self__, "path_filter", path_filter)

    @property
    @pulumi.getter(name="eventFilters")
    def event_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterArgs']]]]:
        """
        Structure describing filtering process for the service-specific data plane events.
        """
        return pulumi.get(self, "event_filters")

    @event_filters.setter
    def event_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterArgs']]]]):
        pulumi.set(self, "event_filters", value)

    @property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterArgs']]:
        """
        Structure describing filtering process for default control plane events. If omitted, the trail will not deliver this category.
        """
        return pulumi.get(self, "path_filter")

    @path_filter.setter
    def path_filter(self, value: Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterArgs']]):
        pulumi.set(self, "path_filter", value)


if not MYPY:
    class AuditTrailsTrailFilterEventFilterArgsDict(TypedDict):
        categories: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterCategoryArgsDict']]]
        """
        List of structures describing categories of gathered data plane events.
        """
        path_filter: pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterArgsDict']
        """
        Structure describing filtering process based on cloud resources for the described event set. Structurally equal to the `filter.path_filter`.
        """
        service: pulumi.Input[str]
        """
        ID of the service which events will be gathered.
        """
elif False:
    AuditTrailsTrailFilterEventFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterEventFilterArgs:
    def __init__(__self__, *,
                 categories: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterCategoryArgs']]],
                 path_filter: pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterArgs'],
                 service: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterCategoryArgs']]] categories: List of structures describing categories of gathered data plane events.
        :param pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterArgs'] path_filter: Structure describing filtering process based on cloud resources for the described event set. Structurally equal to the `filter.path_filter`.
        :param pulumi.Input[str] service: ID of the service which events will be gathered.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "path_filter", path_filter)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def categories(self) -> pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterCategoryArgs']]]:
        """
        List of structures describing categories of gathered data plane events.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterCategoryArgs']]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterArgs']:
        """
        Structure describing filtering process based on cloud resources for the described event set. Structurally equal to the `filter.path_filter`.
        """
        return pulumi.get(self, "path_filter")

    @path_filter.setter
    def path_filter(self, value: pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterArgs']):
        pulumi.set(self, "path_filter", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        ID of the service which events will be gathered.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class AuditTrailsTrailFilterEventFilterCategoryArgsDict(TypedDict):
        plane: pulumi.Input[str]
        """
        Type of the event by its relation to the cloud resource model. Possible values: `CONTROL_PLANE`/`DATA_PLANE`.
        """
        type: pulumi.Input[str]
        """
        Type of the event by its operation effect on the resource. Possible values: `READ`/`WRITE`.
        """
elif False:
    AuditTrailsTrailFilterEventFilterCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterEventFilterCategoryArgs:
    def __init__(__self__, *,
                 plane: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] plane: Type of the event by its relation to the cloud resource model. Possible values: `CONTROL_PLANE`/`DATA_PLANE`.
        :param pulumi.Input[str] type: Type of the event by its operation effect on the resource. Possible values: `READ`/`WRITE`.
        """
        pulumi.set(__self__, "plane", plane)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def plane(self) -> pulumi.Input[str]:
        """
        Type of the event by its relation to the cloud resource model. Possible values: `CONTROL_PLANE`/`DATA_PLANE`.
        """
        return pulumi.get(self, "plane")

    @plane.setter
    def plane(self, value: pulumi.Input[str]):
        pulumi.set(self, "plane", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the event by its operation effect on the resource. Possible values: `READ`/`WRITE`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AuditTrailsTrailFilterEventFilterPathFilterArgsDict(TypedDict):
        any_filter: NotRequired[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgsDict']]
        """
        Structure describing that events will be gathered from all cloud resources that belong to the parent resource. Mutually exclusive with `some_filter`.
        """
        some_filter: NotRequired[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgsDict']]
        """
        Structure describing that events will be gathered from some of the cloud resources that belong to the parent resource. Mutually exclusive with `any_filter`.
        """
elif False:
    AuditTrailsTrailFilterEventFilterPathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterEventFilterPathFilterArgs:
    def __init__(__self__, *,
                 any_filter: Optional[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs']] = None,
                 some_filter: Optional[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs']] = None):
        """
        :param pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs'] any_filter: Structure describing that events will be gathered from all cloud resources that belong to the parent resource. Mutually exclusive with `some_filter`.
        :param pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs'] some_filter: Structure describing that events will be gathered from some of the cloud resources that belong to the parent resource. Mutually exclusive with `any_filter`.
        """
        if any_filter is not None:
            pulumi.set(__self__, "any_filter", any_filter)
        if some_filter is not None:
            pulumi.set(__self__, "some_filter", some_filter)

    @property
    @pulumi.getter(name="anyFilter")
    def any_filter(self) -> Optional[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs']]:
        """
        Structure describing that events will be gathered from all cloud resources that belong to the parent resource. Mutually exclusive with `some_filter`.
        """
        return pulumi.get(self, "any_filter")

    @any_filter.setter
    def any_filter(self, value: Optional[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs']]):
        pulumi.set(self, "any_filter", value)

    @property
    @pulumi.getter(name="someFilter")
    def some_filter(self) -> Optional[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs']]:
        """
        Structure describing that events will be gathered from some of the cloud resources that belong to the parent resource. Mutually exclusive with `any_filter`.
        """
        return pulumi.get(self, "some_filter")

    @some_filter.setter
    def some_filter(self, value: Optional[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs']]):
        pulumi.set(self, "some_filter", value)


if not MYPY:
    class AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        resource_type: pulumi.Input[str]
elif False:
    AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgsDict(TypedDict):
        any_filters: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgsDict']]]
        """
        List of child resources from which events will be gathered.
        """
        resource_id: pulumi.Input[str]
        resource_type: pulumi.Input[str]
elif False:
    AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs:
    def __init__(__self__, *,
                 any_filters: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs']]],
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs']]] any_filters: List of child resources from which events will be gathered.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs']]]:
        """
        List of child resources from which events will be gathered.
        """
        return pulumi.get(self, "any_filters")

    @any_filters.setter
    def any_filters(self, value: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs']]]):
        pulumi.set(self, "any_filters", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        resource_type: pulumi.Input[str]
elif False:
    AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilterPathFilterArgsDict(TypedDict):
        any_filter: NotRequired[pulumi.Input['AuditTrailsTrailFilterPathFilterAnyFilterArgsDict']]
        """
        Structure describing that events will be gathered from all cloud resources that belong to the parent resource. Mutually exclusive with `some_filter`.
        """
        some_filter: NotRequired[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterArgsDict']]
        """
        Structure describing that events will be gathered from some of the cloud resources that belong to the parent resource. Mutually exclusive with `any_filter`.
        """
elif False:
    AuditTrailsTrailFilterPathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterPathFilterArgs:
    def __init__(__self__, *,
                 any_filter: Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterAnyFilterArgs']] = None,
                 some_filter: Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterArgs']] = None):
        """
        :param pulumi.Input['AuditTrailsTrailFilterPathFilterAnyFilterArgs'] any_filter: Structure describing that events will be gathered from all cloud resources that belong to the parent resource. Mutually exclusive with `some_filter`.
        :param pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterArgs'] some_filter: Structure describing that events will be gathered from some of the cloud resources that belong to the parent resource. Mutually exclusive with `any_filter`.
        """
        if any_filter is not None:
            pulumi.set(__self__, "any_filter", any_filter)
        if some_filter is not None:
            pulumi.set(__self__, "some_filter", some_filter)

    @property
    @pulumi.getter(name="anyFilter")
    def any_filter(self) -> Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterAnyFilterArgs']]:
        """
        Structure describing that events will be gathered from all cloud resources that belong to the parent resource. Mutually exclusive with `some_filter`.
        """
        return pulumi.get(self, "any_filter")

    @any_filter.setter
    def any_filter(self, value: Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterAnyFilterArgs']]):
        pulumi.set(self, "any_filter", value)

    @property
    @pulumi.getter(name="someFilter")
    def some_filter(self) -> Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterArgs']]:
        """
        Structure describing that events will be gathered from some of the cloud resources that belong to the parent resource. Mutually exclusive with `any_filter`.
        """
        return pulumi.get(self, "some_filter")

    @some_filter.setter
    def some_filter(self, value: Optional[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterArgs']]):
        pulumi.set(self, "some_filter", value)


if not MYPY:
    class AuditTrailsTrailFilterPathFilterAnyFilterArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        """
        ID of the parent resource.
        """
        resource_type: pulumi.Input[str]
        """
        Resource type of the parent resource.
        """
elif False:
    AuditTrailsTrailFilterPathFilterAnyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterPathFilterAnyFilterArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] resource_id: ID of the parent resource.
        :param pulumi.Input[str] resource_type: Resource type of the parent resource.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        ID of the parent resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        Resource type of the parent resource.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilterPathFilterSomeFilterArgsDict(TypedDict):
        any_filters: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgsDict']]]
        """
        List of child resources from which events will be gathered.
        """
        resource_id: pulumi.Input[str]
        """
        ID of the parent resource.
        """
        resource_type: pulumi.Input[str]
        """
        Resource type of the parent resource.
        """
elif False:
    AuditTrailsTrailFilterPathFilterSomeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterPathFilterSomeFilterArgs:
    def __init__(__self__, *,
                 any_filters: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs']]],
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs']]] any_filters: List of child resources from which events will be gathered.
        :param pulumi.Input[str] resource_id: ID of the parent resource.
        :param pulumi.Input[str] resource_type: Resource type of the parent resource.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs']]]:
        """
        List of child resources from which events will be gathered.
        """
        return pulumi.get(self, "any_filters")

    @any_filters.setter
    def any_filters(self, value: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs']]]):
        pulumi.set(self, "any_filters", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        ID of the parent resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        Resource type of the parent resource.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        """
        ID of the child resource.
        """
        resource_type: pulumi.Input[str]
        """
        Resource type of the child resource.
        """
elif False:
    AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] resource_id: ID of the child resource.
        :param pulumi.Input[str] resource_type: Resource type of the child resource.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        ID of the child resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        Resource type of the child resource.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilteringPolicyArgsDict(TypedDict):
        data_events_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterArgsDict']]]]
        """
        Structure describing filtering process for the service-specific data events.
        """
        management_events_filter: NotRequired[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterArgsDict']]
        """
        Structure describing filtering process for management events.
        """
elif False:
    AuditTrailsTrailFilteringPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilteringPolicyArgs:
    def __init__(__self__, *,
                 data_events_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterArgs']]]] = None,
                 management_events_filter: Optional[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterArgs']]] data_events_filters: Structure describing filtering process for the service-specific data events.
        :param pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs'] management_events_filter: Structure describing filtering process for management events.
        """
        if data_events_filters is not None:
            pulumi.set(__self__, "data_events_filters", data_events_filters)
        if management_events_filter is not None:
            pulumi.set(__self__, "management_events_filter", management_events_filter)

    @property
    @pulumi.getter(name="dataEventsFilters")
    def data_events_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterArgs']]]]:
        """
        Structure describing filtering process for the service-specific data events.
        """
        return pulumi.get(self, "data_events_filters")

    @data_events_filters.setter
    def data_events_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterArgs']]]]):
        pulumi.set(self, "data_events_filters", value)

    @property
    @pulumi.getter(name="managementEventsFilter")
    def management_events_filter(self) -> Optional[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs']]:
        """
        Structure describing filtering process for management events.
        """
        return pulumi.get(self, "management_events_filter")

    @management_events_filter.setter
    def management_events_filter(self, value: Optional[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs']]):
        pulumi.set(self, "management_events_filter", value)


if not MYPY:
    class AuditTrailsTrailFilteringPolicyDataEventsFilterArgsDict(TypedDict):
        resource_scopes: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgsDict']]]
        service: pulumi.Input[str]
        excluded_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        """
        included_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        """
elif False:
    AuditTrailsTrailFilteringPolicyDataEventsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilteringPolicyDataEventsFilterArgs:
    def __init__(__self__, *,
                 resource_scopes: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs']]],
                 service: pulumi.Input[str],
                 excluded_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_events: A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_events: A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        """
        pulumi.set(__self__, "resource_scopes", resource_scopes)
        pulumi.set(__self__, "service", service)
        if excluded_events is not None:
            pulumi.set(__self__, "excluded_events", excluded_events)
        if included_events is not None:
            pulumi.set(__self__, "included_events", included_events)

    @property
    @pulumi.getter(name="resourceScopes")
    def resource_scopes(self) -> pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs']]]:
        return pulumi.get(self, "resource_scopes")

    @resource_scopes.setter
    def resource_scopes(self, value: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs']]]):
        pulumi.set(self, "resource_scopes", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="excludedEvents")
    def excluded_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        """
        return pulumi.get(self, "excluded_events")

    @excluded_events.setter
    def excluded_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_events", value)

    @property
    @pulumi.getter(name="includedEvents")
    def included_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        """
        return pulumi.get(self, "included_events")

    @included_events.setter
    def included_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_events", value)


if not MYPY:
    class AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        resource_type: pulumi.Input[str]
elif False:
    AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailFilteringPolicyManagementEventsFilterArgsDict(TypedDict):
        resource_scopes: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgsDict']]]
elif False:
    AuditTrailsTrailFilteringPolicyManagementEventsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs:
    def __init__(__self__, *,
                 resource_scopes: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs']]]):
        pulumi.set(__self__, "resource_scopes", resource_scopes)

    @property
    @pulumi.getter(name="resourceScopes")
    def resource_scopes(self) -> pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs']]]:
        return pulumi.get(self, "resource_scopes")

    @resource_scopes.setter
    def resource_scopes(self, value: pulumi.Input[Sequence[pulumi.Input['AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs']]]):
        pulumi.set(self, "resource_scopes", value)


if not MYPY:
    class AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        resource_type: pulumi.Input[str]
elif False:
    AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 resource_type: pulumi.Input[str]):
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AuditTrailsTrailLoggingDestinationArgsDict(TypedDict):
        log_group_id: pulumi.Input[str]
        """
        ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
elif False:
    AuditTrailsTrailLoggingDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailLoggingDestinationArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_group_id: ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        pulumi.set(__self__, "log_group_id", log_group_id)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[str]:
        """
        ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_id", value)


if not MYPY:
    class AuditTrailsTrailStorageDestinationArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        """
        object_prefix: NotRequired[pulumi.Input[str]]
        """
        Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
elif False:
    AuditTrailsTrailStorageDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditTrailsTrailStorageDestinationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 object_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        :param pulumi.Input[str] object_prefix: Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if object_prefix is not None:
            pulumi.set(__self__, "object_prefix", object_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
        return pulumi.get(self, "object_prefix")

    @object_prefix.setter
    def object_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_prefix", value)


if not MYPY:
    class BackupPolicyReattemptsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
         Enable flag
        """
        interval: NotRequired[pulumi.Input[str]]
        """
        Retry interval. See `interval_type` for available values
        """
        max_attempts: NotRequired[pulumi.Input[int]]
        """
        Maximum number of attempts before throwing an error
        """
elif False:
    BackupPolicyReattemptsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyReattemptsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 max_attempts: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled:  Enable flag
        :param pulumi.Input[str] interval: Retry interval. See `interval_type` for available values
        :param pulumi.Input[int] max_attempts: Maximum number of attempts before throwing an error
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
         Enable flag
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Retry interval. See `interval_type` for available values
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of attempts before throwing an error
        """
        return pulumi.get(self, "max_attempts")

    @max_attempts.setter
    def max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_attempts", value)


if not MYPY:
    class BackupPolicyRetentionArgsDict(TypedDict):
        after_backup: NotRequired[pulumi.Input[bool]]
        """
         Defines whether retention rule applies after creating backup or before.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackupPolicyRetentionRuleArgsDict']]]]
elif False:
    BackupPolicyRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyRetentionArgs:
    def __init__(__self__, *,
                 after_backup: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicyRetentionRuleArgs']]]] = None):
        """
        :param pulumi.Input[bool] after_backup:  Defines whether retention rule applies after creating backup or before.
        """
        if after_backup is not None:
            pulumi.set(__self__, "after_backup", after_backup)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="afterBackup")
    def after_backup(self) -> Optional[pulumi.Input[bool]]:
        """
         Defines whether retention rule applies after creating backup or before.
        """
        return pulumi.get(self, "after_backup")

    @after_backup.setter
    def after_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "after_backup", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicyRetentionRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicyRetentionRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class BackupPolicyRetentionRuleArgsDict(TypedDict):
        max_age: NotRequired[pulumi.Input[str]]
        """
         Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        """
        max_count: NotRequired[pulumi.Input[int]]
        """
         Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        """
        repeat_periods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    BackupPolicyRetentionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyRetentionRuleArgs:
    def __init__(__self__, *,
                 max_age: Optional[pulumi.Input[str]] = None,
                 max_count: Optional[pulumi.Input[int]] = None,
                 repeat_periods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] max_age:  Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        :param pulumi.Input[int] max_count:  Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        """
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if repeat_periods is not None:
            pulumi.set(__self__, "repeat_periods", repeat_periods)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        """
         Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
         Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)

    @property
    @pulumi.getter(name="repeatPeriods")
    def repeat_periods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "repeat_periods")

    @repeat_periods.setter
    def repeat_periods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "repeat_periods", value)


if not MYPY:
    class BackupPolicySchedulingArgsDict(TypedDict):
        backup_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetArgsDict']]]]
        """
        A list of schedules with backup sets that compose the whole scheme.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
         enables or disables scheduling.
        """
        execute_by_interval: NotRequired[pulumi.Input[int]]
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        execute_by_times: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingExecuteByTimeArgsDict']]]]
        """
         Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        max_parallel_backups: NotRequired[pulumi.Input[int]]
        """
         Maximum number of backup processes allowed to run in parallel. 0 for unlimited.
        """
        random_max_delay: NotRequired[pulumi.Input[str]]
        """
         Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values.
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
         Scheme of the backups. Available values are: `"ALWAYS_INCREMENTAL"`, `"ALWAYS_FULL"`, `"WEEKLY_FULL_DAILY_INCREMENTAL"`, `'WEEKLY_INCREMENTAL"`.
        """
        weekly_backup_day: NotRequired[pulumi.Input[str]]
        """
         A day of week to start weekly backups. See `day_type` for available values.
        """
elif False:
    BackupPolicySchedulingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicySchedulingArgs:
    def __init__(__self__, *,
                 backup_sets: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 execute_by_interval: Optional[pulumi.Input[int]] = None,
                 execute_by_times: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingExecuteByTimeArgs']]]] = None,
                 max_parallel_backups: Optional[pulumi.Input[int]] = None,
                 random_max_delay: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 weekly_backup_day: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetArgs']]] backup_sets: A list of schedules with backup sets that compose the whole scheme.
        :param pulumi.Input[bool] enabled:  enables or disables scheduling.
        :param pulumi.Input[int] execute_by_interval: Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingExecuteByTimeArgs']]] execute_by_times:  Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param pulumi.Input[int] max_parallel_backups:  Maximum number of backup processes allowed to run in parallel. 0 for unlimited.
        :param pulumi.Input[str] random_max_delay:  Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values.
        :param pulumi.Input[str] scheme:  Scheme of the backups. Available values are: `"ALWAYS_INCREMENTAL"`, `"ALWAYS_FULL"`, `"WEEKLY_FULL_DAILY_INCREMENTAL"`, `'WEEKLY_INCREMENTAL"`.
        :param pulumi.Input[str] weekly_backup_day:  A day of week to start weekly backups. See `day_type` for available values.
        """
        if backup_sets is not None:
            pulumi.set(__self__, "backup_sets", backup_sets)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if execute_by_interval is not None:
            warnings.warn("""The 'execute_by_interval' field has been deprecated. Please use 'backup_sets' instead.""", DeprecationWarning)
            pulumi.log.warn("""execute_by_interval is deprecated: The 'execute_by_interval' field has been deprecated. Please use 'backup_sets' instead.""")
        if execute_by_interval is not None:
            pulumi.set(__self__, "execute_by_interval", execute_by_interval)
        if execute_by_times is not None:
            warnings.warn("""The 'execute_by_time' field has been deprecated. Please use 'backup_sets' instead.""", DeprecationWarning)
            pulumi.log.warn("""execute_by_times is deprecated: The 'execute_by_time' field has been deprecated. Please use 'backup_sets' instead.""")
        if execute_by_times is not None:
            pulumi.set(__self__, "execute_by_times", execute_by_times)
        if max_parallel_backups is not None:
            pulumi.set(__self__, "max_parallel_backups", max_parallel_backups)
        if random_max_delay is not None:
            pulumi.set(__self__, "random_max_delay", random_max_delay)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if weekly_backup_day is not None:
            pulumi.set(__self__, "weekly_backup_day", weekly_backup_day)

    @property
    @pulumi.getter(name="backupSets")
    def backup_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetArgs']]]]:
        """
        A list of schedules with backup sets that compose the whole scheme.
        """
        return pulumi.get(self, "backup_sets")

    @backup_sets.setter
    def backup_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetArgs']]]]):
        pulumi.set(self, "backup_sets", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
         enables or disables scheduling.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="executeByInterval")
    @_utilities.deprecated("""The 'execute_by_interval' field has been deprecated. Please use 'backup_sets' instead.""")
    def execute_by_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_interval")

    @execute_by_interval.setter
    def execute_by_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "execute_by_interval", value)

    @property
    @pulumi.getter(name="executeByTimes")
    @_utilities.deprecated("""The 'execute_by_time' field has been deprecated. Please use 'backup_sets' instead.""")
    def execute_by_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingExecuteByTimeArgs']]]]:
        """
         Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_times")

    @execute_by_times.setter
    def execute_by_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingExecuteByTimeArgs']]]]):
        pulumi.set(self, "execute_by_times", value)

    @property
    @pulumi.getter(name="maxParallelBackups")
    def max_parallel_backups(self) -> Optional[pulumi.Input[int]]:
        """
         Maximum number of backup processes allowed to run in parallel. 0 for unlimited.
        """
        return pulumi.get(self, "max_parallel_backups")

    @max_parallel_backups.setter
    def max_parallel_backups(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallel_backups", value)

    @property
    @pulumi.getter(name="randomMaxDelay")
    def random_max_delay(self) -> Optional[pulumi.Input[str]]:
        """
         Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values.
        """
        return pulumi.get(self, "random_max_delay")

    @random_max_delay.setter
    def random_max_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "random_max_delay", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
         Scheme of the backups. Available values are: `"ALWAYS_INCREMENTAL"`, `"ALWAYS_FULL"`, `"WEEKLY_FULL_DAILY_INCREMENTAL"`, `'WEEKLY_INCREMENTAL"`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="weeklyBackupDay")
    def weekly_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
         A day of week to start weekly backups. See `day_type` for available values.
        """
        return pulumi.get(self, "weekly_backup_day")

    @weekly_backup_day.setter
    def weekly_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weekly_backup_day", value)


if not MYPY:
    class BackupPolicySchedulingBackupSetArgsDict(TypedDict):
        execute_by_interval: NotRequired[pulumi.Input[int]]
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        execute_by_times: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetExecuteByTimeArgsDict']]]]
        """
         Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        BackupSet type. See `backup_set_type` for available values.
        """
elif False:
    BackupPolicySchedulingBackupSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicySchedulingBackupSetArgs:
    def __init__(__self__, *,
                 execute_by_interval: Optional[pulumi.Input[int]] = None,
                 execute_by_times: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetExecuteByTimeArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] execute_by_interval: Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetExecuteByTimeArgs']]] execute_by_times:  Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param pulumi.Input[str] type: BackupSet type. See `backup_set_type` for available values.
        """
        if execute_by_interval is not None:
            pulumi.set(__self__, "execute_by_interval", execute_by_interval)
        if execute_by_times is not None:
            pulumi.set(__self__, "execute_by_times", execute_by_times)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="executeByInterval")
    def execute_by_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_interval")

    @execute_by_interval.setter
    def execute_by_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "execute_by_interval", value)

    @property
    @pulumi.getter(name="executeByTimes")
    def execute_by_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetExecuteByTimeArgs']]]]:
        """
         Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_times")

    @execute_by_times.setter
    def execute_by_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPolicySchedulingBackupSetExecuteByTimeArgs']]]]):
        pulumi.set(self, "execute_by_times", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        BackupSet type. See `backup_set_type` for available values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class BackupPolicySchedulingBackupSetExecuteByTimeArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
         Type of the scheduling. Available values are: `"HOURLY"`, `"DAILY"`, `"WEEKLY"`, `"MONTHLY"`.
        """
        include_last_day_of_month: NotRequired[pulumi.Input[bool]]
        """
         If true, schedule will be applied on the last day of month. See `day_type` for available values.
        """
        monthdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
         List of days when schedule applies. Used in `"MONTHLY"` type.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        repeat_ats: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
         List of time in format `"HH:MM" (24-hours format)`, when the schedule applies.
        """
        repeat_every: NotRequired[pulumi.Input[str]]
        """
         Frequency of backup repetition. See `interval_type` for available values.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
         List of weekdays when the backup will be applied. Used in `"WEEKLY"` type.
        """
elif False:
    BackupPolicySchedulingBackupSetExecuteByTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicySchedulingBackupSetExecuteByTimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 include_last_day_of_month: Optional[pulumi.Input[bool]] = None,
                 monthdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 repeat_ats: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_every: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type:  Type of the scheduling. Available values are: `"HOURLY"`, `"DAILY"`, `"WEEKLY"`, `"MONTHLY"`.
        :param pulumi.Input[bool] include_last_day_of_month:  If true, schedule will be applied on the last day of month. See `day_type` for available values.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] monthdays:  List of days when schedule applies. Used in `"MONTHLY"` type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repeat_ats:  List of time in format `"HH:MM" (24-hours format)`, when the schedule applies.
        :param pulumi.Input[str] repeat_every:  Frequency of backup repetition. See `interval_type` for available values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] weekdays:  List of weekdays when the backup will be applied. Used in `"WEEKLY"` type.
        """
        pulumi.set(__self__, "type", type)
        if include_last_day_of_month is not None:
            pulumi.set(__self__, "include_last_day_of_month", include_last_day_of_month)
        if monthdays is not None:
            pulumi.set(__self__, "monthdays", monthdays)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if repeat_ats is not None:
            pulumi.set(__self__, "repeat_ats", repeat_ats)
        if repeat_every is not None:
            pulumi.set(__self__, "repeat_every", repeat_every)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
         Type of the scheduling. Available values are: `"HOURLY"`, `"DAILY"`, `"WEEKLY"`, `"MONTHLY"`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="includeLastDayOfMonth")
    def include_last_day_of_month(self) -> Optional[pulumi.Input[bool]]:
        """
         If true, schedule will be applied on the last day of month. See `day_type` for available values.
        """
        return pulumi.get(self, "include_last_day_of_month")

    @include_last_day_of_month.setter
    def include_last_day_of_month(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_last_day_of_month", value)

    @property
    @pulumi.getter
    def monthdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
         List of days when schedule applies. Used in `"MONTHLY"` type.
        """
        return pulumi.get(self, "monthdays")

    @monthdays.setter
    def monthdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "monthdays", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="repeatAts")
    def repeat_ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
         List of time in format `"HH:MM" (24-hours format)`, when the schedule applies.
        """
        return pulumi.get(self, "repeat_ats")

    @repeat_ats.setter
    def repeat_ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "repeat_ats", value)

    @property
    @pulumi.getter(name="repeatEvery")
    def repeat_every(self) -> Optional[pulumi.Input[str]]:
        """
         Frequency of backup repetition. See `interval_type` for available values.
        """
        return pulumi.get(self, "repeat_every")

    @repeat_every.setter
    def repeat_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_every", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
         List of weekdays when the backup will be applied. Used in `"WEEKLY"` type.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "weekdays", value)


if not MYPY:
    class BackupPolicySchedulingExecuteByTimeArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
         Type of the scheduling. Available values are: `"HOURLY"`, `"DAILY"`, `"WEEKLY"`, `"MONTHLY"`.
        """
        include_last_day_of_month: NotRequired[pulumi.Input[bool]]
        """
         If true, schedule will be applied on the last day of month. See `day_type` for available values.
        """
        monthdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
         List of days when schedule applies. Used in `"MONTHLY"` type.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        repeat_ats: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
         List of time in format `"HH:MM" (24-hours format)`, when the schedule applies.
        """
        repeat_every: NotRequired[pulumi.Input[str]]
        """
         Frequency of backup repetition. See `interval_type` for available values.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
         List of weekdays when the backup will be applied. Used in `"WEEKLY"` type.
        """
elif False:
    BackupPolicySchedulingExecuteByTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicySchedulingExecuteByTimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 include_last_day_of_month: Optional[pulumi.Input[bool]] = None,
                 monthdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 repeat_ats: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat_every: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type:  Type of the scheduling. Available values are: `"HOURLY"`, `"DAILY"`, `"WEEKLY"`, `"MONTHLY"`.
        :param pulumi.Input[bool] include_last_day_of_month:  If true, schedule will be applied on the last day of month. See `day_type` for available values.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] monthdays:  List of days when schedule applies. Used in `"MONTHLY"` type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repeat_ats:  List of time in format `"HH:MM" (24-hours format)`, when the schedule applies.
        :param pulumi.Input[str] repeat_every:  Frequency of backup repetition. See `interval_type` for available values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] weekdays:  List of weekdays when the backup will be applied. Used in `"WEEKLY"` type.
        """
        pulumi.set(__self__, "type", type)
        if include_last_day_of_month is not None:
            pulumi.set(__self__, "include_last_day_of_month", include_last_day_of_month)
        if monthdays is not None:
            pulumi.set(__self__, "monthdays", monthdays)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if repeat_ats is not None:
            pulumi.set(__self__, "repeat_ats", repeat_ats)
        if repeat_every is not None:
            pulumi.set(__self__, "repeat_every", repeat_every)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
         Type of the scheduling. Available values are: `"HOURLY"`, `"DAILY"`, `"WEEKLY"`, `"MONTHLY"`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="includeLastDayOfMonth")
    def include_last_day_of_month(self) -> Optional[pulumi.Input[bool]]:
        """
         If true, schedule will be applied on the last day of month. See `day_type` for available values.
        """
        return pulumi.get(self, "include_last_day_of_month")

    @include_last_day_of_month.setter
    def include_last_day_of_month(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_last_day_of_month", value)

    @property
    @pulumi.getter
    def monthdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
         List of days when schedule applies. Used in `"MONTHLY"` type.
        """
        return pulumi.get(self, "monthdays")

    @monthdays.setter
    def monthdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "monthdays", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="repeatAts")
    def repeat_ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
         List of time in format `"HH:MM" (24-hours format)`, when the schedule applies.
        """
        return pulumi.get(self, "repeat_ats")

    @repeat_ats.setter
    def repeat_ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "repeat_ats", value)

    @property
    @pulumi.getter(name="repeatEvery")
    def repeat_every(self) -> Optional[pulumi.Input[str]]:
        """
         Frequency of backup repetition. See `interval_type` for available values.
        """
        return pulumi.get(self, "repeat_every")

    @repeat_every.setter
    def repeat_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_every", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
         List of weekdays when the backup will be applied. Used in `"WEEKLY"` type.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "weekdays", value)


if not MYPY:
    class BackupPolicyVmSnapshotReattemptsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
         Enable flag
        """
        interval: NotRequired[pulumi.Input[str]]
        """
        Retry interval. See `interval_type` for available values
        """
        max_attempts: NotRequired[pulumi.Input[int]]
        """
        Maximum number of attempts before throwing an error
        """
elif False:
    BackupPolicyVmSnapshotReattemptsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyVmSnapshotReattemptsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 max_attempts: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled:  Enable flag
        :param pulumi.Input[str] interval: Retry interval. See `interval_type` for available values
        :param pulumi.Input[int] max_attempts: Maximum number of attempts before throwing an error
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
         Enable flag
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Retry interval. See `interval_type` for available values
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of attempts before throwing an error
        """
        return pulumi.get(self, "max_attempts")

    @max_attempts.setter
    def max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_attempts", value)


if not MYPY:
    class CdnOriginGroupOriginArgsDict(TypedDict):
        source: pulumi.Input[str]
        backup: NotRequired[pulumi.Input[bool]]
        enabled: NotRequired[pulumi.Input[bool]]
        origin_group_id: NotRequired[pulumi.Input[int]]
elif False:
    CdnOriginGroupOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CdnOriginGroupOriginArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 backup: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 origin_group_id: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if origin_group_id is not None:
            pulumi.set(__self__, "origin_group_id", origin_group_id)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="originGroupId")
    def origin_group_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "origin_group_id")

    @origin_group_id.setter
    def origin_group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "origin_group_id", value)


if not MYPY:
    class CdnResourceOptionsArgsDict(TypedDict):
        allowed_http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        browser_cache_settings: NotRequired[pulumi.Input[int]]
        """
        set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        cache_http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list HTTP headers that must be included in responses to clients.
        """
        cors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        custom_host_header: NotRequired[pulumi.Input[str]]
        """
        custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        custom_server_name: NotRequired[pulumi.Input[str]]
        """
        wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        """
        disable_cache: NotRequired[pulumi.Input[bool]]
        """
        setup a cache status.
        """
        disable_proxy_force_ranges: NotRequired[pulumi.Input[bool]]
        """
        disabling proxy force ranges.
        """
        edge_cache_settings: NotRequired[pulumi.Input[int]]
        """
        content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        enable_ip_url_signing: NotRequired[pulumi.Input[bool]]
        """
        enable access limiting by IP addresses, option available only with setting secure_key.

        * `ip_address_acl.excepted_values` - the list of specified IP addresses to be allowed or denied depending on acl policy type.

        * `ip_address_acl.policy_type` - the policy type for ip_address_acl option, one of "allow" or "deny" values.
        """
        fetched_compressed: NotRequired[pulumi.Input[bool]]
        """
        option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        forward_host_header: NotRequired[pulumi.Input[bool]]
        """
        choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        gzip_on: NotRequired[pulumi.Input[bool]]
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        ignore_cookie: NotRequired[pulumi.Input[bool]]
        """
        set for ignoring cookie.
        """
        ignore_query_params: NotRequired[pulumi.Input[bool]]
        """
        files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        ip_address_acl: NotRequired[pulumi.Input['CdnResourceOptionsIpAddressAclArgsDict']]
        proxy_cache_methods_set: NotRequired[pulumi.Input[bool]]
        """
        allows caching for GET, HEAD and POST requests.
        """
        query_params_blacklists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        query_params_whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        redirect_http_to_https: NotRequired[pulumi.Input[bool]]
        """
        set up a redirect from HTTP to HTTPS.
        """
        redirect_https_to_http: NotRequired[pulumi.Input[bool]]
        """
        set up a redirect from HTTPS to HTTP.
        """
        secure_key: NotRequired[pulumi.Input[str]]
        """
        set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        """
        slice: NotRequired[pulumi.Input[bool]]
        """
        files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        static_request_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        set up custom headers that CDN servers will send in requests to origins.
        """
        static_response_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        set up custom headers that CDN servers will send in response to clients.
        """
elif False:
    CdnResourceOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CdnResourceOptionsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 browser_cache_settings: Optional[pulumi.Input[int]] = None,
                 cache_http_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_host_header: Optional[pulumi.Input[str]] = None,
                 custom_server_name: Optional[pulumi.Input[str]] = None,
                 disable_cache: Optional[pulumi.Input[bool]] = None,
                 disable_proxy_force_ranges: Optional[pulumi.Input[bool]] = None,
                 edge_cache_settings: Optional[pulumi.Input[int]] = None,
                 enable_ip_url_signing: Optional[pulumi.Input[bool]] = None,
                 fetched_compressed: Optional[pulumi.Input[bool]] = None,
                 forward_host_header: Optional[pulumi.Input[bool]] = None,
                 gzip_on: Optional[pulumi.Input[bool]] = None,
                 ignore_cookie: Optional[pulumi.Input[bool]] = None,
                 ignore_query_params: Optional[pulumi.Input[bool]] = None,
                 ip_address_acl: Optional[pulumi.Input['CdnResourceOptionsIpAddressAclArgs']] = None,
                 proxy_cache_methods_set: Optional[pulumi.Input[bool]] = None,
                 query_params_blacklists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query_params_whitelists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redirect_http_to_https: Optional[pulumi.Input[bool]] = None,
                 redirect_https_to_http: Optional[pulumi.Input[bool]] = None,
                 secure_key: Optional[pulumi.Input[str]] = None,
                 slice: Optional[pulumi.Input[bool]] = None,
                 static_request_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 static_response_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_http_methods: HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        :param pulumi.Input[int] browser_cache_settings: set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cache_http_headers: list HTTP headers that must be included in responses to clients.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cors: parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        :param pulumi.Input[str] custom_host_header: custom value for the Host header. Your server must be able to process requests with the chosen header.
        :param pulumi.Input[str] custom_server_name: wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        :param pulumi.Input[bool] disable_cache: setup a cache status.
        :param pulumi.Input[bool] disable_proxy_force_ranges: disabling proxy force ranges.
        :param pulumi.Input[int] edge_cache_settings: content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        :param pulumi.Input[bool] enable_ip_url_signing: enable access limiting by IP addresses, option available only with setting secure_key.
               
               * `ip_address_acl.excepted_values` - the list of specified IP addresses to be allowed or denied depending on acl policy type.
               
               * `ip_address_acl.policy_type` - the policy type for ip_address_acl option, one of "allow" or "deny" values.
        :param pulumi.Input[bool] fetched_compressed: option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        :param pulumi.Input[bool] forward_host_header: choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        :param pulumi.Input[bool] gzip_on: GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        :param pulumi.Input[bool] ignore_cookie: set for ignoring cookie.
        :param pulumi.Input[bool] ignore_query_params: files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        :param pulumi.Input[bool] proxy_cache_methods_set: allows caching for GET, HEAD and POST requests.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_params_blacklists: files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_params_whitelists: files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        :param pulumi.Input[bool] redirect_http_to_https: set up a redirect from HTTP to HTTPS.
        :param pulumi.Input[bool] redirect_https_to_http: set up a redirect from HTTPS to HTTP.
        :param pulumi.Input[str] secure_key: set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        :param pulumi.Input[bool] slice: files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] static_request_headers: set up custom headers that CDN servers will send in requests to origins.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] static_response_headers: set up custom headers that CDN servers will send in response to clients.
        """
        if allowed_http_methods is not None:
            pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        if browser_cache_settings is not None:
            pulumi.set(__self__, "browser_cache_settings", browser_cache_settings)
        if cache_http_headers is not None:
            pulumi.set(__self__, "cache_http_headers", cache_http_headers)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if custom_host_header is not None:
            pulumi.set(__self__, "custom_host_header", custom_host_header)
        if custom_server_name is not None:
            pulumi.set(__self__, "custom_server_name", custom_server_name)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_proxy_force_ranges is not None:
            pulumi.set(__self__, "disable_proxy_force_ranges", disable_proxy_force_ranges)
        if edge_cache_settings is not None:
            pulumi.set(__self__, "edge_cache_settings", edge_cache_settings)
        if enable_ip_url_signing is not None:
            pulumi.set(__self__, "enable_ip_url_signing", enable_ip_url_signing)
        if fetched_compressed is not None:
            pulumi.set(__self__, "fetched_compressed", fetched_compressed)
        if forward_host_header is not None:
            pulumi.set(__self__, "forward_host_header", forward_host_header)
        if gzip_on is not None:
            pulumi.set(__self__, "gzip_on", gzip_on)
        if ignore_cookie is not None:
            pulumi.set(__self__, "ignore_cookie", ignore_cookie)
        if ignore_query_params is not None:
            pulumi.set(__self__, "ignore_query_params", ignore_query_params)
        if ip_address_acl is not None:
            pulumi.set(__self__, "ip_address_acl", ip_address_acl)
        if proxy_cache_methods_set is not None:
            pulumi.set(__self__, "proxy_cache_methods_set", proxy_cache_methods_set)
        if query_params_blacklists is not None:
            pulumi.set(__self__, "query_params_blacklists", query_params_blacklists)
        if query_params_whitelists is not None:
            pulumi.set(__self__, "query_params_whitelists", query_params_whitelists)
        if redirect_http_to_https is not None:
            pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        if redirect_https_to_http is not None:
            pulumi.set(__self__, "redirect_https_to_http", redirect_https_to_http)
        if secure_key is not None:
            pulumi.set(__self__, "secure_key", secure_key)
        if slice is not None:
            pulumi.set(__self__, "slice", slice)
        if static_request_headers is not None:
            pulumi.set(__self__, "static_request_headers", static_request_headers)
        if static_response_headers is not None:
            pulumi.set(__self__, "static_response_headers", static_response_headers)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_http_methods", value)

    @property
    @pulumi.getter(name="browserCacheSettings")
    def browser_cache_settings(self) -> Optional[pulumi.Input[int]]:
        """
        set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        return pulumi.get(self, "browser_cache_settings")

    @browser_cache_settings.setter
    def browser_cache_settings(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "browser_cache_settings", value)

    @property
    @pulumi.getter(name="cacheHttpHeaders")
    def cache_http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list HTTP headers that must be included in responses to clients.
        """
        return pulumi.get(self, "cache_http_headers")

    @cache_http_headers.setter
    def cache_http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cache_http_headers", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="customHostHeader")
    def custom_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        return pulumi.get(self, "custom_host_header")

    @custom_host_header.setter
    def custom_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_host_header", value)

    @property
    @pulumi.getter(name="customServerName")
    def custom_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        """
        return pulumi.get(self, "custom_server_name")

    @custom_server_name.setter
    def custom_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_server_name", value)

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[pulumi.Input[bool]]:
        """
        setup a cache status.
        """
        return pulumi.get(self, "disable_cache")

    @disable_cache.setter
    def disable_cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_cache", value)

    @property
    @pulumi.getter(name="disableProxyForceRanges")
    def disable_proxy_force_ranges(self) -> Optional[pulumi.Input[bool]]:
        """
        disabling proxy force ranges.
        """
        return pulumi.get(self, "disable_proxy_force_ranges")

    @disable_proxy_force_ranges.setter
    def disable_proxy_force_ranges(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_proxy_force_ranges", value)

    @property
    @pulumi.getter(name="edgeCacheSettings")
    def edge_cache_settings(self) -> Optional[pulumi.Input[int]]:
        """
        content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        return pulumi.get(self, "edge_cache_settings")

    @edge_cache_settings.setter
    def edge_cache_settings(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "edge_cache_settings", value)

    @property
    @pulumi.getter(name="enableIpUrlSigning")
    def enable_ip_url_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        enable access limiting by IP addresses, option available only with setting secure_key.

        * `ip_address_acl.excepted_values` - the list of specified IP addresses to be allowed or denied depending on acl policy type.

        * `ip_address_acl.policy_type` - the policy type for ip_address_acl option, one of "allow" or "deny" values.
        """
        return pulumi.get(self, "enable_ip_url_signing")

    @enable_ip_url_signing.setter
    def enable_ip_url_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_url_signing", value)

    @property
    @pulumi.getter(name="fetchedCompressed")
    def fetched_compressed(self) -> Optional[pulumi.Input[bool]]:
        """
        option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        return pulumi.get(self, "fetched_compressed")

    @fetched_compressed.setter
    def fetched_compressed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetched_compressed", value)

    @property
    @pulumi.getter(name="forwardHostHeader")
    def forward_host_header(self) -> Optional[pulumi.Input[bool]]:
        """
        choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        return pulumi.get(self, "forward_host_header")

    @forward_host_header.setter
    def forward_host_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "forward_host_header", value)

    @property
    @pulumi.getter(name="gzipOn")
    def gzip_on(self) -> Optional[pulumi.Input[bool]]:
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        return pulumi.get(self, "gzip_on")

    @gzip_on.setter
    def gzip_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gzip_on", value)

    @property
    @pulumi.getter(name="ignoreCookie")
    def ignore_cookie(self) -> Optional[pulumi.Input[bool]]:
        """
        set for ignoring cookie.
        """
        return pulumi.get(self, "ignore_cookie")

    @ignore_cookie.setter
    def ignore_cookie(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_cookie", value)

    @property
    @pulumi.getter(name="ignoreQueryParams")
    def ignore_query_params(self) -> Optional[pulumi.Input[bool]]:
        """
        files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        return pulumi.get(self, "ignore_query_params")

    @ignore_query_params.setter
    def ignore_query_params(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_query_params", value)

    @property
    @pulumi.getter(name="ipAddressAcl")
    def ip_address_acl(self) -> Optional[pulumi.Input['CdnResourceOptionsIpAddressAclArgs']]:
        return pulumi.get(self, "ip_address_acl")

    @ip_address_acl.setter
    def ip_address_acl(self, value: Optional[pulumi.Input['CdnResourceOptionsIpAddressAclArgs']]):
        pulumi.set(self, "ip_address_acl", value)

    @property
    @pulumi.getter(name="proxyCacheMethodsSet")
    def proxy_cache_methods_set(self) -> Optional[pulumi.Input[bool]]:
        """
        allows caching for GET, HEAD and POST requests.
        """
        return pulumi.get(self, "proxy_cache_methods_set")

    @proxy_cache_methods_set.setter
    def proxy_cache_methods_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "proxy_cache_methods_set", value)

    @property
    @pulumi.getter(name="queryParamsBlacklists")
    def query_params_blacklists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        return pulumi.get(self, "query_params_blacklists")

    @query_params_blacklists.setter
    def query_params_blacklists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "query_params_blacklists", value)

    @property
    @pulumi.getter(name="queryParamsWhitelists")
    def query_params_whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        return pulumi.get(self, "query_params_whitelists")

    @query_params_whitelists.setter
    def query_params_whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "query_params_whitelists", value)

    @property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> Optional[pulumi.Input[bool]]:
        """
        set up a redirect from HTTP to HTTPS.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @redirect_http_to_https.setter
    def redirect_http_to_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redirect_http_to_https", value)

    @property
    @pulumi.getter(name="redirectHttpsToHttp")
    def redirect_https_to_http(self) -> Optional[pulumi.Input[bool]]:
        """
        set up a redirect from HTTPS to HTTP.
        """
        return pulumi.get(self, "redirect_https_to_http")

    @redirect_https_to_http.setter
    def redirect_https_to_http(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redirect_https_to_http", value)

    @property
    @pulumi.getter(name="secureKey")
    def secure_key(self) -> Optional[pulumi.Input[str]]:
        """
        set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        """
        return pulumi.get(self, "secure_key")

    @secure_key.setter
    def secure_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_key", value)

    @property
    @pulumi.getter
    def slice(self) -> Optional[pulumi.Input[bool]]:
        """
        files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        return pulumi.get(self, "slice")

    @slice.setter
    def slice(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "slice", value)

    @property
    @pulumi.getter(name="staticRequestHeaders")
    def static_request_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        set up custom headers that CDN servers will send in requests to origins.
        """
        return pulumi.get(self, "static_request_headers")

    @static_request_headers.setter
    def static_request_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "static_request_headers", value)

    @property
    @pulumi.getter(name="staticResponseHeaders")
    def static_response_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        set up custom headers that CDN servers will send in response to clients.
        """
        return pulumi.get(self, "static_response_headers")

    @static_response_headers.setter
    def static_response_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "static_response_headers", value)


if not MYPY:
    class CdnResourceOptionsIpAddressAclArgsDict(TypedDict):
        excepted_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        policy_type: NotRequired[pulumi.Input[str]]
elif False:
    CdnResourceOptionsIpAddressAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CdnResourceOptionsIpAddressAclArgs:
    def __init__(__self__, *,
                 excepted_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 policy_type: Optional[pulumi.Input[str]] = None):
        if excepted_values is not None:
            pulumi.set(__self__, "excepted_values", excepted_values)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="exceptedValues")
    def excepted_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excepted_values")

    @excepted_values.setter
    def excepted_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excepted_values", value)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_type", value)


if not MYPY:
    class CdnResourceSslCertificateArgsDict(TypedDict):
        type: pulumi.Input[str]
        certificate_manager_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    CdnResourceSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CdnResourceSslCertificateArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 certificate_manager_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "type", type)
        if certificate_manager_id is not None:
            pulumi.set(__self__, "certificate_manager_id", certificate_manager_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="certificateManagerId")
    def certificate_manager_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_manager_id")

    @certificate_manager_id.setter
    def certificate_manager_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_manager_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class CmCertificateChallengeArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        """
        Time the challenge was created.
        """
        dns_name: NotRequired[pulumi.Input[str]]
        """
        DNS record name (only for DNS challenge).
        """
        dns_type: NotRequired[pulumi.Input[str]]
        """
        DNS record type: `"TXT"` or `"CNAME"` (only for DNS challenge).
        """
        dns_value: NotRequired[pulumi.Input[str]]
        """
        DNS record value (only for DNS challenge).
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Validated domain.
        """
        http_content: NotRequired[pulumi.Input[str]]
        """
        The content that should be made accessible with the given `http_url` (only for HTTP challenge).
        """
        http_url: NotRequired[pulumi.Input[str]]
        """
        URL where the challenge content http_content should be placed (only for HTTP challenge).
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Current status message.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Challenge type `"DNS"` or `"HTTP"`.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        Last time the challenge was updated.
        """
elif False:
    CmCertificateChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmCertificateChallengeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 dns_name: Optional[pulumi.Input[str]] = None,
                 dns_type: Optional[pulumi.Input[str]] = None,
                 dns_value: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 http_content: Optional[pulumi.Input[str]] = None,
                 http_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: Time the challenge was created.
        :param pulumi.Input[str] dns_name: DNS record name (only for DNS challenge).
        :param pulumi.Input[str] dns_type: DNS record type: `"TXT"` or `"CNAME"` (only for DNS challenge).
        :param pulumi.Input[str] dns_value: DNS record value (only for DNS challenge).
        :param pulumi.Input[str] domain: Validated domain.
        :param pulumi.Input[str] http_content: The content that should be made accessible with the given `http_url` (only for HTTP challenge).
        :param pulumi.Input[str] http_url: URL where the challenge content http_content should be placed (only for HTTP challenge).
        :param pulumi.Input[str] message: Current status message.
        :param pulumi.Input[str] type: Challenge type `"DNS"` or `"HTTP"`.
        :param pulumi.Input[str] updated_at: Last time the challenge was updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if dns_type is not None:
            pulumi.set(__self__, "dns_type", dns_type)
        if dns_value is not None:
            pulumi.set(__self__, "dns_value", dns_value)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if http_content is not None:
            pulumi.set(__self__, "http_content", http_content)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        Time the challenge was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record name (only for DNS challenge).
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter(name="dnsType")
    def dns_type(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record type: `"TXT"` or `"CNAME"` (only for DNS challenge).
        """
        return pulumi.get(self, "dns_type")

    @dns_type.setter
    def dns_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_type", value)

    @property
    @pulumi.getter(name="dnsValue")
    def dns_value(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record value (only for DNS challenge).
        """
        return pulumi.get(self, "dns_value")

    @dns_value.setter
    def dns_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_value", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Validated domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="httpContent")
    def http_content(self) -> Optional[pulumi.Input[str]]:
        """
        The content that should be made accessible with the given `http_url` (only for HTTP challenge).
        """
        return pulumi.get(self, "http_content")

    @http_content.setter
    def http_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_content", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL where the challenge content http_content should be placed (only for HTTP challenge).
        """
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Current status message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Challenge type `"DNS"` or `"HTTP"`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the challenge was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class CmCertificateManagedArgsDict(TypedDict):
        challenge_type: pulumi.Input[str]
        """
        Domain owner-check method. Possible values:
        - "DNS_CNAME" - you will need to create a CNAME dns record with the specified value. Recommended for fully automated certificate renewal;
        - "DNS_TXT" - you will need to create a TXT dns record with specified value;
        - "HTTP" - you will need to place specified value into specified url.
        """
        challenge_count: NotRequired[pulumi.Input[int]]
        """
        . Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.

        > Resource creation awaits getting challenges from issue provider.
        """
elif False:
    CmCertificateManagedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmCertificateManagedArgs:
    def __init__(__self__, *,
                 challenge_type: pulumi.Input[str],
                 challenge_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] challenge_type: Domain owner-check method. Possible values:
               - "DNS_CNAME" - you will need to create a CNAME dns record with the specified value. Recommended for fully automated certificate renewal;
               - "DNS_TXT" - you will need to create a TXT dns record with specified value;
               - "HTTP" - you will need to place specified value into specified url.
        :param pulumi.Input[int] challenge_count: . Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.
               
               > Resource creation awaits getting challenges from issue provider.
        """
        pulumi.set(__self__, "challenge_type", challenge_type)
        if challenge_count is not None:
            pulumi.set(__self__, "challenge_count", challenge_count)

    @property
    @pulumi.getter(name="challengeType")
    def challenge_type(self) -> pulumi.Input[str]:
        """
        Domain owner-check method. Possible values:
        - "DNS_CNAME" - you will need to create a CNAME dns record with the specified value. Recommended for fully automated certificate renewal;
        - "DNS_TXT" - you will need to create a TXT dns record with specified value;
        - "HTTP" - you will need to place specified value into specified url.
        """
        return pulumi.get(self, "challenge_type")

    @challenge_type.setter
    def challenge_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "challenge_type", value)

    @property
    @pulumi.getter(name="challengeCount")
    def challenge_count(self) -> Optional[pulumi.Input[int]]:
        """
        . Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.

        > Resource creation awaits getting challenges from issue provider.
        """
        return pulumi.get(self, "challenge_count")

    @challenge_count.setter
    def challenge_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "challenge_count", value)


if not MYPY:
    class CmCertificateSelfManagedArgsDict(TypedDict):
        certificate: pulumi.Input[str]
        """
        Certificate with chain.
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        Private key of certificate.
        """
        private_key_lockbox_secret: NotRequired[pulumi.Input['CmCertificateSelfManagedPrivateKeyLockboxSecretArgsDict']]
        """
        Lockbox secret specification for getting private key. Structure is documented below.

        > Only one type `private_key` or `private_key_lockbox_secret` should be specified.
        """
elif False:
    CmCertificateSelfManagedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmCertificateSelfManagedArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_lockbox_secret: Optional[pulumi.Input['CmCertificateSelfManagedPrivateKeyLockboxSecretArgs']] = None):
        """
        :param pulumi.Input[str] certificate: Certificate with chain.
        :param pulumi.Input[str] private_key: Private key of certificate.
        :param pulumi.Input['CmCertificateSelfManagedPrivateKeyLockboxSecretArgs'] private_key_lockbox_secret: Lockbox secret specification for getting private key. Structure is documented below.
               
               > Only one type `private_key` or `private_key_lockbox_secret` should be specified.
        """
        pulumi.set(__self__, "certificate", certificate)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_lockbox_secret is not None:
            pulumi.set(__self__, "private_key_lockbox_secret", private_key_lockbox_secret)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        Certificate with chain.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private key of certificate.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyLockboxSecret")
    def private_key_lockbox_secret(self) -> Optional[pulumi.Input['CmCertificateSelfManagedPrivateKeyLockboxSecretArgs']]:
        """
        Lockbox secret specification for getting private key. Structure is documented below.

        > Only one type `private_key` or `private_key_lockbox_secret` should be specified.
        """
        return pulumi.get(self, "private_key_lockbox_secret")

    @private_key_lockbox_secret.setter
    def private_key_lockbox_secret(self, value: Optional[pulumi.Input['CmCertificateSelfManagedPrivateKeyLockboxSecretArgs']]):
        pulumi.set(self, "private_key_lockbox_secret", value)


if not MYPY:
    class CmCertificateSelfManagedPrivateKeyLockboxSecretArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Lockbox secret Id.
        """
        key: pulumi.Input[str]
        """
        Key of the Lockbox secret, the value of which contains the private key of the certificate.
        """
elif False:
    CmCertificateSelfManagedPrivateKeyLockboxSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmCertificateSelfManagedPrivateKeyLockboxSecretArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Lockbox secret Id.
        :param pulumi.Input[str] key: Key of the Lockbox secret, the value of which contains the private key of the certificate.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Lockbox secret Id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key of the Lockbox secret, the value of which contains the private key of the certificate.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ComputeDiskDiskPlacementPolicyArgsDict(TypedDict):
        disk_placement_group_id: pulumi.Input[str]
        """
        Specifies Disk Placement Group id.
        """
elif False:
    ComputeDiskDiskPlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeDiskDiskPlacementPolicyArgs:
    def __init__(__self__, *,
                 disk_placement_group_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] disk_placement_group_id: Specifies Disk Placement Group id.
        """
        pulumi.set(__self__, "disk_placement_group_id", disk_placement_group_id)

    @property
    @pulumi.getter(name="diskPlacementGroupId")
    def disk_placement_group_id(self) -> pulumi.Input[str]:
        """
        Specifies Disk Placement Group id.
        """
        return pulumi.get(self, "disk_placement_group_id")

    @disk_placement_group_id.setter
    def disk_placement_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_placement_group_id", value)


if not MYPY:
    class ComputeDiskHardwareGenerationArgsDict(TypedDict):
        generation2_features: NotRequired[pulumi.Input['ComputeDiskHardwareGenerationGeneration2FeaturesArgsDict']]
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.

        > Only one of `image_id` or `snapshot_id` can be specified.
        """
        legacy_features: NotRequired[pulumi.Input['ComputeDiskHardwareGenerationLegacyFeaturesArgsDict']]
        """
        Defines the first known hardware generation and its features, which are:
        """
elif False:
    ComputeDiskHardwareGenerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeDiskHardwareGenerationArgs:
    def __init__(__self__, *,
                 generation2_features: Optional[pulumi.Input['ComputeDiskHardwareGenerationGeneration2FeaturesArgs']] = None,
                 legacy_features: Optional[pulumi.Input['ComputeDiskHardwareGenerationLegacyFeaturesArgs']] = None):
        """
        :param pulumi.Input['ComputeDiskHardwareGenerationGeneration2FeaturesArgs'] generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
               
               > Only one of `image_id` or `snapshot_id` can be specified.
        :param pulumi.Input['ComputeDiskHardwareGenerationLegacyFeaturesArgs'] legacy_features: Defines the first known hardware generation and its features, which are:
        """
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional[pulumi.Input['ComputeDiskHardwareGenerationGeneration2FeaturesArgs']]:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.

        > Only one of `image_id` or `snapshot_id` can be specified.
        """
        return pulumi.get(self, "generation2_features")

    @generation2_features.setter
    def generation2_features(self, value: Optional[pulumi.Input['ComputeDiskHardwareGenerationGeneration2FeaturesArgs']]):
        pulumi.set(self, "generation2_features", value)

    @property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional[pulumi.Input['ComputeDiskHardwareGenerationLegacyFeaturesArgs']]:
        """
        Defines the first known hardware generation and its features, which are:
        """
        return pulumi.get(self, "legacy_features")

    @legacy_features.setter
    def legacy_features(self, value: Optional[pulumi.Input['ComputeDiskHardwareGenerationLegacyFeaturesArgs']]):
        pulumi.set(self, "legacy_features", value)


if not MYPY:
    class ComputeDiskHardwareGenerationGeneration2FeaturesArgsDict(TypedDict):
        pass
elif False:
    ComputeDiskHardwareGenerationGeneration2FeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeDiskHardwareGenerationGeneration2FeaturesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeDiskHardwareGenerationLegacyFeaturesArgsDict(TypedDict):
        pci_topology: NotRequired[pulumi.Input[str]]
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
elif False:
    ComputeDiskHardwareGenerationLegacyFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeDiskHardwareGenerationLegacyFeaturesArgs:
    def __init__(__self__, *,
                 pci_topology: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[pulumi.Input[str]]:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")

    @pci_topology.setter
    def pci_topology(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pci_topology", value)


if not MYPY:
    class ComputeImageHardwareGenerationArgsDict(TypedDict):
        generation2_features: NotRequired[pulumi.Input['ComputeImageHardwareGenerationGeneration2FeaturesArgsDict']]
        legacy_features: NotRequired[pulumi.Input['ComputeImageHardwareGenerationLegacyFeaturesArgsDict']]
elif False:
    ComputeImageHardwareGenerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeImageHardwareGenerationArgs:
    def __init__(__self__, *,
                 generation2_features: Optional[pulumi.Input['ComputeImageHardwareGenerationGeneration2FeaturesArgs']] = None,
                 legacy_features: Optional[pulumi.Input['ComputeImageHardwareGenerationLegacyFeaturesArgs']] = None):
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional[pulumi.Input['ComputeImageHardwareGenerationGeneration2FeaturesArgs']]:
        return pulumi.get(self, "generation2_features")

    @generation2_features.setter
    def generation2_features(self, value: Optional[pulumi.Input['ComputeImageHardwareGenerationGeneration2FeaturesArgs']]):
        pulumi.set(self, "generation2_features", value)

    @property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional[pulumi.Input['ComputeImageHardwareGenerationLegacyFeaturesArgs']]:
        return pulumi.get(self, "legacy_features")

    @legacy_features.setter
    def legacy_features(self, value: Optional[pulumi.Input['ComputeImageHardwareGenerationLegacyFeaturesArgs']]):
        pulumi.set(self, "legacy_features", value)


if not MYPY:
    class ComputeImageHardwareGenerationGeneration2FeaturesArgsDict(TypedDict):
        pass
elif False:
    ComputeImageHardwareGenerationGeneration2FeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeImageHardwareGenerationGeneration2FeaturesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeImageHardwareGenerationLegacyFeaturesArgsDict(TypedDict):
        pci_topology: NotRequired[pulumi.Input[str]]
elif False:
    ComputeImageHardwareGenerationLegacyFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeImageHardwareGenerationLegacyFeaturesArgs:
    def __init__(__self__, *,
                 pci_topology: Optional[pulumi.Input[str]] = None):
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pci_topology")

    @pci_topology.setter
    def pci_topology(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pci_topology", value)


if not MYPY:
    class ComputeInstanceBootDiskArgsDict(TypedDict):
        auto_delete: NotRequired[pulumi.Input[bool]]
        """
        Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        Name that can be used to access an attached disk.
        """
        disk_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        """
        initialize_params: NotRequired[pulumi.Input['ComputeInstanceBootDiskInitializeParamsArgsDict']]
        """
        Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. The structure is documented below.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
elif False:
    ComputeInstanceBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceBootDiskArgs:
    def __init__(__self__, *,
                 auto_delete: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 disk_id: Optional[pulumi.Input[str]] = None,
                 initialize_params: Optional[pulumi.Input['ComputeInstanceBootDiskInitializeParamsArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] auto_delete: Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        :param pulumi.Input[str] device_name: Name that can be used to access an attached disk.
        :param pulumi.Input[str] disk_id: The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        :param pulumi.Input['ComputeInstanceBootDiskInitializeParamsArgs'] initialize_params: Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. The structure is documented below.
        :param pulumi.Input[str] mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        """
        return pulumi.get(self, "auto_delete")

    @auto_delete.setter
    def auto_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_delete", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name that can be used to access an attached disk.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_id", value)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[pulumi.Input['ComputeInstanceBootDiskInitializeParamsArgs']]:
        """
        Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: Optional[pulumi.Input['ComputeInstanceBootDiskInitializeParamsArgs']]):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ComputeInstanceBootDiskInitializeParamsArgsDict(TypedDict):
        block_size: NotRequired[pulumi.Input[int]]
        """
        Block size of the disk, specified in bytes.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the boot disk.
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        A disk image to initialize this disk from.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        ID of KMS symmetric key used to encrypt disk.

        > Either `initialize_params` or `disk_id` must be specified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the boot disk.
        """
        size: NotRequired[pulumi.Input[int]]
        """
        Size of the disk in GB.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        A snapshot to initialize this disk from.

        > Either `image_id` or `snapshot_id` must be specified.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Disk type.
        """
elif False:
    ComputeInstanceBootDiskInitializeParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceBootDiskInitializeParamsArgs:
    def __init__(__self__, *,
                 block_size: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] block_size: Block size of the disk, specified in bytes.
        :param pulumi.Input[str] description: Description of the boot disk.
        :param pulumi.Input[str] image_id: A disk image to initialize this disk from.
        :param pulumi.Input[str] kms_key_id: ID of KMS symmetric key used to encrypt disk.
               
               > Either `initialize_params` or `disk_id` must be specified.
        :param pulumi.Input[str] name: Name of the boot disk.
        :param pulumi.Input[int] size: Size of the disk in GB.
        :param pulumi.Input[str] snapshot_id: A snapshot to initialize this disk from.
               
               > Either `image_id` or `snapshot_id` must be specified.
        :param pulumi.Input[str] type: Disk type.
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[pulumi.Input[int]]:
        """
        Block size of the disk, specified in bytes.
        """
        return pulumi.get(self, "block_size")

    @block_size.setter
    def block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the boot disk.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        A disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of KMS symmetric key used to encrypt disk.

        > Either `initialize_params` or `disk_id` must be specified.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the boot disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        A snapshot to initialize this disk from.

        > Either `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComputeInstanceFilesystemArgsDict(TypedDict):
        filesystem_id: pulumi.Input[str]
        """
        ID of the filesystem that should be attached.
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        Name of the device representing the filesystem on the instance.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
elif False:
    ComputeInstanceFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceFilesystemArgs:
    def __init__(__self__, *,
                 filesystem_id: pulumi.Input[str],
                 device_name: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] filesystem_id: ID of the filesystem that should be attached.
        :param pulumi.Input[str] device_name: Name of the device representing the filesystem on the instance.
        :param pulumi.Input[str] mode: Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> pulumi.Input[str]:
        """
        ID of the filesystem that should be attached.
        """
        return pulumi.get(self, "filesystem_id")

    @filesystem_id.setter
    def filesystem_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "filesystem_id", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the device representing the filesystem on the instance.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ComputeInstanceGroupAllocationPolicyArgsDict(TypedDict):
        zones: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of availability zones.
        """
        instance_tags_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgsDict']]]]
        """
        Array of availability zone IDs with list of instance tags.
        """
elif False:
    ComputeInstanceGroupAllocationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupAllocationPolicyArgs:
    def __init__(__self__, *,
                 zones: pulumi.Input[Sequence[pulumi.Input[str]]],
                 instance_tags_pools: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: A list of availability zones.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs']]] instance_tags_pools: Array of availability zone IDs with list of instance tags.
        """
        pulumi.set(__self__, "zones", zones)
        if instance_tags_pools is not None:
            pulumi.set(__self__, "instance_tags_pools", instance_tags_pools)

    @property
    @pulumi.getter
    def zones(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of availability zones.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "zones", value)

    @property
    @pulumi.getter(name="instanceTagsPools")
    def instance_tags_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs']]]]:
        """
        Array of availability zone IDs with list of instance tags.
        """
        return pulumi.get(self, "instance_tags_pools")

    @instance_tags_pools.setter
    def instance_tags_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs']]]]):
        pulumi.set(self, "instance_tags_pools", value)


if not MYPY:
    class ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgsDict(TypedDict):
        tags: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of tags for instances in zone.
        """
        zone: pulumi.Input[str]
        """
        Availability zone.
        """
elif False:
    ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs:
    def __init__(__self__, *,
                 tags: pulumi.Input[Sequence[pulumi.Input[str]]],
                 zone: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: List of tags for instances in zone.
        :param pulumi.Input[str] zone: Availability zone.
        """
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of tags for instances in zone.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        Availability zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ComputeInstanceGroupApplicationLoadBalancerArgsDict(TypedDict):
        ignore_health_checks: NotRequired[pulumi.Input[bool]]
        """
        Do not wait load balancer health checks.
        """
        max_opening_traffic_duration: NotRequired[pulumi.Input[int]]
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        status_message: NotRequired[pulumi.Input[str]]
        """
        The status message of the instance.
        """
        target_group_description: NotRequired[pulumi.Input[str]]
        """
        A description of the target group.
        """
        target_group_id: NotRequired[pulumi.Input[str]]
        target_group_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value label pairs.
        """
        target_group_name: NotRequired[pulumi.Input[str]]
        """
        The name of the target group.
        """
elif False:
    ComputeInstanceGroupApplicationLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupApplicationLoadBalancerArgs:
    def __init__(__self__, *,
                 ignore_health_checks: Optional[pulumi.Input[bool]] = None,
                 max_opening_traffic_duration: Optional[pulumi.Input[int]] = None,
                 status_message: Optional[pulumi.Input[str]] = None,
                 target_group_description: Optional[pulumi.Input[str]] = None,
                 target_group_id: Optional[pulumi.Input[str]] = None,
                 target_group_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 target_group_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] ignore_health_checks: Do not wait load balancer health checks.
        :param pulumi.Input[int] max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param pulumi.Input[str] status_message: The status message of the instance.
        :param pulumi.Input[str] target_group_description: A description of the target group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] target_group_labels: A set of key/value label pairs.
        :param pulumi.Input[str] target_group_name: The name of the target group.
        """
        if ignore_health_checks is not None:
            pulumi.set(__self__, "ignore_health_checks", ignore_health_checks)
        if max_opening_traffic_duration is not None:
            pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if target_group_description is not None:
            pulumi.set(__self__, "target_group_description", target_group_description)
        if target_group_id is not None:
            pulumi.set(__self__, "target_group_id", target_group_id)
        if target_group_labels is not None:
            pulumi.set(__self__, "target_group_labels", target_group_labels)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)

    @property
    @pulumi.getter(name="ignoreHealthChecks")
    def ignore_health_checks(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not wait load balancer health checks.
        """
        return pulumi.get(self, "ignore_health_checks")

    @ignore_health_checks.setter
    def ignore_health_checks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_health_checks", value)

    @property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @max_opening_traffic_duration.setter
    def max_opening_traffic_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_opening_traffic_duration", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[str]]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_message", value)

    @property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @target_group_description.setter
    def target_group_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_description", value)

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_group_id")

    @target_group_id.setter
    def target_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_id", value)

    @property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @target_group_labels.setter
    def target_group_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "target_group_labels", value)

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")

    @target_group_name.setter
    def target_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_name", value)


if not MYPY:
    class ComputeInstanceGroupDeployPolicyArgsDict(TypedDict):
        max_expansion: pulumi.Input[int]
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        """
        max_unavailable: pulumi.Input[int]
        """
        The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        """
        max_creating: NotRequired[pulumi.Input[int]]
        """
        The maximum number of instances that can be created at the same time.
        """
        max_deleting: NotRequired[pulumi.Input[int]]
        """
        The maximum number of instances that can be deleted at the same time.
        """
        startup_duration: NotRequired[pulumi.Input[int]]
        """
        The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
elif False:
    ComputeInstanceGroupDeployPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupDeployPolicyArgs:
    def __init__(__self__, *,
                 max_expansion: pulumi.Input[int],
                 max_unavailable: pulumi.Input[int],
                 max_creating: Optional[pulumi.Input[int]] = None,
                 max_deleting: Optional[pulumi.Input[int]] = None,
                 startup_duration: Optional[pulumi.Input[int]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        :param pulumi.Input[int] max_unavailable: The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        :param pulumi.Input[int] max_creating: The maximum number of instances that can be created at the same time.
        :param pulumi.Input[int] max_deleting: The maximum number of instances that can be deleted at the same time.
        :param pulumi.Input[int] startup_duration: The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        :param pulumi.Input[str] strategy: Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        if max_creating is not None:
            pulumi.set(__self__, "max_creating", max_creating)
        if max_deleting is not None:
            pulumi.set(__self__, "max_deleting", max_deleting)
        if startup_duration is not None:
            pulumi.set(__self__, "startup_duration", startup_duration)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> pulumi.Input[int]:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        """
        return pulumi.get(self, "max_expansion")

    @max_expansion.setter
    def max_expansion(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_expansion", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> pulumi.Input[int]:
        """
        The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter(name="maxCreating")
    def max_creating(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of instances that can be created at the same time.
        """
        return pulumi.get(self, "max_creating")

    @max_creating.setter
    def max_creating(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_creating", value)

    @property
    @pulumi.getter(name="maxDeleting")
    def max_deleting(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of instances that can be deleted at the same time.
        """
        return pulumi.get(self, "max_deleting")

    @max_deleting.setter
    def max_deleting(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_deleting", value)

    @property
    @pulumi.getter(name="startupDuration")
    def startup_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        """
        return pulumi.get(self, "startup_duration")

    @startup_duration.setter
    def startup_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "startup_duration", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ComputeInstanceGroupHealthCheckArgsDict(TypedDict):
        healthy_threshold: NotRequired[pulumi.Input[int]]
        """
        The number of successful health checks before the managed instance is declared healthy.
        """
        http_options: NotRequired[pulumi.Input['ComputeInstanceGroupHealthCheckHttpOptionsArgsDict']]
        """
        HTTP check options. The structure is documented below.
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        The interval to wait between health checks in seconds.
        """
        tcp_options: NotRequired[pulumi.Input['ComputeInstanceGroupHealthCheckTcpOptionsArgsDict']]
        """
        TCP check options. The structure is documented below.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The length of time to wait for a response before the health check times out in seconds.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[int]]
        """
        The number of failed health checks before the managed instance is declared unhealthy.
        """
elif False:
    ComputeInstanceGroupHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupHealthCheckArgs:
    def __init__(__self__, *,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 http_options: Optional[pulumi.Input['ComputeInstanceGroupHealthCheckHttpOptionsArgs']] = None,
                 interval: Optional[pulumi.Input[int]] = None,
                 tcp_options: Optional[pulumi.Input['ComputeInstanceGroupHealthCheckTcpOptionsArgs']] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] healthy_threshold: The number of successful health checks before the managed instance is declared healthy.
        :param pulumi.Input['ComputeInstanceGroupHealthCheckHttpOptionsArgs'] http_options: HTTP check options. The structure is documented below.
        :param pulumi.Input[int] interval: The interval to wait between health checks in seconds.
        :param pulumi.Input['ComputeInstanceGroupHealthCheckTcpOptionsArgs'] tcp_options: TCP check options. The structure is documented below.
        :param pulumi.Input[int] timeout: The length of time to wait for a response before the health check times out in seconds.
        :param pulumi.Input[int] unhealthy_threshold: The number of failed health checks before the managed instance is declared unhealthy.
        """
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of successful health checks before the managed instance is declared healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional[pulumi.Input['ComputeInstanceGroupHealthCheckHttpOptionsArgs']]:
        """
        HTTP check options. The structure is documented below.
        """
        return pulumi.get(self, "http_options")

    @http_options.setter
    def http_options(self, value: Optional[pulumi.Input['ComputeInstanceGroupHealthCheckHttpOptionsArgs']]):
        pulumi.set(self, "http_options", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The interval to wait between health checks in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['ComputeInstanceGroupHealthCheckTcpOptionsArgs']]:
        """
        TCP check options. The structure is documented below.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['ComputeInstanceGroupHealthCheckTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time to wait for a response before the health check times out in seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of failed health checks before the managed instance is declared unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class ComputeInstanceGroupHealthCheckHttpOptionsArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        The URL path used for health check requests.
        """
        port: pulumi.Input[int]
        """
        The port used for HTTP health checks.
        """
elif False:
    ComputeInstanceGroupHealthCheckHttpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupHealthCheckHttpOptionsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] path: The URL path used for health check requests.
        :param pulumi.Input[int] port: The port used for HTTP health checks.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The URL path used for health check requests.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port used for HTTP health checks.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ComputeInstanceGroupHealthCheckTcpOptionsArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        The port used for TCP health checks.
        """
elif False:
    ComputeInstanceGroupHealthCheckTcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupHealthCheckTcpOptionsArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] port: The port used for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port used for TCP health checks.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ComputeInstanceGroupInstanceArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The Fully Qualified Domain Name.
        """
        instance_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the instance.
        """
        instance_tag: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the instance group.
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceNetworkInterfaceArgsDict']]]]
        """
        An array with the network interfaces attached to the managed instance.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        The status of the instance.
        """
        status_changed_at: NotRequired[pulumi.Input[str]]
        status_message: NotRequired[pulumi.Input[str]]
        """
        The status message of the instance.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the availability zone where the instance resides.
        """
elif False:
    ComputeInstanceGroupInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 instance_tag: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceNetworkInterfaceArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 status_changed_at: Optional[pulumi.Input[str]] = None,
                 status_message: Optional[pulumi.Input[str]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] fqdn: The Fully Qualified Domain Name.
        :param pulumi.Input[str] instance_id: The ID of the instance.
        :param pulumi.Input[str] name: The name of the instance group.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceNetworkInterfaceArgs']]] network_interfaces: An array with the network interfaces attached to the managed instance.
        :param pulumi.Input[str] status: The status of the instance.
        :param pulumi.Input[str] status_message: The status message of the instance.
        :param pulumi.Input[str] zone_id: The ID of the availability zone where the instance resides.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_tag is not None:
            pulumi.set(__self__, "instance_tag", instance_tag)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_changed_at is not None:
            pulumi.set(__self__, "status_changed_at", status_changed_at)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="instanceTag")
    def instance_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_tag")

    @instance_tag.setter
    def instance_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_tag", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the instance group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceNetworkInterfaceArgs']]]]:
        """
        An array with the network interfaces attached to the managed instance.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the instance.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusChangedAt")
    def status_changed_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status_changed_at")

    @status_changed_at.setter
    def status_changed_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_changed_at", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[str]]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_message", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the availability zone where the instance resides.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class ComputeInstanceGroupInstanceNetworkInterfaceArgsDict(TypedDict):
        index: NotRequired[pulumi.Input[int]]
        """
        The index of the network interface as generated by the server.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        Manual set static IP address.
        """
        ipv4: NotRequired[pulumi.Input[bool]]
        """
        True if IPv4 address allocated for the network interface.
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        ipv6_address: NotRequired[pulumi.Input[str]]
        """
        Manual set static IPv6 address.
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        The MAC address assigned to the network interface.
        """
        nat: NotRequired[pulumi.Input[bool]]
        """
        Flag for using NAT.
        """
        nat_ip_address: NotRequired[pulumi.Input[str]]
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        nat_ip_version: NotRequired[pulumi.Input[str]]
        """
        The IP version for the public address.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
elif False:
    ComputeInstanceGroupInstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 index: Optional[pulumi.Input[int]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ipv4: Optional[pulumi.Input[bool]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 nat: Optional[pulumi.Input[bool]] = None,
                 nat_ip_address: Optional[pulumi.Input[str]] = None,
                 nat_ip_version: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] index: The index of the network interface as generated by the server.
        :param pulumi.Input[str] ip_address: Manual set static IP address.
        :param pulumi.Input[bool] ipv4: True if IPv4 address allocated for the network interface.
        :param pulumi.Input[str] ipv6_address: Manual set static IPv6 address.
        :param pulumi.Input[str] mac_address: The MAC address assigned to the network interface.
        :param pulumi.Input[bool] nat: Flag for using NAT.
        :param pulumi.Input[str] nat_ip_address: A public address that can be used to access the internet over NAT. Use `variables` to set.
        :param pulumi.Input[str] nat_ip_version: The IP version for the public address.
        :param pulumi.Input[str] subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        The index of the network interface as generated by the server.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[bool]]:
        """
        True if IPv4 address allocated for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        The MAC address assigned to the network interface.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nat", value)

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        return pulumi.get(self, "nat_ip_address")

    @nat_ip_address.setter
    def nat_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_address", value)

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        The IP version for the public address.
        """
        return pulumi.get(self, "nat_ip_version")

    @nat_ip_version.setter
    def nat_ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_version", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateArgsDict(TypedDict):
        boot_disk: pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskArgsDict']
        """
        Boot disk specifications for the instance. The structure is documented below.
        """
        network_interfaces: pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgsDict']]]
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        """
        resources: pulumi.Input['ComputeInstanceGroupInstanceTemplateResourcesArgsDict']
        """
        Compute resource specifications for the instance. The structure is documented below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the instance.
        """
        filesystems: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateFilesystemArgsDict']]]]
        """
        List of filesystems to attach to the instance. The structure is documented below.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname template for the instance.
        This field is used to generate the FQDN value of instance.
        The hostname must be unique within the network and region.
        If not specified, the hostname will be equal to id of the instance
        and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
        In order to be unique it must contain at least on of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, `name` value will be used
        It may also contain another placeholders, see metadata doc for full list.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value label pairs to assign to the instance.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        metadata_options: NotRequired[pulumi.Input['ComputeInstanceGroupInstanceTemplateMetadataOptionsArgsDict']]
        """
        Options allow user to configure access to managed instances metadata
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name template of the instance.
        In order to be unique it must contain at least one of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, default is used: {instance_group.id}-{instance.short_id}
        It may also contain another placeholders, see metadata doc for full list.
        """
        network_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkSettingArgsDict']]]]
        """
        Network acceleration type for instance. The structure is documented below.
        """
        placement_policy: NotRequired[pulumi.Input['ComputeInstanceGroupInstanceTemplatePlacementPolicyArgsDict']]
        """
        The placement policy configuration. The structure is documented below.
        """
        platform_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
        """
        scheduling_policy: NotRequired[pulumi.Input['ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgsDict']]
        """
        The scheduling policy configuration. The structure is documented below.
        """
        secondary_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgsDict']]]]
        """
        A list of disks to attach to the instance. The structure is documented below.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the service account authorized for this instance.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateArgs:
    def __init__(__self__, *,
                 boot_disk: pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskArgs'],
                 network_interfaces: pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs']]],
                 resources: pulumi.Input['ComputeInstanceGroupInstanceTemplateResourcesArgs'],
                 description: Optional[pulumi.Input[str]] = None,
                 filesystems: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateFilesystemArgs']]]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 metadata_options: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkSettingArgs']]]] = None,
                 placement_policy: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs']] = None,
                 platform_id: Optional[pulumi.Input[str]] = None,
                 scheduling_policy: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs']] = None,
                 secondary_disks: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs']]]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskArgs'] boot_disk: Boot disk specifications for the instance. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs']]] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplateResourcesArgs'] resources: Compute resource specifications for the instance. The structure is documented below.
        :param pulumi.Input[str] description: A description of the instance.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateFilesystemArgs']]] filesystems: List of filesystems to attach to the instance. The structure is documented below.
        :param pulumi.Input[str] hostname: Hostname template for the instance.
               This field is used to generate the FQDN value of instance.
               The hostname must be unique within the network and region.
               If not specified, the hostname will be equal to id of the instance
               and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
               In order to be unique it must contain at least on of instance unique placeholders:
               {instance.short_id}
               {instance.index}
               combination of {instance.zone_id} and {instance.index_in_zone}
               Example: my-instance-{instance.index}
               If not set, `name` value will be used
               It may also contain another placeholders, see metadata doc for full list.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A set of key/value label pairs to assign to the instance.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs'] metadata_options: Options allow user to configure access to managed instances metadata
        :param pulumi.Input[str] name: Name template of the instance.
               In order to be unique it must contain at least one of instance unique placeholders:
               {instance.short_id}
               {instance.index}
               combination of {instance.zone_id} and {instance.index_in_zone}
               Example: my-instance-{instance.index}
               If not set, default is used: {instance_group.id}-{instance.short_id}
               It may also contain another placeholders, see metadata doc for full list.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkSettingArgs']]] network_settings: Network acceleration type for instance. The structure is documented below.
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs'] placement_policy: The placement policy configuration. The structure is documented below.
        :param pulumi.Input[str] platform_id: The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs'] scheduling_policy: The scheduling policy configuration. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs']]] secondary_disks: A list of disks to attach to the instance. The structure is documented below.
        :param pulumi.Input[str] service_account_id: The ID of the service account authorized for this instance.
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_settings is not None:
            pulumi.set(__self__, "network_settings", network_settings)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        if secondary_disks is not None:
            pulumi.set(__self__, "secondary_disks", secondary_disks)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskArgs']:
        """
        Boot disk specifications for the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disk")

    @boot_disk.setter
    def boot_disk(self, value: pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskArgs']):
        pulumi.set(self, "boot_disk", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs']]]:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs']]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['ComputeInstanceGroupInstanceTemplateResourcesArgs']:
        """
        Compute resource specifications for the instance. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['ComputeInstanceGroupInstanceTemplateResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the instance.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def filesystems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateFilesystemArgs']]]]:
        """
        List of filesystems to attach to the instance. The structure is documented below.
        """
        return pulumi.get(self, "filesystems")

    @filesystems.setter
    def filesystems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateFilesystemArgs']]]]):
        pulumi.set(self, "filesystems", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname template for the instance.
        This field is used to generate the FQDN value of instance.
        The hostname must be unique within the network and region.
        If not specified, the hostname will be equal to id of the instance
        and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
        In order to be unique it must contain at least on of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, `name` value will be used
        It may also contain another placeholders, see metadata doc for full list.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs']]:
        """
        Options allow user to configure access to managed instances metadata
        """
        return pulumi.get(self, "metadata_options")

    @metadata_options.setter
    def metadata_options(self, value: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs']]):
        pulumi.set(self, "metadata_options", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name template of the instance.
        In order to be unique it must contain at least one of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, default is used: {instance_group.id}-{instance.short_id}
        It may also contain another placeholders, see metadata doc for full list.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkSettings")
    def network_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkSettingArgs']]]]:
        """
        Network acceleration type for instance. The structure is documented below.
        """
        return pulumi.get(self, "network_settings")

    @network_settings.setter
    def network_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkSettingArgs']]]]):
        pulumi.set(self, "network_settings", value)

    @property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs']]:
        """
        The placement policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "placement_policy")

    @placement_policy.setter
    def placement_policy(self, value: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs']]):
        pulumi.set(self, "placement_policy", value)

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
        """
        return pulumi.get(self, "platform_id")

    @platform_id.setter
    def platform_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_id", value)

    @property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs']]:
        """
        The scheduling policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "scheduling_policy")

    @scheduling_policy.setter
    def scheduling_policy(self, value: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs']]):
        pulumi.set(self, "scheduling_policy", value)

    @property
    @pulumi.getter(name="secondaryDisks")
    def secondary_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs']]]]:
        """
        A list of disks to attach to the instance. The structure is documented below.
        """
        return pulumi.get(self, "secondary_disks")

    @secondary_disks.setter
    def secondary_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs']]]]):
        pulumi.set(self, "secondary_disks", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the service account authorized for this instance.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateBootDiskArgsDict(TypedDict):
        device_name: NotRequired[pulumi.Input[str]]
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        disk_id: NotRequired[pulumi.Input[str]]
        """
        ID of the existing disk. To set use variables.
        """
        initialize_params: NotRequired[pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgsDict']]
        """
        Parameters for creating a disk alongside the instance. The structure is documented below.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        When set can be later used to change DiskSpec of actual disk.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateBootDiskArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 disk_id: Optional[pulumi.Input[str]] = None,
                 initialize_params: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param pulumi.Input[str] disk_id: ID of the existing disk. To set use variables.
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs'] initialize_params: Parameters for creating a disk alongside the instance. The structure is documented below.
        :param pulumi.Input[str] mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        :param pulumi.Input[str] name: When set can be later used to change DiskSpec of actual disk.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_id", value)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs']]:
        """
        Parameters for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs']]):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        When set can be later used to change DiskSpec of actual disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the boot disk.
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        The disk image to initialize this disk from.
        """
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in GB.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        The snapshot to initialize this disk from.

        > `image_id` or `snapshot_id` must be specified.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The disk type.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the boot disk.
        :param pulumi.Input[str] image_id: The disk image to initialize this disk from.
        :param pulumi.Input[int] size: The size of the disk in GB.
        :param pulumi.Input[str] snapshot_id: The snapshot to initialize this disk from.
               
               > `image_id` or `snapshot_id` must be specified.
        :param pulumi.Input[str] type: The disk type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot to initialize this disk from.

        > `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateFilesystemArgsDict(TypedDict):
        filesystem_id: pulumi.Input[str]
        """
        (Required) ID of the filesystem that should be attached.
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        (Optional) Name of the device representing the filesystem on the instance.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        (Optional) Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateFilesystemArgs:
    def __init__(__self__, *,
                 filesystem_id: pulumi.Input[str],
                 device_name: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] filesystem_id: (Required) ID of the filesystem that should be attached.
        :param pulumi.Input[str] device_name: (Optional) Name of the device representing the filesystem on the instance.
        :param pulumi.Input[str] mode: (Optional) Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> pulumi.Input[str]:
        """
        (Required) ID of the filesystem that should be attached.
        """
        return pulumi.get(self, "filesystem_id")

    @filesystem_id.setter
    def filesystem_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "filesystem_id", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Name of the device representing the filesystem on the instance.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateMetadataOptionsArgsDict(TypedDict):
        aws_v1_http_endpoint: NotRequired[pulumi.Input[int]]
        aws_v1_http_token: NotRequired[pulumi.Input[int]]
        gce_http_endpoint: NotRequired[pulumi.Input[int]]
        gce_http_token: NotRequired[pulumi.Input[int]]
elif False:
    ComputeInstanceGroupInstanceTemplateMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs:
    def __init__(__self__, *,
                 aws_v1_http_endpoint: Optional[pulumi.Input[int]] = None,
                 aws_v1_http_token: Optional[pulumi.Input[int]] = None,
                 gce_http_endpoint: Optional[pulumi.Input[int]] = None,
                 gce_http_token: Optional[pulumi.Input[int]] = None):
        if aws_v1_http_endpoint is not None:
            pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        if aws_v1_http_token is not None:
            pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        if gce_http_endpoint is not None:
            pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        if gce_http_token is not None:
            pulumi.set(__self__, "gce_http_token", gce_http_token)

    @property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "aws_v1_http_endpoint")

    @aws_v1_http_endpoint.setter
    def aws_v1_http_endpoint(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "aws_v1_http_endpoint", value)

    @property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "aws_v1_http_token")

    @aws_v1_http_token.setter
    def aws_v1_http_token(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "aws_v1_http_token", value)

    @property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gce_http_endpoint")

    @gce_http_endpoint.setter
    def gce_http_endpoint(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gce_http_endpoint", value)

    @property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gce_http_token")

    @gce_http_token.setter
    def gce_http_token(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gce_http_token", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgsDict(TypedDict):
        dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgsDict']]]]
        """
        List of dns records. The structure is documented below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        Manual set static IP address.
        """
        ipv4: NotRequired[pulumi.Input[bool]]
        """
        True if IPv4 address allocated for the network interface.
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        ipv6_address: NotRequired[pulumi.Input[str]]
        """
        Manual set static IPv6 address.
        """
        ipv6_dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict']]]]
        """
        List of ipv6 dns records. The structure is documented below.
        """
        nat: NotRequired[pulumi.Input[bool]]
        """
        Flag for using NAT.
        """
        nat_dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgsDict']]]]
        """
        List of nat dns records. The structure is documented below.
        """
        nat_ip_address: NotRequired[pulumi.Input[str]]
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        network_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the network.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Security group ids for network interface.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ID of the subnets to attach this interface to.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs']]]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ipv4: Optional[pulumi.Input[bool]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]]] = None,
                 nat: Optional[pulumi.Input[bool]] = None,
                 nat_dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs']]]] = None,
                 nat_ip_address: Optional[pulumi.Input[str]] = None,
                 network_id: Optional[pulumi.Input[str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs']]] dns_records: List of dns records. The structure is documented below.
        :param pulumi.Input[str] ip_address: Manual set static IP address.
        :param pulumi.Input[bool] ipv4: True if IPv4 address allocated for the network interface.
        :param pulumi.Input[str] ipv6_address: Manual set static IPv6 address.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]] ipv6_dns_records: List of ipv6 dns records. The structure is documented below.
        :param pulumi.Input[bool] nat: Flag for using NAT.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs']]] nat_dns_records: List of nat dns records. The structure is documented below.
        :param pulumi.Input[str] nat_ip_address: A public address that can be used to access the internet over NAT. Use `variables` to set.
        :param pulumi.Input[str] network_id: The ID of the network.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Security group ids for network interface.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: The ID of the subnets to attach this interface to.
        """
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_dns_records is not None:
            pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs']]]]:
        """
        List of dns records. The structure is documented below.
        """
        return pulumi.get(self, "dns_records")

    @dns_records.setter
    def dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs']]]]):
        pulumi.set(self, "dns_records", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[bool]]:
        """
        True if IPv4 address allocated for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]]]:
        """
        List of ipv6 dns records. The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @ipv6_dns_records.setter
    def ipv6_dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]]]):
        pulumi.set(self, "ipv6_dns_records", value)

    @property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nat", value)

    @property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs']]]]:
        """
        List of nat dns records. The structure is documented below.
        """
        return pulumi.get(self, "nat_dns_records")

    @nat_dns_records.setter
    def nat_dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs']]]]):
        pulumi.set(self, "nat_dns_records", value)

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        return pulumi.get(self, "nat_ip_address")

    @nat_ip_address.setter
    def nat_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_address", value)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the network.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the subnets to attach this interface to.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        DNS record fqdn (must have dot at the end).
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        """
        DNS zone id (if not set, private zone used).
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        When set to true, also create PTR DNS record.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        DNS record TTL.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: DNS record fqdn (must have dot at the end).
        :param pulumi.Input[str] dns_zone_id: DNS zone id (if not set, private zone used).
        :param pulumi.Input[bool] ptr: When set to true, also create PTR DNS record.
        :param pulumi.Input[int] ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        DNS record fqdn (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        The Fully Qualified Domain Name.
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        ptr: NotRequired[pulumi.Input[bool]]
        ttl: NotRequired[pulumi.Input[int]]
elif False:
    ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: The Fully Qualified Domain Name.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        DNS record fqdn (must have dot at the end).
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        """
        DNS zone id (if not set, private zone used).
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        When set to true, also create PTR DNS record.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        DNS record TTL.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: DNS record fqdn (must have dot at the end).
        :param pulumi.Input[str] dns_zone_id: DNS zone id (if not set, private zone used).
        :param pulumi.Input[bool] ptr: When set to true, also create PTR DNS record.
        :param pulumi.Input[int] ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        DNS record fqdn (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateNetworkSettingArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateNetworkSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateNetworkSettingArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplatePlacementPolicyArgsDict(TypedDict):
        placement_group_id: pulumi.Input[str]
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
elif False:
    ComputeInstanceGroupInstanceTemplatePlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs:
    def __init__(__self__, *,
                 placement_group_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "placement_group_id", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateResourcesArgsDict(TypedDict):
        cores: pulumi.Input[int]
        """
        The number of CPU cores for the instance.
        """
        memory: pulumi.Input[float]
        """
        The memory size in GB.
        """
        core_fraction: NotRequired[pulumi.Input[int]]
        """
        If provided, specifies baseline core performance as a percent.
        """
        gpus: NotRequired[pulumi.Input[int]]
elif False:
    ComputeInstanceGroupInstanceTemplateResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateResourcesArgs:
    def __init__(__self__, *,
                 cores: pulumi.Input[int],
                 memory: pulumi.Input[float],
                 core_fraction: Optional[pulumi.Input[int]] = None,
                 gpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cores: The number of CPU cores for the instance.
        :param pulumi.Input[float] memory: The memory size in GB.
        :param pulumi.Input[int] core_fraction: If provided, specifies baseline core performance as a percent.
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[float]:
        """
        The memory size in GB.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[pulumi.Input[int]]:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @core_fraction.setter
    def core_fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "core_fraction", value)

    @property
    @pulumi.getter
    def gpus(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gpus")

    @gpus.setter
    def gpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpus", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgsDict(TypedDict):
        preemptible: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs:
    def __init__(__self__, *,
                 preemptible: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] preemptible: Specifies if the instance is preemptible. Defaults to false.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preemptible", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateSecondaryDiskArgsDict(TypedDict):
        device_name: NotRequired[pulumi.Input[str]]
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        disk_id: NotRequired[pulumi.Input[str]]
        """
        ID of the existing disk. To set use variables.
        """
        initialize_params: NotRequired[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgsDict']]
        """
        Parameters used for creating a disk alongside the instance. The structure is documented below.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        When set can be later used to change DiskSpec of actual disk.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateSecondaryDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 disk_id: Optional[pulumi.Input[str]] = None,
                 initialize_params: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param pulumi.Input[str] disk_id: ID of the existing disk. To set use variables.
        :param pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs'] initialize_params: Parameters used for creating a disk alongside the instance. The structure is documented below.
        :param pulumi.Input[str] mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        :param pulumi.Input[str] name: When set can be later used to change DiskSpec of actual disk.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_id", value)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs']]:
        """
        Parameters used for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: Optional[pulumi.Input['ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs']]):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        When set can be later used to change DiskSpec of actual disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the boot disk.
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        The disk image to initialize this disk from.
        """
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in GB.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        The snapshot to initialize this disk from.

        > `image_id` or `snapshot_id` must be specified.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The disk type.
        """
elif False:
    ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the boot disk.
        :param pulumi.Input[str] image_id: The disk image to initialize this disk from.
        :param pulumi.Input[int] size: The size of the disk in GB.
        :param pulumi.Input[str] snapshot_id: The snapshot to initialize this disk from.
               
               > `image_id` or `snapshot_id` must be specified.
        :param pulumi.Input[str] type: The disk type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot to initialize this disk from.

        > `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComputeInstanceGroupLoadBalancerArgsDict(TypedDict):
        ignore_health_checks: NotRequired[pulumi.Input[bool]]
        """
        Do not wait load balancer health checks.
        """
        max_opening_traffic_duration: NotRequired[pulumi.Input[int]]
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        status_message: NotRequired[pulumi.Input[str]]
        """
        The status message of the target group.
        """
        target_group_description: NotRequired[pulumi.Input[str]]
        """
        A description of the target group.
        """
        target_group_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the target group.
        """
        target_group_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value label pairs.
        """
        target_group_name: NotRequired[pulumi.Input[str]]
        """
        The name of the target group.
        """
elif False:
    ComputeInstanceGroupLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupLoadBalancerArgs:
    def __init__(__self__, *,
                 ignore_health_checks: Optional[pulumi.Input[bool]] = None,
                 max_opening_traffic_duration: Optional[pulumi.Input[int]] = None,
                 status_message: Optional[pulumi.Input[str]] = None,
                 target_group_description: Optional[pulumi.Input[str]] = None,
                 target_group_id: Optional[pulumi.Input[str]] = None,
                 target_group_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 target_group_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] ignore_health_checks: Do not wait load balancer health checks.
        :param pulumi.Input[int] max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param pulumi.Input[str] status_message: The status message of the target group.
        :param pulumi.Input[str] target_group_description: A description of the target group.
        :param pulumi.Input[str] target_group_id: The ID of the target group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] target_group_labels: A set of key/value label pairs.
        :param pulumi.Input[str] target_group_name: The name of the target group.
        """
        if ignore_health_checks is not None:
            pulumi.set(__self__, "ignore_health_checks", ignore_health_checks)
        if max_opening_traffic_duration is not None:
            pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if target_group_description is not None:
            pulumi.set(__self__, "target_group_description", target_group_description)
        if target_group_id is not None:
            pulumi.set(__self__, "target_group_id", target_group_id)
        if target_group_labels is not None:
            pulumi.set(__self__, "target_group_labels", target_group_labels)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)

    @property
    @pulumi.getter(name="ignoreHealthChecks")
    def ignore_health_checks(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not wait load balancer health checks.
        """
        return pulumi.get(self, "ignore_health_checks")

    @ignore_health_checks.setter
    def ignore_health_checks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_health_checks", value)

    @property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @max_opening_traffic_duration.setter
    def max_opening_traffic_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_opening_traffic_duration", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[str]]:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_message", value)

    @property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @target_group_description.setter
    def target_group_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_description", value)

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @target_group_id.setter
    def target_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_id", value)

    @property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @target_group_labels.setter
    def target_group_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "target_group_labels", value)

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")

    @target_group_name.setter
    def target_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_name", value)


if not MYPY:
    class ComputeInstanceGroupScalePolicyArgsDict(TypedDict):
        auto_scale: NotRequired[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleArgsDict']]
        """
        The auto scaling policy of the instance group. The structure is documented below.

        > Either `fixed_scale` or `auto_scale` must be specified.
        """
        fixed_scale: NotRequired[pulumi.Input['ComputeInstanceGroupScalePolicyFixedScaleArgsDict']]
        """
        The fixed scaling policy of the instance group. The structure is documented below.
        """
        test_auto_scale: NotRequired[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleArgsDict']]
        """
        The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
elif False:
    ComputeInstanceGroupScalePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupScalePolicyArgs:
    def __init__(__self__, *,
                 auto_scale: Optional[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleArgs']] = None,
                 fixed_scale: Optional[pulumi.Input['ComputeInstanceGroupScalePolicyFixedScaleArgs']] = None,
                 test_auto_scale: Optional[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleArgs']] = None):
        """
        :param pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleArgs'] auto_scale: The auto scaling policy of the instance group. The structure is documented below.
               
               > Either `fixed_scale` or `auto_scale` must be specified.
        :param pulumi.Input['ComputeInstanceGroupScalePolicyFixedScaleArgs'] fixed_scale: The fixed scaling policy of the instance group. The structure is documented below.
        :param pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleArgs'] test_auto_scale: The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)
        if test_auto_scale is not None:
            pulumi.set(__self__, "test_auto_scale", test_auto_scale)

    @property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleArgs']]:
        """
        The auto scaling policy of the instance group. The structure is documented below.

        > Either `fixed_scale` or `auto_scale` must be specified.
        """
        return pulumi.get(self, "auto_scale")

    @auto_scale.setter
    def auto_scale(self, value: Optional[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleArgs']]):
        pulumi.set(self, "auto_scale", value)

    @property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional[pulumi.Input['ComputeInstanceGroupScalePolicyFixedScaleArgs']]:
        """
        The fixed scaling policy of the instance group. The structure is documented below.
        """
        return pulumi.get(self, "fixed_scale")

    @fixed_scale.setter
    def fixed_scale(self, value: Optional[pulumi.Input['ComputeInstanceGroupScalePolicyFixedScaleArgs']]):
        pulumi.set(self, "fixed_scale", value)

    @property
    @pulumi.getter(name="testAutoScale")
    def test_auto_scale(self) -> Optional[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleArgs']]:
        """
        The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
        return pulumi.get(self, "test_auto_scale")

    @test_auto_scale.setter
    def test_auto_scale(self, value: Optional[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleArgs']]):
        pulumi.set(self, "test_auto_scale", value)


if not MYPY:
    class ComputeInstanceGroupScalePolicyAutoScaleArgsDict(TypedDict):
        initial_size: pulumi.Input[int]
        """
        The initial number of instances in the instance group.
        """
        measurement_duration: pulumi.Input[int]
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        auto_scale_type: NotRequired[pulumi.Input[str]]
        """
        . Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        cpu_utilization_target: NotRequired[pulumi.Input[float]]
        """
        Target CPU load level.
        """
        custom_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgsDict']]]]
        """
        A list of custom rules. The structure is documented below.
        """
        max_size: NotRequired[pulumi.Input[int]]
        """
        The maximum number of virtual machines in the group.
        """
        min_zone_size: NotRequired[pulumi.Input[int]]
        """
        The minimum number of virtual machines in a single availability zone.
        """
        stabilization_duration: NotRequired[pulumi.Input[int]]
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        warmup_duration: NotRequired[pulumi.Input[int]]
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
elif False:
    ComputeInstanceGroupScalePolicyAutoScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupScalePolicyAutoScaleArgs:
    def __init__(__self__, *,
                 initial_size: pulumi.Input[int],
                 measurement_duration: pulumi.Input[int],
                 auto_scale_type: Optional[pulumi.Input[str]] = None,
                 cpu_utilization_target: Optional[pulumi.Input[float]] = None,
                 custom_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs']]]] = None,
                 max_size: Optional[pulumi.Input[int]] = None,
                 min_zone_size: Optional[pulumi.Input[int]] = None,
                 stabilization_duration: Optional[pulumi.Input[int]] = None,
                 warmup_duration: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] initial_size: The initial number of instances in the instance group.
        :param pulumi.Input[int] measurement_duration: The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        :param pulumi.Input[str] auto_scale_type: . Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        :param pulumi.Input[float] cpu_utilization_target: Target CPU load level.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs']]] custom_rules: A list of custom rules. The structure is documented below.
        :param pulumi.Input[int] max_size: The maximum number of virtual machines in the group.
        :param pulumi.Input[int] min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param pulumi.Input[int] stabilization_duration: The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param pulumi.Input[int] warmup_duration: The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        if auto_scale_type is not None:
            pulumi.set(__self__, "auto_scale_type", auto_scale_type)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> pulumi.Input[int]:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @initial_size.setter
    def initial_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "initial_size", value)

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> pulumi.Input[int]:
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @measurement_duration.setter
    def measurement_duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "measurement_duration", value)

    @property
    @pulumi.getter(name="autoScaleType")
    def auto_scale_type(self) -> Optional[pulumi.Input[str]]:
        """
        . Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        return pulumi.get(self, "auto_scale_type")

    @auto_scale_type.setter
    def auto_scale_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_scale_type", value)

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[pulumi.Input[float]]:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @cpu_utilization_target.setter
    def cpu_utilization_target(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_utilization_target", value)

    @property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs']]]]:
        """
        A list of custom rules. The structure is documented below.
        """
        return pulumi.get(self, "custom_rules")

    @custom_rules.setter
    def custom_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs']]]]):
        pulumi.set(self, "custom_rules", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @min_zone_size.setter
    def min_zone_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_zone_size", value)

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @stabilization_duration.setter
    def stabilization_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stabilization_duration", value)

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")

    @warmup_duration.setter
    def warmup_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "warmup_duration", value)


if not MYPY:
    class ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The name of metric.
        """
        metric_type: pulumi.Input[str]
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        rule_type: pulumi.Input[str]
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        """
        target: pulumi.Input[float]
        """
        Target metric value level.
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of labels of metric.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
elif False:
    ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 metric_type: pulumi.Input[str],
                 rule_type: pulumi.Input[str],
                 target: pulumi.Input[float],
                 folder_id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The name of metric.
        :param pulumi.Input[str] metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param pulumi.Input[str] rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        :param pulumi.Input[float] target: Target metric value level.
        :param pulumi.Input[str] folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A map of labels of metric.
        :param pulumi.Input[str] service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "target", target)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> pulumi.Input[str]:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[float]:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[float]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ComputeInstanceGroupScalePolicyFixedScaleArgsDict(TypedDict):
        size: pulumi.Input[int]
        """
        The number of instances in the instance group.
        """
elif False:
    ComputeInstanceGroupScalePolicyFixedScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupScalePolicyFixedScaleArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[int]):
        """
        :param pulumi.Input[int] size: The number of instances in the instance group.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The number of instances in the instance group.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)


if not MYPY:
    class ComputeInstanceGroupScalePolicyTestAutoScaleArgsDict(TypedDict):
        initial_size: pulumi.Input[int]
        """
        The initial number of instances in the instance group.
        """
        measurement_duration: pulumi.Input[int]
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        auto_scale_type: NotRequired[pulumi.Input[str]]
        """
        . Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        cpu_utilization_target: NotRequired[pulumi.Input[float]]
        """
        Target CPU load level.
        """
        custom_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgsDict']]]]
        """
        A list of custom rules. The structure is documented below.
        """
        max_size: NotRequired[pulumi.Input[int]]
        """
        The maximum number of virtual machines in the group.
        """
        min_zone_size: NotRequired[pulumi.Input[int]]
        """
        The minimum number of virtual machines in a single availability zone.
        """
        stabilization_duration: NotRequired[pulumi.Input[int]]
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        warmup_duration: NotRequired[pulumi.Input[int]]
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
elif False:
    ComputeInstanceGroupScalePolicyTestAutoScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupScalePolicyTestAutoScaleArgs:
    def __init__(__self__, *,
                 initial_size: pulumi.Input[int],
                 measurement_duration: pulumi.Input[int],
                 auto_scale_type: Optional[pulumi.Input[str]] = None,
                 cpu_utilization_target: Optional[pulumi.Input[float]] = None,
                 custom_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs']]]] = None,
                 max_size: Optional[pulumi.Input[int]] = None,
                 min_zone_size: Optional[pulumi.Input[int]] = None,
                 stabilization_duration: Optional[pulumi.Input[int]] = None,
                 warmup_duration: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] initial_size: The initial number of instances in the instance group.
        :param pulumi.Input[int] measurement_duration: The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        :param pulumi.Input[str] auto_scale_type: . Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        :param pulumi.Input[float] cpu_utilization_target: Target CPU load level.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs']]] custom_rules: A list of custom rules. The structure is documented below.
        :param pulumi.Input[int] max_size: The maximum number of virtual machines in the group.
        :param pulumi.Input[int] min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param pulumi.Input[int] stabilization_duration: The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param pulumi.Input[int] warmup_duration: The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        if auto_scale_type is not None:
            pulumi.set(__self__, "auto_scale_type", auto_scale_type)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> pulumi.Input[int]:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @initial_size.setter
    def initial_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "initial_size", value)

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> pulumi.Input[int]:
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @measurement_duration.setter
    def measurement_duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "measurement_duration", value)

    @property
    @pulumi.getter(name="autoScaleType")
    def auto_scale_type(self) -> Optional[pulumi.Input[str]]:
        """
        . Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        return pulumi.get(self, "auto_scale_type")

    @auto_scale_type.setter
    def auto_scale_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_scale_type", value)

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[pulumi.Input[float]]:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @cpu_utilization_target.setter
    def cpu_utilization_target(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_utilization_target", value)

    @property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs']]]]:
        """
        A list of custom rules. The structure is documented below.
        """
        return pulumi.get(self, "custom_rules")

    @custom_rules.setter
    def custom_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs']]]]):
        pulumi.set(self, "custom_rules", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @min_zone_size.setter
    def min_zone_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_zone_size", value)

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @stabilization_duration.setter
    def stabilization_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stabilization_duration", value)

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")

    @warmup_duration.setter
    def warmup_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "warmup_duration", value)


if not MYPY:
    class ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The name of metric.
        """
        metric_type: pulumi.Input[str]
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        rule_type: pulumi.Input[str]
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        """
        target: pulumi.Input[float]
        """
        Target metric value level.
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of labels of metric.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
elif False:
    ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 metric_type: pulumi.Input[str],
                 rule_type: pulumi.Input[str],
                 target: pulumi.Input[float],
                 folder_id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The name of metric.
        :param pulumi.Input[str] metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param pulumi.Input[str] rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        :param pulumi.Input[float] target: Target metric value level.
        :param pulumi.Input[str] folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A map of labels of metric.
        :param pulumi.Input[str] service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "target", target)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> pulumi.Input[str]:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[float]:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[float]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ComputeInstanceHardwareGenerationArgsDict(TypedDict):
        generation2_features: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationGeneration2FeatureArgsDict']]]]
        legacy_features: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationLegacyFeatureArgsDict']]]]
elif False:
    ComputeInstanceHardwareGenerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceHardwareGenerationArgs:
    def __init__(__self__, *,
                 generation2_features: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationGeneration2FeatureArgs']]]] = None,
                 legacy_features: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationLegacyFeatureArgs']]]] = None):
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationGeneration2FeatureArgs']]]]:
        return pulumi.get(self, "generation2_features")

    @generation2_features.setter
    def generation2_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationGeneration2FeatureArgs']]]]):
        pulumi.set(self, "generation2_features", value)

    @property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationLegacyFeatureArgs']]]]:
        return pulumi.get(self, "legacy_features")

    @legacy_features.setter
    def legacy_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceHardwareGenerationLegacyFeatureArgs']]]]):
        pulumi.set(self, "legacy_features", value)


if not MYPY:
    class ComputeInstanceHardwareGenerationGeneration2FeatureArgsDict(TypedDict):
        pass
elif False:
    ComputeInstanceHardwareGenerationGeneration2FeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceHardwareGenerationGeneration2FeatureArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeInstanceHardwareGenerationLegacyFeatureArgsDict(TypedDict):
        pci_topology: NotRequired[pulumi.Input[str]]
elif False:
    ComputeInstanceHardwareGenerationLegacyFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceHardwareGenerationLegacyFeatureArgs:
    def __init__(__self__, *,
                 pci_topology: Optional[pulumi.Input[str]] = None):
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pci_topology")

    @pci_topology.setter
    def pci_topology(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pci_topology", value)


if not MYPY:
    class ComputeInstanceLocalDiskArgsDict(TypedDict):
        size_bytes: pulumi.Input[int]
        """
        Size of the disk, specified in bytes.

        > Local disks are not available for all users by default.
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        The name of the local disk device.
        """
elif False:
    ComputeInstanceLocalDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceLocalDiskArgs:
    def __init__(__self__, *,
                 size_bytes: pulumi.Input[int],
                 device_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] size_bytes: Size of the disk, specified in bytes.
               
               > Local disks are not available for all users by default.
        :param pulumi.Input[str] device_name: The name of the local disk device.
        """
        pulumi.set(__self__, "size_bytes", size_bytes)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> pulumi.Input[int]:
        """
        Size of the disk, specified in bytes.

        > Local disks are not available for all users by default.
        """
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the local disk device.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)


if not MYPY:
    class ComputeInstanceMetadataOptionsArgsDict(TypedDict):
        aws_v1_http_endpoint: NotRequired[pulumi.Input[int]]
        aws_v1_http_token: NotRequired[pulumi.Input[int]]
        gce_http_endpoint: NotRequired[pulumi.Input[int]]
        gce_http_token: NotRequired[pulumi.Input[int]]
elif False:
    ComputeInstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 aws_v1_http_endpoint: Optional[pulumi.Input[int]] = None,
                 aws_v1_http_token: Optional[pulumi.Input[int]] = None,
                 gce_http_endpoint: Optional[pulumi.Input[int]] = None,
                 gce_http_token: Optional[pulumi.Input[int]] = None):
        if aws_v1_http_endpoint is not None:
            pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        if aws_v1_http_token is not None:
            pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        if gce_http_endpoint is not None:
            pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        if gce_http_token is not None:
            pulumi.set(__self__, "gce_http_token", gce_http_token)

    @property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "aws_v1_http_endpoint")

    @aws_v1_http_endpoint.setter
    def aws_v1_http_endpoint(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "aws_v1_http_endpoint", value)

    @property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "aws_v1_http_token")

    @aws_v1_http_token.setter
    def aws_v1_http_token(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "aws_v1_http_token", value)

    @property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gce_http_endpoint")

    @gce_http_endpoint.setter
    def gce_http_endpoint(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gce_http_endpoint", value)

    @property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gce_http_token")

    @gce_http_token.setter
    def gce_http_token(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gce_http_token", value)


if not MYPY:
    class ComputeInstanceNetworkInterfaceArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        """
        dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceDnsRecordArgsDict']]]]
        """
        List of configurations for creating ipv4 DNS records. The structure is documented below.
        """
        index: NotRequired[pulumi.Input[int]]
        """
        Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        """
        ipv4: NotRequired[pulumi.Input[bool]]
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        ipv6_address: NotRequired[pulumi.Input[str]]
        """
        The private IPv6 address to assign to the instance.
        """
        ipv6_dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgsDict']]]]
        """
        List of configurations for creating ipv6 DNS records. The structure is documented below.
        """
        mac_address: NotRequired[pulumi.Input[str]]
        nat: NotRequired[pulumi.Input[bool]]
        """
        Provide a public address, for instance, to access the internet over NAT.
        """
        nat_dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceNatDnsRecordArgsDict']]]]
        """
        List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        """
        nat_ip_address: NotRequired[pulumi.Input[str]]
        """
        Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        """
        nat_ip_version: NotRequired[pulumi.Input[str]]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Security group ids for network interface.
        """
elif False:
    ComputeInstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceDnsRecordArgs']]]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ipv4: Optional[pulumi.Input[bool]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs']]]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 nat: Optional[pulumi.Input[bool]] = None,
                 nat_dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceNatDnsRecordArgs']]]] = None,
                 nat_ip_address: Optional[pulumi.Input[str]] = None,
                 nat_ip_version: Optional[pulumi.Input[str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] subnet_id: ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceDnsRecordArgs']]] dns_records: List of configurations for creating ipv4 DNS records. The structure is documented below.
        :param pulumi.Input[int] index: Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        :param pulumi.Input[str] ip_address: The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        :param pulumi.Input[bool] ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param pulumi.Input[bool] ipv6: If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param pulumi.Input[str] ipv6_address: The private IPv6 address to assign to the instance.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs']]] ipv6_dns_records: List of configurations for creating ipv6 DNS records. The structure is documented below.
        :param pulumi.Input[bool] nat: Provide a public address, for instance, to access the internet over NAT.
        :param pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceNatDnsRecordArgs']]] nat_dns_records: List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        :param pulumi.Input[str] nat_ip_address: Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Security group ids for network interface.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_dns_records is not None:
            pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceDnsRecordArgs']]]]:
        """
        List of configurations for creating ipv4 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "dns_records")

    @dns_records.setter
    def dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceDnsRecordArgs']]]]):
        pulumi.set(self, "dns_records", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[bool]]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private IPv6 address to assign to the instance.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs']]]]:
        """
        List of configurations for creating ipv6 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @ipv6_dns_records.setter
    def ipv6_dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs']]]]):
        pulumi.set(self, "ipv6_dns_records", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input[bool]]:
        """
        Provide a public address, for instance, to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nat", value)

    @property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceNatDnsRecordArgs']]]]:
        """
        List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        """
        return pulumi.get(self, "nat_dns_records")

    @nat_dns_records.setter
    def nat_dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstanceNetworkInterfaceNatDnsRecordArgs']]]]):
        pulumi.set(self, "nat_dns_records", value)

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        """
        return pulumi.get(self, "nat_ip_address")

    @nat_ip_address.setter
    def nat_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_address", value)

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nat_ip_version")

    @nat_ip_version.setter
    def nat_ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_version", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class ComputeInstanceNetworkInterfaceDnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        DNS record FQDN (must have a dot at the end).
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        """
        DNS zone ID (if not set, private zone used).
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        When set to true, also create a PTR DNS record.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        DNS record TTL. in seconds
        """
elif False:
    ComputeInstanceNetworkInterfaceDnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceNetworkInterfaceDnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: DNS record FQDN (must have a dot at the end).
        :param pulumi.Input[str] dns_zone_id: DNS zone ID (if not set, private zone used).
        :param pulumi.Input[bool] ptr: When set to true, also create a PTR DNS record.
        :param pulumi.Input[int] ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ComputeInstanceNetworkInterfaceIpv6DnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        The fully qualified DNS name of this instance.
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        ptr: NotRequired[pulumi.Input[bool]]
        ttl: NotRequired[pulumi.Input[int]]
elif False:
    ComputeInstanceNetworkInterfaceIpv6DnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: The fully qualified DNS name of this instance.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        The fully qualified DNS name of this instance.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ComputeInstanceNetworkInterfaceNatDnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        DNS record FQDN (must have a dot at the end).
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        """
        DNS zone ID (if not set, private zone used).
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        When set to true, also create a PTR DNS record.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        DNS record TTL. in seconds
        """
elif False:
    ComputeInstanceNetworkInterfaceNatDnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceNetworkInterfaceNatDnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: DNS record FQDN (must have a dot at the end).
        :param pulumi.Input[str] dns_zone_id: DNS zone ID (if not set, private zone used).
        :param pulumi.Input[bool] ptr: When set to true, also create a PTR DNS record.
        :param pulumi.Input[int] ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ComputeInstancePlacementPolicyArgsDict(TypedDict):
        host_affinity_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeInstancePlacementPolicyHostAffinityRuleArgsDict']]]]
        placement_group_id: NotRequired[pulumi.Input[str]]
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        placement_group_partition: NotRequired[pulumi.Input[int]]
elif False:
    ComputeInstancePlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstancePlacementPolicyArgs:
    def __init__(__self__, *,
                 host_affinity_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstancePlacementPolicyHostAffinityRuleArgs']]]] = None,
                 placement_group_id: Optional[pulumi.Input[str]] = None,
                 placement_group_partition: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] placement_group_id: Specifies the id of the Placement Group to assign to the instance.
        """
        if host_affinity_rules is not None:
            pulumi.set(__self__, "host_affinity_rules", host_affinity_rules)
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="hostAffinityRules")
    def host_affinity_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstancePlacementPolicyHostAffinityRuleArgs']]]]:
        return pulumi.get(self, "host_affinity_rules")

    @host_affinity_rules.setter
    def host_affinity_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeInstancePlacementPolicyHostAffinityRuleArgs']]]]):
        pulumi.set(self, "host_affinity_rules", value)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_group_id", value)

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "placement_group_partition")

    @placement_group_partition.setter
    def placement_group_partition(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "placement_group_partition", value)


if not MYPY:
    class ComputeInstancePlacementPolicyHostAffinityRuleArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        """
        op: pulumi.Input[str]
        """
        Affinity action. The only value supported is `IN`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of values (host IDs or host group IDs).
        """
elif False:
    ComputeInstancePlacementPolicyHostAffinityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstancePlacementPolicyHostAffinityRuleArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 op: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        :param pulumi.Input[str] op: Affinity action. The only value supported is `IN`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of values (host IDs or host group IDs).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        Affinity action. The only value supported is `IN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of values (host IDs or host group IDs).
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ComputeInstanceResourcesArgsDict(TypedDict):
        cores: pulumi.Input[int]
        """
        CPU cores for the instance.
        """
        memory: pulumi.Input[float]
        """
        Memory size in GB.
        """
        core_fraction: NotRequired[pulumi.Input[int]]
        """
        If provided, specifies baseline performance for a core as a percent.
        """
        gpus: NotRequired[pulumi.Input[int]]
        """
        If provided, specifies the number of GPU devices for the instance
        """
elif False:
    ComputeInstanceResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceResourcesArgs:
    def __init__(__self__, *,
                 cores: pulumi.Input[int],
                 memory: pulumi.Input[float],
                 core_fraction: Optional[pulumi.Input[int]] = None,
                 gpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cores: CPU cores for the instance.
        :param pulumi.Input[float] memory: Memory size in GB.
        :param pulumi.Input[int] core_fraction: If provided, specifies baseline performance for a core as a percent.
        :param pulumi.Input[int] gpus: If provided, specifies the number of GPU devices for the instance
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[int]:
        """
        CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[float]:
        """
        Memory size in GB.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[pulumi.Input[int]]:
        """
        If provided, specifies baseline performance for a core as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @core_fraction.setter
    def core_fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "core_fraction", value)

    @property
    @pulumi.getter
    def gpus(self) -> Optional[pulumi.Input[int]]:
        """
        If provided, specifies the number of GPU devices for the instance
        """
        return pulumi.get(self, "gpus")

    @gpus.setter
    def gpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpus", value)


if not MYPY:
    class ComputeInstanceSchedulingPolicyArgsDict(TypedDict):
        preemptible: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
elif False:
    ComputeInstanceSchedulingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceSchedulingPolicyArgs:
    def __init__(__self__, *,
                 preemptible: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] preemptible: Specifies if the instance is preemptible. Defaults to false.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preemptible", value)


if not MYPY:
    class ComputeInstanceSecondaryDiskArgsDict(TypedDict):
        disk_id: pulumi.Input[str]
        """
        ID of the disk that is attached to the instance.
        """
        auto_delete: NotRequired[pulumi.Input[bool]]
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is false.
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
elif False:
    ComputeInstanceSecondaryDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceSecondaryDiskArgs:
    def __init__(__self__, *,
                 disk_id: pulumi.Input[str],
                 auto_delete: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disk_id: ID of the disk that is attached to the instance.
        :param pulumi.Input[bool] auto_delete: Whether the disk is auto-deleted when the instance is deleted. The default value is false.
        :param pulumi.Input[str] device_name: Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        :param pulumi.Input[str] mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "disk_id", disk_id)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> pulumi.Input[str]:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_id", value)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is false.
        """
        return pulumi.get(self, "auto_delete")

    @auto_delete.setter
    def auto_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_delete", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ComputeSnapshotHardwareGenerationArgsDict(TypedDict):
        generation2_features: NotRequired[pulumi.Input['ComputeSnapshotHardwareGenerationGeneration2FeaturesArgsDict']]
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        legacy_features: NotRequired[pulumi.Input['ComputeSnapshotHardwareGenerationLegacyFeaturesArgsDict']]
        """
        Defines the first known hardware generation and its features, which are:
        """
elif False:
    ComputeSnapshotHardwareGenerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeSnapshotHardwareGenerationArgs:
    def __init__(__self__, *,
                 generation2_features: Optional[pulumi.Input['ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs']] = None,
                 legacy_features: Optional[pulumi.Input['ComputeSnapshotHardwareGenerationLegacyFeaturesArgs']] = None):
        """
        :param pulumi.Input['ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs'] generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param pulumi.Input['ComputeSnapshotHardwareGenerationLegacyFeaturesArgs'] legacy_features: Defines the first known hardware generation and its features, which are:
        """
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional[pulumi.Input['ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs']]:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @generation2_features.setter
    def generation2_features(self, value: Optional[pulumi.Input['ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs']]):
        pulumi.set(self, "generation2_features", value)

    @property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional[pulumi.Input['ComputeSnapshotHardwareGenerationLegacyFeaturesArgs']]:
        """
        Defines the first known hardware generation and its features, which are:
        """
        return pulumi.get(self, "legacy_features")

    @legacy_features.setter
    def legacy_features(self, value: Optional[pulumi.Input['ComputeSnapshotHardwareGenerationLegacyFeaturesArgs']]):
        pulumi.set(self, "legacy_features", value)


if not MYPY:
    class ComputeSnapshotHardwareGenerationGeneration2FeaturesArgsDict(TypedDict):
        pass
elif False:
    ComputeSnapshotHardwareGenerationGeneration2FeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeSnapshotHardwareGenerationLegacyFeaturesArgsDict(TypedDict):
        pci_topology: NotRequired[pulumi.Input[str]]
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
elif False:
    ComputeSnapshotHardwareGenerationLegacyFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeSnapshotHardwareGenerationLegacyFeaturesArgs:
    def __init__(__self__, *,
                 pci_topology: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[pulumi.Input[str]]:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")

    @pci_topology.setter
    def pci_topology(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pci_topology", value)


if not MYPY:
    class ComputeSnapshotScheduleSchedulePolicyArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Cron expression to schedule snapshots (in cron format "* * * * *").
        """
        start_at: NotRequired[pulumi.Input[str]]
        """
        Time to start the snapshot schedule (in format RFC3339 "2006-01-02T15:04:05Z07:00"). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
elif False:
    ComputeSnapshotScheduleSchedulePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeSnapshotScheduleSchedulePolicyArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 start_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Cron expression to schedule snapshots (in cron format "* * * * *").
        :param pulumi.Input[str] start_at: Time to start the snapshot schedule (in format RFC3339 "2006-01-02T15:04:05Z07:00"). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if start_at is not None:
            pulumi.set(__self__, "start_at", start_at)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Cron expression to schedule snapshots (in cron format "* * * * *").
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="startAt")
    def start_at(self) -> Optional[pulumi.Input[str]]:
        """
        Time to start the snapshot schedule (in format RFC3339 "2006-01-02T15:04:05Z07:00"). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
        return pulumi.get(self, "start_at")

    @start_at.setter
    def start_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_at", value)


if not MYPY:
    class ComputeSnapshotScheduleSnapshotSpecArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Description to assign to snapshots created by this snapshot schedule.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
elif False:
    ComputeSnapshotScheduleSnapshotSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeSnapshotScheduleSnapshotSpecArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] description: Description to assign to snapshots created by this snapshot schedule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description to assign to snapshots created by this snapshot schedule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class ContainerRepositoryLifecyclePolicyRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the lifecycle policy.
        """
        expire_period: NotRequired[pulumi.Input[str]]
        """
        The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        """
        retained_top: NotRequired[pulumi.Input[int]]
        """
        The number of images to be retained even if the expire_period already expired.
        """
        tag_regexp: NotRequired[pulumi.Input[str]]
        """
        Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        """
        untagged: NotRequired[pulumi.Input[bool]]
        """
        If enabled, rules apply to untagged Docker images.
        """
elif False:
    ContainerRepositoryLifecyclePolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRepositoryLifecyclePolicyRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expire_period: Optional[pulumi.Input[str]] = None,
                 retained_top: Optional[pulumi.Input[int]] = None,
                 tag_regexp: Optional[pulumi.Input[str]] = None,
                 untagged: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] description: Description of the lifecycle policy.
        :param pulumi.Input[str] expire_period: The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        :param pulumi.Input[int] retained_top: The number of images to be retained even if the expire_period already expired.
        :param pulumi.Input[str] tag_regexp: Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        :param pulumi.Input[bool] untagged: If enabled, rules apply to untagged Docker images.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expire_period is not None:
            pulumi.set(__self__, "expire_period", expire_period)
        if retained_top is not None:
            pulumi.set(__self__, "retained_top", retained_top)
        if tag_regexp is not None:
            pulumi.set(__self__, "tag_regexp", tag_regexp)
        if untagged is not None:
            pulumi.set(__self__, "untagged", untagged)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the lifecycle policy.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="expirePeriod")
    def expire_period(self) -> Optional[pulumi.Input[str]]:
        """
        The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        """
        return pulumi.get(self, "expire_period")

    @expire_period.setter
    def expire_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expire_period", value)

    @property
    @pulumi.getter(name="retainedTop")
    def retained_top(self) -> Optional[pulumi.Input[int]]:
        """
        The number of images to be retained even if the expire_period already expired.
        """
        return pulumi.get(self, "retained_top")

    @retained_top.setter
    def retained_top(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retained_top", value)

    @property
    @pulumi.getter(name="tagRegexp")
    def tag_regexp(self) -> Optional[pulumi.Input[str]]:
        """
        Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        """
        return pulumi.get(self, "tag_regexp")

    @tag_regexp.setter
    def tag_regexp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_regexp", value)

    @property
    @pulumi.getter
    def untagged(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, rules apply to untagged Docker images.
        """
        return pulumi.get(self, "untagged")

    @untagged.setter
    def untagged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "untagged", value)


if not MYPY:
    class DataprocClusterClusterConfigArgsDict(TypedDict):
        subcluster_specs: pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecArgsDict']]]
        """
        Configuration of the Yandex Data Processing subcluster. The structure is documented below.
        """
        hadoop: NotRequired[pulumi.Input['DataprocClusterClusterConfigHadoopArgsDict']]
        """
        Yandex Data Processing specific options. The structure is documented below.
        """
        version_id: NotRequired[pulumi.Input[str]]
        """
        Version of Yandex Data Processing image.
        """
elif False:
    DataprocClusterClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataprocClusterClusterConfigArgs:
    def __init__(__self__, *,
                 subcluster_specs: pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecArgs']]],
                 hadoop: Optional[pulumi.Input['DataprocClusterClusterConfigHadoopArgs']] = None,
                 version_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecArgs']]] subcluster_specs: Configuration of the Yandex Data Processing subcluster. The structure is documented below.
        :param pulumi.Input['DataprocClusterClusterConfigHadoopArgs'] hadoop: Yandex Data Processing specific options. The structure is documented below.
        :param pulumi.Input[str] version_id: Version of Yandex Data Processing image.
        """
        pulumi.set(__self__, "subcluster_specs", subcluster_specs)
        if hadoop is not None:
            pulumi.set(__self__, "hadoop", hadoop)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="subclusterSpecs")
    def subcluster_specs(self) -> pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecArgs']]]:
        """
        Configuration of the Yandex Data Processing subcluster. The structure is documented below.
        """
        return pulumi.get(self, "subcluster_specs")

    @subcluster_specs.setter
    def subcluster_specs(self, value: pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecArgs']]]):
        pulumi.set(self, "subcluster_specs", value)

    @property
    @pulumi.getter
    def hadoop(self) -> Optional[pulumi.Input['DataprocClusterClusterConfigHadoopArgs']]:
        """
        Yandex Data Processing specific options. The structure is documented below.
        """
        return pulumi.get(self, "hadoop")

    @hadoop.setter
    def hadoop(self, value: Optional[pulumi.Input['DataprocClusterClusterConfigHadoopArgs']]):
        pulumi.set(self, "hadoop", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[str]]:
        """
        Version of Yandex Data Processing image.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class DataprocClusterClusterConfigHadoopArgsDict(TypedDict):
        initialization_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigHadoopInitializationActionArgsDict']]]]
        """
        List of initialization scripts. The structure is documented below.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value pairs that are used to configure cluster services.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of services to run on Yandex Data Processing cluster.
        """
        ssh_public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://cloud.yandex.com/docs/data-proc/operations/connect).
        """
elif False:
    DataprocClusterClusterConfigHadoopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataprocClusterClusterConfigHadoopArgs:
    def __init__(__self__, *,
                 initialization_actions: Optional[pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigHadoopInitializationActionArgs']]]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigHadoopInitializationActionArgs']]] initialization_actions: List of initialization scripts. The structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: A set of key/value pairs that are used to configure cluster services.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of services to run on Yandex Data Processing cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_public_keys: List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://cloud.yandex.com/docs/data-proc/operations/connect).
        """
        if initialization_actions is not None:
            pulumi.set(__self__, "initialization_actions", initialization_actions)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @property
    @pulumi.getter(name="initializationActions")
    def initialization_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigHadoopInitializationActionArgs']]]]:
        """
        List of initialization scripts. The structure is documented below.
        """
        return pulumi.get(self, "initialization_actions")

    @initialization_actions.setter
    def initialization_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataprocClusterClusterConfigHadoopInitializationActionArgs']]]]):
        pulumi.set(self, "initialization_actions", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value pairs that are used to configure cluster services.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of services to run on Yandex Data Processing cluster.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://cloud.yandex.com/docs/data-proc/operations/connect).
        """
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)


if not MYPY:
    class DataprocClusterClusterConfigHadoopInitializationActionArgsDict(TypedDict):
        uri: pulumi.Input[str]
        """
        Script URI.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of arguments of the initialization script.
        """
        timeout: NotRequired[pulumi.Input[str]]
        """
        Script execution timeout, in seconds.
        """
elif False:
    DataprocClusterClusterConfigHadoopInitializationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataprocClusterClusterConfigHadoopInitializationActionArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: Script URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: List of arguments of the initialization script.
        :param pulumi.Input[str] timeout: Script execution timeout, in seconds.
        """
        pulumi.set(__self__, "uri", uri)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Script URI.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of arguments of the initialization script.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Script execution timeout, in seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class DataprocClusterClusterConfigSubclusterSpecArgsDict(TypedDict):
        hosts_count: pulumi.Input[int]
        """
        Number of hosts within Yandex Data Processing subcluster.
        """
        name: pulumi.Input[str]
        """
        Name of the Yandex Data Processing subcluster.
        """
        resources: pulumi.Input['DataprocClusterClusterConfigSubclusterSpecResourcesArgsDict']
        """
        Resources allocated to each host of the Yandex Data Processing subcluster. The structure is documented below.
        """
        role: pulumi.Input[str]
        """
        Role of the subcluster in the Yandex Data Processing cluster.
        """
        subnet_id: pulumi.Input[str]
        """
        The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        If true then assign public IP addresses to the hosts of the subclusters.
        """
        autoscaling_config: NotRequired[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgsDict']]
        """
        Autoscaling configuration for compute subclusters.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) ID of a new Yandex Data Processing cluster.
        """
elif False:
    DataprocClusterClusterConfigSubclusterSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataprocClusterClusterConfigSubclusterSpecArgs:
    def __init__(__self__, *,
                 hosts_count: pulumi.Input[int],
                 name: pulumi.Input[str],
                 resources: pulumi.Input['DataprocClusterClusterConfigSubclusterSpecResourcesArgs'],
                 role: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 autoscaling_config: Optional[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] hosts_count: Number of hosts within Yandex Data Processing subcluster.
        :param pulumi.Input[str] name: Name of the Yandex Data Processing subcluster.
        :param pulumi.Input['DataprocClusterClusterConfigSubclusterSpecResourcesArgs'] resources: Resources allocated to each host of the Yandex Data Processing subcluster. The structure is documented below.
        :param pulumi.Input[str] role: Role of the subcluster in the Yandex Data Processing cluster.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        :param pulumi.Input[bool] assign_public_ip: If true then assign public IP addresses to the hosts of the subclusters.
        :param pulumi.Input['DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs'] autoscaling_config: Autoscaling configuration for compute subclusters.
        :param pulumi.Input[str] id: (Computed) ID of a new Yandex Data Processing cluster.
        """
        pulumi.set(__self__, "hosts_count", hosts_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if autoscaling_config is not None:
            pulumi.set(__self__, "autoscaling_config", autoscaling_config)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="hostsCount")
    def hosts_count(self) -> pulumi.Input[int]:
        """
        Number of hosts within Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "hosts_count")

    @hosts_count.setter
    def hosts_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "hosts_count", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['DataprocClusterClusterConfigSubclusterSpecResourcesArgs']:
        """
        Resources allocated to each host of the Yandex Data Processing subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['DataprocClusterClusterConfigSubclusterSpecResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        Role of the subcluster in the Yandex Data Processing cluster.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        If true then assign public IP addresses to the hosts of the subclusters.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="autoscalingConfig")
    def autoscaling_config(self) -> Optional[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs']]:
        """
        Autoscaling configuration for compute subclusters.
        """
        return pulumi.get(self, "autoscaling_config")

    @autoscaling_config.setter
    def autoscaling_config(self, value: Optional[pulumi.Input['DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs']]):
        pulumi.set(self, "autoscaling_config", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) ID of a new Yandex Data Processing cluster.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgsDict(TypedDict):
        max_hosts_count: pulumi.Input[int]
        """
        Maximum number of nodes in autoscaling subclusters.
        """
        cpu_utilization_target: NotRequired[pulumi.Input[str]]
        """
        Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        """
        decommission_timeout: NotRequired[pulumi.Input[str]]
        """
        Timeout to gracefully decommission nodes during downscaling. In seconds.
        """
        measurement_duration: NotRequired[pulumi.Input[str]]
        """
        Time in seconds allotted for averaging metrics.
        """
        preemptible: NotRequired[pulumi.Input[bool]]
        """
        Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        """
        stabilization_duration: NotRequired[pulumi.Input[str]]
        """
        Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        """
        warmup_duration: NotRequired[pulumi.Input[str]]
        """
        The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
elif False:
    DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs:
    def __init__(__self__, *,
                 max_hosts_count: pulumi.Input[int],
                 cpu_utilization_target: Optional[pulumi.Input[str]] = None,
                 decommission_timeout: Optional[pulumi.Input[str]] = None,
                 measurement_duration: Optional[pulumi.Input[str]] = None,
                 preemptible: Optional[pulumi.Input[bool]] = None,
                 stabilization_duration: Optional[pulumi.Input[str]] = None,
                 warmup_duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] max_hosts_count: Maximum number of nodes in autoscaling subclusters.
        :param pulumi.Input[str] cpu_utilization_target: Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        :param pulumi.Input[str] decommission_timeout: Timeout to gracefully decommission nodes during downscaling. In seconds.
        :param pulumi.Input[str] measurement_duration: Time in seconds allotted for averaging metrics.
        :param pulumi.Input[bool] preemptible: Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        :param pulumi.Input[str] stabilization_duration: Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        :param pulumi.Input[str] warmup_duration: The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        pulumi.set(__self__, "max_hosts_count", max_hosts_count)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if decommission_timeout is not None:
            pulumi.set(__self__, "decommission_timeout", decommission_timeout)
        if measurement_duration is not None:
            pulumi.set(__self__, "measurement_duration", measurement_duration)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="maxHostsCount")
    def max_hosts_count(self) -> pulumi.Input[int]:
        """
        Maximum number of nodes in autoscaling subclusters.
        """
        return pulumi.get(self, "max_hosts_count")

    @max_hosts_count.setter
    def max_hosts_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_hosts_count", value)

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[pulumi.Input[str]]:
        """
        Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @cpu_utilization_target.setter
    def cpu_utilization_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_utilization_target", value)

    @property
    @pulumi.getter(name="decommissionTimeout")
    def decommission_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout to gracefully decommission nodes during downscaling. In seconds.
        """
        return pulumi.get(self, "decommission_timeout")

    @decommission_timeout.setter
    def decommission_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decommission_timeout", value)

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> Optional[pulumi.Input[str]]:
        """
        Time in seconds allotted for averaging metrics.
        """
        return pulumi.get(self, "measurement_duration")

    @measurement_duration.setter
    def measurement_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "measurement_duration", value)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        """
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preemptible", value)

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        """
        return pulumi.get(self, "stabilization_duration")

    @stabilization_duration.setter
    def stabilization_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stabilization_duration", value)

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        return pulumi.get(self, "warmup_duration")

    @warmup_duration.setter
    def warmup_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warmup_duration", value)


if not MYPY:
    class DataprocClusterClusterConfigSubclusterSpecResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        resource_preset_id: pulumi.Input[str]
        """
        The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        """
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
elif False:
    DataprocClusterClusterConfigSubclusterSpecResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataprocClusterClusterConfigSubclusterSpecResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 resource_preset_id: pulumi.Input[str],
                 disk_type_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] resource_preset_id: The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        :param pulumi.Input[str] disk_type_id: Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        """
        The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)


if not MYPY:
    class DatatransferEndpointSettingsArgsDict(TypedDict):
        clickhouse_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceArgsDict']]
        """
        Settings specific to the ClickHouse source endpoint.
        """
        clickhouse_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetArgsDict']]
        """
        Settings specific to the ClickHouse target endpoint.
        """
        kafka_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceArgsDict']]
        """
        Settings specific to the Kafka source endpoint.
        """
        kafka_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetArgsDict']]
        """
        Settings specific to the Kafka target endpoint.
        """
        metrika_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceArgsDict']]
        mongo_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceArgsDict']]
        """
        Settings specific to the MongoDB source endpoint.
        """
        mongo_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetArgsDict']]
        """
        Settings specific to the MongoDB target endpoint.
        """
        mysql_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceArgsDict']]
        """
        Settings specific to the MySQL source endpoint.
        """
        mysql_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetArgsDict']]
        """
        Settings specific to the MySQL target endpoint.
        """
        postgres_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceArgsDict']]
        """
        Settings specific to the PostgreSQL source endpoint.
        """
        postgres_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetArgsDict']]
        """
        Settings specific to the PostgreSQL target endpoint.
        """
        ydb_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdbSourceArgsDict']]
        """
        Settings specific to the YDB source endpoint.
        """
        ydb_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdbTargetArgsDict']]
        """
        Settings specific to the YDB target endpoint.
        """
        yds_source: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceArgsDict']]
        """
        Settings specific to the YDS source endpoint.
        """
        yds_target: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsTargetArgsDict']]
        """
        Settings specific to the YDS target endpoint.

        For the documentation of the specific endpoint settings see below.
        """
elif False:
    DatatransferEndpointSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsArgs:
    def __init__(__self__, *,
                 clickhouse_source: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceArgs']] = None,
                 clickhouse_target: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetArgs']] = None,
                 kafka_source: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceArgs']] = None,
                 kafka_target: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetArgs']] = None,
                 metrika_source: Optional[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceArgs']] = None,
                 mongo_source: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceArgs']] = None,
                 mongo_target: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetArgs']] = None,
                 mysql_source: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceArgs']] = None,
                 mysql_target: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetArgs']] = None,
                 postgres_source: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceArgs']] = None,
                 postgres_target: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetArgs']] = None,
                 ydb_source: Optional[pulumi.Input['DatatransferEndpointSettingsYdbSourceArgs']] = None,
                 ydb_target: Optional[pulumi.Input['DatatransferEndpointSettingsYdbTargetArgs']] = None,
                 yds_source: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceArgs']] = None,
                 yds_target: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceArgs'] clickhouse_source: Settings specific to the ClickHouse source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetArgs'] clickhouse_target: Settings specific to the ClickHouse target endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceArgs'] kafka_source: Settings specific to the Kafka source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetArgs'] kafka_target: Settings specific to the Kafka target endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceArgs'] mongo_source: Settings specific to the MongoDB source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetArgs'] mongo_target: Settings specific to the MongoDB target endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceArgs'] mysql_source: Settings specific to the MySQL source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetArgs'] mysql_target: Settings specific to the MySQL target endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceArgs'] postgres_source: Settings specific to the PostgreSQL source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetArgs'] postgres_target: Settings specific to the PostgreSQL target endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsYdbSourceArgs'] ydb_source: Settings specific to the YDB source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsYdbTargetArgs'] ydb_target: Settings specific to the YDB target endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceArgs'] yds_source: Settings specific to the YDS source endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsYdsTargetArgs'] yds_target: Settings specific to the YDS target endpoint.
               
               For the documentation of the specific endpoint settings see below.
        """
        if clickhouse_source is not None:
            pulumi.set(__self__, "clickhouse_source", clickhouse_source)
        if clickhouse_target is not None:
            pulumi.set(__self__, "clickhouse_target", clickhouse_target)
        if kafka_source is not None:
            pulumi.set(__self__, "kafka_source", kafka_source)
        if kafka_target is not None:
            pulumi.set(__self__, "kafka_target", kafka_target)
        if metrika_source is not None:
            pulumi.set(__self__, "metrika_source", metrika_source)
        if mongo_source is not None:
            pulumi.set(__self__, "mongo_source", mongo_source)
        if mongo_target is not None:
            pulumi.set(__self__, "mongo_target", mongo_target)
        if mysql_source is not None:
            pulumi.set(__self__, "mysql_source", mysql_source)
        if mysql_target is not None:
            pulumi.set(__self__, "mysql_target", mysql_target)
        if postgres_source is not None:
            pulumi.set(__self__, "postgres_source", postgres_source)
        if postgres_target is not None:
            pulumi.set(__self__, "postgres_target", postgres_target)
        if ydb_source is not None:
            pulumi.set(__self__, "ydb_source", ydb_source)
        if ydb_target is not None:
            pulumi.set(__self__, "ydb_target", ydb_target)
        if yds_source is not None:
            pulumi.set(__self__, "yds_source", yds_source)
        if yds_target is not None:
            pulumi.set(__self__, "yds_target", yds_target)

    @property
    @pulumi.getter(name="clickhouseSource")
    def clickhouse_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceArgs']]:
        """
        Settings specific to the ClickHouse source endpoint.
        """
        return pulumi.get(self, "clickhouse_source")

    @clickhouse_source.setter
    def clickhouse_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceArgs']]):
        pulumi.set(self, "clickhouse_source", value)

    @property
    @pulumi.getter(name="clickhouseTarget")
    def clickhouse_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetArgs']]:
        """
        Settings specific to the ClickHouse target endpoint.
        """
        return pulumi.get(self, "clickhouse_target")

    @clickhouse_target.setter
    def clickhouse_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetArgs']]):
        pulumi.set(self, "clickhouse_target", value)

    @property
    @pulumi.getter(name="kafkaSource")
    def kafka_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceArgs']]:
        """
        Settings specific to the Kafka source endpoint.
        """
        return pulumi.get(self, "kafka_source")

    @kafka_source.setter
    def kafka_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceArgs']]):
        pulumi.set(self, "kafka_source", value)

    @property
    @pulumi.getter(name="kafkaTarget")
    def kafka_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetArgs']]:
        """
        Settings specific to the Kafka target endpoint.
        """
        return pulumi.get(self, "kafka_target")

    @kafka_target.setter
    def kafka_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetArgs']]):
        pulumi.set(self, "kafka_target", value)

    @property
    @pulumi.getter(name="metrikaSource")
    def metrika_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceArgs']]:
        return pulumi.get(self, "metrika_source")

    @metrika_source.setter
    def metrika_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceArgs']]):
        pulumi.set(self, "metrika_source", value)

    @property
    @pulumi.getter(name="mongoSource")
    def mongo_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceArgs']]:
        """
        Settings specific to the MongoDB source endpoint.
        """
        return pulumi.get(self, "mongo_source")

    @mongo_source.setter
    def mongo_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceArgs']]):
        pulumi.set(self, "mongo_source", value)

    @property
    @pulumi.getter(name="mongoTarget")
    def mongo_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetArgs']]:
        """
        Settings specific to the MongoDB target endpoint.
        """
        return pulumi.get(self, "mongo_target")

    @mongo_target.setter
    def mongo_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetArgs']]):
        pulumi.set(self, "mongo_target", value)

    @property
    @pulumi.getter(name="mysqlSource")
    def mysql_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceArgs']]:
        """
        Settings specific to the MySQL source endpoint.
        """
        return pulumi.get(self, "mysql_source")

    @mysql_source.setter
    def mysql_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceArgs']]):
        pulumi.set(self, "mysql_source", value)

    @property
    @pulumi.getter(name="mysqlTarget")
    def mysql_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetArgs']]:
        """
        Settings specific to the MySQL target endpoint.
        """
        return pulumi.get(self, "mysql_target")

    @mysql_target.setter
    def mysql_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetArgs']]):
        pulumi.set(self, "mysql_target", value)

    @property
    @pulumi.getter(name="postgresSource")
    def postgres_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceArgs']]:
        """
        Settings specific to the PostgreSQL source endpoint.
        """
        return pulumi.get(self, "postgres_source")

    @postgres_source.setter
    def postgres_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceArgs']]):
        pulumi.set(self, "postgres_source", value)

    @property
    @pulumi.getter(name="postgresTarget")
    def postgres_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetArgs']]:
        """
        Settings specific to the PostgreSQL target endpoint.
        """
        return pulumi.get(self, "postgres_target")

    @postgres_target.setter
    def postgres_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetArgs']]):
        pulumi.set(self, "postgres_target", value)

    @property
    @pulumi.getter(name="ydbSource")
    def ydb_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdbSourceArgs']]:
        """
        Settings specific to the YDB source endpoint.
        """
        return pulumi.get(self, "ydb_source")

    @ydb_source.setter
    def ydb_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdbSourceArgs']]):
        pulumi.set(self, "ydb_source", value)

    @property
    @pulumi.getter(name="ydbTarget")
    def ydb_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdbTargetArgs']]:
        """
        Settings specific to the YDB target endpoint.
        """
        return pulumi.get(self, "ydb_target")

    @ydb_target.setter
    def ydb_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdbTargetArgs']]):
        pulumi.set(self, "ydb_target", value)

    @property
    @pulumi.getter(name="ydsSource")
    def yds_source(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceArgs']]:
        """
        Settings specific to the YDS source endpoint.
        """
        return pulumi.get(self, "yds_source")

    @yds_source.setter
    def yds_source(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceArgs']]):
        pulumi.set(self, "yds_source", value)

    @property
    @pulumi.getter(name="ydsTarget")
    def yds_target(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetArgs']]:
        """
        Settings specific to the YDS target endpoint.

        For the documentation of the specific endpoint settings see below.
        """
        return pulumi.get(self, "yds_target")

    @yds_target.setter
    def yds_target(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetArgs']]):
        pulumi.set(self, "yds_target", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceArgsDict(TypedDict):
        clickhouse_cluster_name: NotRequired[pulumi.Input[str]]
        """
        Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of tables that should not be transferred.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of tables that should be transferred. Leave empty if all tables should be transferred.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceArgs:
    def __init__(__self__, *,
                 clickhouse_cluster_name: Optional[pulumi.Input[str]] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionArgs']] = None,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] clickhouse_cluster_name: Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: The list of tables that should not be transferred.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: The list of tables that should be transferred. Leave empty if all tables should be transferred.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if clickhouse_cluster_name is not None:
            pulumi.set(__self__, "clickhouse_cluster_name", clickhouse_cluster_name)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="clickhouseClusterName")
    def clickhouse_cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        """
        return pulumi.get(self, "clickhouse_cluster_name")

    @clickhouse_cluster_name.setter
    def clickhouse_cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clickhouse_cluster_name", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of tables that should not be transferred.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of tables that should be transferred. Leave empty if all tables should be transferred.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionArgsDict(TypedDict):
        connection_options: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgsDict']]
        """
        Connection options. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionArgs:
    def __init__(__self__, *,
                 connection_options: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgs'] connection_options: Connection options. The structure is documented below.
        """
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgs']]:
        """
        Connection options. The structure is documented below.
        """
        return pulumi.get(self, "connection_options")

    @connection_options.setter
    def connection_options(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgs']]):
        pulumi.set(self, "connection_options", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgsDict(TypedDict):
        database: NotRequired[pulumi.Input[str]]
        """
        Database name.
        """
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed ClickHouse cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgsDict']]
        """
        Connection settings of the on-premise ClickHouse server.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for database access.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsArgs:
    def __init__(__self__, *,
                 database: Optional[pulumi.Input[str]] = None,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgs']] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgs']] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed ClickHouse cluster.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgs'] on_premise: Connection settings of the on-premise ClickHouse server.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[str] user: User for database access.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed ClickHouse cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgs']]:
        """
        Connection settings of the on-premise ClickHouse server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgsDict(TypedDict):
        http_port: NotRequired[pulumi.Input[int]]
        """
        TCP port number for the HTTP interface of the ClickHouse server.
        """
        native_port: NotRequired[pulumi.Input[int]]
        """
        TCP port number for the native interface of the ClickHouse server.
        """
        shards: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgsDict']]]]
        """
        The list of ClickHouse shards. The structure is documented below.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseArgs:
    def __init__(__self__, *,
                 http_port: Optional[pulumi.Input[int]] = None,
                 native_port: Optional[pulumi.Input[int]] = None,
                 shards: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgs']]]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[int] http_port: TCP port number for the HTTP interface of the ClickHouse server.
        :param pulumi.Input[int] native_port: TCP port number for the native interface of the ClickHouse server.
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgs']]] shards: The list of ClickHouse shards. The structure is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if native_port is not None:
            pulumi.set(__self__, "native_port", native_port)
        if shards is not None:
            pulumi.set(__self__, "shards", shards)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port number for the HTTP interface of the ClickHouse server.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="nativePort")
    def native_port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port number for the native interface of the ClickHouse server.
        """
        return pulumi.get(self, "native_port")

    @native_port.setter
    def native_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "native_port", value)

    @property
    @pulumi.getter
    def shards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgs']]]]:
        """
        The list of ClickHouse shards. The structure is documented below.
        """
        return pulumi.get(self, "shards")

    @shards.setter
    def shards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgs']]]]):
        pulumi.set(self, "shards", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ClickHouse server host names.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShardArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: List of ClickHouse server host names.
        :param pulumi.Input[str] name: Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ClickHouse server host names.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetArgsDict(TypedDict):
        alt_names: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetAltNameArgsDict']]]]
        """
        Table renaming rules. The structure is documented below.
        """
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        How to clean collections when activating the transfer. One of "CLICKHOUSE_CLEANUP_POLICY_DISABLED" or "CLICKHOUSE_CLEANUP_POLICY_DROP".
        """
        clickhouse_cluster_name: NotRequired[pulumi.Input[str]]
        """
        Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        sharding: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingArgsDict']]
        """
        Shard selection rules for the data being transferred. The structure is documented below.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetArgs:
    def __init__(__self__, *,
                 alt_names: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetAltNameArgs']]]] = None,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 clickhouse_cluster_name: Optional[pulumi.Input[str]] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sharding: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingArgs']] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetAltNameArgs']]] alt_names: Table renaming rules. The structure is documented below.
        :param pulumi.Input[str] cleanup_policy: How to clean collections when activating the transfer. One of "CLICKHOUSE_CLEANUP_POLICY_DISABLED" or "CLICKHOUSE_CLEANUP_POLICY_DROP".
        :param pulumi.Input[str] clickhouse_cluster_name: Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingArgs'] sharding: Shard selection rules for the data being transferred. The structure is documented below.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if alt_names is not None:
            pulumi.set(__self__, "alt_names", alt_names)
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if clickhouse_cluster_name is not None:
            pulumi.set(__self__, "clickhouse_cluster_name", clickhouse_cluster_name)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if sharding is not None:
            pulumi.set(__self__, "sharding", sharding)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="altNames")
    def alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetAltNameArgs']]]]:
        """
        Table renaming rules. The structure is documented below.
        """
        return pulumi.get(self, "alt_names")

    @alt_names.setter
    def alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetAltNameArgs']]]]):
        pulumi.set(self, "alt_names", value)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        How to clean collections when activating the transfer. One of "CLICKHOUSE_CLEANUP_POLICY_DISABLED" or "CLICKHOUSE_CLEANUP_POLICY_DROP".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter(name="clickhouseClusterName")
    def clickhouse_cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        """
        return pulumi.get(self, "clickhouse_cluster_name")

    @clickhouse_cluster_name.setter
    def clickhouse_cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clickhouse_cluster_name", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def sharding(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingArgs']]:
        """
        Shard selection rules for the data being transferred. The structure is documented below.
        """
        return pulumi.get(self, "sharding")

    @sharding.setter
    def sharding(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingArgs']]):
        pulumi.set(self, "sharding", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetAltNameArgsDict(TypedDict):
        from_name: NotRequired[pulumi.Input[str]]
        to_name: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsClickhouseTargetAltNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetAltNameArgs:
    def __init__(__self__, *,
                 from_name: Optional[pulumi.Input[str]] = None,
                 to_name: Optional[pulumi.Input[str]] = None):
        if from_name is not None:
            pulumi.set(__self__, "from_name", from_name)
        if to_name is not None:
            pulumi.set(__self__, "to_name", to_name)

    @property
    @pulumi.getter(name="fromName")
    def from_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_name")

    @from_name.setter
    def from_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_name", value)

    @property
    @pulumi.getter(name="toName")
    def to_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "to_name")

    @to_name.setter
    def to_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_name", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionArgsDict(TypedDict):
        connection_options: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgsDict']]
        """
        Connection options. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionArgs:
    def __init__(__self__, *,
                 connection_options: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs'] connection_options: Connection options. The structure is documented below.
        """
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs']]:
        """
        Connection options. The structure is documented below.
        """
        return pulumi.get(self, "connection_options")

    @connection_options.setter
    def connection_options(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs']]):
        pulumi.set(self, "connection_options", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgsDict(TypedDict):
        database: NotRequired[pulumi.Input[str]]
        """
        Database name.
        """
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed ClickHouse cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgsDict']]
        """
        Connection settings of the on-premise ClickHouse server.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for database access.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs:
    def __init__(__self__, *,
                 database: Optional[pulumi.Input[str]] = None,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs']] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs']] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed ClickHouse cluster.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs'] on_premise: Connection settings of the on-premise ClickHouse server.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[str] user: User for database access.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed ClickHouse cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs']]:
        """
        Connection settings of the on-premise ClickHouse server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgsDict(TypedDict):
        http_port: NotRequired[pulumi.Input[int]]
        """
        TCP port number for the HTTP interface of the ClickHouse server.
        """
        native_port: NotRequired[pulumi.Input[int]]
        """
        TCP port number for the native interface of the ClickHouse server.
        """
        shards: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgsDict']]]]
        """
        The list of ClickHouse shards. The structure is documented below.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs:
    def __init__(__self__, *,
                 http_port: Optional[pulumi.Input[int]] = None,
                 native_port: Optional[pulumi.Input[int]] = None,
                 shards: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs']]]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[int] http_port: TCP port number for the HTTP interface of the ClickHouse server.
        :param pulumi.Input[int] native_port: TCP port number for the native interface of the ClickHouse server.
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs']]] shards: The list of ClickHouse shards. The structure is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if native_port is not None:
            pulumi.set(__self__, "native_port", native_port)
        if shards is not None:
            pulumi.set(__self__, "shards", shards)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port number for the HTTP interface of the ClickHouse server.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="nativePort")
    def native_port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port number for the native interface of the ClickHouse server.
        """
        return pulumi.get(self, "native_port")

    @native_port.setter
    def native_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "native_port", value)

    @property
    @pulumi.getter
    def shards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs']]]]:
        """
        The list of ClickHouse shards. The structure is documented below.
        """
        return pulumi.get(self, "shards")

    @shards.setter
    def shards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs']]]]):
        pulumi.set(self, "shards", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ClickHouse server host names.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: List of ClickHouse server host names.
        :param pulumi.Input[str] name: Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ClickHouse server host names.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingArgsDict(TypedDict):
        column_value_hash: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgsDict']]
        """
        Shard data by the hash value of the specified column. The structure is documented below.
        """
        custom_mapping: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgsDict']]
        """
        A custom shard mapping by the value of the specified column. The structure is documented below.
        """
        round_robin: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgsDict']]
        """
        Distribute incoming rows between ClickHouse shards in a round-robin manner. Specify as an empty block to enable.
        """
        transfer_id: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgsDict']]
        """
        Shard data by ID of the transfer.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingArgs:
    def __init__(__self__, *,
                 column_value_hash: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs']] = None,
                 custom_mapping: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs']] = None,
                 round_robin: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs']] = None,
                 transfer_id: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs'] column_value_hash: Shard data by the hash value of the specified column. The structure is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs'] custom_mapping: A custom shard mapping by the value of the specified column. The structure is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs'] round_robin: Distribute incoming rows between ClickHouse shards in a round-robin manner. Specify as an empty block to enable.
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs'] transfer_id: Shard data by ID of the transfer.
        """
        if column_value_hash is not None:
            pulumi.set(__self__, "column_value_hash", column_value_hash)
        if custom_mapping is not None:
            pulumi.set(__self__, "custom_mapping", custom_mapping)
        if round_robin is not None:
            pulumi.set(__self__, "round_robin", round_robin)
        if transfer_id is not None:
            pulumi.set(__self__, "transfer_id", transfer_id)

    @property
    @pulumi.getter(name="columnValueHash")
    def column_value_hash(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs']]:
        """
        Shard data by the hash value of the specified column. The structure is documented below.
        """
        return pulumi.get(self, "column_value_hash")

    @column_value_hash.setter
    def column_value_hash(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs']]):
        pulumi.set(self, "column_value_hash", value)

    @property
    @pulumi.getter(name="customMapping")
    def custom_mapping(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs']]:
        """
        A custom shard mapping by the value of the specified column. The structure is documented below.
        """
        return pulumi.get(self, "custom_mapping")

    @custom_mapping.setter
    def custom_mapping(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs']]):
        pulumi.set(self, "custom_mapping", value)

    @property
    @pulumi.getter(name="roundRobin")
    def round_robin(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs']]:
        """
        Distribute incoming rows between ClickHouse shards in a round-robin manner. Specify as an empty block to enable.
        """
        return pulumi.get(self, "round_robin")

    @round_robin.setter
    def round_robin(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs']]):
        pulumi.set(self, "round_robin", value)

    @property
    @pulumi.getter(name="transferId")
    def transfer_id(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs']]:
        """
        Shard data by ID of the transfer.
        """
        return pulumi.get(self, "transfer_id")

    @transfer_id.setter
    def transfer_id(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs']]):
        pulumi.set(self, "transfer_id", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[str]]
        """
        The name of the column to calculate hash from.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] column_name: The name of the column to calculate hash from.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column to calculate hash from.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgsDict(TypedDict):
        column_name: NotRequired[pulumi.Input[str]]
        """
        The name of the column to inspect when deciding the shard to chose for an incoming row.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgsDict']]]]
        """
        The mapping of the specified column values to the shard names. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[str]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] column_name: The name of the column to inspect when deciding the shard to chose for an incoming row.
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs']]] mappings: The mapping of the specified column values to the shard names. The structure is documented below.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column to inspect when deciding the shard to chose for an incoming row.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs']]]]:
        """
        The mapping of the specified column values to the shard names. The structure is documented below.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgsDict(TypedDict):
        column_value: NotRequired[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgsDict']]
        """
        The value of the column. Currently only the string columns are supported. The structure is documented below.
        """
        shard_name: NotRequired[pulumi.Input[str]]
        """
        The name of the shard into which all the rows with the specified `column_value` will be written.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs:
    def __init__(__self__, *,
                 column_value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs']] = None,
                 shard_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs'] column_value: The value of the column. Currently only the string columns are supported. The structure is documented below.
        :param pulumi.Input[str] shard_name: The name of the shard into which all the rows with the specified `column_value` will be written.
        """
        if column_value is not None:
            pulumi.set(__self__, "column_value", column_value)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)

    @property
    @pulumi.getter(name="columnValue")
    def column_value(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs']]:
        """
        The value of the column. Currently only the string columns are supported. The structure is documented below.
        """
        return pulumi.get(self, "column_value")

    @column_value.setter
    def column_value(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs']]):
        pulumi.set(self, "column_value", value)

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the shard into which all the rows with the specified `column_value` will be written.
        """
        return pulumi.get(self, "shard_name")

    @shard_name.setter
    def shard_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shard_name", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgsDict(TypedDict):
        string_value: NotRequired[pulumi.Input[str]]
        """
        The string value of the column.
        """
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs:
    def __init__(__self__, *,
                 string_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] string_value: The string value of the column.
        """
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        The string value of the column.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthArgsDict']]
        """
        Authentication data.
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionArgsDict']]
        """
        Connection settings.
        """
        parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserArgsDict']]
        """
        Data parsing parameters. If not set, the source messages are read in raw.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        topic_name: NotRequired[pulumi.Input[str]]
        """
        Deprecated. Please use `topic_names` instead.
        """
        topic_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of full source topic names.
        """
        transformer: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceTransformerArgsDict']]
        """
        Transform data with a custom Cloud Function.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthArgs']] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionArgs']] = None,
                 parser: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topic_name: Optional[pulumi.Input[str]] = None,
                 topic_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 transformer: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceTransformerArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthArgs'] auth: Authentication data.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionArgs'] connection: Connection settings.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserArgs'] parser: Data parsing parameters. If not set, the source messages are read in raw.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] topic_name: Deprecated. Please use `topic_names` instead.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topic_names: The list of full source topic names.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceTransformerArgs'] transformer: Transform data with a custom Cloud Function.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)
        if topic_names is not None:
            pulumi.set(__self__, "topic_names", topic_names)
        if transformer is not None:
            pulumi.set(__self__, "transformer", transformer)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthArgs']]:
        """
        Authentication data.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionArgs']]:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserArgs']]:
        """
        Data parsing parameters. If not set, the source messages are read in raw.
        """
        return pulumi.get(self, "parser")

    @parser.setter
    def parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserArgs']]):
        pulumi.set(self, "parser", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated. Please use `topic_names` instead.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="topicNames")
    def topic_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of full source topic names.
        """
        return pulumi.get(self, "topic_names")

    @topic_names.setter
    def topic_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topic_names", value)

    @property
    @pulumi.getter
    def transformer(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceTransformerArgs']]:
        """
        Transform data with a custom Cloud Function.
        """
        return pulumi.get(self, "transformer")

    @transformer.setter
    def transformer(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceTransformerArgs']]):
        pulumi.set(self, "transformer", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceAuthArgsDict(TypedDict):
        no_auth: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgsDict']]
        """
        Connection without authentication data.
        """
        sasl: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslArgsDict']]
        """
        Authentication using sasl.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceAuthArgs:
    def __init__(__self__, *,
                 no_auth: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgs']] = None,
                 sasl: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgs'] no_auth: Connection without authentication data.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslArgs'] sasl: Authentication using sasl.
        """
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgs']]:
        """
        Connection without authentication data.
        """
        return pulumi.get(self, "no_auth")

    @no_auth.setter
    def no_auth(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgs']]):
        pulumi.set(self, "no_auth", value)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslArgs']]:
        """
        Authentication using sasl.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslArgs']]):
        pulumi.set(self, "sasl", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceAuthNoAuthArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceAuthSaslArgsDict(TypedDict):
        mechanism: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgsDict']]
        user: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsKafkaSourceAuthSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceAuthSaslArgs:
    def __init__(__self__, *,
                 mechanism: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgs']] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mechanism")

    @mechanism.setter
    def mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mechanism", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgs']]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceAuthSaslPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceConnectionArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed Kafka cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgsDict']]
        """
        Connection settings of the on-premise Kafka server.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceConnectionArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgs']] = None):
        """
        :param pulumi.Input[str] cluster_id: Identifier of the Managed Kafka cluster.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgs'] on_premise: Connection settings of the on-premise Kafka server.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed Kafka cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgs']]:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgsDict(TypedDict):
        broker_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Kafka broker URLs.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseArgs:
    def __init__(__self__, *,
                 broker_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] broker_urls: List of Kafka broker URLs.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if broker_urls is not None:
            pulumi.set(__self__, "broker_urls", broker_urls)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="brokerUrls")
    def broker_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Kafka broker URLs.
        """
        return pulumi.get(self, "broker_urls")

    @broker_urls.setter
    def broker_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "broker_urls", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserArgsDict(TypedDict):
        audit_trails_v1_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgsDict']]
        """
        Parse Audit Trails data. Empty struct.
        """
        cloud_logging_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgsDict']]
        """
        Parse Cloud Logging data. Empty struct.
        """
        json_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserArgsDict']]
        """
        Parse data in json format.
        """
        tskv_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserArgsDict']]
        """
        Parse data if tskv format.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserArgs:
    def __init__(__self__, *,
                 audit_trails_v1_parser: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs']] = None,
                 cloud_logging_parser: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs']] = None,
                 json_parser: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs']] = None,
                 tskv_parser: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs'] audit_trails_v1_parser: Parse Audit Trails data. Empty struct.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs'] cloud_logging_parser: Parse Cloud Logging data. Empty struct.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs'] json_parser: Parse data in json format.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs'] tskv_parser: Parse data if tskv format.
        """
        if audit_trails_v1_parser is not None:
            pulumi.set(__self__, "audit_trails_v1_parser", audit_trails_v1_parser)
        if cloud_logging_parser is not None:
            pulumi.set(__self__, "cloud_logging_parser", cloud_logging_parser)
        if json_parser is not None:
            pulumi.set(__self__, "json_parser", json_parser)
        if tskv_parser is not None:
            pulumi.set(__self__, "tskv_parser", tskv_parser)

    @property
    @pulumi.getter(name="auditTrailsV1Parser")
    def audit_trails_v1_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs']]:
        """
        Parse Audit Trails data. Empty struct.
        """
        return pulumi.get(self, "audit_trails_v1_parser")

    @audit_trails_v1_parser.setter
    def audit_trails_v1_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs']]):
        pulumi.set(self, "audit_trails_v1_parser", value)

    @property
    @pulumi.getter(name="cloudLoggingParser")
    def cloud_logging_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs']]:
        """
        Parse Cloud Logging data. Empty struct.
        """
        return pulumi.get(self, "cloud_logging_parser")

    @cloud_logging_parser.setter
    def cloud_logging_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs']]):
        pulumi.set(self, "cloud_logging_parser", value)

    @property
    @pulumi.getter(name="jsonParser")
    def json_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs']]:
        """
        Parse data in json format.
        """
        return pulumi.get(self, "json_parser")

    @json_parser.setter
    def json_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs']]):
        pulumi.set(self, "json_parser", value)

    @property
    @pulumi.getter(name="tskvParser")
    def tskv_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs']]:
        """
        Parse data if tskv format.
        """
        return pulumi.get(self, "tskv_parser")

    @tskv_parser.setter
    def tskv_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs']]):
        pulumi.set(self, "tskv_parser", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserJsonParserArgsDict(TypedDict):
        add_rest_column: NotRequired[pulumi.Input[bool]]
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        data_schema: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgsDict']]
        """
        Data parsing scheme.The structure is documented below.
        """
        null_keys_allowed: NotRequired[pulumi.Input[bool]]
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        unescape_string_values: NotRequired[pulumi.Input[bool]]
        """
        Allow unescape string values.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserJsonParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs:
    def __init__(__self__, *,
                 add_rest_column: Optional[pulumi.Input[bool]] = None,
                 data_schema: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs']] = None,
                 null_keys_allowed: Optional[pulumi.Input[bool]] = None,
                 unescape_string_values: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] add_rest_column: Add fields, that are not in the schema, into the _rest column.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs'] data_schema: Data parsing scheme.The structure is documented below.
        :param pulumi.Input[bool] null_keys_allowed: Allow null keys. If `false` - null keys will be putted to unparsed data
        :param pulumi.Input[bool] unescape_string_values: Allow unescape string values.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[pulumi.Input[bool]]:
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        return pulumi.get(self, "add_rest_column")

    @add_rest_column.setter
    def add_rest_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_rest_column", value)

    @property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs']]:
        """
        Data parsing scheme.The structure is documented below.
        """
        return pulumi.get(self, "data_schema")

    @data_schema.setter
    def data_schema(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs']]):
        pulumi.set(self, "data_schema", value)

    @property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        return pulumi.get(self, "null_keys_allowed")

    @null_keys_allowed.setter
    def null_keys_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "null_keys_allowed", value)

    @property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow unescape string values.
        """
        return pulumi.get(self, "unescape_string_values")

    @unescape_string_values.setter
    def unescape_string_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unescape_string_values", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgsDict']]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        json_fields: NotRequired[pulumi.Input[str]]
        """
        Description of the data schema as JSON specification.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgs']] = None,
                 json_fields: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgs'] fields: Description of the data schema in the array of `fields` structure (documented below).
        :param pulumi.Input[str] json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgs']]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgs']]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")

    @json_fields.setter
    def json_fields(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_fields", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgsDict']]]]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs']]] fields: Description of the data schema in the array of `fields` structure (documented below).
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs']]]]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs']]]]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[bool]]
        """
        Mark field as Primary Key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Field name.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to the field.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Mark field as required.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] key: Mark field as Primary Key.
        :param pulumi.Input[str] name: Field name.
        :param pulumi.Input[str] path: Path to the field.
        :param pulumi.Input[bool] required: Mark field as required.
        :param pulumi.Input[str] type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserTskvParserArgsDict(TypedDict):
        add_rest_column: NotRequired[pulumi.Input[bool]]
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        data_schema: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgsDict']]
        """
        (Required) Data parsing scheme.The structure is documented below.
        """
        null_keys_allowed: NotRequired[pulumi.Input[bool]]
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        unescape_string_values: NotRequired[pulumi.Input[bool]]
        """
        Allow unescape string values.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserTskvParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs:
    def __init__(__self__, *,
                 add_rest_column: Optional[pulumi.Input[bool]] = None,
                 data_schema: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs']] = None,
                 null_keys_allowed: Optional[pulumi.Input[bool]] = None,
                 unescape_string_values: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] add_rest_column: Add fields, that are not in the schema, into the _rest column.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs'] data_schema: (Required) Data parsing scheme.The structure is documented below.
        :param pulumi.Input[bool] null_keys_allowed: Allow null keys. If `false` - null keys will be putted to unparsed data
        :param pulumi.Input[bool] unescape_string_values: Allow unescape string values.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[pulumi.Input[bool]]:
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        return pulumi.get(self, "add_rest_column")

    @add_rest_column.setter
    def add_rest_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_rest_column", value)

    @property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs']]:
        """
        (Required) Data parsing scheme.The structure is documented below.
        """
        return pulumi.get(self, "data_schema")

    @data_schema.setter
    def data_schema(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs']]):
        pulumi.set(self, "data_schema", value)

    @property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        return pulumi.get(self, "null_keys_allowed")

    @null_keys_allowed.setter
    def null_keys_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "null_keys_allowed", value)

    @property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow unescape string values.
        """
        return pulumi.get(self, "unescape_string_values")

    @unescape_string_values.setter
    def unescape_string_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unescape_string_values", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgsDict']]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        json_fields: NotRequired[pulumi.Input[str]]
        """
        Description of the data schema as JSON specification.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs']] = None,
                 json_fields: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs'] fields: Description of the data schema in the array of `fields` structure (documented below).
        :param pulumi.Input[str] json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs']]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs']]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")

    @json_fields.setter
    def json_fields(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_fields", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgsDict']]]]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgs']]] fields: Description of the data schema in the array of `fields` structure (documented below).
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgs']]]]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgs']]]]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[bool]]
        """
        Mark field as Primary Key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Field name.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to the field.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Mark field as required.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsFieldArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] key: Mark field as Primary Key.
        :param pulumi.Input[str] name: Field name.
        :param pulumi.Input[str] path: Path to the field.
        :param pulumi.Input[bool] required: Mark field as required.
        :param pulumi.Input[str] type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaSourceTransformerArgsDict(TypedDict):
        buffer_flush_interval: NotRequired[pulumi.Input[str]]
        buffer_size: NotRequired[pulumi.Input[str]]
        cloud_function: NotRequired[pulumi.Input[str]]
        invocation_timeout: NotRequired[pulumi.Input[str]]
        number_of_retries: NotRequired[pulumi.Input[int]]
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        - (Required) Service account ID for interaction with database.
        """
elif False:
    DatatransferEndpointSettingsKafkaSourceTransformerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaSourceTransformerArgs:
    def __init__(__self__, *,
                 buffer_flush_interval: Optional[pulumi.Input[str]] = None,
                 buffer_size: Optional[pulumi.Input[str]] = None,
                 cloud_function: Optional[pulumi.Input[str]] = None,
                 invocation_timeout: Optional[pulumi.Input[str]] = None,
                 number_of_retries: Optional[pulumi.Input[int]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_account_id: - (Required) Service account ID for interaction with database.
        """
        if buffer_flush_interval is not None:
            pulumi.set(__self__, "buffer_flush_interval", buffer_flush_interval)
        if buffer_size is not None:
            pulumi.set(__self__, "buffer_size", buffer_size)
        if cloud_function is not None:
            pulumi.set(__self__, "cloud_function", cloud_function)
        if invocation_timeout is not None:
            pulumi.set(__self__, "invocation_timeout", invocation_timeout)
        if number_of_retries is not None:
            pulumi.set(__self__, "number_of_retries", number_of_retries)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="bufferFlushInterval")
    def buffer_flush_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "buffer_flush_interval")

    @buffer_flush_interval.setter
    def buffer_flush_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "buffer_flush_interval", value)

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "buffer_size", value)

    @property
    @pulumi.getter(name="cloudFunction")
    def cloud_function(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_function")

    @cloud_function.setter
    def cloud_function(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_function", value)

    @property
    @pulumi.getter(name="invocationTimeout")
    def invocation_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "invocation_timeout")

    @invocation_timeout.setter
    def invocation_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_timeout", value)

    @property
    @pulumi.getter(name="numberOfRetries")
    def number_of_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_retries")

    @number_of_retries.setter
    def number_of_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_retries", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthArgsDict']]
        """
        Authentication data.
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionArgsDict']]
        """
        Connection settings.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        serializer: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerArgsDict']]
        """
        Data serialization settings.
        """
        topic_settings: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsArgsDict']]
        """
        Target topic settings.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthArgs']] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 serializer: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerArgs']] = None,
                 topic_settings: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthArgs'] auth: Authentication data.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionArgs'] connection: Connection settings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerArgs'] serializer: Data serialization settings.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs'] topic_settings: Target topic settings.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)
        if topic_settings is not None:
            pulumi.set(__self__, "topic_settings", topic_settings)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthArgs']]:
        """
        Authentication data.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionArgs']]:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerArgs']]:
        """
        Data serialization settings.
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerArgs']]):
        pulumi.set(self, "serializer", value)

    @property
    @pulumi.getter(name="topicSettings")
    def topic_settings(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs']]:
        """
        Target topic settings.
        """
        return pulumi.get(self, "topic_settings")

    @topic_settings.setter
    def topic_settings(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs']]):
        pulumi.set(self, "topic_settings", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetAuthArgsDict(TypedDict):
        no_auth: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgsDict']]
        """
        Connection without authentication data.
        """
        sasl: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslArgsDict']]
        """
        Authentication using sasl.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetAuthArgs:
    def __init__(__self__, *,
                 no_auth: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs']] = None,
                 sasl: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs'] no_auth: Connection without authentication data.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslArgs'] sasl: Authentication using sasl.
        """
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs']]:
        """
        Connection without authentication data.
        """
        return pulumi.get(self, "no_auth")

    @no_auth.setter
    def no_auth(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs']]):
        pulumi.set(self, "no_auth", value)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslArgs']]:
        """
        Authentication using sasl.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslArgs']]):
        pulumi.set(self, "sasl", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetAuthSaslArgsDict(TypedDict):
        mechanism: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgsDict']]
        user: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsKafkaTargetAuthSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetAuthSaslArgs:
    def __init__(__self__, *,
                 mechanism: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgs']] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mechanism")

    @mechanism.setter
    def mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mechanism", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgs']]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetAuthSaslPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetConnectionArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed Kafka cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgsDict']]
        """
        Connection settings of the on-premise Kafka server.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetConnectionArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs']] = None):
        """
        :param pulumi.Input[str] cluster_id: Identifier of the Managed Kafka cluster.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs'] on_premise: Connection settings of the on-premise Kafka server.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed Kafka cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs']]:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgsDict(TypedDict):
        broker_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Kafka broker URLs.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs:
    def __init__(__self__, *,
                 broker_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] broker_urls: List of Kafka broker URLs.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if broker_urls is not None:
            pulumi.set(__self__, "broker_urls", broker_urls)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="brokerUrls")
    def broker_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Kafka broker URLs.
        """
        return pulumi.get(self, "broker_urls")

    @broker_urls.setter
    def broker_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "broker_urls", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetSerializerArgsDict(TypedDict):
        serializer_auto: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgsDict']]
        """
        Empty block. Select data serialization format automatically.
        """
        serializer_debezium: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgsDict']]
        """
        Serialize data in json format. The structure is documented below.
        """
        serializer_json: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgsDict']]
        """
        Empty block. Serialize data in json format.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetSerializerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetSerializerArgs:
    def __init__(__self__, *,
                 serializer_auto: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs']] = None,
                 serializer_debezium: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs']] = None,
                 serializer_json: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs'] serializer_auto: Empty block. Select data serialization format automatically.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs'] serializer_debezium: Serialize data in json format. The structure is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs'] serializer_json: Empty block. Serialize data in json format.
        """
        if serializer_auto is not None:
            pulumi.set(__self__, "serializer_auto", serializer_auto)
        if serializer_debezium is not None:
            pulumi.set(__self__, "serializer_debezium", serializer_debezium)
        if serializer_json is not None:
            pulumi.set(__self__, "serializer_json", serializer_json)

    @property
    @pulumi.getter(name="serializerAuto")
    def serializer_auto(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs']]:
        """
        Empty block. Select data serialization format automatically.
        """
        return pulumi.get(self, "serializer_auto")

    @serializer_auto.setter
    def serializer_auto(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs']]):
        pulumi.set(self, "serializer_auto", value)

    @property
    @pulumi.getter(name="serializerDebezium")
    def serializer_debezium(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs']]:
        """
        Serialize data in json format. The structure is documented below.
        """
        return pulumi.get(self, "serializer_debezium")

    @serializer_debezium.setter
    def serializer_debezium(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs']]):
        pulumi.set(self, "serializer_debezium", value)

    @property
    @pulumi.getter(name="serializerJson")
    def serializer_json(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs']]:
        """
        Empty block. Serialize data in json format.
        """
        return pulumi.get(self, "serializer_json")

    @serializer_json.setter
    def serializer_json(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs']]):
        pulumi.set(self, "serializer_json", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgsDict(TypedDict):
        serializer_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgsDict']]]]
        """
        A list of debezium parameters set by the structure of the `key` and `value` string fields.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs:
    def __init__(__self__, *,
                 serializer_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs']]] serializer_parameters: A list of debezium parameters set by the structure of the `key` and `value` string fields.
        """
        if serializer_parameters is not None:
            pulumi.set(__self__, "serializer_parameters", serializer_parameters)

    @property
    @pulumi.getter(name="serializerParameters")
    def serializer_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs']]]]:
        """
        A list of debezium parameters set by the structure of the `key` and `value` string fields.
        """
        return pulumi.get(self, "serializer_parameters")

    @serializer_parameters.setter
    def serializer_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs']]]]):
        pulumi.set(self, "serializer_parameters", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Mark field as Primary Key.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Mark field as Primary Key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetTopicSettingsArgsDict(TypedDict):
        topic: NotRequired[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgsDict']]
        """
        All messages will be sent to one topic. The structure is documented below.
        """
        topic_prefix: NotRequired[pulumi.Input[str]]
        """
        Topic name prefix. Messages will be sent to topic with name <topic_prefix>.<schema>.<table_name>.
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetTopicSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs:
    def __init__(__self__, *,
                 topic: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs']] = None,
                 topic_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs'] topic: All messages will be sent to one topic. The structure is documented below.
        :param pulumi.Input[str] topic_prefix: Topic name prefix. Messages will be sent to topic with name <topic_prefix>.<schema>.<table_name>.
        """
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if topic_prefix is not None:
            pulumi.set(__self__, "topic_prefix", topic_prefix)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs']]:
        """
        All messages will be sent to one topic. The structure is documented below.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs']]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="topicPrefix")
    def topic_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Topic name prefix. Messages will be sent to topic with name <topic_prefix>.<schema>.<table_name>.
        """
        return pulumi.get(self, "topic_prefix")

    @topic_prefix.setter
    def topic_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_prefix", value)


if not MYPY:
    class DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgsDict(TypedDict):
        save_tx_order: NotRequired[pulumi.Input[bool]]
        """
        Not to split events queue into separate per-table queues.
        """
        topic_name: NotRequired[pulumi.Input[str]]
        """
        Full topic name
        """
elif False:
    DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs:
    def __init__(__self__, *,
                 save_tx_order: Optional[pulumi.Input[bool]] = None,
                 topic_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] save_tx_order: Not to split events queue into separate per-table queues.
        :param pulumi.Input[str] topic_name: Full topic name
        """
        if save_tx_order is not None:
            pulumi.set(__self__, "save_tx_order", save_tx_order)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter(name="saveTxOrder")
    def save_tx_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Not to split events queue into separate per-table queues.
        """
        return pulumi.get(self, "save_tx_order")

    @save_tx_order.setter
    def save_tx_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "save_tx_order", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[pulumi.Input[str]]:
        """
        Full topic name
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_name", value)


if not MYPY:
    class DatatransferEndpointSettingsMetrikaSourceArgsDict(TypedDict):
        counter_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        streams: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceStreamArgsDict']]]]
        token: NotRequired[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceTokenArgsDict']]
elif False:
    DatatransferEndpointSettingsMetrikaSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMetrikaSourceArgs:
    def __init__(__self__, *,
                 counter_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceStreamArgs']]]] = None,
                 token: Optional[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceTokenArgs']] = None):
        if counter_ids is not None:
            pulumi.set(__self__, "counter_ids", counter_ids)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="counterIds")
    def counter_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "counter_ids")

    @counter_ids.setter
    def counter_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "counter_ids", value)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceStreamArgs']]]]:
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceStreamArgs']]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceTokenArgs']]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMetrikaSourceTokenArgs']]):
        pulumi.set(self, "token", value)


if not MYPY:
    class DatatransferEndpointSettingsMetrikaSourceStreamArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
        """
        (Required) Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
elif False:
    DatatransferEndpointSettingsMetrikaSourceStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMetrikaSourceStreamArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Required) Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatatransferEndpointSettingsMetrikaSourceTokenArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsMetrikaSourceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMetrikaSourceTokenArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceArgsDict(TypedDict):
        collections: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceCollectionArgsDict']]]]
        """
        The list of the MongoDB collections that should be transferred. If omitted, all available collections will be transferred. The structure of the list item is documented below.
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        excluded_collections: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceExcludedCollectionArgsDict']]]]
        """
        The list of the MongoDB collections that should not be transferred.
        """
        secondary_preferred_mode: NotRequired[pulumi.Input[bool]]
        """
        whether the secondary server should be preferred to the primary when copying data.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceArgs:
    def __init__(__self__, *,
                 collections: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceCollectionArgs']]]] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionArgs']] = None,
                 excluded_collections: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs']]]] = None,
                 secondary_preferred_mode: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceCollectionArgs']]] collections: The list of the MongoDB collections that should be transferred. If omitted, all available collections will be transferred. The structure of the list item is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs']]] excluded_collections: The list of the MongoDB collections that should not be transferred.
        :param pulumi.Input[bool] secondary_preferred_mode: whether the secondary server should be preferred to the primary when copying data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if excluded_collections is not None:
            pulumi.set(__self__, "excluded_collections", excluded_collections)
        if secondary_preferred_mode is not None:
            pulumi.set(__self__, "secondary_preferred_mode", secondary_preferred_mode)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def collections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceCollectionArgs']]]]:
        """
        The list of the MongoDB collections that should be transferred. If omitted, all available collections will be transferred. The structure of the list item is documented below.
        """
        return pulumi.get(self, "collections")

    @collections.setter
    def collections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceCollectionArgs']]]]):
        pulumi.set(self, "collections", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="excludedCollections")
    def excluded_collections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs']]]]:
        """
        The list of the MongoDB collections that should not be transferred.
        """
        return pulumi.get(self, "excluded_collections")

    @excluded_collections.setter
    def excluded_collections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs']]]]):
        pulumi.set(self, "excluded_collections", value)

    @property
    @pulumi.getter(name="secondaryPreferredMode")
    def secondary_preferred_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        whether the secondary server should be preferred to the primary when copying data.
        """
        return pulumi.get(self, "secondary_preferred_mode")

    @secondary_preferred_mode.setter
    def secondary_preferred_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secondary_preferred_mode", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceCollectionArgsDict(TypedDict):
        collection_name: NotRequired[pulumi.Input[str]]
        """
        Collection name.
        """
        database_name: NotRequired[pulumi.Input[str]]
        """
        Database name.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceCollectionArgs:
    def __init__(__self__, *,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] collection_name: Collection name.
        :param pulumi.Input[str] database_name: Database name.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        Collection name.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionArgsDict(TypedDict):
        connection_options: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgsDict']]
        """
        Connection options. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionArgs:
    def __init__(__self__, *,
                 connection_options: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgs'] connection_options: Connection options. The structure is documented below.
        """
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgs']]:
        """
        Connection options. The structure is documented below.
        """
        return pulumi.get(self, "connection_options")

    @connection_options.setter
    def connection_options(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgs']]):
        pulumi.set(self, "connection_options", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgsDict(TypedDict):
        auth_source: NotRequired[pulumi.Input[str]]
        """
        Name of the database associated with the credentials.
        """
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed ClickHouse cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgsDict']]
        """
        Connection settings of the on-premise ClickHouse server.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for database access.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsArgs:
    def __init__(__self__, *,
                 auth_source: Optional[pulumi.Input[str]] = None,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs']] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgs']] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_source: Name of the database associated with the credentials.
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed ClickHouse cluster.
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs'] on_premise: Connection settings of the on-premise ClickHouse server.
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[str] user: User for database access.
        """
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database associated with the credentials.
        """
        return pulumi.get(self, "auth_source")

    @auth_source.setter
    def auth_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_source", value)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed ClickHouse cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs']]:
        """
        Connection settings of the on-premise ClickHouse server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Host names of the replica set.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        TCP Port number.
        """
        replica_set: NotRequired[pulumi.Input[str]]
        """
        Replica set name.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 replica_set: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host names of the replica set.
        :param pulumi.Input[int] port: TCP Port number.
        :param pulumi.Input[str] replica_set: Replica set name.
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[pulumi.Input[str]]:
        """
        Replica set name.
        """
        return pulumi.get(self, "replica_set")

    @replica_set.setter
    def replica_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoSourceExcludedCollectionArgsDict(TypedDict):
        collection_name: NotRequired[pulumi.Input[str]]
        """
        Collection name.
        """
        database_name: NotRequired[pulumi.Input[str]]
        """
        Database name.
        """
elif False:
    DatatransferEndpointSettingsMongoSourceExcludedCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs:
    def __init__(__self__, *,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] collection_name: Collection name.
        :param pulumi.Input[str] database_name: Database name.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        Collection name.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        How to clean collections when activating the transfer. One of "DISABLED", "DROP" or "TRUNCATE".
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        If not empty, then all the data will be written to the database with the specified name; otherwise the database name is the same as in the source endpoint.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsMongoTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionArgs']] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cleanup_policy: How to clean collections when activating the transfer. One of "DISABLED", "DROP" or "TRUNCATE".
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[str] database: If not empty, then all the data will be written to the database with the specified name; otherwise the database name is the same as in the source endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        How to clean collections when activating the transfer. One of "DISABLED", "DROP" or "TRUNCATE".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        If not empty, then all the data will be written to the database with the specified name; otherwise the database name is the same as in the source endpoint.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionArgsDict(TypedDict):
        connection_options: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgsDict']]
        """
        Connection options. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionArgs:
    def __init__(__self__, *,
                 connection_options: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs'] connection_options: Connection options. The structure is documented below.
        """
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs']]:
        """
        Connection options. The structure is documented below.
        """
        return pulumi.get(self, "connection_options")

    @connection_options.setter
    def connection_options(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs']]):
        pulumi.set(self, "connection_options", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgsDict(TypedDict):
        auth_source: NotRequired[pulumi.Input[str]]
        """
        Name of the database associated with the credentials.
        """
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed ClickHouse cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgsDict']]
        """
        Connection settings of the on-premise ClickHouse server.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for database access.
        """
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs:
    def __init__(__self__, *,
                 auth_source: Optional[pulumi.Input[str]] = None,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs']] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs']] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_source: Name of the database associated with the credentials.
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed ClickHouse cluster.
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs'] on_premise: Connection settings of the on-premise ClickHouse server.
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[str] user: User for database access.
        """
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database associated with the credentials.
        """
        return pulumi.get(self, "auth_source")

    @auth_source.setter
    def auth_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_source", value)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed ClickHouse cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs']]:
        """
        Connection settings of the on-premise ClickHouse server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Host names of the replica set.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        TCP Port number.
        """
        replica_set: NotRequired[pulumi.Input[str]]
        """
        Replica set name.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 replica_set: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host names of the replica set.
        :param pulumi.Input[int] port: TCP Port number.
        :param pulumi.Input[str] replica_set: Replica set name.
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[pulumi.Input[str]]:
        """
        Replica set name.
        """
        return pulumi.get(self, "replica_set")

    @replica_set.setter
    def replica_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceArgsDict(TypedDict):
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        Name of the database to transfer.
        """
        exclude_tables_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        """
        include_tables_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        """
        object_transfer_settings: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgsDict']]
        """
        Defines which database schema objects should be transferred, e.g. views, routines, etc.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourcePasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        service_database: NotRequired[pulumi.Input[str]]
        """
        The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for the database access.
        """
elif False:
    DatatransferEndpointSettingsMysqlSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceArgs:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionArgs']] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 exclude_tables_regexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables_regexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 object_transfer_settings: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs']] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourcePasswordArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_database: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[str] database: Name of the database to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables_regexes: Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables_regexes: List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs'] object_transfer_settings: Defines which database schema objects should be transferred, e.g. views, routines, etc.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourcePasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] service_database: The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        :param pulumi.Input[str] timezone: Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        :param pulumi.Input[str] user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if exclude_tables_regexes is not None:
            pulumi.set(__self__, "exclude_tables_regexes", exclude_tables_regexes)
        if include_tables_regexes is not None:
            pulumi.set(__self__, "include_tables_regexes", include_tables_regexes)
        if object_transfer_settings is not None:
            pulumi.set(__self__, "object_transfer_settings", object_transfer_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_database is not None:
            pulumi.set(__self__, "service_database", service_database)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="excludeTablesRegexes")
    def exclude_tables_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        """
        return pulumi.get(self, "exclude_tables_regexes")

    @exclude_tables_regexes.setter
    def exclude_tables_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables_regexes", value)

    @property
    @pulumi.getter(name="includeTablesRegexes")
    def include_tables_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        """
        return pulumi.get(self, "include_tables_regexes")

    @include_tables_regexes.setter
    def include_tables_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables_regexes", value)

    @property
    @pulumi.getter(name="objectTransferSettings")
    def object_transfer_settings(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs']]:
        """
        Defines which database schema objects should be transferred, e.g. views, routines, etc.
        """
        return pulumi.get(self, "object_transfer_settings")

    @object_transfer_settings.setter
    def object_transfer_settings(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs']]):
        pulumi.set(self, "object_transfer_settings", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourcePasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourcePasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceDatabase")
    def service_database(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        """
        return pulumi.get(self, "service_database")

    @service_database.setter
    def service_database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_database", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceConnectionArgsDict(TypedDict):
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed MySQL cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgsDict']]
        """
        Connection settings of the on-premise Kafka server.
        """
elif False:
    DatatransferEndpointSettingsMysqlSourceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceConnectionArgs:
    def __init__(__self__, *,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs']] = None):
        """
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs'] on_premise: Connection settings of the on-premise Kafka server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs']]:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Host names of the replica set.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        TCP Port number.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host names of the replica set.
        :param pulumi.Input[int] port: TCP Port number.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgsDict(TypedDict):
        routine: NotRequired[pulumi.Input[str]]
        tables: NotRequired[pulumi.Input[str]]
        trigger: NotRequired[pulumi.Input[str]]
        """
        All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        view: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs:
    def __init__(__self__, *,
                 routine: Optional[pulumi.Input[str]] = None,
                 tables: Optional[pulumi.Input[str]] = None,
                 trigger: Optional[pulumi.Input[str]] = None,
                 view: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] trigger: All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        if routine is not None:
            pulumi.set(__self__, "routine", routine)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def routine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "routine")

    @routine.setter
    def routine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routine", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tables", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input[str]]:
        """
        All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter
    def view(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlSourcePasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsMysqlSourcePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlSourcePasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        How to clean tables when activating the transfer. One of "DISABLED", "DROP" or "TRUNCATE".
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        Name of the database to transfer.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetPasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        service_database: NotRequired[pulumi.Input[str]]
        """
        The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        """
        skip_constraint_checks: NotRequired[pulumi.Input[bool]]
        """
        When true, disables foreign key checks. See [foreign_key_checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). False by default.
        """
        sql_mode: NotRequired[pulumi.Input[str]]
        """
        [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to "NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION".
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for the database access.
        """
elif False:
    DatatransferEndpointSettingsMysqlTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionArgs']] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetPasswordArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_database: Optional[pulumi.Input[str]] = None,
                 skip_constraint_checks: Optional[pulumi.Input[bool]] = None,
                 sql_mode: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cleanup_policy: How to clean tables when activating the transfer. One of "DISABLED", "DROP" or "TRUNCATE".
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[str] database: Name of the database to transfer.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetPasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] service_database: The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        :param pulumi.Input[bool] skip_constraint_checks: When true, disables foreign key checks. See [foreign_key_checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). False by default.
        :param pulumi.Input[str] sql_mode: [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to "NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION".
        :param pulumi.Input[str] timezone: Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        :param pulumi.Input[str] user: User for the database access.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_database is not None:
            pulumi.set(__self__, "service_database", service_database)
        if skip_constraint_checks is not None:
            pulumi.set(__self__, "skip_constraint_checks", skip_constraint_checks)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        How to clean tables when activating the transfer. One of "DISABLED", "DROP" or "TRUNCATE".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetPasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceDatabase")
    def service_database(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        """
        return pulumi.get(self, "service_database")

    @service_database.setter
    def service_database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_database", value)

    @property
    @pulumi.getter(name="skipConstraintChecks")
    def skip_constraint_checks(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, disables foreign key checks. See [foreign_key_checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). False by default.
        """
        return pulumi.get(self, "skip_constraint_checks")

    @skip_constraint_checks.setter
    def skip_constraint_checks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_constraint_checks", value)

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[pulumi.Input[str]]:
        """
        [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to "NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION".
        """
        return pulumi.get(self, "sql_mode")

    @sql_mode.setter
    def sql_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_mode", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetConnectionArgsDict(TypedDict):
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed MySQL cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgsDict']]
        """
        Connection settings of the on-premise Kafka server.
        """
elif False:
    DatatransferEndpointSettingsMysqlTargetConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetConnectionArgs:
    def __init__(__self__, *,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs']] = None):
        """
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs'] on_premise: Connection settings of the on-premise Kafka server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs']]:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Host names of the replica set.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        TCP Port number.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host names of the replica set.
        :param pulumi.Input[int] port: TCP Port number.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsMysqlTargetPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsMysqlTargetPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsMysqlTargetPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceArgsDict(TypedDict):
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        Name of the database to transfer.
        """
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables which will not be transfered, formatted as `schemaname.tablename`.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        """
        object_transfer_settings: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgsDict']]
        """
        Defines which database schema objects should be transferred, e.g. views, functions, etc.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourcePasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        service_schema: NotRequired[pulumi.Input[str]]
        """
        Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        """
        slot_gigabyte_lag_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. Unlimited by default.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for the database access.
        """
elif False:
    DatatransferEndpointSettingsPostgresSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceArgs:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionArgs']] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 object_transfer_settings: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs']] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourcePasswordArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_schema: Optional[pulumi.Input[str]] = None,
                 slot_gigabyte_lag_limit: Optional[pulumi.Input[int]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[str] database: Name of the database to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables which will not be transfered, formatted as `schemaname.tablename`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs'] object_transfer_settings: Defines which database schema objects should be transferred, e.g. views, functions, etc.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourcePasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] service_schema: Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        :param pulumi.Input[int] slot_gigabyte_lag_limit: Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. Unlimited by default.
        :param pulumi.Input[str] user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)
        if object_transfer_settings is not None:
            pulumi.set(__self__, "object_transfer_settings", object_transfer_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_schema is not None:
            pulumi.set(__self__, "service_schema", service_schema)
        if slot_gigabyte_lag_limit is not None:
            pulumi.set(__self__, "slot_gigabyte_lag_limit", slot_gigabyte_lag_limit)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables which will not be transfered, formatted as `schemaname.tablename`.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)

    @property
    @pulumi.getter(name="objectTransferSettings")
    def object_transfer_settings(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs']]:
        """
        Defines which database schema objects should be transferred, e.g. views, functions, etc.
        """
        return pulumi.get(self, "object_transfer_settings")

    @object_transfer_settings.setter
    def object_transfer_settings(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs']]):
        pulumi.set(self, "object_transfer_settings", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourcePasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourcePasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceSchema")
    def service_schema(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        """
        return pulumi.get(self, "service_schema")

    @service_schema.setter
    def service_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_schema", value)

    @property
    @pulumi.getter(name="slotGigabyteLagLimit")
    def slot_gigabyte_lag_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. Unlimited by default.
        """
        return pulumi.get(self, "slot_gigabyte_lag_limit")

    @slot_gigabyte_lag_limit.setter
    def slot_gigabyte_lag_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slot_gigabyte_lag_limit", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceConnectionArgsDict(TypedDict):
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed MySQL cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgsDict']]
        """
        Connection settings of the on-premise Kafka server.
        """
elif False:
    DatatransferEndpointSettingsPostgresSourceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceConnectionArgs:
    def __init__(__self__, *,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs']] = None):
        """
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs'] on_premise: Connection settings of the on-premise Kafka server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs']]:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Host names of the replica set.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        TCP Port number.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host names of the replica set.
        :param pulumi.Input[int] port: TCP Port number.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgsDict(TypedDict):
        cast: NotRequired[pulumi.Input[str]]
        """
        All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        collation: NotRequired[pulumi.Input[str]]
        constraint: NotRequired[pulumi.Input[str]]
        default_values: NotRequired[pulumi.Input[str]]
        fk_constraint: NotRequired[pulumi.Input[str]]
        function: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[str]]
        materialized_view: NotRequired[pulumi.Input[str]]
        policy: NotRequired[pulumi.Input[str]]
        primary_key: NotRequired[pulumi.Input[str]]
        rule: NotRequired[pulumi.Input[str]]
        sequence: NotRequired[pulumi.Input[str]]
        sequence_owned_by: NotRequired[pulumi.Input[str]]
        sequence_set: NotRequired[pulumi.Input[str]]
        table: NotRequired[pulumi.Input[str]]
        trigger: NotRequired[pulumi.Input[str]]
        """
        All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        type: NotRequired[pulumi.Input[str]]
        view: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs:
    def __init__(__self__, *,
                 cast: Optional[pulumi.Input[str]] = None,
                 collation: Optional[pulumi.Input[str]] = None,
                 constraint: Optional[pulumi.Input[str]] = None,
                 default_values: Optional[pulumi.Input[str]] = None,
                 fk_constraint: Optional[pulumi.Input[str]] = None,
                 function: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[str]] = None,
                 materialized_view: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 rule: Optional[pulumi.Input[str]] = None,
                 sequence: Optional[pulumi.Input[str]] = None,
                 sequence_owned_by: Optional[pulumi.Input[str]] = None,
                 sequence_set: Optional[pulumi.Input[str]] = None,
                 table: Optional[pulumi.Input[str]] = None,
                 trigger: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 view: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cast: All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        :param pulumi.Input[str] trigger: All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        if cast is not None:
            pulumi.set(__self__, "cast", cast)
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if constraint is not None:
            pulumi.set(__self__, "constraint", constraint)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if fk_constraint is not None:
            pulumi.set(__self__, "fk_constraint", fk_constraint)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if materialized_view is not None:
            pulumi.set(__self__, "materialized_view", materialized_view)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if sequence is not None:
            pulumi.set(__self__, "sequence", sequence)
        if sequence_owned_by is not None:
            pulumi.set(__self__, "sequence_owned_by", sequence_owned_by)
        if sequence_set is not None:
            pulumi.set(__self__, "sequence_set", sequence_set)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def cast(self) -> Optional[pulumi.Input[str]]:
        """
        All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        return pulumi.get(self, "cast")

    @cast.setter
    def cast(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cast", value)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter
    def constraint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "constraint")

    @constraint.setter
    def constraint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "constraint", value)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_values", value)

    @property
    @pulumi.getter(name="fkConstraint")
    def fk_constraint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fk_constraint")

    @fk_constraint.setter
    def fk_constraint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fk_constraint", value)

    @property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="materializedView")
    def materialized_view(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "materialized_view")

    @materialized_view.setter
    def materialized_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "materialized_view", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def sequence(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sequence")

    @sequence.setter
    def sequence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sequence", value)

    @property
    @pulumi.getter(name="sequenceOwnedBy")
    def sequence_owned_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sequence_owned_by")

    @sequence_owned_by.setter
    def sequence_owned_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sequence_owned_by", value)

    @property
    @pulumi.getter(name="sequenceSet")
    def sequence_set(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sequence_set")

    @sequence_set.setter
    def sequence_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sequence_set", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input[str]]:
        """
        All of the attrubutes are optional and should be either "BEFORE_DATA", "AFTER_DATA" or "NEVER".
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def view(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresSourcePasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsPostgresSourcePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresSourcePasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        - (Optional) How to clean collections when activating the transfer. One of "YDB_CLEANUP_POLICY_DISABLED" or "YDB_CLEANUP_POLICY_DROP".
        """
        connection: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionArgsDict']]
        """
        Connection settings. The structure is documented below.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        Name of the database to transfer.
        """
        password: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetPasswordArgsDict']]
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User for the database access.
        """
elif False:
    DatatransferEndpointSettingsPostgresTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 connection: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionArgs']] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetPasswordArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cleanup_policy: - (Optional) How to clean collections when activating the transfer. One of "YDB_CLEANUP_POLICY_DISABLED" or "YDB_CLEANUP_POLICY_DROP".
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionArgs'] connection: Connection settings. The structure is documented below.
        :param pulumi.Input[str] database: Name of the database to transfer.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetPasswordArgs'] password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] user: User for the database access.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) How to clean collections when activating the transfer. One of "YDB_CLEANUP_POLICY_DISABLED" or "YDB_CLEANUP_POLICY_DROP".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionArgs']]:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetPasswordArgs']]:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetPasswordArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetConnectionArgsDict(TypedDict):
        mdb_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Managed MySQL cluster.
        """
        on_premise: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgsDict']]
        """
        Connection settings of the on-premise Kafka server.
        """
elif False:
    DatatransferEndpointSettingsPostgresTargetConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetConnectionArgs:
    def __init__(__self__, *,
                 mdb_cluster_id: Optional[pulumi.Input[str]] = None,
                 on_premise: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs']] = None):
        """
        :param pulumi.Input[str] mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs'] on_premise: Connection settings of the on-premise Kafka server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @mdb_cluster_id.setter
    def mdb_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdb_cluster_id", value)

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs']]:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")

    @on_premise.setter
    def on_premise(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs']]):
        pulumi.set(self, "on_premise", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Host names of the replica set.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        TCP Port number.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        tls_mode: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgsDict']]
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 tls_mode: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host names of the replica set.
        :param pulumi.Input[int] port: TCP Port number.
        :param pulumi.Input[str] subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs'] tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs']]:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")

    @tls_mode.setter
    def tls_mode(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs']]):
        pulumi.set(self, "tls_mode", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgsDict']]
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        enabled: NotRequired[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgsDict']]
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
elif False:
    DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs'] disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs'] enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs']]:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs']]:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs']]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
elif False:
    DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)


if not MYPY:
    class DatatransferEndpointSettingsPostgresTargetPasswordArgsDict(TypedDict):
        raw: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsPostgresTargetPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsPostgresTargetPasswordArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


if not MYPY:
    class DatatransferEndpointSettingsYdbSourceArgsDict(TypedDict):
        changefeed_custom_name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Custom name for changefeed.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        - (Required) Database.
        """
        instance: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Instance of YDB. Example: "my-cute-ydb.yandex.cloud:2135".
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) A list of paths which should be uploaded. When not specified, all available tables are uploaded.
        """
        sa_key_content: NotRequired[pulumi.Input[str]]
        """
        - (Optional, Sensitive) Authentication key.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        - (Required) Service account ID for interaction with database.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsYdbSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdbSourceArgs:
    def __init__(__self__, *,
                 changefeed_custom_name: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input[str]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sa_key_content: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] changefeed_custom_name: - (Optional) Custom name for changefeed.
        :param pulumi.Input[str] database: - (Required) Database.
        :param pulumi.Input[str] instance: - (Optional) Instance of YDB. Example: "my-cute-ydb.yandex.cloud:2135".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: - (Optional) A list of paths which should be uploaded. When not specified, all available tables are uploaded.
        :param pulumi.Input[str] sa_key_content: - (Optional, Sensitive) Authentication key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: - (Optional) List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] service_account_id: - (Required) Service account ID for interaction with database.
        :param pulumi.Input[str] subnet_id: - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if changefeed_custom_name is not None:
            pulumi.set(__self__, "changefeed_custom_name", changefeed_custom_name)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if sa_key_content is not None:
            pulumi.set(__self__, "sa_key_content", sa_key_content)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="changefeedCustomName")
    def changefeed_custom_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Custom name for changefeed.
        """
        return pulumi.get(self, "changefeed_custom_name")

    @changefeed_custom_name.setter
    def changefeed_custom_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "changefeed_custom_name", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Instance of YDB. Example: "my-cute-ydb.yandex.cloud:2135".
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) A list of paths which should be uploaded. When not specified, all available tables are uploaded.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="saKeyContent")
    def sa_key_content(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional, Sensitive) Authentication key.
        """
        return pulumi.get(self, "sa_key_content")

    @sa_key_content.setter
    def sa_key_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sa_key_content", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsYdbTargetArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        - (Optional) How to clean collections when activating the transfer. One of "YDB_CLEANUP_POLICY_DISABLED" or "YDB_CLEANUP_POLICY_DROP".
        """
        database: NotRequired[pulumi.Input[str]]
        """
        - (Required) Database.
        """
        default_compression: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Compression that will be used for default columns family on YDB table creation One of "YDB_DEFAULT_COMPRESSION_UNSPECIFIED", "YDB_DEFAULT_COMPRESSION_DISABLED", "YDB_DEFAULT_COMPRESSION_LZ4".
        """
        instance: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Instance of YDB. Example: "my-cute-ydb.yandex.cloud:2135".
        """
        is_table_column_oriented: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) Whether a column-oriented (i.e. OLAP) tables should be created. Default is `false` (create row-oriented OLTP tables).
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to the field.
        """
        sa_key_content: NotRequired[pulumi.Input[str]]
        """
        - (Optional, Sensitive) Authentication key.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        - (Required) Service account ID for interaction with database.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsYdbTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdbTargetArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 default_compression: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input[str]] = None,
                 is_table_column_oriented: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 sa_key_content: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cleanup_policy: - (Optional) How to clean collections when activating the transfer. One of "YDB_CLEANUP_POLICY_DISABLED" or "YDB_CLEANUP_POLICY_DROP".
        :param pulumi.Input[str] database: - (Required) Database.
        :param pulumi.Input[str] default_compression: - (Optional) Compression that will be used for default columns family on YDB table creation One of "YDB_DEFAULT_COMPRESSION_UNSPECIFIED", "YDB_DEFAULT_COMPRESSION_DISABLED", "YDB_DEFAULT_COMPRESSION_LZ4".
        :param pulumi.Input[str] instance: - (Optional) Instance of YDB. Example: "my-cute-ydb.yandex.cloud:2135".
        :param pulumi.Input[bool] is_table_column_oriented: - (Optional) Whether a column-oriented (i.e. OLAP) tables should be created. Default is `false` (create row-oriented OLTP tables).
        :param pulumi.Input[str] path: Path to the field.
        :param pulumi.Input[str] sa_key_content: - (Optional, Sensitive) Authentication key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: - (Optional) List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] service_account_id: - (Required) Service account ID for interaction with database.
        :param pulumi.Input[str] subnet_id: - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if default_compression is not None:
            pulumi.set(__self__, "default_compression", default_compression)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if is_table_column_oriented is not None:
            pulumi.set(__self__, "is_table_column_oriented", is_table_column_oriented)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sa_key_content is not None:
            pulumi.set(__self__, "sa_key_content", sa_key_content)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) How to clean collections when activating the transfer. One of "YDB_CLEANUP_POLICY_DISABLED" or "YDB_CLEANUP_POLICY_DROP".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="defaultCompression")
    def default_compression(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Compression that will be used for default columns family on YDB table creation One of "YDB_DEFAULT_COMPRESSION_UNSPECIFIED", "YDB_DEFAULT_COMPRESSION_DISABLED", "YDB_DEFAULT_COMPRESSION_LZ4".
        """
        return pulumi.get(self, "default_compression")

    @default_compression.setter
    def default_compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_compression", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Instance of YDB. Example: "my-cute-ydb.yandex.cloud:2135".
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="isTableColumnOriented")
    def is_table_column_oriented(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) Whether a column-oriented (i.e. OLAP) tables should be created. Default is `false` (create row-oriented OLTP tables).
        """
        return pulumi.get(self, "is_table_column_oriented")

    @is_table_column_oriented.setter
    def is_table_column_oriented(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_table_column_oriented", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="saKeyContent")
    def sa_key_content(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional, Sensitive) Authentication key.
        """
        return pulumi.get(self, "sa_key_content")

    @sa_key_content.setter
    def sa_key_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sa_key_content", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceArgsDict(TypedDict):
        allow_ttl_rewind: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) Should continue working, if consumer read lag exceed TTL of topic.
        """
        consumer: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Consumer.
        """
        database: NotRequired[pulumi.Input[str]]
        """
        - (Required) Database.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        - (Optional) YDS Endpoint.
        """
        parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserArgsDict']]
        """
        - (Optional) Data parsing rules.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        - (Required) Service account ID for interaction with database.
        """
        stream: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Stream.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        supported_codecs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) List of supported compression codec.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceArgs:
    def __init__(__self__, *,
                 allow_ttl_rewind: Optional[pulumi.Input[bool]] = None,
                 consumer: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 parser: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 stream: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 supported_codecs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] allow_ttl_rewind: - (Optional) Should continue working, if consumer read lag exceed TTL of topic.
        :param pulumi.Input[str] consumer: - (Optional) Consumer.
        :param pulumi.Input[str] database: - (Required) Database.
        :param pulumi.Input[str] endpoint: - (Optional) YDS Endpoint.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserArgs'] parser: - (Optional) Data parsing rules.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: - (Optional) List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input[str] service_account_id: - (Required) Service account ID for interaction with database.
        :param pulumi.Input[str] stream: - (Optional) Stream.
        :param pulumi.Input[str] subnet_id: - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_codecs: - (Optional) List of supported compression codec.
        """
        if allow_ttl_rewind is not None:
            pulumi.set(__self__, "allow_ttl_rewind", allow_ttl_rewind)
        if consumer is not None:
            pulumi.set(__self__, "consumer", consumer)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if supported_codecs is not None:
            pulumi.set(__self__, "supported_codecs", supported_codecs)

    @property
    @pulumi.getter(name="allowTtlRewind")
    def allow_ttl_rewind(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) Should continue working, if consumer read lag exceed TTL of topic.
        """
        return pulumi.get(self, "allow_ttl_rewind")

    @allow_ttl_rewind.setter
    def allow_ttl_rewind(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ttl_rewind", value)

    @property
    @pulumi.getter
    def consumer(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Consumer.
        """
        return pulumi.get(self, "consumer")

    @consumer.setter
    def consumer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) YDS Endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserArgs']]:
        """
        - (Optional) Data parsing rules.
        """
        return pulumi.get(self, "parser")

    @parser.setter
    def parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserArgs']]):
        pulumi.set(self, "parser", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter
    def stream(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Stream.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="supportedCodecs")
    def supported_codecs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) List of supported compression codec.
        """
        return pulumi.get(self, "supported_codecs")

    @supported_codecs.setter
    def supported_codecs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_codecs", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserArgsDict(TypedDict):
        audit_trails_v1_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgsDict']]
        """
        Parse Audit Trails data. Empty struct.
        """
        cloud_logging_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgsDict']]
        """
        Parse Cloud Logging data. Empty struct.
        """
        json_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserArgsDict']]
        """
        Parse data in json format.
        """
        tskv_parser: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserArgsDict']]
        """
        Parse data if tskv format.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserArgs:
    def __init__(__self__, *,
                 audit_trails_v1_parser: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs']] = None,
                 cloud_logging_parser: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs']] = None,
                 json_parser: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserArgs']] = None,
                 tskv_parser: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs'] audit_trails_v1_parser: Parse Audit Trails data. Empty struct.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs'] cloud_logging_parser: Parse Cloud Logging data. Empty struct.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserArgs'] json_parser: Parse data in json format.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserArgs'] tskv_parser: Parse data if tskv format.
        """
        if audit_trails_v1_parser is not None:
            pulumi.set(__self__, "audit_trails_v1_parser", audit_trails_v1_parser)
        if cloud_logging_parser is not None:
            pulumi.set(__self__, "cloud_logging_parser", cloud_logging_parser)
        if json_parser is not None:
            pulumi.set(__self__, "json_parser", json_parser)
        if tskv_parser is not None:
            pulumi.set(__self__, "tskv_parser", tskv_parser)

    @property
    @pulumi.getter(name="auditTrailsV1Parser")
    def audit_trails_v1_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs']]:
        """
        Parse Audit Trails data. Empty struct.
        """
        return pulumi.get(self, "audit_trails_v1_parser")

    @audit_trails_v1_parser.setter
    def audit_trails_v1_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs']]):
        pulumi.set(self, "audit_trails_v1_parser", value)

    @property
    @pulumi.getter(name="cloudLoggingParser")
    def cloud_logging_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs']]:
        """
        Parse Cloud Logging data. Empty struct.
        """
        return pulumi.get(self, "cloud_logging_parser")

    @cloud_logging_parser.setter
    def cloud_logging_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs']]):
        pulumi.set(self, "cloud_logging_parser", value)

    @property
    @pulumi.getter(name="jsonParser")
    def json_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserArgs']]:
        """
        Parse data in json format.
        """
        return pulumi.get(self, "json_parser")

    @json_parser.setter
    def json_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserArgs']]):
        pulumi.set(self, "json_parser", value)

    @property
    @pulumi.getter(name="tskvParser")
    def tskv_parser(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserArgs']]:
        """
        Parse data if tskv format.
        """
        return pulumi.get(self, "tskv_parser")

    @tskv_parser.setter
    def tskv_parser(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserArgs']]):
        pulumi.set(self, "tskv_parser", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserJsonParserArgsDict(TypedDict):
        add_rest_column: NotRequired[pulumi.Input[bool]]
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        data_schema: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgsDict']]
        """
        Data parsing scheme.The structure is documented below.
        """
        null_keys_allowed: NotRequired[pulumi.Input[bool]]
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        unescape_string_values: NotRequired[pulumi.Input[bool]]
        """
        Allow unescape string values.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserJsonParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserArgs:
    def __init__(__self__, *,
                 add_rest_column: Optional[pulumi.Input[bool]] = None,
                 data_schema: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs']] = None,
                 null_keys_allowed: Optional[pulumi.Input[bool]] = None,
                 unescape_string_values: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] add_rest_column: Add fields, that are not in the schema, into the _rest column.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs'] data_schema: Data parsing scheme.The structure is documented below.
        :param pulumi.Input[bool] null_keys_allowed: Allow null keys. If `false` - null keys will be putted to unparsed data
        :param pulumi.Input[bool] unescape_string_values: Allow unescape string values.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[pulumi.Input[bool]]:
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        return pulumi.get(self, "add_rest_column")

    @add_rest_column.setter
    def add_rest_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_rest_column", value)

    @property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs']]:
        """
        Data parsing scheme.The structure is documented below.
        """
        return pulumi.get(self, "data_schema")

    @data_schema.setter
    def data_schema(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs']]):
        pulumi.set(self, "data_schema", value)

    @property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        return pulumi.get(self, "null_keys_allowed")

    @null_keys_allowed.setter
    def null_keys_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "null_keys_allowed", value)

    @property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow unescape string values.
        """
        return pulumi.get(self, "unescape_string_values")

    @unescape_string_values.setter
    def unescape_string_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unescape_string_values", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgsDict']]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        json_fields: NotRequired[pulumi.Input[str]]
        """
        Description of the data schema as JSON specification.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs']] = None,
                 json_fields: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs'] fields: Description of the data schema in the array of `fields` structure (documented below).
        :param pulumi.Input[str] json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs']]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs']]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")

    @json_fields.setter
    def json_fields(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_fields", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgsDict']]]]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs']]] fields: Description of the data schema in the array of `fields` structure (documented below).
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs']]]]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs']]]]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[bool]]
        """
        Mark field as Primary Key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Field name.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to the field.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Mark field as required.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] key: Mark field as Primary Key.
        :param pulumi.Input[str] name: Field name.
        :param pulumi.Input[str] path: Path to the field.
        :param pulumi.Input[bool] required: Mark field as required.
        :param pulumi.Input[str] type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserTskvParserArgsDict(TypedDict):
        add_rest_column: NotRequired[pulumi.Input[bool]]
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        data_schema: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgsDict']]
        """
        (Required) Data parsing scheme.The structure is documented below.
        """
        null_keys_allowed: NotRequired[pulumi.Input[bool]]
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        unescape_string_values: NotRequired[pulumi.Input[bool]]
        """
        Allow unescape string values.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserTskvParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserArgs:
    def __init__(__self__, *,
                 add_rest_column: Optional[pulumi.Input[bool]] = None,
                 data_schema: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgs']] = None,
                 null_keys_allowed: Optional[pulumi.Input[bool]] = None,
                 unescape_string_values: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] add_rest_column: Add fields, that are not in the schema, into the _rest column.
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgs'] data_schema: (Required) Data parsing scheme.The structure is documented below.
        :param pulumi.Input[bool] null_keys_allowed: Allow null keys. If `false` - null keys will be putted to unparsed data
        :param pulumi.Input[bool] unescape_string_values: Allow unescape string values.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[pulumi.Input[bool]]:
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        return pulumi.get(self, "add_rest_column")

    @add_rest_column.setter
    def add_rest_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_rest_column", value)

    @property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgs']]:
        """
        (Required) Data parsing scheme.The structure is documented below.
        """
        return pulumi.get(self, "data_schema")

    @data_schema.setter
    def data_schema(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgs']]):
        pulumi.set(self, "data_schema", value)

    @property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data
        """
        return pulumi.get(self, "null_keys_allowed")

    @null_keys_allowed.setter
    def null_keys_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "null_keys_allowed", value)

    @property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow unescape string values.
        """
        return pulumi.get(self, "unescape_string_values")

    @unescape_string_values.setter
    def unescape_string_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unescape_string_values", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgsDict']]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        json_fields: NotRequired[pulumi.Input[str]]
        """
        Description of the data schema as JSON specification.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgs']] = None,
                 json_fields: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgs'] fields: Description of the data schema in the array of `fields` structure (documented below).
        :param pulumi.Input[str] json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgs']]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgs']]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")

    @json_fields.setter
    def json_fields(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_fields", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgsDict']]]]
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgs']]] fields: Description of the data schema in the array of `fields` structure (documented below).
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgs']]]]:
        """
        Description of the data schema in the array of `fields` structure (documented below).
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgs']]]]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[bool]]
        """
        Mark field as Primary Key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Field name.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to the field.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Mark field as required.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
elif False:
    DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsFieldArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] key: Mark field as Primary Key.
        :param pulumi.Input[str] name: Field name.
        :param pulumi.Input[str] path: Path to the field.
        :param pulumi.Input[bool] required: Mark field as required.
        :param pulumi.Input[str] type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsTargetArgsDict(TypedDict):
        database: NotRequired[pulumi.Input[str]]
        """
        - (Required) Database.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        - (Optional) YDS Endpoint.
        """
        save_tx_order: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) Save transaction order
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        serializer: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerArgsDict']]
        """
        - (Optional) Data serialization format.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        - (Required) Service account ID for interaction with database.
        """
        stream: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Stream.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
elif False:
    DatatransferEndpointSettingsYdsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsTargetArgs:
    def __init__(__self__, *,
                 database: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 save_tx_order: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 serializer: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerArgs']] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 stream: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database: - (Required) Database.
        :param pulumi.Input[str] endpoint: - (Optional) YDS Endpoint.
        :param pulumi.Input[bool] save_tx_order: - (Optional) Save transaction order
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: - (Optional) List of security groups that the transfer associated with this endpoint should use.
        :param pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerArgs'] serializer: - (Optional) Data serialization format.
        :param pulumi.Input[str] service_account_id: - (Required) Service account ID for interaction with database.
        :param pulumi.Input[str] stream: - (Optional) Stream.
        :param pulumi.Input[str] subnet_id: - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if save_tx_order is not None:
            pulumi.set(__self__, "save_tx_order", save_tx_order)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) YDS Endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="saveTxOrder")
    def save_tx_order(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) Save transaction order
        """
        return pulumi.get(self, "save_tx_order")

    @save_tx_order.setter
    def save_tx_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "save_tx_order", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def serializer(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerArgs']]:
        """
        - (Optional) Data serialization format.
        """
        return pulumi.get(self, "serializer")

    @serializer.setter
    def serializer(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerArgs']]):
        pulumi.set(self, "serializer", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter
    def stream(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Stream.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsTargetSerializerArgsDict(TypedDict):
        serializer_auto: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgsDict']]
        """
        Empty block. Select data serialization format automatically.
        """
        serializer_debezium: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgsDict']]
        """
        Serialize data in json format. The structure is documented below.
        """
        serializer_json: NotRequired[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgsDict']]
        """
        Empty block. Serialize data in json format.
        """
elif False:
    DatatransferEndpointSettingsYdsTargetSerializerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsTargetSerializerArgs:
    def __init__(__self__, *,
                 serializer_auto: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs']] = None,
                 serializer_debezium: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs']] = None,
                 serializer_json: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs']] = None):
        """
        :param pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs'] serializer_auto: Empty block. Select data serialization format automatically.
        :param pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs'] serializer_debezium: Serialize data in json format. The structure is documented below.
        :param pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs'] serializer_json: Empty block. Serialize data in json format.
        """
        if serializer_auto is not None:
            pulumi.set(__self__, "serializer_auto", serializer_auto)
        if serializer_debezium is not None:
            pulumi.set(__self__, "serializer_debezium", serializer_debezium)
        if serializer_json is not None:
            pulumi.set(__self__, "serializer_json", serializer_json)

    @property
    @pulumi.getter(name="serializerAuto")
    def serializer_auto(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs']]:
        """
        Empty block. Select data serialization format automatically.
        """
        return pulumi.get(self, "serializer_auto")

    @serializer_auto.setter
    def serializer_auto(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs']]):
        pulumi.set(self, "serializer_auto", value)

    @property
    @pulumi.getter(name="serializerDebezium")
    def serializer_debezium(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs']]:
        """
        Serialize data in json format. The structure is documented below.
        """
        return pulumi.get(self, "serializer_debezium")

    @serializer_debezium.setter
    def serializer_debezium(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs']]):
        pulumi.set(self, "serializer_debezium", value)

    @property
    @pulumi.getter(name="serializerJson")
    def serializer_json(self) -> Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs']]:
        """
        Empty block. Serialize data in json format.
        """
        return pulumi.get(self, "serializer_json")

    @serializer_json.setter
    def serializer_json(self, value: Optional[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs']]):
        pulumi.set(self, "serializer_json", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgsDict(TypedDict):
        serializer_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgsDict']]]]
        """
        A list of debezium parameters set by the structure of the `key` and `value` string fields.
        """
elif False:
    DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs:
    def __init__(__self__, *,
                 serializer_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs']]] serializer_parameters: A list of debezium parameters set by the structure of the `key` and `value` string fields.
        """
        if serializer_parameters is not None:
            pulumi.set(__self__, "serializer_parameters", serializer_parameters)

    @property
    @pulumi.getter(name="serializerParameters")
    def serializer_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs']]]]:
        """
        A list of debezium parameters set by the structure of the `key` and `value` string fields.
        """
        return pulumi.get(self, "serializer_parameters")

    @serializer_parameters.setter
    def serializer_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs']]]]):
        pulumi.set(self, "serializer_parameters", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Mark field as Primary Key.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Mark field as Primary Key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgsDict(TypedDict):
        pass
elif False:
    DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DatatransferTransferRuntimeArgsDict(TypedDict):
        yc_runtime: NotRequired[pulumi.Input['DatatransferTransferRuntimeYcRuntimeArgsDict']]
        """
        YC Runtime parameters for the transfer.
        """
elif False:
    DatatransferTransferRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferRuntimeArgs:
    def __init__(__self__, *,
                 yc_runtime: Optional[pulumi.Input['DatatransferTransferRuntimeYcRuntimeArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferRuntimeYcRuntimeArgs'] yc_runtime: YC Runtime parameters for the transfer.
        """
        if yc_runtime is not None:
            pulumi.set(__self__, "yc_runtime", yc_runtime)

    @property
    @pulumi.getter(name="ycRuntime")
    def yc_runtime(self) -> Optional[pulumi.Input['DatatransferTransferRuntimeYcRuntimeArgs']]:
        """
        YC Runtime parameters for the transfer.
        """
        return pulumi.get(self, "yc_runtime")

    @yc_runtime.setter
    def yc_runtime(self, value: Optional[pulumi.Input['DatatransferTransferRuntimeYcRuntimeArgs']]):
        pulumi.set(self, "yc_runtime", value)


if not MYPY:
    class DatatransferTransferRuntimeYcRuntimeArgsDict(TypedDict):
        job_count: NotRequired[pulumi.Input[int]]
        """
        Number of workers in parallel replication.
        """
        upload_shard_params: NotRequired[pulumi.Input['DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgsDict']]
        """
        Parallel snapshot parameters.
        """
elif False:
    DatatransferTransferRuntimeYcRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferRuntimeYcRuntimeArgs:
    def __init__(__self__, *,
                 job_count: Optional[pulumi.Input[int]] = None,
                 upload_shard_params: Optional[pulumi.Input['DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs']] = None):
        """
        :param pulumi.Input[int] job_count: Number of workers in parallel replication.
        :param pulumi.Input['DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs'] upload_shard_params: Parallel snapshot parameters.
        """
        if job_count is not None:
            pulumi.set(__self__, "job_count", job_count)
        if upload_shard_params is not None:
            pulumi.set(__self__, "upload_shard_params", upload_shard_params)

    @property
    @pulumi.getter(name="jobCount")
    def job_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of workers in parallel replication.
        """
        return pulumi.get(self, "job_count")

    @job_count.setter
    def job_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_count", value)

    @property
    @pulumi.getter(name="uploadShardParams")
    def upload_shard_params(self) -> Optional[pulumi.Input['DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs']]:
        """
        Parallel snapshot parameters.
        """
        return pulumi.get(self, "upload_shard_params")

    @upload_shard_params.setter
    def upload_shard_params(self, value: Optional[pulumi.Input['DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs']]):
        pulumi.set(self, "upload_shard_params", value)


if not MYPY:
    class DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgsDict(TypedDict):
        job_count: NotRequired[pulumi.Input[int]]
        """
        Number of workers.
        """
        process_count: NotRequired[pulumi.Input[int]]
        """
        Number of threads.
        """
elif False:
    DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs:
    def __init__(__self__, *,
                 job_count: Optional[pulumi.Input[int]] = None,
                 process_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] job_count: Number of workers.
        :param pulumi.Input[int] process_count: Number of threads.
        """
        if job_count is not None:
            pulumi.set(__self__, "job_count", job_count)
        if process_count is not None:
            pulumi.set(__self__, "process_count", process_count)

    @property
    @pulumi.getter(name="jobCount")
    def job_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of workers.
        """
        return pulumi.get(self, "job_count")

    @job_count.setter
    def job_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_count", value)

    @property
    @pulumi.getter(name="processCount")
    def process_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of threads.
        """
        return pulumi.get(self, "process_count")

    @process_count.setter
    def process_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "process_count", value)


if not MYPY:
    class DatatransferTransferTransformationArgsDict(TypedDict):
        transformers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerArgsDict']]]]
        """
        A list of transformers. You can specify exactly 1 transformer in each element of list.
        """
elif False:
    DatatransferTransferTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationArgs:
    def __init__(__self__, *,
                 transformers: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerArgs']]] transformers: A list of transformers. You can specify exactly 1 transformer in each element of list.
        """
        if transformers is not None:
            pulumi.set(__self__, "transformers", transformers)

    @property
    @pulumi.getter
    def transformers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerArgs']]]]:
        """
        A list of transformers. You can specify exactly 1 transformer in each element of list.
        """
        return pulumi.get(self, "transformers")

    @transformers.setter
    def transformers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerArgs']]]]):
        pulumi.set(self, "transformers", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerArgsDict(TypedDict):
        convert_to_string: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringArgsDict']]
        """
        Convert column values to strings.
        """
        filter_columns: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsArgsDict']]
        """
        Set up a list of table columns to transfer.
        """
        filter_rows: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsArgsDict']]
        """
        This filter only applies to transfers with queues (Apache Kafka) as a data source. When running a transfer, only the strings meeting the specified criteria remain in a changefeed.
        """
        mask_field: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldArgsDict']]
        """
        Mask field transformer allows you to hash data.
        """
        rename_tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesArgsDict']]
        """
        Set rules for renaming tables by specifying the current names of the tables in the source and new names for these tables in the target.
        """
        replace_primary_key: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyArgsDict']]
        """
        Override primary keys.
        """
        sharder_transformer: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerArgsDict']]
        """
        Set the number of shards for particular tables and a list of columns whose values will be used for calculating a hash to determine a shard.
        """
        table_splitter_transformer: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerArgsDict']]
        """
        Splits the X table into multiple tables (X_1, X_2, ..., X_n) based on data.
        """
elif False:
    DatatransferTransferTransformationTransformerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerArgs:
    def __init__(__self__, *,
                 convert_to_string: Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringArgs']] = None,
                 filter_columns: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsArgs']] = None,
                 filter_rows: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsArgs']] = None,
                 mask_field: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldArgs']] = None,
                 rename_tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesArgs']] = None,
                 replace_primary_key: Optional[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs']] = None,
                 sharder_transformer: Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerArgs']] = None,
                 table_splitter_transformer: Optional[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringArgs'] convert_to_string: Convert column values to strings.
        :param pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsArgs'] filter_columns: Set up a list of table columns to transfer.
        :param pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsArgs'] filter_rows: This filter only applies to transfers with queues (Apache Kafka) as a data source. When running a transfer, only the strings meeting the specified criteria remain in a changefeed.
        :param pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldArgs'] mask_field: Mask field transformer allows you to hash data.
        :param pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesArgs'] rename_tables: Set rules for renaming tables by specifying the current names of the tables in the source and new names for these tables in the target.
        :param pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs'] replace_primary_key: Override primary keys.
        :param pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerArgs'] sharder_transformer: Set the number of shards for particular tables and a list of columns whose values will be used for calculating a hash to determine a shard.
        :param pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerArgs'] table_splitter_transformer: Splits the X table into multiple tables (X_1, X_2, ..., X_n) based on data.
        """
        if convert_to_string is not None:
            pulumi.set(__self__, "convert_to_string", convert_to_string)
        if filter_columns is not None:
            pulumi.set(__self__, "filter_columns", filter_columns)
        if filter_rows is not None:
            pulumi.set(__self__, "filter_rows", filter_rows)
        if mask_field is not None:
            pulumi.set(__self__, "mask_field", mask_field)
        if rename_tables is not None:
            pulumi.set(__self__, "rename_tables", rename_tables)
        if replace_primary_key is not None:
            pulumi.set(__self__, "replace_primary_key", replace_primary_key)
        if sharder_transformer is not None:
            pulumi.set(__self__, "sharder_transformer", sharder_transformer)
        if table_splitter_transformer is not None:
            pulumi.set(__self__, "table_splitter_transformer", table_splitter_transformer)

    @property
    @pulumi.getter(name="convertToString")
    def convert_to_string(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringArgs']]:
        """
        Convert column values to strings.
        """
        return pulumi.get(self, "convert_to_string")

    @convert_to_string.setter
    def convert_to_string(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringArgs']]):
        pulumi.set(self, "convert_to_string", value)

    @property
    @pulumi.getter(name="filterColumns")
    def filter_columns(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsArgs']]:
        """
        Set up a list of table columns to transfer.
        """
        return pulumi.get(self, "filter_columns")

    @filter_columns.setter
    def filter_columns(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsArgs']]):
        pulumi.set(self, "filter_columns", value)

    @property
    @pulumi.getter(name="filterRows")
    def filter_rows(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsArgs']]:
        """
        This filter only applies to transfers with queues (Apache Kafka) as a data source. When running a transfer, only the strings meeting the specified criteria remain in a changefeed.
        """
        return pulumi.get(self, "filter_rows")

    @filter_rows.setter
    def filter_rows(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsArgs']]):
        pulumi.set(self, "filter_rows", value)

    @property
    @pulumi.getter(name="maskField")
    def mask_field(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldArgs']]:
        """
        Mask field transformer allows you to hash data.
        """
        return pulumi.get(self, "mask_field")

    @mask_field.setter
    def mask_field(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldArgs']]):
        pulumi.set(self, "mask_field", value)

    @property
    @pulumi.getter(name="renameTables")
    def rename_tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesArgs']]:
        """
        Set rules for renaming tables by specifying the current names of the tables in the source and new names for these tables in the target.
        """
        return pulumi.get(self, "rename_tables")

    @rename_tables.setter
    def rename_tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesArgs']]):
        pulumi.set(self, "rename_tables", value)

    @property
    @pulumi.getter(name="replacePrimaryKey")
    def replace_primary_key(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs']]:
        """
        Override primary keys.
        """
        return pulumi.get(self, "replace_primary_key")

    @replace_primary_key.setter
    def replace_primary_key(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs']]):
        pulumi.set(self, "replace_primary_key", value)

    @property
    @pulumi.getter(name="sharderTransformer")
    def sharder_transformer(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerArgs']]:
        """
        Set the number of shards for particular tables and a list of columns whose values will be used for calculating a hash to determine a shard.
        """
        return pulumi.get(self, "sharder_transformer")

    @sharder_transformer.setter
    def sharder_transformer(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerArgs']]):
        pulumi.set(self, "sharder_transformer", value)

    @property
    @pulumi.getter(name="tableSplitterTransformer")
    def table_splitter_transformer(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerArgs']]:
        """
        Splits the X table into multiple tables (X_1, X_2, ..., X_n) based on data.
        """
        return pulumi.get(self, "table_splitter_transformer")

    @table_splitter_transformer.setter
    def table_splitter_transformer(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerArgs']]):
        pulumi.set(self, "table_splitter_transformer", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerConvertToStringArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringColumnsArgsDict']]
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringTablesArgsDict']]
        """
        Table filter (see block documentation below).
        """
elif False:
    DatatransferTransferTransformationTransformerConvertToStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerConvertToStringArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringColumnsArgs']] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringTablesArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringColumnsArgs'] columns: List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        :param pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringTablesArgs'] tables: Table filter (see block documentation below).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringColumnsArgs']]:
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringColumnsArgs']]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringTablesArgs']]:
        """
        Table filter (see block documentation below).
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerConvertToStringTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerConvertToStringColumnsArgsDict(TypedDict):
        exclude_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns that will be excluded to transfer.
        """
        include_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerConvertToStringColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerConvertToStringColumnsArgs:
    def __init__(__self__, *,
                 exclude_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_columns: List of columns that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_columns: List of columns that will be included to transfer.
        """
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)

    @property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_columns")

    @exclude_columns.setter
    def exclude_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_columns", value)

    @property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns that will be included to transfer.
        """
        return pulumi.get(self, "include_columns")

    @include_columns.setter
    def include_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_columns", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerConvertToStringTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerConvertToStringTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerConvertToStringTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerFilterColumnsArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsColumnsArgsDict']]
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsTablesArgsDict']]
        """
        Table filter (see block documentation below).
        """
elif False:
    DatatransferTransferTransformationTransformerFilterColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerFilterColumnsArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs']] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsTablesArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs'] columns: List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        :param pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsTablesArgs'] tables: Table filter (see block documentation below).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs']]:
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs']]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsTablesArgs']]:
        """
        Table filter (see block documentation below).
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterColumnsTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerFilterColumnsColumnsArgsDict(TypedDict):
        exclude_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns that will be excluded to transfer.
        """
        include_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerFilterColumnsColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs:
    def __init__(__self__, *,
                 exclude_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_columns: List of columns that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_columns: List of columns that will be included to transfer.
        """
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)

    @property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_columns")

    @exclude_columns.setter
    def exclude_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_columns", value)

    @property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns that will be included to transfer.
        """
        return pulumi.get(self, "include_columns")

    @include_columns.setter
    def include_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_columns", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerFilterColumnsTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerFilterColumnsTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerFilterColumnsTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerFilterRowsArgsDict(TypedDict):
        filter: NotRequired[pulumi.Input[str]]
        """
        Filtering criterion. This can be comparison operators for numeric, string, and Boolean values, comparison to NULL, and checking whether a substring is part of a string. Details here: https://yandex.cloud/docs/data-transfer/concepts/data-transformation#append-only-sources
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsTablesArgsDict']]
        """
        Table filter (see block documentation below).
        """
elif False:
    DatatransferTransferTransformationTransformerFilterRowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerFilterRowsArgs:
    def __init__(__self__, *,
                 filter: Optional[pulumi.Input[str]] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsTablesArgs']] = None):
        """
        :param pulumi.Input[str] filter: Filtering criterion. This can be comparison operators for numeric, string, and Boolean values, comparison to NULL, and checking whether a substring is part of a string. Details here: https://yandex.cloud/docs/data-transfer/concepts/data-transformation#append-only-sources
        :param pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsTablesArgs'] tables: Table filter (see block documentation below).
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        Filtering criterion. This can be comparison operators for numeric, string, and Boolean values, comparison to NULL, and checking whether a substring is part of a string. Details here: https://yandex.cloud/docs/data-transfer/concepts/data-transformation#append-only-sources
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsTablesArgs']]:
        """
        Table filter (see block documentation below).
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerFilterRowsTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerFilterRowsTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerFilterRowsTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerFilterRowsTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerMaskFieldArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings that specify the name of the column for data masking (a regular expression).
        """
        function: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionArgsDict']]
        """
        Mask function.
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldTablesArgsDict']]
        """
        Table filter.
        """
elif False:
    DatatransferTransferTransformationTransformerMaskFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerMaskFieldArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 function: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionArgs']] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldTablesArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: List of strings that specify the name of the column for data masking (a regular expression).
        :param pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionArgs'] function: Mask function.
        :param pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldTablesArgs'] tables: Table filter.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings that specify the name of the column for data masking (a regular expression).
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionArgs']]:
        """
        Mask function.
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionArgs']]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldTablesArgs']]:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerMaskFieldFunctionArgsDict(TypedDict):
        mask_function_hash: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgsDict']]
        """
        Hash mask function.
        """
elif False:
    DatatransferTransferTransformationTransformerMaskFieldFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerMaskFieldFunctionArgs:
    def __init__(__self__, *,
                 mask_function_hash: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs'] mask_function_hash: Hash mask function.
        """
        if mask_function_hash is not None:
            pulumi.set(__self__, "mask_function_hash", mask_function_hash)

    @property
    @pulumi.getter(name="maskFunctionHash")
    def mask_function_hash(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs']]:
        """
        Hash mask function.
        """
        return pulumi.get(self, "mask_function_hash")

    @mask_function_hash.setter
    def mask_function_hash(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs']]):
        pulumi.set(self, "mask_function_hash", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgsDict(TypedDict):
        user_defined_salt: NotRequired[pulumi.Input[str]]
        """
        This string will be used in the HMAC(sha256, salt) function applied to the column data.
        """
elif False:
    DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs:
    def __init__(__self__, *,
                 user_defined_salt: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_defined_salt: This string will be used in the HMAC(sha256, salt) function applied to the column data.
        """
        if user_defined_salt is not None:
            pulumi.set(__self__, "user_defined_salt", user_defined_salt)

    @property
    @pulumi.getter(name="userDefinedSalt")
    def user_defined_salt(self) -> Optional[pulumi.Input[str]]:
        """
        This string will be used in the HMAC(sha256, salt) function applied to the column data.
        """
        return pulumi.get(self, "user_defined_salt")

    @user_defined_salt.setter
    def user_defined_salt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_defined_salt", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerMaskFieldTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerMaskFieldTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerMaskFieldTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerRenameTablesArgsDict(TypedDict):
        rename_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableArgsDict']]]]
        """
        List of renaming rules.
        """
elif False:
    DatatransferTransferTransformationTransformerRenameTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerRenameTablesArgs:
    def __init__(__self__, *,
                 rename_tables: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs']]] rename_tables: List of renaming rules.
        """
        if rename_tables is not None:
            pulumi.set(__self__, "rename_tables", rename_tables)

    @property
    @pulumi.getter(name="renameTables")
    def rename_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs']]]]:
        """
        List of renaming rules.
        """
        return pulumi.get(self, "rename_tables")

    @rename_tables.setter
    def rename_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs']]]]):
        pulumi.set(self, "rename_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerRenameTablesRenameTableArgsDict(TypedDict):
        new_name: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgsDict']]
        """
        Specify the new names for this table in the target.
        """
        original_name: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgsDict']]
        """
        Specify the current names of the table in the source.
        """
elif False:
    DatatransferTransferTransformationTransformerRenameTablesRenameTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs:
    def __init__(__self__, *,
                 new_name: Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs']] = None,
                 original_name: Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs'] new_name: Specify the new names for this table in the target.
        :param pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs'] original_name: Specify the current names of the table in the source.
        """
        if new_name is not None:
            pulumi.set(__self__, "new_name", new_name)
        if original_name is not None:
            pulumi.set(__self__, "original_name", original_name)

    @property
    @pulumi.getter(name="newName")
    def new_name(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs']]:
        """
        Specify the new names for this table in the target.
        """
        return pulumi.get(self, "new_name")

    @new_name.setter
    def new_name(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs']]):
        pulumi.set(self, "new_name", value)

    @property
    @pulumi.getter(name="originalName")
    def original_name(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs']]:
        """
        Specify the current names of the table in the source.
        """
        return pulumi.get(self, "original_name")

    @original_name.setter
    def original_name(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs']]):
        pulumi.set(self, "original_name", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the transfer.
        """
        name_space: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 name_space: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the transfer.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_space is not None:
            pulumi.set(__self__, "name_space", name_space)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the transfer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameSpace")
    def name_space(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name_space")

    @name_space.setter
    def name_space(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_space", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the transfer.
        """
        name_space: NotRequired[pulumi.Input[str]]
elif False:
    DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 name_space: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the transfer.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_space is not None:
            pulumi.set(__self__, "name_space", name_space)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the transfer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameSpace")
    def name_space(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name_space")

    @name_space.setter
    def name_space(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_space", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerReplacePrimaryKeyArgsDict(TypedDict):
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns to be used as primary keys.
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgsDict']]
        """
        Table filter (see block documentation below).
        """
elif False:
    DatatransferTransferTransformationTransformerReplacePrimaryKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs:
    def __init__(__self__, *,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: List of columns to be used as primary keys.
        :param pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs'] tables: Table filter (see block documentation below).
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns to be used as primary keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs']]:
        """
        Table filter (see block documentation below).
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerSharderTransformerArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerColumnsArgsDict']]
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        """
        shards_count: NotRequired[pulumi.Input[int]]
        """
        Number of shards.
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerTablesArgsDict']]
        """
        Table filter (see block documentation below).
        """
elif False:
    DatatransferTransferTransformationTransformerSharderTransformerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerSharderTransformerArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs']] = None,
                 shards_count: Optional[pulumi.Input[int]] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerTablesArgs']] = None):
        """
        :param pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs'] columns: List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        :param pulumi.Input[int] shards_count: Number of shards.
        :param pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerTablesArgs'] tables: Table filter (see block documentation below).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if shards_count is not None:
            pulumi.set(__self__, "shards_count", shards_count)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs']]:
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns (see block documentation below).
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs']]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="shardsCount")
    def shards_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of shards.
        """
        return pulumi.get(self, "shards_count")

    @shards_count.setter
    def shards_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shards_count", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerTablesArgs']]:
        """
        Table filter (see block documentation below).
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerSharderTransformerTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerSharderTransformerColumnsArgsDict(TypedDict):
        exclude_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns that will be excluded to transfer.
        """
        include_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of columns that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerSharderTransformerColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs:
    def __init__(__self__, *,
                 exclude_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_columns: List of columns that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_columns: List of columns that will be included to transfer.
        """
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)

    @property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_columns")

    @exclude_columns.setter
    def exclude_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_columns", value)

    @property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of columns that will be included to transfer.
        """
        return pulumi.get(self, "include_columns")

    @include_columns.setter
    def include_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_columns", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerSharderTransformerTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerSharderTransformerTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerSharderTransformerTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerTableSplitterTransformerArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings that specify the columns in the tables to be partitioned.
        """
        splitter: NotRequired[pulumi.Input[str]]
        """
        Specify the split string to be used for merging components in a new table name.
        """
        tables: NotRequired[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgsDict']]
        """
        Table filter (see block documentation below).
        """
elif False:
    DatatransferTransferTransformationTransformerTableSplitterTransformerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerTableSplitterTransformerArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 splitter: Optional[pulumi.Input[str]] = None,
                 tables: Optional[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: List of strings that specify the columns in the tables to be partitioned.
        :param pulumi.Input[str] splitter: Specify the split string to be used for merging components in a new table name.
        :param pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs'] tables: Table filter (see block documentation below).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if splitter is not None:
            pulumi.set(__self__, "splitter", splitter)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings that specify the columns in the tables to be partitioned.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def splitter(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the split string to be used for merging components in a new table name.
        """
        return pulumi.get(self, "splitter")

    @splitter.setter
    def splitter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "splitter", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs']]:
        """
        Table filter (see block documentation below).
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgsDict(TypedDict):
        exclude_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be excluded to transfer.
        """
        include_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tables that will be included to transfer.
        """
elif False:
    DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs:
    def __init__(__self__, *,
                 exclude_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tables: List of tables that will be excluded to transfer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @exclude_tables.setter
    def exclude_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tables", value)

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")

    @include_tables.setter
    def include_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tables", value)


if not MYPY:
    class FunctionAsyncInvocationArgsDict(TypedDict):
        retries_count: NotRequired[pulumi.Input[int]]
        """
        Maximum number of retries for async invocation
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        Service account ID for Yandex Cloud Function
        """
        ymq_failure_target: NotRequired[pulumi.Input['FunctionAsyncInvocationYmqFailureTargetArgsDict']]
        """
        Target for unsuccessful async invocation
        """
        ymq_success_target: NotRequired[pulumi.Input['FunctionAsyncInvocationYmqSuccessTargetArgsDict']]
        """
        Target for successful async invocation
        """
elif False:
    FunctionAsyncInvocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAsyncInvocationArgs:
    def __init__(__self__, *,
                 retries_count: Optional[pulumi.Input[int]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 ymq_failure_target: Optional[pulumi.Input['FunctionAsyncInvocationYmqFailureTargetArgs']] = None,
                 ymq_success_target: Optional[pulumi.Input['FunctionAsyncInvocationYmqSuccessTargetArgs']] = None):
        """
        :param pulumi.Input[int] retries_count: Maximum number of retries for async invocation
        :param pulumi.Input[str] service_account_id: Service account ID for Yandex Cloud Function
        :param pulumi.Input['FunctionAsyncInvocationYmqFailureTargetArgs'] ymq_failure_target: Target for unsuccessful async invocation
        :param pulumi.Input['FunctionAsyncInvocationYmqSuccessTargetArgs'] ymq_success_target: Target for successful async invocation
        """
        if retries_count is not None:
            pulumi.set(__self__, "retries_count", retries_count)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if ymq_failure_target is not None:
            pulumi.set(__self__, "ymq_failure_target", ymq_failure_target)
        if ymq_success_target is not None:
            pulumi.set(__self__, "ymq_success_target", ymq_success_target)

    @property
    @pulumi.getter(name="retriesCount")
    def retries_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of retries for async invocation
        """
        return pulumi.get(self, "retries_count")

    @retries_count.setter
    def retries_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries_count", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        Service account ID for Yandex Cloud Function
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="ymqFailureTarget")
    def ymq_failure_target(self) -> Optional[pulumi.Input['FunctionAsyncInvocationYmqFailureTargetArgs']]:
        """
        Target for unsuccessful async invocation
        """
        return pulumi.get(self, "ymq_failure_target")

    @ymq_failure_target.setter
    def ymq_failure_target(self, value: Optional[pulumi.Input['FunctionAsyncInvocationYmqFailureTargetArgs']]):
        pulumi.set(self, "ymq_failure_target", value)

    @property
    @pulumi.getter(name="ymqSuccessTarget")
    def ymq_success_target(self) -> Optional[pulumi.Input['FunctionAsyncInvocationYmqSuccessTargetArgs']]:
        """
        Target for successful async invocation
        """
        return pulumi.get(self, "ymq_success_target")

    @ymq_success_target.setter
    def ymq_success_target(self, value: Optional[pulumi.Input['FunctionAsyncInvocationYmqSuccessTargetArgs']]):
        pulumi.set(self, "ymq_success_target", value)


if not MYPY:
    class FunctionAsyncInvocationYmqFailureTargetArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        YMQ ARN
        """
        service_account_id: pulumi.Input[str]
        """
        Service account ID for Yandex Cloud Function
        """
elif False:
    FunctionAsyncInvocationYmqFailureTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAsyncInvocationYmqFailureTargetArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 service_account_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] arn: YMQ ARN
        :param pulumi.Input[str] service_account_id: Service account ID for Yandex Cloud Function
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        YMQ ARN
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account ID for Yandex Cloud Function
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class FunctionAsyncInvocationYmqSuccessTargetArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        YMQ ARN
        """
        service_account_id: pulumi.Input[str]
        """
        Service account ID for Yandex Cloud Function
        """
elif False:
    FunctionAsyncInvocationYmqSuccessTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAsyncInvocationYmqSuccessTargetArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 service_account_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] arn: YMQ ARN
        :param pulumi.Input[str] service_account_id: Service account ID for Yandex Cloud Function
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        YMQ ARN
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account ID for Yandex Cloud Function
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class FunctionConnectivityArgsDict(TypedDict):
        network_id: pulumi.Input[str]
elif False:
    FunctionConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionConnectivityArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[str]):
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class FunctionContentArgsDict(TypedDict):
        zip_filename: pulumi.Input[str]
elif False:
    FunctionContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionContentArgs:
    def __init__(__self__, *,
                 zip_filename: pulumi.Input[str]):
        pulumi.set(__self__, "zip_filename", zip_filename)

    @property
    @pulumi.getter(name="zipFilename")
    def zip_filename(self) -> pulumi.Input[str]:
        return pulumi.get(self, "zip_filename")

    @zip_filename.setter
    def zip_filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "zip_filename", value)


if not MYPY:
    class FunctionLogOptionsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Is logging from function disabled
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Folder ID for the Yandex Cloud Function
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to specified log group
        """
        min_level: NotRequired[pulumi.Input[str]]
        """
        Minimum log entry level
        """
elif False:
    FunctionLogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLogOptionsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 min_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: Is logging from function disabled
        :param pulumi.Input[str] folder_id: Folder ID for the Yandex Cloud Function
        :param pulumi.Input[str] log_group_id: Log entries are written to specified log group
        :param pulumi.Input[str] min_level: Minimum log entry level
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is logging from function disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Folder ID for the Yandex Cloud Function
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to specified log group
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum log entry level
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)


if not MYPY:
    class FunctionMountArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Yandex Cloud Function name used to define trigger
        """
        ephemeral_disk: NotRequired[pulumi.Input['FunctionMountEphemeralDiskArgsDict']]
        mode: NotRequired[pulumi.Input[str]]
        object_storage: NotRequired[pulumi.Input['FunctionMountObjectStorageArgsDict']]
elif False:
    FunctionMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionMountArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 ephemeral_disk: Optional[pulumi.Input['FunctionMountEphemeralDiskArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 object_storage: Optional[pulumi.Input['FunctionMountObjectStorageArgs']] = None):
        """
        :param pulumi.Input[str] name: Yandex Cloud Function name used to define trigger
        """
        pulumi.set(__self__, "name", name)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Yandex Cloud Function name used to define trigger
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional[pulumi.Input['FunctionMountEphemeralDiskArgs']]:
        return pulumi.get(self, "ephemeral_disk")

    @ephemeral_disk.setter
    def ephemeral_disk(self, value: Optional[pulumi.Input['FunctionMountEphemeralDiskArgs']]):
        pulumi.set(self, "ephemeral_disk", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional[pulumi.Input['FunctionMountObjectStorageArgs']]:
        return pulumi.get(self, "object_storage")

    @object_storage.setter
    def object_storage(self, value: Optional[pulumi.Input['FunctionMountObjectStorageArgs']]):
        pulumi.set(self, "object_storage", value)


if not MYPY:
    class FunctionMountEphemeralDiskArgsDict(TypedDict):
        size_gb: pulumi.Input[int]
        block_size_kb: NotRequired[pulumi.Input[int]]
elif False:
    FunctionMountEphemeralDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionMountEphemeralDiskArgs:
    def __init__(__self__, *,
                 size_gb: pulumi.Input[int],
                 block_size_kb: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "size_gb", size_gb)
        if block_size_kb is not None:
            pulumi.set(__self__, "block_size_kb", block_size_kb)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_gb", value)

    @property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "block_size_kb")

    @block_size_kb.setter
    def block_size_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size_kb", value)


if not MYPY:
    class FunctionMountObjectStorageArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        prefix: NotRequired[pulumi.Input[str]]
elif False:
    FunctionMountObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionMountObjectStorageArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class FunctionPackageArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        object_name: pulumi.Input[str]
        sha256: NotRequired[pulumi.Input[str]]
elif False:
    FunctionPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionPackageArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 object_name: pulumi.Input[str],
                 sha256: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "object_name", object_name)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "object_name")

    @object_name.setter
    def object_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_name", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class FunctionScalingPolicyPolicyArgsDict(TypedDict):
        tag: pulumi.Input[str]
        zone_instances_limit: NotRequired[pulumi.Input[int]]
        zone_requests_limit: NotRequired[pulumi.Input[int]]
elif False:
    FunctionScalingPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionScalingPolicyPolicyArgs:
    def __init__(__self__, *,
                 tag: pulumi.Input[str],
                 zone_instances_limit: Optional[pulumi.Input[int]] = None,
                 zone_requests_limit: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "tag", tag)
        if zone_instances_limit is not None:
            pulumi.set(__self__, "zone_instances_limit", zone_instances_limit)
        if zone_requests_limit is not None:
            pulumi.set(__self__, "zone_requests_limit", zone_requests_limit)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter(name="zoneInstancesLimit")
    def zone_instances_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "zone_instances_limit")

    @zone_instances_limit.setter
    def zone_instances_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zone_instances_limit", value)

    @property
    @pulumi.getter(name="zoneRequestsLimit")
    def zone_requests_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "zone_requests_limit")

    @zone_requests_limit.setter
    def zone_requests_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zone_requests_limit", value)


if not MYPY:
    class FunctionSecretArgsDict(TypedDict):
        environment_variable: pulumi.Input[str]
        """
        (Required) Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        id: pulumi.Input[str]
        """
        (Required) Secret's id
        """
        key: pulumi.Input[str]
        """
        (Required) Secret's entries key which value will be stored in environment variable
        """
        version_id: pulumi.Input[str]
        """
        (Required) Secret's version id
        """
elif False:
    FunctionSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSecretArgs:
    def __init__(__self__, *,
                 environment_variable: pulumi.Input[str],
                 id: pulumi.Input[str],
                 key: pulumi.Input[str],
                 version_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] environment_variable: (Required) Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        :param pulumi.Input[str] id: (Required) Secret's id
        :param pulumi.Input[str] key: (Required) Secret's entries key which value will be stored in environment variable
        :param pulumi.Input[str] version_id: (Required) Secret's version id
        """
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> pulumi.Input[str]:
        """
        (Required) Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment_variable")

    @environment_variable.setter
    def environment_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_variable", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Required) Secret's id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        (Required) Secret's entries key which value will be stored in environment variable
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> pulumi.Input[str]:
        """
        (Required) Secret's version id
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class FunctionStorageMountArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        mount_point_name: pulumi.Input[str]
        prefix: NotRequired[pulumi.Input[str]]
        read_only: NotRequired[pulumi.Input[bool]]
elif False:
    FunctionStorageMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionStorageMountArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 mount_point_name: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_name", mount_point_name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="mountPointName")
    def mount_point_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mount_point_name")

    @mount_point_name.setter
    def mount_point_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point_name", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class FunctionTriggerContainerArgsDict(TypedDict):
        id: pulumi.Input[str]
        path: NotRequired[pulumi.Input[str]]
        retry_attempts: NotRequired[pulumi.Input[str]]
        retry_interval: NotRequired[pulumi.Input[str]]
        service_account_id: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerContainerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 retry_attempts: Optional[pulumi.Input[str]] = None,
                 retry_interval: Optional[pulumi.Input[str]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "id", id)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if retry_attempts is not None:
            pulumi.set(__self__, "retry_attempts", retry_attempts)
        if retry_interval is not None:
            pulumi.set(__self__, "retry_interval", retry_interval)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retry_attempts")

    @retry_attempts.setter
    def retry_attempts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_attempts", value)

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retry_interval")

    @retry_interval.setter
    def retry_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_interval", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class FunctionTriggerContainerRegistryArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        registry_id: pulumi.Input[str]
        batch_size: NotRequired[pulumi.Input[str]]
        create_image: NotRequired[pulumi.Input[bool]]
        create_image_tag: NotRequired[pulumi.Input[bool]]
        delete_image: NotRequired[pulumi.Input[bool]]
        delete_image_tag: NotRequired[pulumi.Input[bool]]
        image_name: NotRequired[pulumi.Input[str]]
        tag: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerContainerRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerContainerRegistryArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 registry_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[str]] = None,
                 create_image: Optional[pulumi.Input[bool]] = None,
                 create_image_tag: Optional[pulumi.Input[bool]] = None,
                 delete_image: Optional[pulumi.Input[bool]] = None,
                 delete_image_tag: Optional[pulumi.Input[bool]] = None,
                 image_name: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "registry_id", registry_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if create_image is not None:
            pulumi.set(__self__, "create_image", create_image)
        if create_image_tag is not None:
            pulumi.set(__self__, "create_image_tag", create_image_tag)
        if delete_image is not None:
            pulumi.set(__self__, "delete_image", delete_image)
        if delete_image_tag is not None:
            pulumi.set(__self__, "delete_image_tag", delete_image_tag)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "registry_id")

    @registry_id.setter
    def registry_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="createImage")
    def create_image(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_image")

    @create_image.setter
    def create_image(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_image", value)

    @property
    @pulumi.getter(name="createImageTag")
    def create_image_tag(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_image_tag")

    @create_image_tag.setter
    def create_image_tag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_image_tag", value)

    @property
    @pulumi.getter(name="deleteImage")
    def delete_image(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_image")

    @delete_image.setter
    def delete_image(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_image", value)

    @property
    @pulumi.getter(name="deleteImageTag")
    def delete_image_tag(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_image_tag")

    @delete_image_tag.setter
    def delete_image_tag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_image_tag", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class FunctionTriggerDataStreamsArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        database: pulumi.Input[str]
        service_account_id: pulumi.Input[str]
        stream_name: pulumi.Input[str]
        batch_size: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerDataStreamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerDataStreamsArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 database: pulumi.Input[str],
                 service_account_id: pulumi.Input[str],
                 stream_name: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)


if not MYPY:
    class FunctionTriggerDlqArgsDict(TypedDict):
        queue_id: pulumi.Input[str]
        service_account_id: pulumi.Input[str]
elif False:
    FunctionTriggerDlqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerDlqArgs:
    def __init__(__self__, *,
                 queue_id: pulumi.Input[str],
                 service_account_id: pulumi.Input[str]):
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "queue_id")

    @queue_id.setter
    def queue_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_id", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class FunctionTriggerFunctionArgsDict(TypedDict):
        id: pulumi.Input[str]
        retry_attempts: NotRequired[pulumi.Input[str]]
        retry_interval: NotRequired[pulumi.Input[str]]
        service_account_id: NotRequired[pulumi.Input[str]]
        tag: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerFunctionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 retry_attempts: Optional[pulumi.Input[str]] = None,
                 retry_interval: Optional[pulumi.Input[str]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "id", id)
        if retry_attempts is not None:
            pulumi.set(__self__, "retry_attempts", retry_attempts)
        if retry_interval is not None:
            pulumi.set(__self__, "retry_interval", retry_interval)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retry_attempts")

    @retry_attempts.setter
    def retry_attempts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_attempts", value)

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retry_interval")

    @retry_interval.setter
    def retry_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_interval", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class FunctionTriggerIotArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        registry_id: pulumi.Input[str]
        batch_size: NotRequired[pulumi.Input[str]]
        device_id: NotRequired[pulumi.Input[str]]
        topic: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerIotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerIotArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 registry_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[str]] = None,
                 device_id: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "registry_id", registry_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "registry_id")

    @registry_id.setter
    def registry_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class FunctionTriggerLogGroupArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        log_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        batch_size: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerLogGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerLogGroupArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 log_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 batch_size: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "log_group_ids", log_group_ids)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="logGroupIds")
    def log_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "log_group_ids")

    @log_group_ids.setter
    def log_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "log_group_ids", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)


if not MYPY:
    class FunctionTriggerLoggingArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        group_id: pulumi.Input[str]
        batch_size: NotRequired[pulumi.Input[str]]
        levels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        resource_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        stream_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    FunctionTriggerLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerLoggingArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 group_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[str]] = None,
                 levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stream_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "group_id", group_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if levels is not None:
            pulumi.set(__self__, "levels", levels)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if stream_names is not None:
            pulumi.set(__self__, "stream_names", stream_names)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter
    def levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "levels")

    @levels.setter
    def levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "levels", value)

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "resource_ids")

    @resource_ids.setter
    def resource_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_ids", value)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_types", value)

    @property
    @pulumi.getter(name="streamNames")
    def stream_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "stream_names")

    @stream_names.setter
    def stream_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stream_names", value)


if not MYPY:
    class FunctionTriggerMailArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        attachments_bucket_id: NotRequired[pulumi.Input[str]]
        batch_size: NotRequired[pulumi.Input[str]]
        service_account_id: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerMailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerMailArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 attachments_bucket_id: Optional[pulumi.Input[str]] = None,
                 batch_size: Optional[pulumi.Input[str]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        if attachments_bucket_id is not None:
            pulumi.set(__self__, "attachments_bucket_id", attachments_bucket_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="attachmentsBucketId")
    def attachments_bucket_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attachments_bucket_id")

    @attachments_bucket_id.setter
    def attachments_bucket_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attachments_bucket_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class FunctionTriggerMessageQueueArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        queue_id: pulumi.Input[str]
        service_account_id: pulumi.Input[str]
        batch_size: NotRequired[pulumi.Input[str]]
        visibility_timeout: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerMessageQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerMessageQueueArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 queue_id: pulumi.Input[str],
                 service_account_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[str]] = None,
                 visibility_timeout: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "queue_id")

    @queue_id.setter
    def queue_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_id", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visibility_timeout")

    @visibility_timeout.setter
    def visibility_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visibility_timeout", value)


if not MYPY:
    class FunctionTriggerObjectStorageArgsDict(TypedDict):
        batch_cutoff: pulumi.Input[str]
        bucket_id: pulumi.Input[str]
        batch_size: NotRequired[pulumi.Input[str]]
        create: NotRequired[pulumi.Input[bool]]
        delete: NotRequired[pulumi.Input[bool]]
        prefix: NotRequired[pulumi.Input[str]]
        suffix: NotRequired[pulumi.Input[str]]
        update: NotRequired[pulumi.Input[bool]]
elif False:
    FunctionTriggerObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerObjectStorageArgs:
    def __init__(__self__, *,
                 batch_cutoff: pulumi.Input[str],
                 bucket_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[str]] = None,
                 create: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "bucket_id", bucket_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> pulumi.Input[str]:
        return pulumi.get(self, "batch_cutoff")

    @batch_cutoff.setter
    def batch_cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "batch_cutoff", value)

    @property
    @pulumi.getter(name="bucketId")
    def bucket_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_id")

    @bucket_id.setter
    def bucket_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class FunctionTriggerTimerArgsDict(TypedDict):
        cron_expression: pulumi.Input[str]
        payload: NotRequired[pulumi.Input[str]]
elif False:
    FunctionTriggerTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTriggerTimerArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 payload: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "cron_expression", cron_expression)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class IamServiceAccountApiKeyOutputToLockboxArgsDict(TypedDict):
        entry_for_secret_key: pulumi.Input[str]
        """
        Entry where to store the value of `secret_key`.
        """
        secret_id: pulumi.Input[str]
        """
        ID of the Lockbox secret where to store the sensible values.
        """
elif False:
    IamServiceAccountApiKeyOutputToLockboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamServiceAccountApiKeyOutputToLockboxArgs:
    def __init__(__self__, *,
                 entry_for_secret_key: pulumi.Input[str],
                 secret_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] entry_for_secret_key: Entry where to store the value of `secret_key`.
        :param pulumi.Input[str] secret_id: ID of the Lockbox secret where to store the sensible values.
        """
        pulumi.set(__self__, "entry_for_secret_key", entry_for_secret_key)
        pulumi.set(__self__, "secret_id", secret_id)

    @property
    @pulumi.getter(name="entryForSecretKey")
    def entry_for_secret_key(self) -> pulumi.Input[str]:
        """
        Entry where to store the value of `secret_key`.
        """
        return pulumi.get(self, "entry_for_secret_key")

    @entry_for_secret_key.setter
    def entry_for_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_for_secret_key", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        ID of the Lockbox secret where to store the sensible values.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class IamServiceAccountKeyOutputToLockboxArgsDict(TypedDict):
        entry_for_private_key: pulumi.Input[str]
        """
        Entry where to store the value of `private_key`.
        """
        secret_id: pulumi.Input[str]
        """
        ID of the Lockbox secret where to store the sensible values.
        """
elif False:
    IamServiceAccountKeyOutputToLockboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamServiceAccountKeyOutputToLockboxArgs:
    def __init__(__self__, *,
                 entry_for_private_key: pulumi.Input[str],
                 secret_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] entry_for_private_key: Entry where to store the value of `private_key`.
        :param pulumi.Input[str] secret_id: ID of the Lockbox secret where to store the sensible values.
        """
        pulumi.set(__self__, "entry_for_private_key", entry_for_private_key)
        pulumi.set(__self__, "secret_id", secret_id)

    @property
    @pulumi.getter(name="entryForPrivateKey")
    def entry_for_private_key(self) -> pulumi.Input[str]:
        """
        Entry where to store the value of `private_key`.
        """
        return pulumi.get(self, "entry_for_private_key")

    @entry_for_private_key.setter
    def entry_for_private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_for_private_key", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        ID of the Lockbox secret where to store the sensible values.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class IamServiceAccountStaticAccessKeyOutputToLockboxArgsDict(TypedDict):
        entry_for_access_key: pulumi.Input[str]
        """
        Entry where to store the value of `access_key`.
        """
        entry_for_secret_key: pulumi.Input[str]
        """
        Entry where to store the value of `secret_key`.
        """
        secret_id: pulumi.Input[str]
        """
        ID of the Lockbox secret where to store the sensible values.
        """
elif False:
    IamServiceAccountStaticAccessKeyOutputToLockboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamServiceAccountStaticAccessKeyOutputToLockboxArgs:
    def __init__(__self__, *,
                 entry_for_access_key: pulumi.Input[str],
                 entry_for_secret_key: pulumi.Input[str],
                 secret_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] entry_for_access_key: Entry where to store the value of `access_key`.
        :param pulumi.Input[str] entry_for_secret_key: Entry where to store the value of `secret_key`.
        :param pulumi.Input[str] secret_id: ID of the Lockbox secret where to store the sensible values.
        """
        pulumi.set(__self__, "entry_for_access_key", entry_for_access_key)
        pulumi.set(__self__, "entry_for_secret_key", entry_for_secret_key)
        pulumi.set(__self__, "secret_id", secret_id)

    @property
    @pulumi.getter(name="entryForAccessKey")
    def entry_for_access_key(self) -> pulumi.Input[str]:
        """
        Entry where to store the value of `access_key`.
        """
        return pulumi.get(self, "entry_for_access_key")

    @entry_for_access_key.setter
    def entry_for_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_for_access_key", value)

    @property
    @pulumi.getter(name="entryForSecretKey")
    def entry_for_secret_key(self) -> pulumi.Input[str]:
        """
        Entry where to store the value of `secret_key`.
        """
        return pulumi.get(self, "entry_for_secret_key")

    @entry_for_secret_key.setter
    def entry_for_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_for_secret_key", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        ID of the Lockbox secret where to store the sensible values.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class IotCoreBrokerLogOptionsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Is logging for broker disabled
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to default log group for specified folder
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to specified log group
        """
        min_level: NotRequired[pulumi.Input[str]]
        """
        Minimum log entry level
        """
elif False:
    IotCoreBrokerLogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotCoreBrokerLogOptionsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 min_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: Is logging for broker disabled
        :param pulumi.Input[str] folder_id: Log entries are written to default log group for specified folder
        :param pulumi.Input[str] log_group_id: Log entries are written to specified log group
        :param pulumi.Input[str] min_level: Minimum log entry level
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is logging for broker disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to default log group for specified folder
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to specified log group
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum log entry level
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)


if not MYPY:
    class IotCoreRegistryLogOptionsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Is logging for registry disabled
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to default log group for specified folder
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to specified log group
        """
        min_level: NotRequired[pulumi.Input[str]]
        """
        Minimum log entry level
        """
elif False:
    IotCoreRegistryLogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IotCoreRegistryLogOptionsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 min_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: Is logging for registry disabled
        :param pulumi.Input[str] folder_id: Log entries are written to default log group for specified folder
        :param pulumi.Input[str] log_group_id: Log entries are written to specified log group
        :param pulumi.Input[str] min_level: Minimum log entry level
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is logging for registry disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to default log group for specified folder
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to specified log group
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum log entry level
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)


if not MYPY:
    class KubernetesClusterKmsProviderArgsDict(TypedDict):
        key_id: NotRequired[pulumi.Input[str]]
        """
        KMS key ID.
        """
elif False:
    KubernetesClusterKmsProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterKmsProviderArgs:
    def __init__(__self__, *,
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_id: KMS key ID.
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        KMS key ID.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class KubernetesClusterMasterArgsDict(TypedDict):
        cluster_ca_certificate: NotRequired[pulumi.Input[str]]
        """
        (Computed) PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        """
        etcd_cluster_size: NotRequired[pulumi.Input[int]]
        external_v4_address: NotRequired[pulumi.Input[str]]
        """
        (Computed) An IPv4 external network address that is assigned to the master.
        """
        external_v4_endpoint: NotRequired[pulumi.Input[str]]
        """
        (Computed) External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        external_v6_address: NotRequired[pulumi.Input[str]]
        external_v6_endpoint: NotRequired[pulumi.Input[str]]
        internal_v4_address: NotRequired[pulumi.Input[str]]
        """
        (Computed) An IPv4 internal network address that is assigned to the master.
        """
        internal_v4_endpoint: NotRequired[pulumi.Input[str]]
        """
        (Computed) Internal endpoint that can be used to connect to the master from cloud networks.
        """
        maintenance_policy: NotRequired[pulumi.Input['KubernetesClusterMasterMaintenancePolicyArgsDict']]
        """
        (Optional) (Computed) Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually. The structure is documented below.
        """
        master_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMasterLocationArgsDict']]]]
        """
        (Optional) Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated inplace. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend. The structure is documented below.
        """
        master_logging: NotRequired[pulumi.Input['KubernetesClusterMasterMasterLoggingArgsDict']]
        """
        (Optional) Master Logging options. The structure is documented below.
        """
        public_ip: NotRequired[pulumi.Input[bool]]
        """
        (Optional) (Computed) Boolean flag. When `true`, Kubernetes master will have visible ipv4 address.
        """
        regional: NotRequired[pulumi.Input['KubernetesClusterMasterRegionalArgsDict']]
        """
        (Optional) Initialize parameters for Regional Master (highly available master). The structure is documented below.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) List of security group IDs to which the Kubernetes cluster belongs.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        (Optional) (Computed) Version of Kubernetes that will be used for master.
        """
        version_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterVersionInfoArgsDict']]]]
        """
        (Computed) Information about cluster version. The structure is documented below.
        """
        zonal: NotRequired[pulumi.Input['KubernetesClusterMasterZonalArgsDict']]
        """
        (Optional) Initialize parameters for Zonal Master (single node master). The structure is documented below.
        """
elif False:
    KubernetesClusterMasterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterArgs:
    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 etcd_cluster_size: Optional[pulumi.Input[int]] = None,
                 external_v4_address: Optional[pulumi.Input[str]] = None,
                 external_v4_endpoint: Optional[pulumi.Input[str]] = None,
                 external_v6_address: Optional[pulumi.Input[str]] = None,
                 external_v6_endpoint: Optional[pulumi.Input[str]] = None,
                 internal_v4_address: Optional[pulumi.Input[str]] = None,
                 internal_v4_endpoint: Optional[pulumi.Input[str]] = None,
                 maintenance_policy: Optional[pulumi.Input['KubernetesClusterMasterMaintenancePolicyArgs']] = None,
                 master_locations: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMasterLocationArgs']]]] = None,
                 master_logging: Optional[pulumi.Input['KubernetesClusterMasterMasterLoggingArgs']] = None,
                 public_ip: Optional[pulumi.Input[bool]] = None,
                 regional: Optional[pulumi.Input['KubernetesClusterMasterRegionalArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 version_infos: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterVersionInfoArgs']]]] = None,
                 zonal: Optional[pulumi.Input['KubernetesClusterMasterZonalArgs']] = None):
        """
        :param pulumi.Input[str] cluster_ca_certificate: (Computed) PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        :param pulumi.Input[str] external_v4_address: (Computed) An IPv4 external network address that is assigned to the master.
        :param pulumi.Input[str] external_v4_endpoint: (Computed) External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param pulumi.Input[str] internal_v4_address: (Computed) An IPv4 internal network address that is assigned to the master.
        :param pulumi.Input[str] internal_v4_endpoint: (Computed) Internal endpoint that can be used to connect to the master from cloud networks.
        :param pulumi.Input['KubernetesClusterMasterMaintenancePolicyArgs'] maintenance_policy: (Optional) (Computed) Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMasterLocationArgs']]] master_locations: (Optional) Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated inplace. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend. The structure is documented below.
        :param pulumi.Input['KubernetesClusterMasterMasterLoggingArgs'] master_logging: (Optional) Master Logging options. The structure is documented below.
        :param pulumi.Input[bool] public_ip: (Optional) (Computed) Boolean flag. When `true`, Kubernetes master will have visible ipv4 address.
        :param pulumi.Input['KubernetesClusterMasterRegionalArgs'] regional: (Optional) Initialize parameters for Regional Master (highly available master). The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: (Optional) List of security group IDs to which the Kubernetes cluster belongs.
        :param pulumi.Input[str] version: (Optional) (Computed) Version of Kubernetes that will be used for master.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterVersionInfoArgs']]] version_infos: (Computed) Information about cluster version. The structure is documented below.
        :param pulumi.Input['KubernetesClusterMasterZonalArgs'] zonal: (Optional) Initialize parameters for Zonal Master (single node master). The structure is documented below.
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if external_v4_address is not None:
            pulumi.set(__self__, "external_v4_address", external_v4_address)
        if external_v4_endpoint is not None:
            pulumi.set(__self__, "external_v4_endpoint", external_v4_endpoint)
        if external_v6_address is not None:
            pulumi.set(__self__, "external_v6_address", external_v6_address)
        if external_v6_endpoint is not None:
            pulumi.set(__self__, "external_v6_endpoint", external_v6_endpoint)
        if internal_v4_address is not None:
            pulumi.set(__self__, "internal_v4_address", internal_v4_address)
        if internal_v4_endpoint is not None:
            pulumi.set(__self__, "internal_v4_endpoint", internal_v4_endpoint)
        if maintenance_policy is not None:
            pulumi.set(__self__, "maintenance_policy", maintenance_policy)
        if master_locations is not None:
            pulumi.set(__self__, "master_locations", master_locations)
        if master_logging is not None:
            pulumi.set(__self__, "master_logging", master_logging)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if regional is not None:
            pulumi.set(__self__, "regional", regional)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_infos is not None:
            pulumi.set(__self__, "version_infos", version_infos)
        if zonal is not None:
            pulumi.set(__self__, "zonal", zonal)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "etcd_cluster_size")

    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "etcd_cluster_size", value)

    @property
    @pulumi.getter(name="externalV4Address")
    def external_v4_address(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) An IPv4 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v4_address")

    @external_v4_address.setter
    def external_v4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_v4_address", value)

    @property
    @pulumi.getter(name="externalV4Endpoint")
    def external_v4_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v4_endpoint")

    @external_v4_endpoint.setter
    def external_v4_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_v4_endpoint", value)

    @property
    @pulumi.getter(name="externalV6Address")
    def external_v6_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_v6_address")

    @external_v6_address.setter
    def external_v6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_v6_address", value)

    @property
    @pulumi.getter(name="externalV6Endpoint")
    def external_v6_endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_v6_endpoint")

    @external_v6_endpoint.setter
    def external_v6_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_v6_endpoint", value)

    @property
    @pulumi.getter(name="internalV4Address")
    def internal_v4_address(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) An IPv4 internal network address that is assigned to the master.
        """
        return pulumi.get(self, "internal_v4_address")

    @internal_v4_address.setter
    def internal_v4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_v4_address", value)

    @property
    @pulumi.getter(name="internalV4Endpoint")
    def internal_v4_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) Internal endpoint that can be used to connect to the master from cloud networks.
        """
        return pulumi.get(self, "internal_v4_endpoint")

    @internal_v4_endpoint.setter
    def internal_v4_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_v4_endpoint", value)

    @property
    @pulumi.getter(name="maintenancePolicy")
    def maintenance_policy(self) -> Optional[pulumi.Input['KubernetesClusterMasterMaintenancePolicyArgs']]:
        """
        (Optional) (Computed) Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually. The structure is documented below.
        """
        return pulumi.get(self, "maintenance_policy")

    @maintenance_policy.setter
    def maintenance_policy(self, value: Optional[pulumi.Input['KubernetesClusterMasterMaintenancePolicyArgs']]):
        pulumi.set(self, "maintenance_policy", value)

    @property
    @pulumi.getter(name="masterLocations")
    def master_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMasterLocationArgs']]]]:
        """
        (Optional) Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated inplace. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend. The structure is documented below.
        """
        return pulumi.get(self, "master_locations")

    @master_locations.setter
    def master_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMasterLocationArgs']]]]):
        pulumi.set(self, "master_locations", value)

    @property
    @pulumi.getter(name="masterLogging")
    def master_logging(self) -> Optional[pulumi.Input['KubernetesClusterMasterMasterLoggingArgs']]:
        """
        (Optional) Master Logging options. The structure is documented below.
        """
        return pulumi.get(self, "master_logging")

    @master_logging.setter
    def master_logging(self, value: Optional[pulumi.Input['KubernetesClusterMasterMasterLoggingArgs']]):
        pulumi.set(self, "master_logging", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) (Computed) Boolean flag. When `true`, Kubernetes master will have visible ipv4 address.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def regional(self) -> Optional[pulumi.Input['KubernetesClusterMasterRegionalArgs']]:
        """
        (Optional) Initialize parameters for Regional Master (highly available master). The structure is documented below.
        """
        return pulumi.get(self, "regional")

    @regional.setter
    def regional(self, value: Optional[pulumi.Input['KubernetesClusterMasterRegionalArgs']]):
        pulumi.set(self, "regional", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) List of security group IDs to which the Kubernetes cluster belongs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) (Computed) Version of Kubernetes that will be used for master.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="versionInfos")
    def version_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterVersionInfoArgs']]]]:
        """
        (Computed) Information about cluster version. The structure is documented below.
        """
        return pulumi.get(self, "version_infos")

    @version_infos.setter
    def version_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterVersionInfoArgs']]]]):
        pulumi.set(self, "version_infos", value)

    @property
    @pulumi.getter
    def zonal(self) -> Optional[pulumi.Input['KubernetesClusterMasterZonalArgs']]:
        """
        (Optional) Initialize parameters for Zonal Master (single node master). The structure is documented below.
        """
        return pulumi.get(self, "zonal")

    @zonal.setter
    def zonal(self, value: Optional[pulumi.Input['KubernetesClusterMasterZonalArgs']]):
        pulumi.set(self, "zonal", value)


if not MYPY:
    class KubernetesClusterMasterMaintenancePolicyArgsDict(TypedDict):
        auto_upgrade: pulumi.Input[bool]
        """
        (Required) Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        """
        maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgsDict']]]]
        """
        (Optional) (Computed) This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
elif False:
    KubernetesClusterMasterMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterMaintenancePolicyArgs:
    def __init__(__self__, *,
                 auto_upgrade: pulumi.Input[bool],
                 maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs']]]] = None):
        """
        :param pulumi.Input[bool] auto_upgrade: (Required) Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs']]] maintenance_windows: (Optional) (Computed) This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> pulumi.Input[bool]:
        """
        (Required) Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_upgrade")

    @auto_upgrade.setter
    def auto_upgrade(self, value: pulumi.Input[bool]):
        pulumi.set(self, "auto_upgrade", value)

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs']]]]:
        """
        (Optional) (Computed) This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
        return pulumi.get(self, "maintenance_windows")

    @maintenance_windows.setter
    def maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs']]]]):
        pulumi.set(self, "maintenance_windows", value)


if not MYPY:
    class KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgsDict(TypedDict):
        duration: pulumi.Input[str]
        start_time: pulumi.Input[str]
        day: NotRequired[pulumi.Input[str]]
elif False:
    KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        if day is not None:
            pulumi.set(__self__, "day", day)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)


if not MYPY:
    class KubernetesClusterMasterMasterLocationArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the subnet.
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the availability zone.
        """
elif False:
    KubernetesClusterMasterMasterLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterMasterLocationArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: (Optional) ID of the subnet.
        :param pulumi.Input[str] zone: (Optional) ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the availability zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class KubernetesClusterMasterMasterLoggingArgsDict(TypedDict):
        audit_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Optional) Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        """
        cluster_autoscaler_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Optional) Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        (Optional) Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://cloud.yandex.com/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        """
        events_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Optional) Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the folder that the Kubernetes cluster belongs to. If it is not provided, the default provider folder is used.
        """
        kube_apiserver_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Optional) Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the Yandex Cloud Logging [Log group](https://cloud.yandex.com/docs/logging/concepts/log-group).
        """
elif False:
    KubernetesClusterMasterMasterLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterMasterLoggingArgs:
    def __init__(__self__, *,
                 audit_enabled: Optional[pulumi.Input[bool]] = None,
                 cluster_autoscaler_enabled: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 events_enabled: Optional[pulumi.Input[bool]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 kube_apiserver_enabled: Optional[pulumi.Input[bool]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] audit_enabled: (Optional) Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        :param pulumi.Input[bool] cluster_autoscaler_enabled: (Optional) Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        :param pulumi.Input[bool] enabled: (Optional) Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://cloud.yandex.com/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        :param pulumi.Input[bool] events_enabled: (Optional) Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        :param pulumi.Input[str] folder_id: The ID of the folder that the Kubernetes cluster belongs to. If it is not provided, the default provider folder is used.
        :param pulumi.Input[bool] kube_apiserver_enabled: (Optional) Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        :param pulumi.Input[str] log_group_id: (Optional) ID of the Yandex Cloud Logging [Log group](https://cloud.yandex.com/docs/logging/concepts/log-group).
        """
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if cluster_autoscaler_enabled is not None:
            pulumi.set(__self__, "cluster_autoscaler_enabled", cluster_autoscaler_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if events_enabled is not None:
            pulumi.set(__self__, "events_enabled", events_enabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if kube_apiserver_enabled is not None:
            pulumi.set(__self__, "kube_apiserver_enabled", kube_apiserver_enabled)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "audit_enabled", value)

    @property
    @pulumi.getter(name="clusterAutoscalerEnabled")
    def cluster_autoscaler_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "cluster_autoscaler_enabled")

    @cluster_autoscaler_enabled.setter
    def cluster_autoscaler_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_autoscaler_enabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://cloud.yandex.com/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="eventsEnabled")
    def events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "events_enabled")

    @events_enabled.setter
    def events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "events_enabled", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the folder that the Kubernetes cluster belongs to. If it is not provided, the default provider folder is used.
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="kubeApiserverEnabled")
    def kube_apiserver_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "kube_apiserver_enabled")

    @kube_apiserver_enabled.setter
    def kube_apiserver_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kube_apiserver_enabled", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the Yandex Cloud Logging [Log group](https://cloud.yandex.com/docs/logging/concepts/log-group).
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)


if not MYPY:
    class KubernetesClusterMasterRegionalArgsDict(TypedDict):
        region: pulumi.Input[str]
        """
        (Required) Name of availability region (e.g. "ru-central1"), where master instances will be allocated.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterRegionalLocationArgsDict']]]]
        """
        Array of locations, where master instances will be allocated. The structure is documented below.
        """
elif False:
    KubernetesClusterMasterRegionalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterRegionalArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterRegionalLocationArgs']]]] = None):
        """
        :param pulumi.Input[str] region: (Required) Name of availability region (e.g. "ru-central1"), where master instances will be allocated.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterRegionalLocationArgs']]] locations: Array of locations, where master instances will be allocated. The structure is documented below.
        """
        pulumi.set(__self__, "region", region)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        (Required) Name of availability region (e.g. "ru-central1"), where master instances will be allocated.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterRegionalLocationArgs']]]]:
        """
        Array of locations, where master instances will be allocated. The structure is documented below.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMasterRegionalLocationArgs']]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class KubernetesClusterMasterRegionalLocationArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the subnet.
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the availability zone.
        """
elif False:
    KubernetesClusterMasterRegionalLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterRegionalLocationArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: (Optional) ID of the subnet.
        :param pulumi.Input[str] zone: (Optional) ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the availability zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class KubernetesClusterMasterVersionInfoArgsDict(TypedDict):
        current_version: NotRequired[pulumi.Input[str]]
        """
        Current Kubernetes version, major.minor (e.g. 1.30).
        """
        new_revision_available: NotRequired[pulumi.Input[bool]]
        """
        Boolean flag. Newer revisions may include Kubernetes patches (e.g 1.30.1 > 1.30.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        """
        new_revision_summary: NotRequired[pulumi.Input[str]]
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        version_deprecated: NotRequired[pulumi.Input[bool]]
        """
        Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
elif False:
    KubernetesClusterMasterVersionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterVersionInfoArgs:
    def __init__(__self__, *,
                 current_version: Optional[pulumi.Input[str]] = None,
                 new_revision_available: Optional[pulumi.Input[bool]] = None,
                 new_revision_summary: Optional[pulumi.Input[str]] = None,
                 version_deprecated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] current_version: Current Kubernetes version, major.minor (e.g. 1.30).
        :param pulumi.Input[bool] new_revision_available: Boolean flag. Newer revisions may include Kubernetes patches (e.g 1.30.1 > 1.30.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        :param pulumi.Input[str] new_revision_summary: Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        :param pulumi.Input[bool] version_deprecated: Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if new_revision_available is not None:
            pulumi.set(__self__, "new_revision_available", new_revision_available)
        if new_revision_summary is not None:
            pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        if version_deprecated is not None:
            pulumi.set(__self__, "version_deprecated", version_deprecated)

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input[str]]:
        """
        Current Kubernetes version, major.minor (e.g. 1.30).
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_version", value)

    @property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag. Newer revisions may include Kubernetes patches (e.g 1.30.1 > 1.30.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @new_revision_available.setter
    def new_revision_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "new_revision_available", value)

    @property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @new_revision_summary.setter
    def new_revision_summary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_revision_summary", value)

    @property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")

    @version_deprecated.setter
    def version_deprecated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "version_deprecated", value)


if not MYPY:
    class KubernetesClusterMasterZonalArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the subnet.
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        (Optional) ID of the availability zone.
        """
elif False:
    KubernetesClusterMasterZonalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMasterZonalArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: (Optional) ID of the subnet.
        :param pulumi.Input[str] zone: (Optional) ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) ID of the availability zone.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class KubernetesClusterNetworkImplementationArgsDict(TypedDict):
        cilium: NotRequired[pulumi.Input['KubernetesClusterNetworkImplementationCiliumArgsDict']]
        """
        (Optional) Cilium network implementation configuration. No options exist.
        """
elif False:
    KubernetesClusterNetworkImplementationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNetworkImplementationArgs:
    def __init__(__self__, *,
                 cilium: Optional[pulumi.Input['KubernetesClusterNetworkImplementationCiliumArgs']] = None):
        """
        :param pulumi.Input['KubernetesClusterNetworkImplementationCiliumArgs'] cilium: (Optional) Cilium network implementation configuration. No options exist.
        """
        if cilium is not None:
            pulumi.set(__self__, "cilium", cilium)

    @property
    @pulumi.getter
    def cilium(self) -> Optional[pulumi.Input['KubernetesClusterNetworkImplementationCiliumArgs']]:
        """
        (Optional) Cilium network implementation configuration. No options exist.
        """
        return pulumi.get(self, "cilium")

    @cilium.setter
    def cilium(self, value: Optional[pulumi.Input['KubernetesClusterNetworkImplementationCiliumArgs']]):
        pulumi.set(self, "cilium", value)


if not MYPY:
    class KubernetesClusterNetworkImplementationCiliumArgsDict(TypedDict):
        pass
elif False:
    KubernetesClusterNetworkImplementationCiliumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNetworkImplementationCiliumArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class KubernetesNodeGroupAllocationPolicyArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupAllocationPolicyLocationArgsDict']]]]
        """
        Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
elif False:
    KubernetesNodeGroupAllocationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupAllocationPolicyArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupAllocationPolicyLocationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupAllocationPolicyLocationArgs']]] locations: Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupAllocationPolicyLocationArgs']]]]:
        """
        Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupAllocationPolicyLocationArgs']]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class KubernetesNodeGroupAllocationPolicyLocationArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        ID of the subnet, that will be used by one compute instance in node group.

        Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        ID of the availability zone where for one compute instance in node group.
        """
elif False:
    KubernetesNodeGroupAllocationPolicyLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupAllocationPolicyLocationArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: ID of the subnet, that will be used by one compute instance in node group.
               
               Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument
        :param pulumi.Input[str] zone: ID of the availability zone where for one compute instance in node group.
        """
        if subnet_id is not None:
            warnings.warn("""The 'subnet_id' field has been deprecated. Please use 'subnet_ids under network_interface' instead.""", DeprecationWarning)
            pulumi.log.warn("""subnet_id is deprecated: The 'subnet_id' field has been deprecated. Please use 'subnet_ids under network_interface' instead.""")
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    @_utilities.deprecated("""The 'subnet_id' field has been deprecated. Please use 'subnet_ids under network_interface' instead.""")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the subnet, that will be used by one compute instance in node group.

        Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the availability zone where for one compute instance in node group.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class KubernetesNodeGroupDeployPolicyArgsDict(TypedDict):
        max_expansion: pulumi.Input[int]
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        """
        max_unavailable: pulumi.Input[int]
        """
        The maximum number of running instances that can be taken offline during update.
        """
elif False:
    KubernetesNodeGroupDeployPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupDeployPolicyArgs:
    def __init__(__self__, *,
                 max_expansion: pulumi.Input[int],
                 max_unavailable: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        :param pulumi.Input[int] max_unavailable: The maximum number of running instances that can be taken offline during update.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> pulumi.Input[int]:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        """
        return pulumi.get(self, "max_expansion")

    @max_expansion.setter
    def max_expansion(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_expansion", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> pulumi.Input[int]:
        """
        The maximum number of running instances that can be taken offline during update.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateArgsDict(TypedDict):
        boot_disk: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplateBootDiskArgsDict']]
        """
        The specifications for boot disks that will be attached to the instance. The structure is documented below.
        """
        container_network: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerNetworkArgsDict']]
        """
        Container network configuration. The structure is documented below.
        """
        container_runtime: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerRuntimeArgsDict']]
        """
        Container runtime configuration. The structure is documented below.
        """
        gpu_settings: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplateGpuSettingsArgsDict']]
        """
        GPU settings. The structure is documented below.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels that will be assigned to compute nodes (instances), created by the Node Group.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key "user-data" won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.

        * `resources.0.memory` - The memory size allocated to the instance.
        * `resources.0.cores` - Number of CPU cores allocated to the instance.
        * `resources.0.core_fraction` - Baseline core performance as a percent.
        * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, default is used: {instance_group.id}-{instance.short_id}
        It may also contain another placeholders, see [Compute Instance group metadata doc](https://yandex.cloud/docs/compute/api-ref/grpc/instance_group_service) for full list.
        """
        nat: NotRequired[pulumi.Input[bool]]
        """
        Boolean flag, enables NAT for node group compute instances.
        """
        network_acceleration_type: NotRequired[pulumi.Input[str]]
        """
        Type of network acceleration. Values: `standard`, `software_accelerated`.
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgsDict']]]]
        """
        An array with the network interfaces that will be attached to the instance. The structure is documented below.
        """
        placement_policy: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplatePlacementPolicyArgsDict']]
        """
        The placement policy configuration. The structure is documented below.
        """
        platform_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the hardware platform configuration for the node group compute instances.
        """
        resources: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplateResourcesArgsDict']]
        scheduling_policy: NotRequired[pulumi.Input['KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgsDict']]
        """
        The scheduling policy for the instances in node group. The structure is documented below.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateArgs:
    def __init__(__self__, *,
                 boot_disk: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateBootDiskArgs']] = None,
                 container_network: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerNetworkArgs']] = None,
                 container_runtime: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs']] = None,
                 gpu_settings: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateGpuSettingsArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nat: Optional[pulumi.Input[bool]] = None,
                 network_acceleration_type: Optional[pulumi.Input[str]] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs']]]] = None,
                 placement_policy: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs']] = None,
                 platform_id: Optional[pulumi.Input[str]] = None,
                 resources: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateResourcesArgs']] = None,
                 scheduling_policy: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs']] = None):
        """
        :param pulumi.Input['KubernetesNodeGroupInstanceTemplateBootDiskArgs'] boot_disk: The specifications for boot disks that will be attached to the instance. The structure is documented below.
        :param pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerNetworkArgs'] container_network: Container network configuration. The structure is documented below.
        :param pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs'] container_runtime: Container runtime configuration. The structure is documented below.
        :param pulumi.Input['KubernetesNodeGroupInstanceTemplateGpuSettingsArgs'] gpu_settings: GPU settings. The structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels that will be assigned to compute nodes (instances), created by the Node Group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key "user-data" won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.
               
               * `resources.0.memory` - The memory size allocated to the instance.
               * `resources.0.cores` - Number of CPU cores allocated to the instance.
               * `resources.0.core_fraction` - Baseline core performance as a percent.
               * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        :param pulumi.Input[str] name: Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
               {instance.short_id}
               {instance.index}
               combination of {instance.zone_id} and {instance.index_in_zone}
               Example: my-instance-{instance.index}
               If not set, default is used: {instance_group.id}-{instance.short_id}
               It may also contain another placeholders, see [Compute Instance group metadata doc](https://yandex.cloud/docs/compute/api-ref/grpc/instance_group_service) for full list.
        :param pulumi.Input[bool] nat: Boolean flag, enables NAT for node group compute instances.
        :param pulumi.Input[str] network_acceleration_type: Type of network acceleration. Values: `standard`, `software_accelerated`.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs']]] network_interfaces: An array with the network interfaces that will be attached to the instance. The structure is documented below.
        :param pulumi.Input['KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs'] placement_policy: The placement policy configuration. The structure is documented below.
        :param pulumi.Input[str] platform_id: The ID of the hardware platform configuration for the node group compute instances.
        :param pulumi.Input['KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs'] scheduling_policy: The scheduling policy for the instances in node group. The structure is documented below.
        """
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if container_network is not None:
            pulumi.set(__self__, "container_network", container_network)
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if gpu_settings is not None:
            pulumi.set(__self__, "gpu_settings", gpu_settings)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nat is not None:
            warnings.warn("""The 'nat' field has been deprecated. Please use 'nat under network_interface' instead.""", DeprecationWarning)
            pulumi.log.warn("""nat is deprecated: The 'nat' field has been deprecated. Please use 'nat under network_interface' instead.""")
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if network_acceleration_type is not None:
            pulumi.set(__self__, "network_acceleration_type", network_acceleration_type)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateBootDiskArgs']]:
        """
        The specifications for boot disks that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disk")

    @boot_disk.setter
    def boot_disk(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateBootDiskArgs']]):
        pulumi.set(self, "boot_disk", value)

    @property
    @pulumi.getter(name="containerNetwork")
    def container_network(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerNetworkArgs']]:
        """
        Container network configuration. The structure is documented below.
        """
        return pulumi.get(self, "container_network")

    @container_network.setter
    def container_network(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerNetworkArgs']]):
        pulumi.set(self, "container_network", value)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs']]:
        """
        Container runtime configuration. The structure is documented below.
        """
        return pulumi.get(self, "container_runtime")

    @container_runtime.setter
    def container_runtime(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs']]):
        pulumi.set(self, "container_runtime", value)

    @property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateGpuSettingsArgs']]:
        """
        GPU settings. The structure is documented below.
        """
        return pulumi.get(self, "gpu_settings")

    @gpu_settings.setter
    def gpu_settings(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateGpuSettingsArgs']]):
        pulumi.set(self, "gpu_settings", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels that will be assigned to compute nodes (instances), created by the Node Group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key "user-data" won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.

        * `resources.0.memory` - The memory size allocated to the instance.
        * `resources.0.cores` - Number of CPU cores allocated to the instance.
        * `resources.0.core_fraction` - Baseline core performance as a percent.
        * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, default is used: {instance_group.id}-{instance.short_id}
        It may also contain another placeholders, see [Compute Instance group metadata doc](https://yandex.cloud/docs/compute/api-ref/grpc/instance_group_service) for full list.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The 'nat' field has been deprecated. Please use 'nat under network_interface' instead.""")
    def nat(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag, enables NAT for node group compute instances.
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nat", value)

    @property
    @pulumi.getter(name="networkAccelerationType")
    def network_acceleration_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of network acceleration. Values: `standard`, `software_accelerated`.
        """
        return pulumi.get(self, "network_acceleration_type")

    @network_acceleration_type.setter
    def network_acceleration_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_acceleration_type", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs']]]]:
        """
        An array with the network interfaces that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs']]:
        """
        The placement policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "placement_policy")

    @placement_policy.setter
    def placement_policy(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs']]):
        pulumi.set(self, "placement_policy", value)

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the hardware platform configuration for the node group compute instances.
        """
        return pulumi.get(self, "platform_id")

    @platform_id.setter
    def platform_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_id", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateResourcesArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs']]:
        """
        The scheduling policy for the instances in node group. The structure is documented below.
        """
        return pulumi.get(self, "scheduling_policy")

    @scheduling_policy.setter
    def scheduling_policy(self, value: Optional[pulumi.Input['KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs']]):
        pulumi.set(self, "scheduling_policy", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateBootDiskArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in GB. Allowed minimal size: 64 GB.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The disk type.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateBootDiskArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] size: The size of the disk in GB. Allowed minimal size: 64 GB.
        :param pulumi.Input[str] type: The disk type.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in GB. Allowed minimal size: 64 GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateContainerNetworkArgsDict(TypedDict):
        pod_mtu: NotRequired[pulumi.Input[int]]
        """
        MTU for pods.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateContainerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateContainerNetworkArgs:
    def __init__(__self__, *,
                 pod_mtu: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] pod_mtu: MTU for pods.
        """
        if pod_mtu is not None:
            pulumi.set(__self__, "pod_mtu", pod_mtu)

    @property
    @pulumi.getter(name="podMtu")
    def pod_mtu(self) -> Optional[pulumi.Input[int]]:
        """
        MTU for pods.
        """
        return pulumi.get(self, "pod_mtu")

    @pod_mtu.setter
    def pod_mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pod_mtu", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateContainerRuntimeArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateContainerRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Type of container runtime. Values: `docker`, `containerd`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateGpuSettingsArgsDict(TypedDict):
        gpu_cluster_id: NotRequired[pulumi.Input[str]]
        """
        GPU cluster id.
        """
        gpu_environment: NotRequired[pulumi.Input[str]]
        """
        GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateGpuSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateGpuSettingsArgs:
    def __init__(__self__, *,
                 gpu_cluster_id: Optional[pulumi.Input[str]] = None,
                 gpu_environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gpu_cluster_id: GPU cluster id.
        :param pulumi.Input[str] gpu_environment: GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
        if gpu_cluster_id is not None:
            pulumi.set(__self__, "gpu_cluster_id", gpu_cluster_id)
        if gpu_environment is not None:
            pulumi.set(__self__, "gpu_environment", gpu_environment)

    @property
    @pulumi.getter(name="gpuClusterId")
    def gpu_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        GPU cluster id.
        """
        return pulumi.get(self, "gpu_cluster_id")

    @gpu_cluster_id.setter
    def gpu_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gpu_cluster_id", value)

    @property
    @pulumi.getter(name="gpuEnvironment")
    def gpu_environment(self) -> Optional[pulumi.Input[str]]:
        """
        GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
        return pulumi.get(self, "gpu_environment")

    @gpu_environment.setter
    def gpu_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gpu_environment", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The IDs of the subnets.
        """
        ipv4: NotRequired[pulumi.Input[bool]]
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        ipv4_dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgsDict']]]]
        """
        List of configurations for creating ipv4 DNS records. The structure is documented below.
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        ipv6_dns_records: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict']]]]
        """
        List of configurations for creating ipv6 DNS records. The structure is documented below.
        """
        nat: NotRequired[pulumi.Input[bool]]
        """
        A public address that can be used to access the internet over NAT.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Security group ids for network interface.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ipv4: Optional[pulumi.Input[bool]] = None,
                 ipv4_dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs']]]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 ipv6_dns_records: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]]] = None,
                 nat: Optional[pulumi.Input[bool]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: The IDs of the subnets.
        :param pulumi.Input[bool] ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs']]] ipv4_dns_records: List of configurations for creating ipv4 DNS records. The structure is documented below.
        :param pulumi.Input[bool] ipv6: If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]] ipv6_dns_records: List of configurations for creating ipv6 DNS records. The structure is documented below.
        :param pulumi.Input[bool] nat: A public address that can be used to access the internet over NAT.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Security group ids for network interface.
        """
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv4_dns_records is not None:
            pulumi.set(__self__, "ipv4_dns_records", ipv4_dns_records)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[bool]]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter(name="ipv4DnsRecords")
    def ipv4_dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs']]]]:
        """
        List of configurations for creating ipv4 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "ipv4_dns_records")

    @ipv4_dns_records.setter
    def ipv4_dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs']]]]):
        pulumi.set(self, "ipv4_dns_records", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]]]:
        """
        List of configurations for creating ipv6 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @ipv6_dns_records.setter
    def ipv6_dns_records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs']]]]):
        pulumi.set(self, "ipv6_dns_records", value)

    @property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input[bool]]:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nat", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        DNS record FQDN.
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        """
        DNS zone ID (if not set, private zone is used).
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        When set to true, also create a PTR DNS record.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        DNS record TTL (in seconds).
        """
elif False:
    KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: DNS record FQDN.
        :param pulumi.Input[str] dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param pulumi.Input[bool] ptr: When set to true, also create a PTR DNS record.
        :param pulumi.Input[int] ttl: DNS record TTL (in seconds).
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        DNS record TTL (in seconds).
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict(TypedDict):
        fqdn: pulumi.Input[str]
        """
        DNS record FQDN.
        """
        dns_zone_id: NotRequired[pulumi.Input[str]]
        """
        DNS zone ID (if not set, private zone is used).
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        When set to true, also create a PTR DNS record.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        DNS record TTL (in seconds).
        """
elif False:
    KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[str],
                 dns_zone_id: Optional[pulumi.Input[str]] = None,
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fqdn: DNS record FQDN.
        :param pulumi.Input[str] dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param pulumi.Input[bool] ptr: When set to true, also create a PTR DNS record.
        :param pulumi.Input[int] ttl: DNS record TTL (in seconds).
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        DNS record TTL (in seconds).
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplatePlacementPolicyArgsDict(TypedDict):
        placement_group_id: pulumi.Input[str]
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
elif False:
    KubernetesNodeGroupInstanceTemplatePlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs:
    def __init__(__self__, *,
                 placement_group_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "placement_group_id", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateResourcesArgsDict(TypedDict):
        core_fraction: NotRequired[pulumi.Input[int]]
        cores: NotRequired[pulumi.Input[int]]
        gpus: NotRequired[pulumi.Input[int]]
        memory: NotRequired[pulumi.Input[float]]
elif False:
    KubernetesNodeGroupInstanceTemplateResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateResourcesArgs:
    def __init__(__self__, *,
                 core_fraction: Optional[pulumi.Input[int]] = None,
                 cores: Optional[pulumi.Input[int]] = None,
                 gpus: Optional[pulumi.Input[int]] = None,
                 memory: Optional[pulumi.Input[float]] = None):
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "core_fraction")

    @core_fraction.setter
    def core_fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "core_fraction", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def gpus(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gpus")

    @gpus.setter
    def gpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpus", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgsDict(TypedDict):
        preemptible: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
elif False:
    KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs:
    def __init__(__self__, *,
                 preemptible: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] preemptible: Specifies if the instance is preemptible. Defaults to false.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preemptible", value)


if not MYPY:
    class KubernetesNodeGroupMaintenancePolicyArgsDict(TypedDict):
        auto_repair: pulumi.Input[bool]
        """
        Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
        """
        auto_upgrade: pulumi.Input[bool]
        """
        Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
        """
        maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgsDict']]]]
        """
        (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.

        To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.

        To allow maintenance only on specific days of week, please provide list of elements, with all fields set. Only one time interval is allowed for each day of week. Please see `my_node_group` config example.
        """
elif False:
    KubernetesNodeGroupMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupMaintenancePolicyArgs:
    def __init__(__self__, *,
                 auto_repair: pulumi.Input[bool],
                 auto_upgrade: pulumi.Input[bool],
                 maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs']]]] = None):
        """
        :param pulumi.Input[bool] auto_repair: Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
        :param pulumi.Input[bool] auto_upgrade: Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs']]] maintenance_windows: (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
               
               To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.
               
               To allow maintenance only on specific days of week, please provide list of elements, with all fields set. Only one time interval is allowed for each day of week. Please see `my_node_group` config example.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> pulumi.Input[bool]:
        """
        Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_repair")

    @auto_repair.setter
    def auto_repair(self, value: pulumi.Input[bool]):
        pulumi.set(self, "auto_repair", value)

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> pulumi.Input[bool]:
        """
        Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_upgrade")

    @auto_upgrade.setter
    def auto_upgrade(self, value: pulumi.Input[bool]):
        pulumi.set(self, "auto_upgrade", value)

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs']]]]:
        """
        (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.

        To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.

        To allow maintenance only on specific days of week, please provide list of elements, with all fields set. Only one time interval is allowed for each day of week. Please see `my_node_group` config example.
        """
        return pulumi.get(self, "maintenance_windows")

    @maintenance_windows.setter
    def maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs']]]]):
        pulumi.set(self, "maintenance_windows", value)


if not MYPY:
    class KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgsDict(TypedDict):
        duration: pulumi.Input[str]
        start_time: pulumi.Input[str]
        day: NotRequired[pulumi.Input[str]]
elif False:
    KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        if day is not None:
            pulumi.set(__self__, "day", day)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)


if not MYPY:
    class KubernetesNodeGroupScalePolicyArgsDict(TypedDict):
        auto_scale: NotRequired[pulumi.Input['KubernetesNodeGroupScalePolicyAutoScaleArgsDict']]
        """
        Scale policy for an autoscaled node group. The structure is documented below.
        """
        fixed_scale: NotRequired[pulumi.Input['KubernetesNodeGroupScalePolicyFixedScaleArgsDict']]
        """
        Scale policy for a fixed scale node group. The structure is documented below.
        """
elif False:
    KubernetesNodeGroupScalePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupScalePolicyArgs:
    def __init__(__self__, *,
                 auto_scale: Optional[pulumi.Input['KubernetesNodeGroupScalePolicyAutoScaleArgs']] = None,
                 fixed_scale: Optional[pulumi.Input['KubernetesNodeGroupScalePolicyFixedScaleArgs']] = None):
        """
        :param pulumi.Input['KubernetesNodeGroupScalePolicyAutoScaleArgs'] auto_scale: Scale policy for an autoscaled node group. The structure is documented below.
        :param pulumi.Input['KubernetesNodeGroupScalePolicyFixedScaleArgs'] fixed_scale: Scale policy for a fixed scale node group. The structure is documented below.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)

    @property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional[pulumi.Input['KubernetesNodeGroupScalePolicyAutoScaleArgs']]:
        """
        Scale policy for an autoscaled node group. The structure is documented below.
        """
        return pulumi.get(self, "auto_scale")

    @auto_scale.setter
    def auto_scale(self, value: Optional[pulumi.Input['KubernetesNodeGroupScalePolicyAutoScaleArgs']]):
        pulumi.set(self, "auto_scale", value)

    @property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional[pulumi.Input['KubernetesNodeGroupScalePolicyFixedScaleArgs']]:
        """
        Scale policy for a fixed scale node group. The structure is documented below.
        """
        return pulumi.get(self, "fixed_scale")

    @fixed_scale.setter
    def fixed_scale(self, value: Optional[pulumi.Input['KubernetesNodeGroupScalePolicyFixedScaleArgs']]):
        pulumi.set(self, "fixed_scale", value)


if not MYPY:
    class KubernetesNodeGroupScalePolicyAutoScaleArgsDict(TypedDict):
        initial: pulumi.Input[int]
        """
        Initial number of instances in the node group.
        """
        max: pulumi.Input[int]
        """
        Maximum number of instances in the node group.
        """
        min: pulumi.Input[int]
        """
        Minimum number of instances in the node group.
        """
elif False:
    KubernetesNodeGroupScalePolicyAutoScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupScalePolicyAutoScaleArgs:
    def __init__(__self__, *,
                 initial: pulumi.Input[int],
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] initial: Initial number of instances in the node group.
        :param pulumi.Input[int] max: Maximum number of instances in the node group.
        :param pulumi.Input[int] min: Minimum number of instances in the node group.
        """
        pulumi.set(__self__, "initial", initial)
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def initial(self) -> pulumi.Input[int]:
        """
        Initial number of instances in the node group.
        """
        return pulumi.get(self, "initial")

    @initial.setter
    def initial(self, value: pulumi.Input[int]):
        pulumi.set(self, "initial", value)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        Maximum number of instances in the node group.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        Minimum number of instances in the node group.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


if not MYPY:
    class KubernetesNodeGroupScalePolicyFixedScaleArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[int]]
        """
        The number of instances in the node group.
        """
elif False:
    KubernetesNodeGroupScalePolicyFixedScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupScalePolicyFixedScaleArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] size: The number of instances in the node group.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class KubernetesNodeGroupVersionInfoArgsDict(TypedDict):
        current_version: NotRequired[pulumi.Input[str]]
        """
        Current Kubernetes version, major.minor (e.g. 1.30).
        """
        new_revision_available: NotRequired[pulumi.Input[bool]]
        """
        True/false flag. Newer revisions may include Kubernetes patches (e.g 1.30.1 > 1.30.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        """
        new_revision_summary: NotRequired[pulumi.Input[str]]
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        version_deprecated: NotRequired[pulumi.Input[bool]]
        """
        True/false flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
elif False:
    KubernetesNodeGroupVersionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupVersionInfoArgs:
    def __init__(__self__, *,
                 current_version: Optional[pulumi.Input[str]] = None,
                 new_revision_available: Optional[pulumi.Input[bool]] = None,
                 new_revision_summary: Optional[pulumi.Input[str]] = None,
                 version_deprecated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] current_version: Current Kubernetes version, major.minor (e.g. 1.30).
        :param pulumi.Input[bool] new_revision_available: True/false flag. Newer revisions may include Kubernetes patches (e.g 1.30.1 > 1.30.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        :param pulumi.Input[str] new_revision_summary: Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        :param pulumi.Input[bool] version_deprecated: True/false flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if new_revision_available is not None:
            pulumi.set(__self__, "new_revision_available", new_revision_available)
        if new_revision_summary is not None:
            pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        if version_deprecated is not None:
            pulumi.set(__self__, "version_deprecated", version_deprecated)

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input[str]]:
        """
        Current Kubernetes version, major.minor (e.g. 1.30).
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_version", value)

    @property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> Optional[pulumi.Input[bool]]:
        """
        True/false flag. Newer revisions may include Kubernetes patches (e.g 1.30.1 > 1.30.2) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @new_revision_available.setter
    def new_revision_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "new_revision_available", value)

    @property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @new_revision_summary.setter
    def new_revision_summary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_revision_summary", value)

    @property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> Optional[pulumi.Input[bool]]:
        """
        True/false flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")

    @version_deprecated.setter
    def version_deprecated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "version_deprecated", value)


if not MYPY:
    class LbNetworkLoadBalancerAttachedTargetGroupArgsDict(TypedDict):
        healthchecks: pulumi.Input[Sequence[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgsDict']]]
        """
        A HealthCheck resource. The structure is documented below.
        """
        target_group_id: pulumi.Input[str]
        """
        ID of the target group.
        """
elif False:
    LbNetworkLoadBalancerAttachedTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerAttachedTargetGroupArgs:
    def __init__(__self__, *,
                 healthchecks: pulumi.Input[Sequence[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs']]],
                 target_group_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs']]] healthchecks: A HealthCheck resource. The structure is documented below.
        :param pulumi.Input[str] target_group_id: ID of the target group.
        """
        pulumi.set(__self__, "healthchecks", healthchecks)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @property
    @pulumi.getter
    def healthchecks(self) -> pulumi.Input[Sequence[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs']]]:
        """
        A HealthCheck resource. The structure is documented below.
        """
        return pulumi.get(self, "healthchecks")

    @healthchecks.setter
    def healthchecks(self, value: pulumi.Input[Sequence[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs']]]):
        pulumi.set(self, "healthchecks", value)

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> pulumi.Input[str]:
        """
        ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @target_group_id.setter
    def target_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_group_id", value)


if not MYPY:
    class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        """
        healthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of successful health checks required in order to set the `HEALTHY` status for the target.
        """
        http_options: NotRequired[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgsDict']]
        """
        Options for HTTP health check. The structure is documented below.
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        The interval between health checks. The default is 2 seconds.
        """
        tcp_options: NotRequired[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgsDict']]
        """
        Options for TCP health check. The structure is documented below.

        > One of `http_options` or `tcp_options` should be specified.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for a target to return a response for the health check. The default is 1 second.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[int]]
        """
        Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
elif False:
    LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 http_options: Optional[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs']] = None,
                 interval: Optional[pulumi.Input[int]] = None,
                 tcp_options: Optional[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs']] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        :param pulumi.Input[int] healthy_threshold: Number of successful health checks required in order to set the `HEALTHY` status for the target.
        :param pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs'] http_options: Options for HTTP health check. The structure is documented below.
        :param pulumi.Input[int] interval: The interval between health checks. The default is 2 seconds.
        :param pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs'] tcp_options: Options for TCP health check. The structure is documented below.
               
               > One of `http_options` or `tcp_options` should be specified.
        :param pulumi.Input[int] timeout: Timeout for a target to return a response for the health check. The default is 1 second.
        :param pulumi.Input[int] unhealthy_threshold: Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        pulumi.set(__self__, "name", name)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of successful health checks required in order to set the `HEALTHY` status for the target.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs']]:
        """
        Options for HTTP health check. The structure is documented below.
        """
        return pulumi.get(self, "http_options")

    @http_options.setter
    def http_options(self, value: Optional[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs']]):
        pulumi.set(self, "http_options", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between health checks. The default is 2 seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs']]:
        """
        Options for TCP health check. The structure is documented below.

        > One of `http_options` or `tcp_options` should be specified.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for a target to return a response for the health check. The default is 1 second.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        Port to use for HTTP health checks.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
elif False:
    LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: Port to use for HTTP health checks.
        :param pulumi.Input[str] path: URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        pulumi.set(__self__, "port", port)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port to use for HTTP health checks.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        Port to use for TCP health checks.
        """
elif False:
    LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] port: Port to use for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port to use for TCP health checks.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class LbNetworkLoadBalancerListenerArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the listener. The name must be unique for each listener on a single load balancer.
        """
        port: pulumi.Input[int]
        """
        Port for incoming traffic.
        """
        external_address_spec: NotRequired[pulumi.Input['LbNetworkLoadBalancerListenerExternalAddressSpecArgsDict']]
        """
        External IP address specification. The structure is documented below.
        """
        internal_address_spec: NotRequired[pulumi.Input['LbNetworkLoadBalancerListenerInternalAddressSpecArgsDict']]
        """
        Internal IP address specification. The structure is documented below.

        > One of `external_address_spec` or `internal_address_spec` should be specified.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol for incoming traffic. TCP or UDP and the default is TCP.
        """
        target_port: NotRequired[pulumi.Input[int]]
        """
        Port of a target. The default is the same as listener's port.
        """
elif False:
    LbNetworkLoadBalancerListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerListenerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 port: pulumi.Input[int],
                 external_address_spec: Optional[pulumi.Input['LbNetworkLoadBalancerListenerExternalAddressSpecArgs']] = None,
                 internal_address_spec: Optional[pulumi.Input['LbNetworkLoadBalancerListenerInternalAddressSpecArgs']] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Name of the listener. The name must be unique for each listener on a single load balancer.
        :param pulumi.Input[int] port: Port for incoming traffic.
        :param pulumi.Input['LbNetworkLoadBalancerListenerExternalAddressSpecArgs'] external_address_spec: External IP address specification. The structure is documented below.
        :param pulumi.Input['LbNetworkLoadBalancerListenerInternalAddressSpecArgs'] internal_address_spec: Internal IP address specification. The structure is documented below.
               
               > One of `external_address_spec` or `internal_address_spec` should be specified.
        :param pulumi.Input[str] protocol: Protocol for incoming traffic. TCP or UDP and the default is TCP.
        :param pulumi.Input[int] target_port: Port of a target. The default is the same as listener's port.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if external_address_spec is not None:
            pulumi.set(__self__, "external_address_spec", external_address_spec)
        if internal_address_spec is not None:
            pulumi.set(__self__, "internal_address_spec", internal_address_spec)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the listener. The name must be unique for each listener on a single load balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="externalAddressSpec")
    def external_address_spec(self) -> Optional[pulumi.Input['LbNetworkLoadBalancerListenerExternalAddressSpecArgs']]:
        """
        External IP address specification. The structure is documented below.
        """
        return pulumi.get(self, "external_address_spec")

    @external_address_spec.setter
    def external_address_spec(self, value: Optional[pulumi.Input['LbNetworkLoadBalancerListenerExternalAddressSpecArgs']]):
        pulumi.set(self, "external_address_spec", value)

    @property
    @pulumi.getter(name="internalAddressSpec")
    def internal_address_spec(self) -> Optional[pulumi.Input['LbNetworkLoadBalancerListenerInternalAddressSpecArgs']]:
        """
        Internal IP address specification. The structure is documented below.

        > One of `external_address_spec` or `internal_address_spec` should be specified.
        """
        return pulumi.get(self, "internal_address_spec")

    @internal_address_spec.setter
    def internal_address_spec(self, value: Optional[pulumi.Input['LbNetworkLoadBalancerListenerInternalAddressSpecArgs']]):
        pulumi.set(self, "internal_address_spec", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol for incoming traffic. TCP or UDP and the default is TCP.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of a target. The default is the same as listener's port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class LbNetworkLoadBalancerListenerExternalAddressSpecArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        External IP address for a listener. IP address will be allocated if it wasn't been set.
        """
        ip_version: NotRequired[pulumi.Input[str]]
        """
        IP version of the external addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
elif False:
    LbNetworkLoadBalancerListenerExternalAddressSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerListenerExternalAddressSpecArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: External IP address for a listener. IP address will be allocated if it wasn't been set.
        :param pulumi.Input[str] ip_version: IP version of the external addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        External IP address for a listener. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        IP version of the external addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)


if not MYPY:
    class LbNetworkLoadBalancerListenerInternalAddressSpecArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        ID of the subnet to which the internal IP address belongs.
        """
        address: NotRequired[pulumi.Input[str]]
        """
        Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        """
        ip_version: NotRequired[pulumi.Input[str]]
        """
        IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
elif False:
    LbNetworkLoadBalancerListenerInternalAddressSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbNetworkLoadBalancerListenerInternalAddressSpecArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 address: Optional[pulumi.Input[str]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: ID of the subnet to which the internal IP address belongs.
        :param pulumi.Input[str] address: Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        :param pulumi.Input[str] ip_version: IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        ID of the subnet to which the internal IP address belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)


if not MYPY:
    class LbTargetGroupTargetArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        IP address of the target.
        """
        subnet_id: pulumi.Input[str]
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
elif False:
    LbTargetGroupTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbTargetGroupTargetArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address: IP address of the target.
        :param pulumi.Input[str] subnet_id: ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        IP address of the target.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class LoadtestingAgentComputeInstanceArgsDict(TypedDict):
        boot_disk: pulumi.Input['LoadtestingAgentComputeInstanceBootDiskArgsDict']
        """
        Boot disk specifications for the instance. The structure is documented below.
        """
        network_interfaces: pulumi.Input[Sequence[pulumi.Input['LoadtestingAgentComputeInstanceNetworkInterfaceArgsDict']]]
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        """
        resources: pulumi.Input['LoadtestingAgentComputeInstanceResourcesArgsDict']
        """
        Compute resource specifications for the instance. The structure is documented below.
        """
        service_account_id: pulumi.Input[str]
        """
        The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        """
        computed_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        """
        computed_metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value label pairs to assign to the instance.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        platform_id: NotRequired[pulumi.Input[str]]
        """
        The Compute platform of virtual machine. If it is not provided, the standard-v2 platform will be used.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        The availability zone where the virtual machine will be created. If it is not provided, the default provider folder is used.
        """
elif False:
    LoadtestingAgentComputeInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadtestingAgentComputeInstanceArgs:
    def __init__(__self__, *,
                 boot_disk: pulumi.Input['LoadtestingAgentComputeInstanceBootDiskArgs'],
                 network_interfaces: pulumi.Input[Sequence[pulumi.Input['LoadtestingAgentComputeInstanceNetworkInterfaceArgs']]],
                 resources: pulumi.Input['LoadtestingAgentComputeInstanceResourcesArgs'],
                 service_account_id: pulumi.Input[str],
                 computed_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 computed_metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 platform_id: Optional[pulumi.Input[str]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LoadtestingAgentComputeInstanceBootDiskArgs'] boot_disk: Boot disk specifications for the instance. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['LoadtestingAgentComputeInstanceNetworkInterfaceArgs']]] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        :param pulumi.Input['LoadtestingAgentComputeInstanceResourcesArgs'] resources: Compute resource specifications for the instance. The structure is documented below.
        :param pulumi.Input[str] service_account_id: The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] computed_labels: The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] computed_metadata: The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A set of key/value label pairs to assign to the instance.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param pulumi.Input[str] platform_id: The Compute platform of virtual machine. If it is not provided, the standard-v2 platform will be used.
        :param pulumi.Input[str] zone_id: The availability zone where the virtual machine will be created. If it is not provided, the default provider folder is used.
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if computed_labels is not None:
            pulumi.set(__self__, "computed_labels", computed_labels)
        if computed_metadata is not None:
            pulumi.set(__self__, "computed_metadata", computed_metadata)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> pulumi.Input['LoadtestingAgentComputeInstanceBootDiskArgs']:
        """
        Boot disk specifications for the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disk")

    @boot_disk.setter
    def boot_disk(self, value: pulumi.Input['LoadtestingAgentComputeInstanceBootDiskArgs']):
        pulumi.set(self, "boot_disk", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> pulumi.Input[Sequence[pulumi.Input['LoadtestingAgentComputeInstanceNetworkInterfaceArgs']]]:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: pulumi.Input[Sequence[pulumi.Input['LoadtestingAgentComputeInstanceNetworkInterfaceArgs']]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['LoadtestingAgentComputeInstanceResourcesArgs']:
        """
        Compute resource specifications for the instance. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['LoadtestingAgentComputeInstanceResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="computedLabels")
    def computed_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        """
        return pulumi.get(self, "computed_labels")

    @computed_labels.setter
    def computed_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "computed_labels", value)

    @property
    @pulumi.getter(name="computedMetadata")
    def computed_metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        """
        return pulumi.get(self, "computed_metadata")

    @computed_metadata.setter
    def computed_metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "computed_metadata", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Compute platform of virtual machine. If it is not provided, the standard-v2 platform will be used.
        """
        return pulumi.get(self, "platform_id")

    @platform_id.setter
    def platform_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_id", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The availability zone where the virtual machine will be created. If it is not provided, the default provider folder is used.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class LoadtestingAgentComputeInstanceBootDiskArgsDict(TypedDict):
        initialize_params: pulumi.Input['LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgsDict']
        """
        Parameters for creating a disk alongside the instance. The structure is documented below.
        """
        auto_delete: NotRequired[pulumi.Input[bool]]
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        disk_id: NotRequired[pulumi.Input[str]]
        """
        The ID of created disk.
        """
elif False:
    LoadtestingAgentComputeInstanceBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadtestingAgentComputeInstanceBootDiskArgs:
    def __init__(__self__, *,
                 initialize_params: pulumi.Input['LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs'],
                 auto_delete: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 disk_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs'] initialize_params: Parameters for creating a disk alongside the instance. The structure is documented below.
        :param pulumi.Input[bool] auto_delete: Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        :param pulumi.Input[str] device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param pulumi.Input[str] disk_id: The ID of created disk.
        """
        pulumi.set(__self__, "initialize_params", initialize_params)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> pulumi.Input['LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs']:
        """
        Parameters for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: pulumi.Input['LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs']):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        """
        return pulumi.get(self, "auto_delete")

    @auto_delete.setter
    def auto_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_delete", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of created disk.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_id", value)


if not MYPY:
    class LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgsDict(TypedDict):
        block_size: NotRequired[pulumi.Input[int]]
        """
        Block size of the disk, specified in bytes.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the boot disk.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A name of the boot disk.
        """
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in GB. Defaults to 15 GB.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The disk type.
        """
elif False:
    LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs:
    def __init__(__self__, *,
                 block_size: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] block_size: Block size of the disk, specified in bytes.
        :param pulumi.Input[str] description: A description of the boot disk.
        :param pulumi.Input[str] name: A name of the boot disk.
        :param pulumi.Input[int] size: The size of the disk in GB. Defaults to 15 GB.
        :param pulumi.Input[str] type: The disk type.
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[pulumi.Input[int]]:
        """
        Block size of the disk, specified in bytes.
        """
        return pulumi.get(self, "block_size")

    @block_size.setter
    def block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name of the boot disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in GB. Defaults to 15 GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadtestingAgentComputeInstanceNetworkInterfaceArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        index: NotRequired[pulumi.Input[int]]
        ip_address: NotRequired[pulumi.Input[str]]
        """
        Manual set static IP address.
        """
        ipv4: NotRequired[pulumi.Input[bool]]
        """
        Flag for allocating IPv4 address for the network interface.
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        """
        Flag for allocating IPv6 address for the network interface.
        """
        ipv6_address: NotRequired[pulumi.Input[str]]
        """
        Manual set static IPv6 address.
        """
        mac_address: NotRequired[pulumi.Input[str]]
        nat: NotRequired[pulumi.Input[bool]]
        """
        Flag for using NAT.
        """
        nat_ip_address: NotRequired[pulumi.Input[str]]
        """
        A public address that can be used to access the internet over NAT.
        """
        nat_ip_version: NotRequired[pulumi.Input[str]]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Security group ids for network interface.
        """
elif False:
    LoadtestingAgentComputeInstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadtestingAgentComputeInstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 index: Optional[pulumi.Input[int]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ipv4: Optional[pulumi.Input[bool]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 nat: Optional[pulumi.Input[bool]] = None,
                 nat_ip_address: Optional[pulumi.Input[str]] = None,
                 nat_ip_version: Optional[pulumi.Input[str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        :param pulumi.Input[str] ip_address: Manual set static IP address.
        :param pulumi.Input[bool] ipv4: Flag for allocating IPv4 address for the network interface.
        :param pulumi.Input[bool] ipv6: Flag for allocating IPv6 address for the network interface.
        :param pulumi.Input[str] ipv6_address: Manual set static IPv6 address.
        :param pulumi.Input[bool] nat: Flag for using NAT.
        :param pulumi.Input[str] nat_ip_address: A public address that can be used to access the internet over NAT.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Security group ids for network interface.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for allocating IPv4 address for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for allocating IPv6 address for the network interface.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nat", value)

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat_ip_address")

    @nat_ip_address.setter
    def nat_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_address", value)

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nat_ip_version")

    @nat_ip_version.setter
    def nat_ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_ip_version", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class LoadtestingAgentComputeInstanceResourcesArgsDict(TypedDict):
        core_fraction: NotRequired[pulumi.Input[int]]
        """
        If provided, specifies baseline core performance as a percent.
        """
        cores: NotRequired[pulumi.Input[int]]
        """
        The number of CPU cores for the instance. Defaults to 2 cores.
        """
        memory: NotRequired[pulumi.Input[float]]
        """
        The memory size in GB. Defaults to 2 GB.
        """
elif False:
    LoadtestingAgentComputeInstanceResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadtestingAgentComputeInstanceResourcesArgs:
    def __init__(__self__, *,
                 core_fraction: Optional[pulumi.Input[int]] = None,
                 cores: Optional[pulumi.Input[int]] = None,
                 memory: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] core_fraction: If provided, specifies baseline core performance as a percent.
        :param pulumi.Input[int] cores: The number of CPU cores for the instance. Defaults to 2 cores.
        :param pulumi.Input[float] memory: The memory size in GB. Defaults to 2 GB.
        """
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[pulumi.Input[int]]:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @core_fraction.setter
    def core_fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "core_fraction", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU cores for the instance. Defaults to 2 cores.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[float]]:
        """
        The memory size in GB. Defaults to 2 GB.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class LoadtestingAgentLogSettingsArgsDict(TypedDict):
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        The ID of cloud logging group to which the load testing agent sends logs.
        """
elif False:
    LoadtestingAgentLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadtestingAgentLogSettingsArgs:
    def __init__(__self__, *,
                 log_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] log_group_id: The ID of cloud logging group to which the load testing agent sends logs.
        """
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of cloud logging group to which the load testing agent sends logs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)


if not MYPY:
    class LockboxSecretPasswordPayloadSpecificationArgsDict(TypedDict):
        password_key: pulumi.Input[str]
        """
        The key with which the generated password will be placed in the secret version.
        """
        excluded_punctuation: NotRequired[pulumi.Input[str]]
        """
        String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        """
        include_digits: NotRequired[pulumi.Input[bool]]
        """
        Use digits in the generated password. Default is true.
        """
        include_lowercase: NotRequired[pulumi.Input[bool]]
        """
        Use lowercase letters in the generated password. Default is true.
        """
        include_punctuation: NotRequired[pulumi.Input[bool]]
        """
        Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        """
        include_uppercase: NotRequired[pulumi.Input[bool]]
        """
        Use capital letters in the generated password. Default is true.
        """
        included_punctuation: NotRequired[pulumi.Input[str]]
        """
        String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        """
        length: NotRequired[pulumi.Input[int]]
        """
        Length of generated password. Default is 36.
        """
elif False:
    LockboxSecretPasswordPayloadSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LockboxSecretPasswordPayloadSpecificationArgs:
    def __init__(__self__, *,
                 password_key: pulumi.Input[str],
                 excluded_punctuation: Optional[pulumi.Input[str]] = None,
                 include_digits: Optional[pulumi.Input[bool]] = None,
                 include_lowercase: Optional[pulumi.Input[bool]] = None,
                 include_punctuation: Optional[pulumi.Input[bool]] = None,
                 include_uppercase: Optional[pulumi.Input[bool]] = None,
                 included_punctuation: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] password_key: The key with which the generated password will be placed in the secret version.
        :param pulumi.Input[str] excluded_punctuation: String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        :param pulumi.Input[bool] include_digits: Use digits in the generated password. Default is true.
        :param pulumi.Input[bool] include_lowercase: Use lowercase letters in the generated password. Default is true.
        :param pulumi.Input[bool] include_punctuation: Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        :param pulumi.Input[bool] include_uppercase: Use capital letters in the generated password. Default is true.
        :param pulumi.Input[str] included_punctuation: String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        :param pulumi.Input[int] length: Length of generated password. Default is 36.
        """
        pulumi.set(__self__, "password_key", password_key)
        if excluded_punctuation is not None:
            pulumi.set(__self__, "excluded_punctuation", excluded_punctuation)
        if include_digits is not None:
            pulumi.set(__self__, "include_digits", include_digits)
        if include_lowercase is not None:
            pulumi.set(__self__, "include_lowercase", include_lowercase)
        if include_punctuation is not None:
            pulumi.set(__self__, "include_punctuation", include_punctuation)
        if include_uppercase is not None:
            pulumi.set(__self__, "include_uppercase", include_uppercase)
        if included_punctuation is not None:
            pulumi.set(__self__, "included_punctuation", included_punctuation)
        if length is not None:
            pulumi.set(__self__, "length", length)

    @property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> pulumi.Input[str]:
        """
        The key with which the generated password will be placed in the secret version.
        """
        return pulumi.get(self, "password_key")

    @password_key.setter
    def password_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_key", value)

    @property
    @pulumi.getter(name="excludedPunctuation")
    def excluded_punctuation(self) -> Optional[pulumi.Input[str]]:
        """
        String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        """
        return pulumi.get(self, "excluded_punctuation")

    @excluded_punctuation.setter
    def excluded_punctuation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "excluded_punctuation", value)

    @property
    @pulumi.getter(name="includeDigits")
    def include_digits(self) -> Optional[pulumi.Input[bool]]:
        """
        Use digits in the generated password. Default is true.
        """
        return pulumi.get(self, "include_digits")

    @include_digits.setter
    def include_digits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_digits", value)

    @property
    @pulumi.getter(name="includeLowercase")
    def include_lowercase(self) -> Optional[pulumi.Input[bool]]:
        """
        Use lowercase letters in the generated password. Default is true.
        """
        return pulumi.get(self, "include_lowercase")

    @include_lowercase.setter
    def include_lowercase(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_lowercase", value)

    @property
    @pulumi.getter(name="includePunctuation")
    def include_punctuation(self) -> Optional[pulumi.Input[bool]]:
        """
        Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        """
        return pulumi.get(self, "include_punctuation")

    @include_punctuation.setter
    def include_punctuation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_punctuation", value)

    @property
    @pulumi.getter(name="includeUppercase")
    def include_uppercase(self) -> Optional[pulumi.Input[bool]]:
        """
        Use capital letters in the generated password. Default is true.
        """
        return pulumi.get(self, "include_uppercase")

    @include_uppercase.setter
    def include_uppercase(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_uppercase", value)

    @property
    @pulumi.getter(name="includedPunctuation")
    def included_punctuation(self) -> Optional[pulumi.Input[str]]:
        """
        String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        """
        return pulumi.get(self, "included_punctuation")

    @included_punctuation.setter
    def included_punctuation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "included_punctuation", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        Length of generated password. Default is 36.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)


if not MYPY:
    class LockboxSecretVersionEntryArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the entry.
        """
        command: NotRequired[pulumi.Input['LockboxSecretVersionEntryCommandArgsDict']]
        """
        The command that generates the text value of the entry.

        Note that either `text_value` or `command` is required.

        The `command` block contains:
        """
        text_value: NotRequired[pulumi.Input[str]]
        """
        The text value of the entry.
        """
elif False:
    LockboxSecretVersionEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LockboxSecretVersionEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 command: Optional[pulumi.Input['LockboxSecretVersionEntryCommandArgs']] = None,
                 text_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the entry.
        :param pulumi.Input['LockboxSecretVersionEntryCommandArgs'] command: The command that generates the text value of the entry.
               
               Note that either `text_value` or `command` is required.
               
               The `command` block contains:
        :param pulumi.Input[str] text_value: The text value of the entry.
        """
        pulumi.set(__self__, "key", key)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the entry.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input['LockboxSecretVersionEntryCommandArgs']]:
        """
        The command that generates the text value of the entry.

        Note that either `text_value` or `command` is required.

        The `command` block contains:
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input['LockboxSecretVersionEntryCommandArgs']]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[pulumi.Input[str]]:
        """
        The text value of the entry.
        """
        return pulumi.get(self, "text_value")

    @text_value.setter
    def text_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_value", value)


if not MYPY:
    class LockboxSecretVersionEntryCommandArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        The path to the script or command to execute.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of arguments to be passed to the script/command.
        """
        env: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Map of environment variables to set before calling the script/command.
        """
elif False:
    LockboxSecretVersionEntryCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LockboxSecretVersionEntryCommandArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] path: The path to the script or command to execute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: List of arguments to be passed to the script/command.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] env: Map of environment variables to set before calling the script/command.
        """
        pulumi.set(__self__, "path", path)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if env is not None:
            pulumi.set(__self__, "env", env)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the script or command to execute.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of arguments to be passed to the script/command.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of environment variables to set before calling the script/command.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "env", value)


if not MYPY:
    class MdbClickhouseClusterAccessArgsDict(TypedDict):
        data_lens: NotRequired[pulumi.Input[bool]]
        """
        Allow access for DataLens. Can be either `true` or `false`.
        """
        data_transfer: NotRequired[pulumi.Input[bool]]
        """
        Allow access for DataTransfer. Can be either `true` or `false`.
        """
        metrika: NotRequired[pulumi.Input[bool]]
        """
        Allow access for Yandex.Metrika. Can be either `true` or `false`.
        """
        serverless: NotRequired[pulumi.Input[bool]]
        """
        Allow access for Serverless. Can be either `true` or `false`.
        """
        web_sql: NotRequired[pulumi.Input[bool]]
        """
        Allow access for Web SQL. Can be either `true` or `false`.
        """
        yandex_query: NotRequired[pulumi.Input[bool]]
        """
        Allow access for YandexQuery. Can be either `true` or `false`.
        """
elif False:
    MdbClickhouseClusterAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[pulumi.Input[bool]] = None,
                 data_transfer: Optional[pulumi.Input[bool]] = None,
                 metrika: Optional[pulumi.Input[bool]] = None,
                 serverless: Optional[pulumi.Input[bool]] = None,
                 web_sql: Optional[pulumi.Input[bool]] = None,
                 yandex_query: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_lens: Allow access for DataLens. Can be either `true` or `false`.
        :param pulumi.Input[bool] data_transfer: Allow access for DataTransfer. Can be either `true` or `false`.
        :param pulumi.Input[bool] metrika: Allow access for Yandex.Metrika. Can be either `true` or `false`.
        :param pulumi.Input[bool] serverless: Allow access for Serverless. Can be either `true` or `false`.
        :param pulumi.Input[bool] web_sql: Allow access for Web SQL. Can be either `true` or `false`.
        :param pulumi.Input[bool] yandex_query: Allow access for YandexQuery. Can be either `true` or `false`.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if metrika is not None:
            pulumi.set(__self__, "metrika", metrika)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)
        if yandex_query is not None:
            pulumi.set(__self__, "yandex_query", yandex_query)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for DataLens. Can be either `true` or `false`.
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for DataTransfer. Can be either `true` or `false`.
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_transfer", value)

    @property
    @pulumi.getter
    def metrika(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for Yandex.Metrika. Can be either `true` or `false`.
        """
        return pulumi.get(self, "metrika")

    @metrika.setter
    def metrika(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "metrika", value)

    @property
    @pulumi.getter
    def serverless(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for Serverless. Can be either `true` or `false`.
        """
        return pulumi.get(self, "serverless")

    @serverless.setter
    def serverless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serverless", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for Web SQL. Can be either `true` or `false`.
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_sql", value)

    @property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for YandexQuery. Can be either `true` or `false`.
        """
        return pulumi.get(self, "yandex_query")

    @yandex_query.setter
    def yandex_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "yandex_query", value)


if not MYPY:
    class MdbClickhouseClusterBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started.
        """
elif False:
    MdbClickhouseClusterBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started.
        :param pulumi.Input[int] minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseConfigArgsDict']]
        """
        Main ClickHouse cluster configuration.
        """
        resources: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseResourcesArgsDict']]
        """
        Resources allocated to hosts of the ClickHouse subcluster. The structure is documented below.
        """
elif False:
    MdbClickhouseClusterClickhouseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigArgs']] = None,
                 resources: Optional[pulumi.Input['MdbClickhouseClusterClickhouseResourcesArgs']] = None):
        """
        :param pulumi.Input['MdbClickhouseClusterClickhouseConfigArgs'] config: Main ClickHouse cluster configuration.
        :param pulumi.Input['MdbClickhouseClusterClickhouseResourcesArgs'] resources: Resources allocated to hosts of the ClickHouse subcluster. The structure is documented below.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigArgs']]:
        """
        Main ClickHouse cluster configuration.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseResourcesArgs']]:
        """
        Resources allocated to hosts of the ClickHouse subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigArgsDict(TypedDict):
        asynchronous_insert_log_enabled: NotRequired[pulumi.Input[bool]]
        asynchronous_insert_log_retention_size: NotRequired[pulumi.Input[int]]
        asynchronous_insert_log_retention_time: NotRequired[pulumi.Input[int]]
        asynchronous_metric_log_enabled: NotRequired[pulumi.Input[bool]]
        asynchronous_metric_log_retention_size: NotRequired[pulumi.Input[int]]
        asynchronous_metric_log_retention_time: NotRequired[pulumi.Input[int]]
        background_buffer_flush_schedule_pool_size: NotRequired[pulumi.Input[int]]
        background_common_pool_size: NotRequired[pulumi.Input[int]]
        background_distributed_schedule_pool_size: NotRequired[pulumi.Input[int]]
        background_fetches_pool_size: NotRequired[pulumi.Input[int]]
        background_merges_mutations_concurrency_ratio: NotRequired[pulumi.Input[int]]
        background_message_broker_schedule_pool_size: NotRequired[pulumi.Input[int]]
        background_move_pool_size: NotRequired[pulumi.Input[int]]
        background_pool_size: NotRequired[pulumi.Input[int]]
        background_schedule_pool_size: NotRequired[pulumi.Input[int]]
        compressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigCompressionArgsDict']]]]
        """
        Data compression configuration. The structure is documented below.
        """
        default_database: NotRequired[pulumi.Input[str]]
        dictionaries_lazy_load: NotRequired[pulumi.Input[bool]]
        geobase_enabled: NotRequired[pulumi.Input[bool]]
        geobase_uri: NotRequired[pulumi.Input[str]]
        graphite_rollups: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict']]]]
        """
        Graphite rollup configuration. The structure is documented below.
        """
        kafka: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaArgsDict']]
        """
        Kafka connection configuration. The structure is documented below.
        """
        kafka_topics: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict']]]]
        """
        Kafka topic connection configuration. The structure is documented below.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[int]]
        log_level: NotRequired[pulumi.Input[str]]
        """
        , `max_connections`, `max_concurrent_queries`, `keep_alive_timeout`, `uncompressed_cache_size`, `mark_cache_size`, `max_table_size_to_drop`, `max_partition_size_to_drop`, `timezone`, `geobase_uri`, `query_log_retention_size`, `query_log_retention_time`, `query_thread_log_enabled`, `query_thread_log_retention_size`, `query_thread_log_retention_time`, `part_log_retention_size`, `part_log_retention_time`, `metric_log_enabled`, `metric_log_retention_size`, `metric_log_retention_time`, `trace_log_enabled`, `trace_log_retention_size`, `trace_log_retention_time`, `text_log_enabled`, `text_log_retention_size`, `text_log_retention_time`, `text_log_level`, `background_pool_size`, `background_schedule_pool_size`, `background_fetches_pool_size`, `background_message_broker_schedule_pool_size`,`background_merges_mutations_concurrency_ratio`, `background_move_pool_size`, `background_distributed_schedule_pool_size`, `background_common_pool_size` `default_database`, `total_memory_profiler_step`, `dictionaries_lazy_load`, `opentelemetry_span_log_enabled`, `opentelemetry_span_log_retention_size`, `opentelemetry_span_log_retention_time`, `query_views_log_enabled`, `query_views_log_retention_size`, `query_views_log_retention_time`, `asynchronous_metric_log_enabled`, `asynchronous_metric_log_retention_size`, `asynchronous_metric_log_retention_time`, `session_log_enabled`, `session_log_retention_size`, `session_log_retention_time`, `zookeeper_log_enabled`, `zookeeper_log_retention_size`, `zookeeper_log_retention_time`, `asynchronous_insert_log_enabled`, `asynchronous_insert_log_retention_size`, `asynchronous_insert_log_retention_time` - (Optional) ClickHouse server parameters. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/settings-list).
        """
        mark_cache_size: NotRequired[pulumi.Input[int]]
        max_concurrent_queries: NotRequired[pulumi.Input[int]]
        max_connections: NotRequired[pulumi.Input[int]]
        max_partition_size_to_drop: NotRequired[pulumi.Input[int]]
        max_table_size_to_drop: NotRequired[pulumi.Input[int]]
        merge_tree: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseConfigMergeTreeArgsDict']]
        """
        MergeTree engine configuration. The structure is documented below.
        """
        metric_log_enabled: NotRequired[pulumi.Input[bool]]
        metric_log_retention_size: NotRequired[pulumi.Input[int]]
        metric_log_retention_time: NotRequired[pulumi.Input[int]]
        opentelemetry_span_log_enabled: NotRequired[pulumi.Input[bool]]
        opentelemetry_span_log_retention_size: NotRequired[pulumi.Input[int]]
        opentelemetry_span_log_retention_time: NotRequired[pulumi.Input[int]]
        part_log_retention_size: NotRequired[pulumi.Input[int]]
        part_log_retention_time: NotRequired[pulumi.Input[int]]
        query_cache: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryCacheArgsDict']]
        """
        Query cache configuration. The structure is documented below.
        """
        query_log_retention_size: NotRequired[pulumi.Input[int]]
        query_log_retention_time: NotRequired[pulumi.Input[int]]
        query_masking_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict']]]]
        """
        Query masking rules configuration. The structure is documented below.
        """
        query_thread_log_enabled: NotRequired[pulumi.Input[bool]]
        query_thread_log_retention_size: NotRequired[pulumi.Input[int]]
        query_thread_log_retention_time: NotRequired[pulumi.Input[int]]
        query_views_log_enabled: NotRequired[pulumi.Input[bool]]
        query_views_log_retention_size: NotRequired[pulumi.Input[int]]
        query_views_log_retention_time: NotRequired[pulumi.Input[int]]
        rabbitmq: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseConfigRabbitmqArgsDict']]
        """
        RabbitMQ connection configuration. The structure is documented below.
        """
        session_log_enabled: NotRequired[pulumi.Input[bool]]
        session_log_retention_size: NotRequired[pulumi.Input[int]]
        session_log_retention_time: NotRequired[pulumi.Input[int]]
        text_log_enabled: NotRequired[pulumi.Input[bool]]
        text_log_level: NotRequired[pulumi.Input[str]]
        text_log_retention_size: NotRequired[pulumi.Input[int]]
        text_log_retention_time: NotRequired[pulumi.Input[int]]
        timezone: NotRequired[pulumi.Input[str]]
        total_memory_profiler_step: NotRequired[pulumi.Input[int]]
        trace_log_enabled: NotRequired[pulumi.Input[bool]]
        trace_log_retention_size: NotRequired[pulumi.Input[int]]
        trace_log_retention_time: NotRequired[pulumi.Input[int]]
        uncompressed_cache_size: NotRequired[pulumi.Input[int]]
        zookeeper_log_enabled: NotRequired[pulumi.Input[bool]]
        zookeeper_log_retention_size: NotRequired[pulumi.Input[int]]
        zookeeper_log_retention_time: NotRequired[pulumi.Input[int]]
elif False:
    MdbClickhouseClusterClickhouseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigArgs:
    def __init__(__self__, *,
                 asynchronous_insert_log_enabled: Optional[pulumi.Input[bool]] = None,
                 asynchronous_insert_log_retention_size: Optional[pulumi.Input[int]] = None,
                 asynchronous_insert_log_retention_time: Optional[pulumi.Input[int]] = None,
                 asynchronous_metric_log_enabled: Optional[pulumi.Input[bool]] = None,
                 asynchronous_metric_log_retention_size: Optional[pulumi.Input[int]] = None,
                 asynchronous_metric_log_retention_time: Optional[pulumi.Input[int]] = None,
                 background_buffer_flush_schedule_pool_size: Optional[pulumi.Input[int]] = None,
                 background_common_pool_size: Optional[pulumi.Input[int]] = None,
                 background_distributed_schedule_pool_size: Optional[pulumi.Input[int]] = None,
                 background_fetches_pool_size: Optional[pulumi.Input[int]] = None,
                 background_merges_mutations_concurrency_ratio: Optional[pulumi.Input[int]] = None,
                 background_message_broker_schedule_pool_size: Optional[pulumi.Input[int]] = None,
                 background_move_pool_size: Optional[pulumi.Input[int]] = None,
                 background_pool_size: Optional[pulumi.Input[int]] = None,
                 background_schedule_pool_size: Optional[pulumi.Input[int]] = None,
                 compressions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigCompressionArgs']]]] = None,
                 default_database: Optional[pulumi.Input[str]] = None,
                 dictionaries_lazy_load: Optional[pulumi.Input[bool]] = None,
                 geobase_enabled: Optional[pulumi.Input[bool]] = None,
                 geobase_uri: Optional[pulumi.Input[str]] = None,
                 graphite_rollups: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']]]] = None,
                 kafka: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaArgs']] = None,
                 kafka_topics: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicArgs']]]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[int]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 mark_cache_size: Optional[pulumi.Input[int]] = None,
                 max_concurrent_queries: Optional[pulumi.Input[int]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 max_partition_size_to_drop: Optional[pulumi.Input[int]] = None,
                 max_table_size_to_drop: Optional[pulumi.Input[int]] = None,
                 merge_tree: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigMergeTreeArgs']] = None,
                 metric_log_enabled: Optional[pulumi.Input[bool]] = None,
                 metric_log_retention_size: Optional[pulumi.Input[int]] = None,
                 metric_log_retention_time: Optional[pulumi.Input[int]] = None,
                 opentelemetry_span_log_enabled: Optional[pulumi.Input[bool]] = None,
                 opentelemetry_span_log_retention_size: Optional[pulumi.Input[int]] = None,
                 opentelemetry_span_log_retention_time: Optional[pulumi.Input[int]] = None,
                 part_log_retention_size: Optional[pulumi.Input[int]] = None,
                 part_log_retention_time: Optional[pulumi.Input[int]] = None,
                 query_cache: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryCacheArgs']] = None,
                 query_log_retention_size: Optional[pulumi.Input[int]] = None,
                 query_log_retention_time: Optional[pulumi.Input[int]] = None,
                 query_masking_rules: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']]]] = None,
                 query_thread_log_enabled: Optional[pulumi.Input[bool]] = None,
                 query_thread_log_retention_size: Optional[pulumi.Input[int]] = None,
                 query_thread_log_retention_time: Optional[pulumi.Input[int]] = None,
                 query_views_log_enabled: Optional[pulumi.Input[bool]] = None,
                 query_views_log_retention_size: Optional[pulumi.Input[int]] = None,
                 query_views_log_retention_time: Optional[pulumi.Input[int]] = None,
                 rabbitmq: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigRabbitmqArgs']] = None,
                 session_log_enabled: Optional[pulumi.Input[bool]] = None,
                 session_log_retention_size: Optional[pulumi.Input[int]] = None,
                 session_log_retention_time: Optional[pulumi.Input[int]] = None,
                 text_log_enabled: Optional[pulumi.Input[bool]] = None,
                 text_log_level: Optional[pulumi.Input[str]] = None,
                 text_log_retention_size: Optional[pulumi.Input[int]] = None,
                 text_log_retention_time: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 total_memory_profiler_step: Optional[pulumi.Input[int]] = None,
                 trace_log_enabled: Optional[pulumi.Input[bool]] = None,
                 trace_log_retention_size: Optional[pulumi.Input[int]] = None,
                 trace_log_retention_time: Optional[pulumi.Input[int]] = None,
                 uncompressed_cache_size: Optional[pulumi.Input[int]] = None,
                 zookeeper_log_enabled: Optional[pulumi.Input[bool]] = None,
                 zookeeper_log_retention_size: Optional[pulumi.Input[int]] = None,
                 zookeeper_log_retention_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigCompressionArgs']]] compressions: Data compression configuration. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']]] graphite_rollups: Graphite rollup configuration. The structure is documented below.
        :param pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaArgs'] kafka: Kafka connection configuration. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicArgs']]] kafka_topics: Kafka topic connection configuration. The structure is documented below.
        :param pulumi.Input[str] log_level: , `max_connections`, `max_concurrent_queries`, `keep_alive_timeout`, `uncompressed_cache_size`, `mark_cache_size`, `max_table_size_to_drop`, `max_partition_size_to_drop`, `timezone`, `geobase_uri`, `query_log_retention_size`, `query_log_retention_time`, `query_thread_log_enabled`, `query_thread_log_retention_size`, `query_thread_log_retention_time`, `part_log_retention_size`, `part_log_retention_time`, `metric_log_enabled`, `metric_log_retention_size`, `metric_log_retention_time`, `trace_log_enabled`, `trace_log_retention_size`, `trace_log_retention_time`, `text_log_enabled`, `text_log_retention_size`, `text_log_retention_time`, `text_log_level`, `background_pool_size`, `background_schedule_pool_size`, `background_fetches_pool_size`, `background_message_broker_schedule_pool_size`,`background_merges_mutations_concurrency_ratio`, `background_move_pool_size`, `background_distributed_schedule_pool_size`, `background_common_pool_size` `default_database`, `total_memory_profiler_step`, `dictionaries_lazy_load`, `opentelemetry_span_log_enabled`, `opentelemetry_span_log_retention_size`, `opentelemetry_span_log_retention_time`, `query_views_log_enabled`, `query_views_log_retention_size`, `query_views_log_retention_time`, `asynchronous_metric_log_enabled`, `asynchronous_metric_log_retention_size`, `asynchronous_metric_log_retention_time`, `session_log_enabled`, `session_log_retention_size`, `session_log_retention_time`, `zookeeper_log_enabled`, `zookeeper_log_retention_size`, `zookeeper_log_retention_time`, `asynchronous_insert_log_enabled`, `asynchronous_insert_log_retention_size`, `asynchronous_insert_log_retention_time` - (Optional) ClickHouse server parameters. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/settings-list).
        :param pulumi.Input['MdbClickhouseClusterClickhouseConfigMergeTreeArgs'] merge_tree: MergeTree engine configuration. The structure is documented below.
        :param pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryCacheArgs'] query_cache: Query cache configuration. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']]] query_masking_rules: Query masking rules configuration. The structure is documented below.
        :param pulumi.Input['MdbClickhouseClusterClickhouseConfigRabbitmqArgs'] rabbitmq: RabbitMQ connection configuration. The structure is documented below.
        """
        if asynchronous_insert_log_enabled is not None:
            pulumi.set(__self__, "asynchronous_insert_log_enabled", asynchronous_insert_log_enabled)
        if asynchronous_insert_log_retention_size is not None:
            pulumi.set(__self__, "asynchronous_insert_log_retention_size", asynchronous_insert_log_retention_size)
        if asynchronous_insert_log_retention_time is not None:
            pulumi.set(__self__, "asynchronous_insert_log_retention_time", asynchronous_insert_log_retention_time)
        if asynchronous_metric_log_enabled is not None:
            pulumi.set(__self__, "asynchronous_metric_log_enabled", asynchronous_metric_log_enabled)
        if asynchronous_metric_log_retention_size is not None:
            pulumi.set(__self__, "asynchronous_metric_log_retention_size", asynchronous_metric_log_retention_size)
        if asynchronous_metric_log_retention_time is not None:
            pulumi.set(__self__, "asynchronous_metric_log_retention_time", asynchronous_metric_log_retention_time)
        if background_buffer_flush_schedule_pool_size is not None:
            pulumi.set(__self__, "background_buffer_flush_schedule_pool_size", background_buffer_flush_schedule_pool_size)
        if background_common_pool_size is not None:
            pulumi.set(__self__, "background_common_pool_size", background_common_pool_size)
        if background_distributed_schedule_pool_size is not None:
            pulumi.set(__self__, "background_distributed_schedule_pool_size", background_distributed_schedule_pool_size)
        if background_fetches_pool_size is not None:
            pulumi.set(__self__, "background_fetches_pool_size", background_fetches_pool_size)
        if background_merges_mutations_concurrency_ratio is not None:
            pulumi.set(__self__, "background_merges_mutations_concurrency_ratio", background_merges_mutations_concurrency_ratio)
        if background_message_broker_schedule_pool_size is not None:
            pulumi.set(__self__, "background_message_broker_schedule_pool_size", background_message_broker_schedule_pool_size)
        if background_move_pool_size is not None:
            pulumi.set(__self__, "background_move_pool_size", background_move_pool_size)
        if background_pool_size is not None:
            pulumi.set(__self__, "background_pool_size", background_pool_size)
        if background_schedule_pool_size is not None:
            pulumi.set(__self__, "background_schedule_pool_size", background_schedule_pool_size)
        if compressions is not None:
            pulumi.set(__self__, "compressions", compressions)
        if default_database is not None:
            pulumi.set(__self__, "default_database", default_database)
        if dictionaries_lazy_load is not None:
            pulumi.set(__self__, "dictionaries_lazy_load", dictionaries_lazy_load)
        if geobase_enabled is not None:
            pulumi.set(__self__, "geobase_enabled", geobase_enabled)
        if geobase_uri is not None:
            pulumi.set(__self__, "geobase_uri", geobase_uri)
        if graphite_rollups is not None:
            pulumi.set(__self__, "graphite_rollups", graphite_rollups)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_topics is not None:
            pulumi.set(__self__, "kafka_topics", kafka_topics)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if mark_cache_size is not None:
            pulumi.set(__self__, "mark_cache_size", mark_cache_size)
        if max_concurrent_queries is not None:
            pulumi.set(__self__, "max_concurrent_queries", max_concurrent_queries)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_partition_size_to_drop is not None:
            pulumi.set(__self__, "max_partition_size_to_drop", max_partition_size_to_drop)
        if max_table_size_to_drop is not None:
            pulumi.set(__self__, "max_table_size_to_drop", max_table_size_to_drop)
        if merge_tree is not None:
            pulumi.set(__self__, "merge_tree", merge_tree)
        if metric_log_enabled is not None:
            pulumi.set(__self__, "metric_log_enabled", metric_log_enabled)
        if metric_log_retention_size is not None:
            pulumi.set(__self__, "metric_log_retention_size", metric_log_retention_size)
        if metric_log_retention_time is not None:
            pulumi.set(__self__, "metric_log_retention_time", metric_log_retention_time)
        if opentelemetry_span_log_enabled is not None:
            pulumi.set(__self__, "opentelemetry_span_log_enabled", opentelemetry_span_log_enabled)
        if opentelemetry_span_log_retention_size is not None:
            pulumi.set(__self__, "opentelemetry_span_log_retention_size", opentelemetry_span_log_retention_size)
        if opentelemetry_span_log_retention_time is not None:
            pulumi.set(__self__, "opentelemetry_span_log_retention_time", opentelemetry_span_log_retention_time)
        if part_log_retention_size is not None:
            pulumi.set(__self__, "part_log_retention_size", part_log_retention_size)
        if part_log_retention_time is not None:
            pulumi.set(__self__, "part_log_retention_time", part_log_retention_time)
        if query_cache is not None:
            pulumi.set(__self__, "query_cache", query_cache)
        if query_log_retention_size is not None:
            pulumi.set(__self__, "query_log_retention_size", query_log_retention_size)
        if query_log_retention_time is not None:
            pulumi.set(__self__, "query_log_retention_time", query_log_retention_time)
        if query_masking_rules is not None:
            pulumi.set(__self__, "query_masking_rules", query_masking_rules)
        if query_thread_log_enabled is not None:
            pulumi.set(__self__, "query_thread_log_enabled", query_thread_log_enabled)
        if query_thread_log_retention_size is not None:
            pulumi.set(__self__, "query_thread_log_retention_size", query_thread_log_retention_size)
        if query_thread_log_retention_time is not None:
            pulumi.set(__self__, "query_thread_log_retention_time", query_thread_log_retention_time)
        if query_views_log_enabled is not None:
            pulumi.set(__self__, "query_views_log_enabled", query_views_log_enabled)
        if query_views_log_retention_size is not None:
            pulumi.set(__self__, "query_views_log_retention_size", query_views_log_retention_size)
        if query_views_log_retention_time is not None:
            pulumi.set(__self__, "query_views_log_retention_time", query_views_log_retention_time)
        if rabbitmq is not None:
            pulumi.set(__self__, "rabbitmq", rabbitmq)
        if session_log_enabled is not None:
            pulumi.set(__self__, "session_log_enabled", session_log_enabled)
        if session_log_retention_size is not None:
            pulumi.set(__self__, "session_log_retention_size", session_log_retention_size)
        if session_log_retention_time is not None:
            pulumi.set(__self__, "session_log_retention_time", session_log_retention_time)
        if text_log_enabled is not None:
            pulumi.set(__self__, "text_log_enabled", text_log_enabled)
        if text_log_level is not None:
            pulumi.set(__self__, "text_log_level", text_log_level)
        if text_log_retention_size is not None:
            pulumi.set(__self__, "text_log_retention_size", text_log_retention_size)
        if text_log_retention_time is not None:
            pulumi.set(__self__, "text_log_retention_time", text_log_retention_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if total_memory_profiler_step is not None:
            pulumi.set(__self__, "total_memory_profiler_step", total_memory_profiler_step)
        if trace_log_enabled is not None:
            pulumi.set(__self__, "trace_log_enabled", trace_log_enabled)
        if trace_log_retention_size is not None:
            pulumi.set(__self__, "trace_log_retention_size", trace_log_retention_size)
        if trace_log_retention_time is not None:
            pulumi.set(__self__, "trace_log_retention_time", trace_log_retention_time)
        if uncompressed_cache_size is not None:
            pulumi.set(__self__, "uncompressed_cache_size", uncompressed_cache_size)
        if zookeeper_log_enabled is not None:
            pulumi.set(__self__, "zookeeper_log_enabled", zookeeper_log_enabled)
        if zookeeper_log_retention_size is not None:
            pulumi.set(__self__, "zookeeper_log_retention_size", zookeeper_log_retention_size)
        if zookeeper_log_retention_time is not None:
            pulumi.set(__self__, "zookeeper_log_retention_time", zookeeper_log_retention_time)

    @property
    @pulumi.getter(name="asynchronousInsertLogEnabled")
    def asynchronous_insert_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "asynchronous_insert_log_enabled")

    @asynchronous_insert_log_enabled.setter
    def asynchronous_insert_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "asynchronous_insert_log_enabled", value)

    @property
    @pulumi.getter(name="asynchronousInsertLogRetentionSize")
    def asynchronous_insert_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "asynchronous_insert_log_retention_size")

    @asynchronous_insert_log_retention_size.setter
    def asynchronous_insert_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asynchronous_insert_log_retention_size", value)

    @property
    @pulumi.getter(name="asynchronousInsertLogRetentionTime")
    def asynchronous_insert_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "asynchronous_insert_log_retention_time")

    @asynchronous_insert_log_retention_time.setter
    def asynchronous_insert_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asynchronous_insert_log_retention_time", value)

    @property
    @pulumi.getter(name="asynchronousMetricLogEnabled")
    def asynchronous_metric_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "asynchronous_metric_log_enabled")

    @asynchronous_metric_log_enabled.setter
    def asynchronous_metric_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "asynchronous_metric_log_enabled", value)

    @property
    @pulumi.getter(name="asynchronousMetricLogRetentionSize")
    def asynchronous_metric_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "asynchronous_metric_log_retention_size")

    @asynchronous_metric_log_retention_size.setter
    def asynchronous_metric_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asynchronous_metric_log_retention_size", value)

    @property
    @pulumi.getter(name="asynchronousMetricLogRetentionTime")
    def asynchronous_metric_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "asynchronous_metric_log_retention_time")

    @asynchronous_metric_log_retention_time.setter
    def asynchronous_metric_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asynchronous_metric_log_retention_time", value)

    @property
    @pulumi.getter(name="backgroundBufferFlushSchedulePoolSize")
    def background_buffer_flush_schedule_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_buffer_flush_schedule_pool_size")

    @background_buffer_flush_schedule_pool_size.setter
    def background_buffer_flush_schedule_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_buffer_flush_schedule_pool_size", value)

    @property
    @pulumi.getter(name="backgroundCommonPoolSize")
    def background_common_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_common_pool_size")

    @background_common_pool_size.setter
    def background_common_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_common_pool_size", value)

    @property
    @pulumi.getter(name="backgroundDistributedSchedulePoolSize")
    def background_distributed_schedule_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_distributed_schedule_pool_size")

    @background_distributed_schedule_pool_size.setter
    def background_distributed_schedule_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_distributed_schedule_pool_size", value)

    @property
    @pulumi.getter(name="backgroundFetchesPoolSize")
    def background_fetches_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_fetches_pool_size")

    @background_fetches_pool_size.setter
    def background_fetches_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_fetches_pool_size", value)

    @property
    @pulumi.getter(name="backgroundMergesMutationsConcurrencyRatio")
    def background_merges_mutations_concurrency_ratio(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_merges_mutations_concurrency_ratio")

    @background_merges_mutations_concurrency_ratio.setter
    def background_merges_mutations_concurrency_ratio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_merges_mutations_concurrency_ratio", value)

    @property
    @pulumi.getter(name="backgroundMessageBrokerSchedulePoolSize")
    def background_message_broker_schedule_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_message_broker_schedule_pool_size")

    @background_message_broker_schedule_pool_size.setter
    def background_message_broker_schedule_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_message_broker_schedule_pool_size", value)

    @property
    @pulumi.getter(name="backgroundMovePoolSize")
    def background_move_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_move_pool_size")

    @background_move_pool_size.setter
    def background_move_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_move_pool_size", value)

    @property
    @pulumi.getter(name="backgroundPoolSize")
    def background_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_pool_size")

    @background_pool_size.setter
    def background_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_pool_size", value)

    @property
    @pulumi.getter(name="backgroundSchedulePoolSize")
    def background_schedule_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "background_schedule_pool_size")

    @background_schedule_pool_size.setter
    def background_schedule_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "background_schedule_pool_size", value)

    @property
    @pulumi.getter
    def compressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigCompressionArgs']]]]:
        """
        Data compression configuration. The structure is documented below.
        """
        return pulumi.get(self, "compressions")

    @compressions.setter
    def compressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigCompressionArgs']]]]):
        pulumi.set(self, "compressions", value)

    @property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_database")

    @default_database.setter
    def default_database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_database", value)

    @property
    @pulumi.getter(name="dictionariesLazyLoad")
    def dictionaries_lazy_load(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "dictionaries_lazy_load")

    @dictionaries_lazy_load.setter
    def dictionaries_lazy_load(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dictionaries_lazy_load", value)

    @property
    @pulumi.getter(name="geobaseEnabled")
    def geobase_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "geobase_enabled")

    @geobase_enabled.setter
    def geobase_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geobase_enabled", value)

    @property
    @pulumi.getter(name="geobaseUri")
    def geobase_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "geobase_uri")

    @geobase_uri.setter
    def geobase_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "geobase_uri", value)

    @property
    @pulumi.getter(name="graphiteRollups")
    def graphite_rollups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']]]]:
        """
        Graphite rollup configuration. The structure is documented below.
        """
        return pulumi.get(self, "graphite_rollups")

    @graphite_rollups.setter
    def graphite_rollups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']]]]):
        pulumi.set(self, "graphite_rollups", value)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaArgs']]:
        """
        Kafka connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaArgs']]):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter(name="kafkaTopics")
    def kafka_topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicArgs']]]]:
        """
        Kafka topic connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka_topics")

    @kafka_topics.setter
    def kafka_topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicArgs']]]]):
        pulumi.set(self, "kafka_topics", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        , `max_connections`, `max_concurrent_queries`, `keep_alive_timeout`, `uncompressed_cache_size`, `mark_cache_size`, `max_table_size_to_drop`, `max_partition_size_to_drop`, `timezone`, `geobase_uri`, `query_log_retention_size`, `query_log_retention_time`, `query_thread_log_enabled`, `query_thread_log_retention_size`, `query_thread_log_retention_time`, `part_log_retention_size`, `part_log_retention_time`, `metric_log_enabled`, `metric_log_retention_size`, `metric_log_retention_time`, `trace_log_enabled`, `trace_log_retention_size`, `trace_log_retention_time`, `text_log_enabled`, `text_log_retention_size`, `text_log_retention_time`, `text_log_level`, `background_pool_size`, `background_schedule_pool_size`, `background_fetches_pool_size`, `background_message_broker_schedule_pool_size`,`background_merges_mutations_concurrency_ratio`, `background_move_pool_size`, `background_distributed_schedule_pool_size`, `background_common_pool_size` `default_database`, `total_memory_profiler_step`, `dictionaries_lazy_load`, `opentelemetry_span_log_enabled`, `opentelemetry_span_log_retention_size`, `opentelemetry_span_log_retention_time`, `query_views_log_enabled`, `query_views_log_retention_size`, `query_views_log_retention_time`, `asynchronous_metric_log_enabled`, `asynchronous_metric_log_retention_size`, `asynchronous_metric_log_retention_time`, `session_log_enabled`, `session_log_retention_size`, `session_log_retention_time`, `zookeeper_log_enabled`, `zookeeper_log_retention_size`, `zookeeper_log_retention_time`, `asynchronous_insert_log_enabled`, `asynchronous_insert_log_retention_size`, `asynchronous_insert_log_retention_time` - (Optional) ClickHouse server parameters. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/settings-list).
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="markCacheSize")
    def mark_cache_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mark_cache_size")

    @mark_cache_size.setter
    def mark_cache_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mark_cache_size", value)

    @property
    @pulumi.getter(name="maxConcurrentQueries")
    def max_concurrent_queries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_concurrent_queries")

    @max_concurrent_queries.setter
    def max_concurrent_queries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_queries", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxPartitionSizeToDrop")
    def max_partition_size_to_drop(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_partition_size_to_drop")

    @max_partition_size_to_drop.setter
    def max_partition_size_to_drop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_partition_size_to_drop", value)

    @property
    @pulumi.getter(name="maxTableSizeToDrop")
    def max_table_size_to_drop(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_table_size_to_drop")

    @max_table_size_to_drop.setter
    def max_table_size_to_drop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_table_size_to_drop", value)

    @property
    @pulumi.getter(name="mergeTree")
    def merge_tree(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigMergeTreeArgs']]:
        """
        MergeTree engine configuration. The structure is documented below.
        """
        return pulumi.get(self, "merge_tree")

    @merge_tree.setter
    def merge_tree(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigMergeTreeArgs']]):
        pulumi.set(self, "merge_tree", value)

    @property
    @pulumi.getter(name="metricLogEnabled")
    def metric_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "metric_log_enabled")

    @metric_log_enabled.setter
    def metric_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "metric_log_enabled", value)

    @property
    @pulumi.getter(name="metricLogRetentionSize")
    def metric_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric_log_retention_size")

    @metric_log_retention_size.setter
    def metric_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric_log_retention_size", value)

    @property
    @pulumi.getter(name="metricLogRetentionTime")
    def metric_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric_log_retention_time")

    @metric_log_retention_time.setter
    def metric_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric_log_retention_time", value)

    @property
    @pulumi.getter(name="opentelemetrySpanLogEnabled")
    def opentelemetry_span_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "opentelemetry_span_log_enabled")

    @opentelemetry_span_log_enabled.setter
    def opentelemetry_span_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "opentelemetry_span_log_enabled", value)

    @property
    @pulumi.getter(name="opentelemetrySpanLogRetentionSize")
    def opentelemetry_span_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "opentelemetry_span_log_retention_size")

    @opentelemetry_span_log_retention_size.setter
    def opentelemetry_span_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "opentelemetry_span_log_retention_size", value)

    @property
    @pulumi.getter(name="opentelemetrySpanLogRetentionTime")
    def opentelemetry_span_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "opentelemetry_span_log_retention_time")

    @opentelemetry_span_log_retention_time.setter
    def opentelemetry_span_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "opentelemetry_span_log_retention_time", value)

    @property
    @pulumi.getter(name="partLogRetentionSize")
    def part_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "part_log_retention_size")

    @part_log_retention_size.setter
    def part_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "part_log_retention_size", value)

    @property
    @pulumi.getter(name="partLogRetentionTime")
    def part_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "part_log_retention_time")

    @part_log_retention_time.setter
    def part_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "part_log_retention_time", value)

    @property
    @pulumi.getter(name="queryCache")
    def query_cache(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryCacheArgs']]:
        """
        Query cache configuration. The structure is documented below.
        """
        return pulumi.get(self, "query_cache")

    @query_cache.setter
    def query_cache(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryCacheArgs']]):
        pulumi.set(self, "query_cache", value)

    @property
    @pulumi.getter(name="queryLogRetentionSize")
    def query_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "query_log_retention_size")

    @query_log_retention_size.setter
    def query_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_log_retention_size", value)

    @property
    @pulumi.getter(name="queryLogRetentionTime")
    def query_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "query_log_retention_time")

    @query_log_retention_time.setter
    def query_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_log_retention_time", value)

    @property
    @pulumi.getter(name="queryMaskingRules")
    def query_masking_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']]]]:
        """
        Query masking rules configuration. The structure is documented below.
        """
        return pulumi.get(self, "query_masking_rules")

    @query_masking_rules.setter
    def query_masking_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']]]]):
        pulumi.set(self, "query_masking_rules", value)

    @property
    @pulumi.getter(name="queryThreadLogEnabled")
    def query_thread_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "query_thread_log_enabled")

    @query_thread_log_enabled.setter
    def query_thread_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "query_thread_log_enabled", value)

    @property
    @pulumi.getter(name="queryThreadLogRetentionSize")
    def query_thread_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "query_thread_log_retention_size")

    @query_thread_log_retention_size.setter
    def query_thread_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_thread_log_retention_size", value)

    @property
    @pulumi.getter(name="queryThreadLogRetentionTime")
    def query_thread_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "query_thread_log_retention_time")

    @query_thread_log_retention_time.setter
    def query_thread_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_thread_log_retention_time", value)

    @property
    @pulumi.getter(name="queryViewsLogEnabled")
    def query_views_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "query_views_log_enabled")

    @query_views_log_enabled.setter
    def query_views_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "query_views_log_enabled", value)

    @property
    @pulumi.getter(name="queryViewsLogRetentionSize")
    def query_views_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "query_views_log_retention_size")

    @query_views_log_retention_size.setter
    def query_views_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_views_log_retention_size", value)

    @property
    @pulumi.getter(name="queryViewsLogRetentionTime")
    def query_views_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "query_views_log_retention_time")

    @query_views_log_retention_time.setter
    def query_views_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_views_log_retention_time", value)

    @property
    @pulumi.getter
    def rabbitmq(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigRabbitmqArgs']]:
        """
        RabbitMQ connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "rabbitmq")

    @rabbitmq.setter
    def rabbitmq(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigRabbitmqArgs']]):
        pulumi.set(self, "rabbitmq", value)

    @property
    @pulumi.getter(name="sessionLogEnabled")
    def session_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "session_log_enabled")

    @session_log_enabled.setter
    def session_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "session_log_enabled", value)

    @property
    @pulumi.getter(name="sessionLogRetentionSize")
    def session_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "session_log_retention_size")

    @session_log_retention_size.setter
    def session_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_log_retention_size", value)

    @property
    @pulumi.getter(name="sessionLogRetentionTime")
    def session_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "session_log_retention_time")

    @session_log_retention_time.setter
    def session_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_log_retention_time", value)

    @property
    @pulumi.getter(name="textLogEnabled")
    def text_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "text_log_enabled")

    @text_log_enabled.setter
    def text_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "text_log_enabled", value)

    @property
    @pulumi.getter(name="textLogLevel")
    def text_log_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "text_log_level")

    @text_log_level.setter
    def text_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_log_level", value)

    @property
    @pulumi.getter(name="textLogRetentionSize")
    def text_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "text_log_retention_size")

    @text_log_retention_size.setter
    def text_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "text_log_retention_size", value)

    @property
    @pulumi.getter(name="textLogRetentionTime")
    def text_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "text_log_retention_time")

    @text_log_retention_time.setter
    def text_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "text_log_retention_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="totalMemoryProfilerStep")
    def total_memory_profiler_step(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "total_memory_profiler_step")

    @total_memory_profiler_step.setter
    def total_memory_profiler_step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_memory_profiler_step", value)

    @property
    @pulumi.getter(name="traceLogEnabled")
    def trace_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "trace_log_enabled")

    @trace_log_enabled.setter
    def trace_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trace_log_enabled", value)

    @property
    @pulumi.getter(name="traceLogRetentionSize")
    def trace_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "trace_log_retention_size")

    @trace_log_retention_size.setter
    def trace_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "trace_log_retention_size", value)

    @property
    @pulumi.getter(name="traceLogRetentionTime")
    def trace_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "trace_log_retention_time")

    @trace_log_retention_time.setter
    def trace_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "trace_log_retention_time", value)

    @property
    @pulumi.getter(name="uncompressedCacheSize")
    def uncompressed_cache_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "uncompressed_cache_size")

    @uncompressed_cache_size.setter
    def uncompressed_cache_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uncompressed_cache_size", value)

    @property
    @pulumi.getter(name="zookeeperLogEnabled")
    def zookeeper_log_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "zookeeper_log_enabled")

    @zookeeper_log_enabled.setter
    def zookeeper_log_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "zookeeper_log_enabled", value)

    @property
    @pulumi.getter(name="zookeeperLogRetentionSize")
    def zookeeper_log_retention_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "zookeeper_log_retention_size")

    @zookeeper_log_retention_size.setter
    def zookeeper_log_retention_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zookeeper_log_retention_size", value)

    @property
    @pulumi.getter(name="zookeeperLogRetentionTime")
    def zookeeper_log_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "zookeeper_log_retention_time")

    @zookeeper_log_retention_time.setter
    def zookeeper_log_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zookeeper_log_retention_time", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigCompressionArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Method: Compression method. Two methods are available: LZ4 and zstd.
        """
        min_part_size: pulumi.Input[int]
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        min_part_size_ratio: pulumi.Input[float]
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        level: NotRequired[pulumi.Input[int]]
        """
        Compression level for `ZSTD` method.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigCompressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigCompressionArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 min_part_size: pulumi.Input[int],
                 min_part_size_ratio: pulumi.Input[float],
                 level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] method: Method: Compression method. Two methods are available: LZ4 and zstd.
        :param pulumi.Input[int] min_part_size: Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        :param pulumi.Input[float] min_part_size_ratio: Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        :param pulumi.Input[int] level: Compression level for `ZSTD` method.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "min_part_size", min_part_size)
        pulumi.set(__self__, "min_part_size_ratio", min_part_size_ratio)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Method: Compression method. Two methods are available: LZ4 and zstd.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="minPartSize")
    def min_part_size(self) -> pulumi.Input[int]:
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        return pulumi.get(self, "min_part_size")

    @min_part_size.setter
    def min_part_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_part_size", value)

    @property
    @pulumi.getter(name="minPartSizeRatio")
    def min_part_size_ratio(self) -> pulumi.Input[float]:
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        return pulumi.get(self, "min_part_size_ratio")

    @min_part_size_ratio.setter
    def min_part_size_ratio(self, value: pulumi.Input[float]):
        pulumi.set(self, "min_part_size_ratio", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[int]]:
        """
        Compression level for `ZSTD` method.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Graphite rollup configuration name.
        """
        path_column_name: NotRequired[pulumi.Input[str]]
        """
        The name of the column storing the metric name (Graphite sensor). Default value: Path.
        """
        patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict']]]]
        """
        Set of thinning rules.
        """
        time_column_name: NotRequired[pulumi.Input[str]]
        """
        The name of the column storing the time of measuring the metric. Default value: Time.
        """
        value_column_name: NotRequired[pulumi.Input[str]]
        """
        The name of the column storing the value of the metric at the time set in time_column_name. Default value: Value.
        """
        version_column_name: NotRequired[pulumi.Input[str]]
        """
        The name of the column storing the version of the metric. Default value: Timestamp.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path_column_name: Optional[pulumi.Input[str]] = None,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']]]] = None,
                 time_column_name: Optional[pulumi.Input[str]] = None,
                 value_column_name: Optional[pulumi.Input[str]] = None,
                 version_column_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Graphite rollup configuration name.
        :param pulumi.Input[str] path_column_name: The name of the column storing the metric name (Graphite sensor). Default value: Path.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']]] patterns: Set of thinning rules.
        :param pulumi.Input[str] time_column_name: The name of the column storing the time of measuring the metric. Default value: Time.
        :param pulumi.Input[str] value_column_name: The name of the column storing the value of the metric at the time set in time_column_name. Default value: Value.
        :param pulumi.Input[str] version_column_name: The name of the column storing the version of the metric. Default value: Timestamp.
        """
        pulumi.set(__self__, "name", name)
        if path_column_name is not None:
            pulumi.set(__self__, "path_column_name", path_column_name)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if time_column_name is not None:
            pulumi.set(__self__, "time_column_name", time_column_name)
        if value_column_name is not None:
            pulumi.set(__self__, "value_column_name", value_column_name)
        if version_column_name is not None:
            pulumi.set(__self__, "version_column_name", version_column_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pathColumnName")
    def path_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column storing the metric name (Graphite sensor). Default value: Path.
        """
        return pulumi.get(self, "path_column_name")

    @path_column_name.setter
    def path_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_column_name", value)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']]]]:
        """
        Set of thinning rules.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']]]]):
        pulumi.set(self, "patterns", value)

    @property
    @pulumi.getter(name="timeColumnName")
    def time_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column storing the time of measuring the metric. Default value: Time.
        """
        return pulumi.get(self, "time_column_name")

    @time_column_name.setter
    def time_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_column_name", value)

    @property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column storing the value of the metric at the time set in time_column_name. Default value: Value.
        """
        return pulumi.get(self, "value_column_name")

    @value_column_name.setter
    def value_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_column_name", value)

    @property
    @pulumi.getter(name="versionColumnName")
    def version_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the column storing the version of the metric. Default value: Timestamp.
        """
        return pulumi.get(self, "version_column_name")

    @version_column_name.setter
    def version_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_column_name", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict(TypedDict):
        function: pulumi.Input[str]
        """
        Aggregation function name.
        """
        regexp: NotRequired[pulumi.Input[str]]
        """
        Regular expression that the metric name must match.
        """
        retentions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict']]]]
        """
        Retain parameters.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs:
    def __init__(__self__, *,
                 function: pulumi.Input[str],
                 regexp: Optional[pulumi.Input[str]] = None,
                 retentions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']]]] = None):
        """
        :param pulumi.Input[str] function: Aggregation function name.
        :param pulumi.Input[str] regexp: Regular expression that the metric name must match.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']]] retentions: Retain parameters.
        """
        pulumi.set(__self__, "function", function)
        if regexp is not None:
            pulumi.set(__self__, "regexp", regexp)
        if retentions is not None:
            pulumi.set(__self__, "retentions", retentions)

    @property
    @pulumi.getter
    def function(self) -> pulumi.Input[str]:
        """
        Aggregation function name.
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: pulumi.Input[str]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def regexp(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression that the metric name must match.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def retentions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']]]]:
        """
        Retain parameters.
        """
        return pulumi.get(self, "retentions")

    @retentions.setter
    def retentions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']]]]):
        pulumi.set(self, "retentions", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict(TypedDict):
        age: pulumi.Input[int]
        """
        Minimum data age in seconds.
        """
        precision: pulumi.Input[int]
        """
        Accuracy of determining the age of the data in seconds.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs:
    def __init__(__self__, *,
                 age: pulumi.Input[int],
                 precision: pulumi.Input[int]):
        """
        :param pulumi.Input[int] age: Minimum data age in seconds.
        :param pulumi.Input[int] precision: Accuracy of determining the age of the data in seconds.
        """
        pulumi.set(__self__, "age", age)
        pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter
    def age(self) -> pulumi.Input[int]:
        """
        Minimum data age in seconds.
        """
        return pulumi.get(self, "age")

    @age.setter
    def age(self, value: pulumi.Input[int]):
        pulumi.set(self, "age", value)

    @property
    @pulumi.getter
    def precision(self) -> pulumi.Input[int]:
        """
        Accuracy of determining the age of the data in seconds.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: pulumi.Input[int]):
        pulumi.set(self, "precision", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigKafkaArgsDict(TypedDict):
        auto_offset_reset: NotRequired[pulumi.Input[str]]
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        debug: NotRequired[pulumi.Input[str]]
        """
        A comma-separated list of debug contexts to enable.
        """
        enable_ssl_certificate_verification: NotRequired[pulumi.Input[bool]]
        """
        enable verification of SSL certificates.
        """
        max_poll_interval_ms: NotRequired[pulumi.Input[int]]
        """
        Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        sasl_mechanism: NotRequired[pulumi.Input[str]]
        """
        SASL mechanism used in kafka authentication.
        """
        sasl_password: NotRequired[pulumi.Input[str]]
        """
        User password on kafka server.
        """
        sasl_username: NotRequired[pulumi.Input[str]]
        """
        Username on kafka server.
        """
        security_protocol: NotRequired[pulumi.Input[str]]
        """
        Security protocol used to connect to kafka server.
        """
        session_timeout_ms: NotRequired[pulumi.Input[int]]
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigKafkaArgs:
    def __init__(__self__, *,
                 auto_offset_reset: Optional[pulumi.Input[str]] = None,
                 debug: Optional[pulumi.Input[str]] = None,
                 enable_ssl_certificate_verification: Optional[pulumi.Input[bool]] = None,
                 max_poll_interval_ms: Optional[pulumi.Input[int]] = None,
                 sasl_mechanism: Optional[pulumi.Input[str]] = None,
                 sasl_password: Optional[pulumi.Input[str]] = None,
                 sasl_username: Optional[pulumi.Input[str]] = None,
                 security_protocol: Optional[pulumi.Input[str]] = None,
                 session_timeout_ms: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] auto_offset_reset: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param pulumi.Input[str] debug: A comma-separated list of debug contexts to enable.
        :param pulumi.Input[bool] enable_ssl_certificate_verification: enable verification of SSL certificates.
        :param pulumi.Input[int] max_poll_interval_ms: Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param pulumi.Input[str] sasl_mechanism: SASL mechanism used in kafka authentication.
        :param pulumi.Input[str] sasl_password: User password on kafka server.
        :param pulumi.Input[str] sasl_username: Username on kafka server.
        :param pulumi.Input[str] security_protocol: Security protocol used to connect to kafka server.
        :param pulumi.Input[int] session_timeout_ms: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        if auto_offset_reset is not None:
            pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if enable_ssl_certificate_verification is not None:
            pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        if max_poll_interval_ms is not None:
            pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @auto_offset_reset.setter
    def auto_offset_reset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_offset_reset", value)

    @property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[str]]:
        """
        A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @enable_ssl_certificate_verification.setter
    def enable_ssl_certificate_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ssl_certificate_verification", value)

    @property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @max_poll_interval_ms.setter
    def max_poll_interval_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_poll_interval_ms", value)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_mechanism", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[pulumi.Input[str]]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[pulumi.Input[str]]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_protocol", value)

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")

    @session_timeout_ms.setter
    def session_timeout_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_timeout_ms", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Kafka topic name.
        """
        settings: NotRequired[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict']]
        """
        Kafka connection settngs sanem as `kafka` block.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigKafkaTopicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 settings: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs']] = None):
        """
        :param pulumi.Input[str] name: Kafka topic name.
        :param pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs'] settings: Kafka connection settngs sanem as `kafka` block.
        """
        pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Kafka topic name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs']]:
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs']]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict(TypedDict):
        auto_offset_reset: NotRequired[pulumi.Input[str]]
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        debug: NotRequired[pulumi.Input[str]]
        """
        A comma-separated list of debug contexts to enable.
        """
        enable_ssl_certificate_verification: NotRequired[pulumi.Input[bool]]
        """
        enable verification of SSL certificates.
        """
        max_poll_interval_ms: NotRequired[pulumi.Input[int]]
        """
        Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        sasl_mechanism: NotRequired[pulumi.Input[str]]
        """
        SASL mechanism used in kafka authentication.
        """
        sasl_password: NotRequired[pulumi.Input[str]]
        """
        User password on kafka server.
        """
        sasl_username: NotRequired[pulumi.Input[str]]
        """
        Username on kafka server.
        """
        security_protocol: NotRequired[pulumi.Input[str]]
        """
        Security protocol used to connect to kafka server.
        """
        session_timeout_ms: NotRequired[pulumi.Input[int]]
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs:
    def __init__(__self__, *,
                 auto_offset_reset: Optional[pulumi.Input[str]] = None,
                 debug: Optional[pulumi.Input[str]] = None,
                 enable_ssl_certificate_verification: Optional[pulumi.Input[bool]] = None,
                 max_poll_interval_ms: Optional[pulumi.Input[int]] = None,
                 sasl_mechanism: Optional[pulumi.Input[str]] = None,
                 sasl_password: Optional[pulumi.Input[str]] = None,
                 sasl_username: Optional[pulumi.Input[str]] = None,
                 security_protocol: Optional[pulumi.Input[str]] = None,
                 session_timeout_ms: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] auto_offset_reset: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param pulumi.Input[str] debug: A comma-separated list of debug contexts to enable.
        :param pulumi.Input[bool] enable_ssl_certificate_verification: enable verification of SSL certificates.
        :param pulumi.Input[int] max_poll_interval_ms: Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param pulumi.Input[str] sasl_mechanism: SASL mechanism used in kafka authentication.
        :param pulumi.Input[str] sasl_password: User password on kafka server.
        :param pulumi.Input[str] sasl_username: Username on kafka server.
        :param pulumi.Input[str] security_protocol: Security protocol used to connect to kafka server.
        :param pulumi.Input[int] session_timeout_ms: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        if auto_offset_reset is not None:
            pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if enable_ssl_certificate_verification is not None:
            pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        if max_poll_interval_ms is not None:
            pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @auto_offset_reset.setter
    def auto_offset_reset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_offset_reset", value)

    @property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[str]]:
        """
        A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @enable_ssl_certificate_verification.setter
    def enable_ssl_certificate_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ssl_certificate_verification", value)

    @property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @max_poll_interval_ms.setter
    def max_poll_interval_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_poll_interval_ms", value)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_mechanism", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[pulumi.Input[str]]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[pulumi.Input[str]]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_protocol", value)

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")

    @session_timeout_ms.setter
    def session_timeout_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_timeout_ms", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigMergeTreeArgsDict(TypedDict):
        allow_remote_fs_zero_copy_replication: NotRequired[pulumi.Input[bool]]
        """
        When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        """
        check_sample_column_is_correct: NotRequired[pulumi.Input[bool]]
        """
        Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        """
        cleanup_delay_period: NotRequired[pulumi.Input[int]]
        """
        Minimum period to clean old queue logs, blocks hashes and parts.
        """
        inactive_parts_to_delay_insert: NotRequired[pulumi.Input[int]]
        """
        If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        """
        inactive_parts_to_throw_insert: NotRequired[pulumi.Input[int]]
        """
        If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the "Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts" exception.
        """
        max_avg_part_size_for_too_many_parts: NotRequired[pulumi.Input[int]]
        """
        The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        """
        max_bytes_to_merge_at_max_space_in_pool: NotRequired[pulumi.Input[int]]
        """
        The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        """
        max_bytes_to_merge_at_min_space_in_pool: NotRequired[pulumi.Input[int]]
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        max_cleanup_delay_period: NotRequired[pulumi.Input[int]]
        """
        Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        """
        max_merge_selecting_sleep_ms: NotRequired[pulumi.Input[int]]
        """
        Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        """
        max_number_of_merges_with_ttl_in_pool: NotRequired[pulumi.Input[int]]
        """
        When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        """
        max_parts_in_total: NotRequired[pulumi.Input[int]]
        """
        Maximum number of parts in all partitions.
        """
        max_replicated_merges_in_queue: NotRequired[pulumi.Input[int]]
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        merge_max_block_size: NotRequired[pulumi.Input[int]]
        """
        The number of rows that are read from the merged parts into memory. Default value: 8192.
        """
        merge_selecting_sleep_ms: NotRequired[pulumi.Input[int]]
        """
        Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        """
        merge_with_recompression_ttl_timeout: NotRequired[pulumi.Input[int]]
        """
        Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        """
        merge_with_ttl_timeout: NotRequired[pulumi.Input[int]]
        """
        Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        """
        min_age_to_force_merge_on_partition_only: NotRequired[pulumi.Input[bool]]
        """
        Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        """
        min_age_to_force_merge_seconds: NotRequired[pulumi.Input[int]]
        """
        Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        """
        min_bytes_for_wide_part: NotRequired[pulumi.Input[int]]
        """
        Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        min_rows_for_wide_part: NotRequired[pulumi.Input[int]]
        """
        Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        number_of_free_entries_in_pool_to_execute_mutation: NotRequired[pulumi.Input[int]]
        """
        When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid "Too many parts". Default value: 20.
        """
        number_of_free_entries_in_pool_to_lower_max_size_of_merge: NotRequired[pulumi.Input[int]]
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        parts_to_delay_insert: NotRequired[pulumi.Input[int]]
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        """
        parts_to_throw_insert: NotRequired[pulumi.Input[int]]
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        replicated_deduplication_window: NotRequired[pulumi.Input[int]]
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        replicated_deduplication_window_seconds: NotRequired[pulumi.Input[int]]
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        ttl_only_drop_parts: NotRequired[pulumi.Input[bool]]
        """
        Enables zero-copy replication when a replica is located on a remote filesystem.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigMergeTreeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigMergeTreeArgs:
    def __init__(__self__, *,
                 allow_remote_fs_zero_copy_replication: Optional[pulumi.Input[bool]] = None,
                 check_sample_column_is_correct: Optional[pulumi.Input[bool]] = None,
                 cleanup_delay_period: Optional[pulumi.Input[int]] = None,
                 inactive_parts_to_delay_insert: Optional[pulumi.Input[int]] = None,
                 inactive_parts_to_throw_insert: Optional[pulumi.Input[int]] = None,
                 max_avg_part_size_for_too_many_parts: Optional[pulumi.Input[int]] = None,
                 max_bytes_to_merge_at_max_space_in_pool: Optional[pulumi.Input[int]] = None,
                 max_bytes_to_merge_at_min_space_in_pool: Optional[pulumi.Input[int]] = None,
                 max_cleanup_delay_period: Optional[pulumi.Input[int]] = None,
                 max_merge_selecting_sleep_ms: Optional[pulumi.Input[int]] = None,
                 max_number_of_merges_with_ttl_in_pool: Optional[pulumi.Input[int]] = None,
                 max_parts_in_total: Optional[pulumi.Input[int]] = None,
                 max_replicated_merges_in_queue: Optional[pulumi.Input[int]] = None,
                 merge_max_block_size: Optional[pulumi.Input[int]] = None,
                 merge_selecting_sleep_ms: Optional[pulumi.Input[int]] = None,
                 merge_with_recompression_ttl_timeout: Optional[pulumi.Input[int]] = None,
                 merge_with_ttl_timeout: Optional[pulumi.Input[int]] = None,
                 min_age_to_force_merge_on_partition_only: Optional[pulumi.Input[bool]] = None,
                 min_age_to_force_merge_seconds: Optional[pulumi.Input[int]] = None,
                 min_bytes_for_wide_part: Optional[pulumi.Input[int]] = None,
                 min_rows_for_wide_part: Optional[pulumi.Input[int]] = None,
                 number_of_free_entries_in_pool_to_execute_mutation: Optional[pulumi.Input[int]] = None,
                 number_of_free_entries_in_pool_to_lower_max_size_of_merge: Optional[pulumi.Input[int]] = None,
                 parts_to_delay_insert: Optional[pulumi.Input[int]] = None,
                 parts_to_throw_insert: Optional[pulumi.Input[int]] = None,
                 replicated_deduplication_window: Optional[pulumi.Input[int]] = None,
                 replicated_deduplication_window_seconds: Optional[pulumi.Input[int]] = None,
                 ttl_only_drop_parts: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_remote_fs_zero_copy_replication: When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        :param pulumi.Input[bool] check_sample_column_is_correct: Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        :param pulumi.Input[int] cleanup_delay_period: Minimum period to clean old queue logs, blocks hashes and parts.
        :param pulumi.Input[int] inactive_parts_to_delay_insert: If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        :param pulumi.Input[int] inactive_parts_to_throw_insert: If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the "Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts" exception.
        :param pulumi.Input[int] max_avg_part_size_for_too_many_parts: The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        :param pulumi.Input[int] max_bytes_to_merge_at_max_space_in_pool: The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        :param pulumi.Input[int] max_bytes_to_merge_at_min_space_in_pool: Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        :param pulumi.Input[int] max_cleanup_delay_period: Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        :param pulumi.Input[int] max_merge_selecting_sleep_ms: Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        :param pulumi.Input[int] max_number_of_merges_with_ttl_in_pool: When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        :param pulumi.Input[int] max_parts_in_total: Maximum number of parts in all partitions.
        :param pulumi.Input[int] max_replicated_merges_in_queue: Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        :param pulumi.Input[int] merge_max_block_size: The number of rows that are read from the merged parts into memory. Default value: 8192.
        :param pulumi.Input[int] merge_selecting_sleep_ms: Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        :param pulumi.Input[int] merge_with_recompression_ttl_timeout: Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        :param pulumi.Input[int] merge_with_ttl_timeout: Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        :param pulumi.Input[bool] min_age_to_force_merge_on_partition_only: Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        :param pulumi.Input[int] min_age_to_force_merge_seconds: Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        :param pulumi.Input[int] min_bytes_for_wide_part: Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param pulumi.Input[int] min_rows_for_wide_part: Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param pulumi.Input[int] number_of_free_entries_in_pool_to_execute_mutation: When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid "Too many parts". Default value: 20.
        :param pulumi.Input[int] number_of_free_entries_in_pool_to_lower_max_size_of_merge: Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        :param pulumi.Input[int] parts_to_delay_insert: Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        :param pulumi.Input[int] parts_to_throw_insert: Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        :param pulumi.Input[int] replicated_deduplication_window: Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        :param pulumi.Input[int] replicated_deduplication_window_seconds: Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        :param pulumi.Input[bool] ttl_only_drop_parts: Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        if allow_remote_fs_zero_copy_replication is not None:
            pulumi.set(__self__, "allow_remote_fs_zero_copy_replication", allow_remote_fs_zero_copy_replication)
        if check_sample_column_is_correct is not None:
            pulumi.set(__self__, "check_sample_column_is_correct", check_sample_column_is_correct)
        if cleanup_delay_period is not None:
            pulumi.set(__self__, "cleanup_delay_period", cleanup_delay_period)
        if inactive_parts_to_delay_insert is not None:
            pulumi.set(__self__, "inactive_parts_to_delay_insert", inactive_parts_to_delay_insert)
        if inactive_parts_to_throw_insert is not None:
            pulumi.set(__self__, "inactive_parts_to_throw_insert", inactive_parts_to_throw_insert)
        if max_avg_part_size_for_too_many_parts is not None:
            pulumi.set(__self__, "max_avg_part_size_for_too_many_parts", max_avg_part_size_for_too_many_parts)
        if max_bytes_to_merge_at_max_space_in_pool is not None:
            pulumi.set(__self__, "max_bytes_to_merge_at_max_space_in_pool", max_bytes_to_merge_at_max_space_in_pool)
        if max_bytes_to_merge_at_min_space_in_pool is not None:
            pulumi.set(__self__, "max_bytes_to_merge_at_min_space_in_pool", max_bytes_to_merge_at_min_space_in_pool)
        if max_cleanup_delay_period is not None:
            pulumi.set(__self__, "max_cleanup_delay_period", max_cleanup_delay_period)
        if max_merge_selecting_sleep_ms is not None:
            pulumi.set(__self__, "max_merge_selecting_sleep_ms", max_merge_selecting_sleep_ms)
        if max_number_of_merges_with_ttl_in_pool is not None:
            pulumi.set(__self__, "max_number_of_merges_with_ttl_in_pool", max_number_of_merges_with_ttl_in_pool)
        if max_parts_in_total is not None:
            pulumi.set(__self__, "max_parts_in_total", max_parts_in_total)
        if max_replicated_merges_in_queue is not None:
            pulumi.set(__self__, "max_replicated_merges_in_queue", max_replicated_merges_in_queue)
        if merge_max_block_size is not None:
            pulumi.set(__self__, "merge_max_block_size", merge_max_block_size)
        if merge_selecting_sleep_ms is not None:
            pulumi.set(__self__, "merge_selecting_sleep_ms", merge_selecting_sleep_ms)
        if merge_with_recompression_ttl_timeout is not None:
            pulumi.set(__self__, "merge_with_recompression_ttl_timeout", merge_with_recompression_ttl_timeout)
        if merge_with_ttl_timeout is not None:
            pulumi.set(__self__, "merge_with_ttl_timeout", merge_with_ttl_timeout)
        if min_age_to_force_merge_on_partition_only is not None:
            pulumi.set(__self__, "min_age_to_force_merge_on_partition_only", min_age_to_force_merge_on_partition_only)
        if min_age_to_force_merge_seconds is not None:
            pulumi.set(__self__, "min_age_to_force_merge_seconds", min_age_to_force_merge_seconds)
        if min_bytes_for_wide_part is not None:
            pulumi.set(__self__, "min_bytes_for_wide_part", min_bytes_for_wide_part)
        if min_rows_for_wide_part is not None:
            pulumi.set(__self__, "min_rows_for_wide_part", min_rows_for_wide_part)
        if number_of_free_entries_in_pool_to_execute_mutation is not None:
            pulumi.set(__self__, "number_of_free_entries_in_pool_to_execute_mutation", number_of_free_entries_in_pool_to_execute_mutation)
        if number_of_free_entries_in_pool_to_lower_max_size_of_merge is not None:
            pulumi.set(__self__, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", number_of_free_entries_in_pool_to_lower_max_size_of_merge)
        if parts_to_delay_insert is not None:
            pulumi.set(__self__, "parts_to_delay_insert", parts_to_delay_insert)
        if parts_to_throw_insert is not None:
            pulumi.set(__self__, "parts_to_throw_insert", parts_to_throw_insert)
        if replicated_deduplication_window is not None:
            pulumi.set(__self__, "replicated_deduplication_window", replicated_deduplication_window)
        if replicated_deduplication_window_seconds is not None:
            pulumi.set(__self__, "replicated_deduplication_window_seconds", replicated_deduplication_window_seconds)
        if ttl_only_drop_parts is not None:
            pulumi.set(__self__, "ttl_only_drop_parts", ttl_only_drop_parts)

    @property
    @pulumi.getter(name="allowRemoteFsZeroCopyReplication")
    def allow_remote_fs_zero_copy_replication(self) -> Optional[pulumi.Input[bool]]:
        """
        When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        """
        return pulumi.get(self, "allow_remote_fs_zero_copy_replication")

    @allow_remote_fs_zero_copy_replication.setter
    def allow_remote_fs_zero_copy_replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_remote_fs_zero_copy_replication", value)

    @property
    @pulumi.getter(name="checkSampleColumnIsCorrect")
    def check_sample_column_is_correct(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        """
        return pulumi.get(self, "check_sample_column_is_correct")

    @check_sample_column_is_correct.setter
    def check_sample_column_is_correct(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_sample_column_is_correct", value)

    @property
    @pulumi.getter(name="cleanupDelayPeriod")
    def cleanup_delay_period(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum period to clean old queue logs, blocks hashes and parts.
        """
        return pulumi.get(self, "cleanup_delay_period")

    @cleanup_delay_period.setter
    def cleanup_delay_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cleanup_delay_period", value)

    @property
    @pulumi.getter(name="inactivePartsToDelayInsert")
    def inactive_parts_to_delay_insert(self) -> Optional[pulumi.Input[int]]:
        """
        If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        """
        return pulumi.get(self, "inactive_parts_to_delay_insert")

    @inactive_parts_to_delay_insert.setter
    def inactive_parts_to_delay_insert(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "inactive_parts_to_delay_insert", value)

    @property
    @pulumi.getter(name="inactivePartsToThrowInsert")
    def inactive_parts_to_throw_insert(self) -> Optional[pulumi.Input[int]]:
        """
        If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the "Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts" exception.
        """
        return pulumi.get(self, "inactive_parts_to_throw_insert")

    @inactive_parts_to_throw_insert.setter
    def inactive_parts_to_throw_insert(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "inactive_parts_to_throw_insert", value)

    @property
    @pulumi.getter(name="maxAvgPartSizeForTooManyParts")
    def max_avg_part_size_for_too_many_parts(self) -> Optional[pulumi.Input[int]]:
        """
        The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        """
        return pulumi.get(self, "max_avg_part_size_for_too_many_parts")

    @max_avg_part_size_for_too_many_parts.setter
    def max_avg_part_size_for_too_many_parts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_avg_part_size_for_too_many_parts", value)

    @property
    @pulumi.getter(name="maxBytesToMergeAtMaxSpaceInPool")
    def max_bytes_to_merge_at_max_space_in_pool(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_max_space_in_pool")

    @max_bytes_to_merge_at_max_space_in_pool.setter
    def max_bytes_to_merge_at_max_space_in_pool(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_to_merge_at_max_space_in_pool", value)

    @property
    @pulumi.getter(name="maxBytesToMergeAtMinSpaceInPool")
    def max_bytes_to_merge_at_min_space_in_pool(self) -> Optional[pulumi.Input[int]]:
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_min_space_in_pool")

    @max_bytes_to_merge_at_min_space_in_pool.setter
    def max_bytes_to_merge_at_min_space_in_pool(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_to_merge_at_min_space_in_pool", value)

    @property
    @pulumi.getter(name="maxCleanupDelayPeriod")
    def max_cleanup_delay_period(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        """
        return pulumi.get(self, "max_cleanup_delay_period")

    @max_cleanup_delay_period.setter
    def max_cleanup_delay_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_cleanup_delay_period", value)

    @property
    @pulumi.getter(name="maxMergeSelectingSleepMs")
    def max_merge_selecting_sleep_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        """
        return pulumi.get(self, "max_merge_selecting_sleep_ms")

    @max_merge_selecting_sleep_ms.setter
    def max_merge_selecting_sleep_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_merge_selecting_sleep_ms", value)

    @property
    @pulumi.getter(name="maxNumberOfMergesWithTtlInPool")
    def max_number_of_merges_with_ttl_in_pool(self) -> Optional[pulumi.Input[int]]:
        """
        When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        """
        return pulumi.get(self, "max_number_of_merges_with_ttl_in_pool")

    @max_number_of_merges_with_ttl_in_pool.setter
    def max_number_of_merges_with_ttl_in_pool(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_merges_with_ttl_in_pool", value)

    @property
    @pulumi.getter(name="maxPartsInTotal")
    def max_parts_in_total(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of parts in all partitions.
        """
        return pulumi.get(self, "max_parts_in_total")

    @max_parts_in_total.setter
    def max_parts_in_total(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parts_in_total", value)

    @property
    @pulumi.getter(name="maxReplicatedMergesInQueue")
    def max_replicated_merges_in_queue(self) -> Optional[pulumi.Input[int]]:
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        return pulumi.get(self, "max_replicated_merges_in_queue")

    @max_replicated_merges_in_queue.setter
    def max_replicated_merges_in_queue(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicated_merges_in_queue", value)

    @property
    @pulumi.getter(name="mergeMaxBlockSize")
    def merge_max_block_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows that are read from the merged parts into memory. Default value: 8192.
        """
        return pulumi.get(self, "merge_max_block_size")

    @merge_max_block_size.setter
    def merge_max_block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_max_block_size", value)

    @property
    @pulumi.getter(name="mergeSelectingSleepMs")
    def merge_selecting_sleep_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        """
        return pulumi.get(self, "merge_selecting_sleep_ms")

    @merge_selecting_sleep_ms.setter
    def merge_selecting_sleep_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_selecting_sleep_ms", value)

    @property
    @pulumi.getter(name="mergeWithRecompressionTtlTimeout")
    def merge_with_recompression_ttl_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_recompression_ttl_timeout")

    @merge_with_recompression_ttl_timeout.setter
    def merge_with_recompression_ttl_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_with_recompression_ttl_timeout", value)

    @property
    @pulumi.getter(name="mergeWithTtlTimeout")
    def merge_with_ttl_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_ttl_timeout")

    @merge_with_ttl_timeout.setter
    def merge_with_ttl_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_with_ttl_timeout", value)

    @property
    @pulumi.getter(name="minAgeToForceMergeOnPartitionOnly")
    def min_age_to_force_merge_on_partition_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        """
        return pulumi.get(self, "min_age_to_force_merge_on_partition_only")

    @min_age_to_force_merge_on_partition_only.setter
    def min_age_to_force_merge_on_partition_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "min_age_to_force_merge_on_partition_only", value)

    @property
    @pulumi.getter(name="minAgeToForceMergeSeconds")
    def min_age_to_force_merge_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        """
        return pulumi.get(self, "min_age_to_force_merge_seconds")

    @min_age_to_force_merge_seconds.setter
    def min_age_to_force_merge_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_age_to_force_merge_seconds", value)

    @property
    @pulumi.getter(name="minBytesForWidePart")
    def min_bytes_for_wide_part(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_bytes_for_wide_part")

    @min_bytes_for_wide_part.setter
    def min_bytes_for_wide_part(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_bytes_for_wide_part", value)

    @property
    @pulumi.getter(name="minRowsForWidePart")
    def min_rows_for_wide_part(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_rows_for_wide_part")

    @min_rows_for_wide_part.setter
    def min_rows_for_wide_part(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_rows_for_wide_part", value)

    @property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToExecuteMutation")
    def number_of_free_entries_in_pool_to_execute_mutation(self) -> Optional[pulumi.Input[int]]:
        """
        When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid "Too many parts". Default value: 20.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_execute_mutation")

    @number_of_free_entries_in_pool_to_execute_mutation.setter
    def number_of_free_entries_in_pool_to_execute_mutation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_free_entries_in_pool_to_execute_mutation", value)

    @property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge")
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self) -> Optional[pulumi.Input[int]]:
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge")

    @number_of_free_entries_in_pool_to_lower_max_size_of_merge.setter
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", value)

    @property
    @pulumi.getter(name="partsToDelayInsert")
    def parts_to_delay_insert(self) -> Optional[pulumi.Input[int]]:
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        """
        return pulumi.get(self, "parts_to_delay_insert")

    @parts_to_delay_insert.setter
    def parts_to_delay_insert(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parts_to_delay_insert", value)

    @property
    @pulumi.getter(name="partsToThrowInsert")
    def parts_to_throw_insert(self) -> Optional[pulumi.Input[int]]:
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        return pulumi.get(self, "parts_to_throw_insert")

    @parts_to_throw_insert.setter
    def parts_to_throw_insert(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parts_to_throw_insert", value)

    @property
    @pulumi.getter(name="replicatedDeduplicationWindow")
    def replicated_deduplication_window(self) -> Optional[pulumi.Input[int]]:
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window")

    @replicated_deduplication_window.setter
    def replicated_deduplication_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicated_deduplication_window", value)

    @property
    @pulumi.getter(name="replicatedDeduplicationWindowSeconds")
    def replicated_deduplication_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window_seconds")

    @replicated_deduplication_window_seconds.setter
    def replicated_deduplication_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicated_deduplication_window_seconds", value)

    @property
    @pulumi.getter(name="ttlOnlyDropParts")
    def ttl_only_drop_parts(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        return pulumi.get(self, "ttl_only_drop_parts")

    @ttl_only_drop_parts.setter
    def ttl_only_drop_parts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ttl_only_drop_parts", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigQueryCacheArgsDict(TypedDict):
        max_entries: NotRequired[pulumi.Input[int]]
        """
        The maximum number of SELECT query results stored in the cache. Default value: 1024.
        """
        max_entry_size_in_bytes: NotRequired[pulumi.Input[int]]
        """
        The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        """
        max_entry_size_in_rows: NotRequired[pulumi.Input[int]]
        """
        The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        """
        max_size_in_bytes: NotRequired[pulumi.Input[int]]
        """
        The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
elif False:
    MdbClickhouseClusterClickhouseConfigQueryCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigQueryCacheArgs:
    def __init__(__self__, *,
                 max_entries: Optional[pulumi.Input[int]] = None,
                 max_entry_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 max_entry_size_in_rows: Optional[pulumi.Input[int]] = None,
                 max_size_in_bytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_entries: The maximum number of SELECT query results stored in the cache. Default value: 1024.
        :param pulumi.Input[int] max_entry_size_in_bytes: The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        :param pulumi.Input[int] max_entry_size_in_rows: The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        :param pulumi.Input[int] max_size_in_bytes: The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        if max_entries is not None:
            pulumi.set(__self__, "max_entries", max_entries)
        if max_entry_size_in_bytes is not None:
            pulumi.set(__self__, "max_entry_size_in_bytes", max_entry_size_in_bytes)
        if max_entry_size_in_rows is not None:
            pulumi.set(__self__, "max_entry_size_in_rows", max_entry_size_in_rows)
        if max_size_in_bytes is not None:
            pulumi.set(__self__, "max_size_in_bytes", max_size_in_bytes)

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of SELECT query results stored in the cache. Default value: 1024.
        """
        return pulumi.get(self, "max_entries")

    @max_entries.setter
    def max_entries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_entries", value)

    @property
    @pulumi.getter(name="maxEntrySizeInBytes")
    def max_entry_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        """
        return pulumi.get(self, "max_entry_size_in_bytes")

    @max_entry_size_in_bytes.setter
    def max_entry_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_entry_size_in_bytes", value)

    @property
    @pulumi.getter(name="maxEntrySizeInRows")
    def max_entry_size_in_rows(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        """
        return pulumi.get(self, "max_entry_size_in_rows")

    @max_entry_size_in_rows.setter
    def max_entry_size_in_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_entry_size_in_rows", value)

    @property
    @pulumi.getter(name="maxSizeInBytes")
    def max_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        return pulumi.get(self, "max_size_in_bytes")

    @max_size_in_bytes.setter
    def max_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size_in_bytes", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict(TypedDict):
        regexp: pulumi.Input[str]
        """
        RE2 compatible regular expression.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name for the rule.
        """
        replace: NotRequired[pulumi.Input[str]]
        """
        Substitution string for sensitive data. Default value: six asterisks.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs:
    def __init__(__self__, *,
                 regexp: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 replace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regexp: RE2 compatible regular expression.
        :param pulumi.Input[str] name: Name for the rule.
        :param pulumi.Input[str] replace: Substitution string for sensitive data. Default value: six asterisks.
        """
        pulumi.set(__self__, "regexp", regexp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        """
        RE2 compatible regular expression.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def replace(self) -> Optional[pulumi.Input[str]]:
        """
        Substitution string for sensitive data. Default value: six asterisks.
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseConfigRabbitmqArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        RabbitMQ user password.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        RabbitMQ username.
        """
        vhost: NotRequired[pulumi.Input[str]]
        """
        RabbitMQ vhost. Default: '\\'.
        """
elif False:
    MdbClickhouseClusterClickhouseConfigRabbitmqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseConfigRabbitmqArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 vhost: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: RabbitMQ user password.
        :param pulumi.Input[str] username: RabbitMQ username.
        :param pulumi.Input[str] vhost: RabbitMQ vhost. Default: '\\'.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        RabbitMQ username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[str]]:
        """
        RabbitMQ vhost. Default: '\\'.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class MdbClickhouseClusterClickhouseResourcesArgsDict(TypedDict):
        disk_size: NotRequired[pulumi.Input[int]]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of hosts.
        """
        resource_preset_id: NotRequired[pulumi.Input[str]]
elif False:
    MdbClickhouseClusterClickhouseResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterClickhouseResourcesArgs:
    def __init__(__self__, *,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type_id: Optional[pulumi.Input[str]] = None,
                 resource_preset_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of hosts.
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbClickhouseClusterCloudStorageArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        data_cache_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enables temporary storage in the cluster repository of data requested from the object repository.
        """
        data_cache_max_size: NotRequired[pulumi.Input[int]]
        """
        Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        """
        move_factor: NotRequired[pulumi.Input[float]]
        """
        Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        """
        prefer_not_to_merge: NotRequired[pulumi.Input[bool]]
        """
        Disables merging of data parts in `Yandex Object Storage`.
        """
elif False:
    MdbClickhouseClusterCloudStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterCloudStorageArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 data_cache_enabled: Optional[pulumi.Input[bool]] = None,
                 data_cache_max_size: Optional[pulumi.Input[int]] = None,
                 move_factor: Optional[pulumi.Input[float]] = None,
                 prefer_not_to_merge: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        :param pulumi.Input[bool] data_cache_enabled: Enables temporary storage in the cluster repository of data requested from the object repository.
        :param pulumi.Input[int] data_cache_max_size: Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        :param pulumi.Input[float] move_factor: Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        :param pulumi.Input[bool] prefer_not_to_merge: Disables merging of data parts in `Yandex Object Storage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if data_cache_enabled is not None:
            pulumi.set(__self__, "data_cache_enabled", data_cache_enabled)
        if data_cache_max_size is not None:
            pulumi.set(__self__, "data_cache_max_size", data_cache_max_size)
        if move_factor is not None:
            pulumi.set(__self__, "move_factor", move_factor)
        if prefer_not_to_merge is not None:
            pulumi.set(__self__, "prefer_not_to_merge", prefer_not_to_merge)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="dataCacheEnabled")
    def data_cache_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables temporary storage in the cluster repository of data requested from the object repository.
        """
        return pulumi.get(self, "data_cache_enabled")

    @data_cache_enabled.setter
    def data_cache_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_cache_enabled", value)

    @property
    @pulumi.getter(name="dataCacheMaxSize")
    def data_cache_max_size(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        """
        return pulumi.get(self, "data_cache_max_size")

    @data_cache_max_size.setter
    def data_cache_max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_cache_max_size", value)

    @property
    @pulumi.getter(name="moveFactor")
    def move_factor(self) -> Optional[pulumi.Input[float]]:
        """
        Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        """
        return pulumi.get(self, "move_factor")

    @move_factor.setter
    def move_factor(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "move_factor", value)

    @property
    @pulumi.getter(name="preferNotToMerge")
    def prefer_not_to_merge(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables merging of data parts in `Yandex Object Storage`.
        """
        return pulumi.get(self, "prefer_not_to_merge")

    @prefer_not_to_merge.setter
    def prefer_not_to_merge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prefer_not_to_merge", value)


if not MYPY:
    class MdbClickhouseClusterDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the database.
        """
elif False:
    MdbClickhouseClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MdbClickhouseClusterFormatSchemaArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the format schema.
        """
        type: pulumi.Input[str]
        """
        Type of the format schema.
        """
        uri: pulumi.Input[str]
        """
        Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
elif False:
    MdbClickhouseClusterFormatSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterFormatSchemaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the format schema.
        :param pulumi.Input[str] type: Type of the format schema.
        :param pulumi.Input[str] uri: Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the format schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the format schema.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class MdbClickhouseClusterHostArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        """
        zone: pulumi.Input[str]
        """
        The availability zone where the ClickHouse host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host.
        """
        shard_name: NotRequired[pulumi.Input[str]]
        """
        The name of the shard to which the host belongs.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
elif False:
    MdbClickhouseClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterHostArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 shard_name: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        :param pulumi.Input[str] zone: The availability zone where the ClickHouse host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param pulumi.Input[bool] assign_public_ip: Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        :param pulumi.Input[str] fqdn: The fully qualified domain name of the host.
        :param pulumi.Input[str] shard_name: The name of the shard to which the host belongs.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        The availability zone where the ClickHouse host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @shard_name.setter
    def shard_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shard_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MdbClickhouseClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
elif False:
    MdbClickhouseClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param pulumi.Input[int] hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbClickhouseClusterMlModelArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the ml model.
        """
        type: pulumi.Input[str]
        """
        Type of the model.
        """
        uri: pulumi.Input[str]
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
elif False:
    MdbClickhouseClusterMlModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterMlModelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the ml model.
        :param pulumi.Input[str] type: Type of the model.
        :param pulumi.Input[str] uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the ml model.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the model.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class MdbClickhouseClusterShardArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of shard.
        """
        resources: NotRequired[pulumi.Input['MdbClickhouseClusterShardResourcesArgsDict']]
        """
        Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        The weight of shard.
        """
elif False:
    MdbClickhouseClusterShardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterShardArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resources: Optional[pulumi.Input['MdbClickhouseClusterShardResourcesArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name of shard.
        :param pulumi.Input['MdbClickhouseClusterShardResourcesArgs'] resources: Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        :param pulumi.Input[int] weight: The weight of shard.
        """
        pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of shard.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MdbClickhouseClusterShardResourcesArgs']]:
        """
        Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MdbClickhouseClusterShardResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The weight of shard.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class MdbClickhouseClusterShardGroupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the shard group, used as cluster name in Distributed tables.
        """
        shard_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of shards names that belong to the shard group.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the shard group.
        """
elif False:
    MdbClickhouseClusterShardGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterShardGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 shard_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the shard group, used as cluster name in Distributed tables.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shard_names: List of shards names that belong to the shard group.
        :param pulumi.Input[str] description: Description of the shard group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "shard_names", shard_names)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the shard group, used as cluster name in Distributed tables.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shardNames")
    def shard_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of shards names that belong to the shard group.
        """
        return pulumi.get(self, "shard_names")

    @shard_names.setter
    def shard_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "shard_names", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the shard group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class MdbClickhouseClusterShardResourcesArgsDict(TypedDict):
        disk_size: NotRequired[pulumi.Input[int]]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of hosts.
        """
        resource_preset_id: NotRequired[pulumi.Input[str]]
elif False:
    MdbClickhouseClusterShardResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterShardResourcesArgs:
    def __init__(__self__, *,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type_id: Optional[pulumi.Input[str]] = None,
                 resource_preset_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of hosts.
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbClickhouseClusterUserArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the user.
        """
        password: pulumi.Input[str]
        """
        The password of the user.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserPermissionArgsDict']]]]
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        quotas: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserQuotaArgsDict']]]]
        """
        Set of user quotas. The structure is documented below.
        """
        settings: NotRequired[pulumi.Input['MdbClickhouseClusterUserSettingsArgsDict']]
        """
        Custom settings for user. The list is documented below.
        """
elif False:
    MdbClickhouseClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserPermissionArgs']]]] = None,
                 quotas: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserQuotaArgs']]]] = None,
                 settings: Optional[pulumi.Input['MdbClickhouseClusterUserSettingsArgs']] = None):
        """
        :param pulumi.Input[str] name: The name of the user.
        :param pulumi.Input[str] password: The password of the user.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserPermissionArgs']]] permissions: Set of permissions granted to the user. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserQuotaArgs']]] quotas: Set of user quotas. The structure is documented below.
        :param pulumi.Input['MdbClickhouseClusterUserSettingsArgs'] settings: Custom settings for user. The list is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if quotas is not None:
            pulumi.set(__self__, "quotas", quotas)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserPermissionArgs']]]]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def quotas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserQuotaArgs']]]]:
        """
        Set of user quotas. The structure is documented below.
        """
        return pulumi.get(self, "quotas")

    @quotas.setter
    def quotas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbClickhouseClusterUserQuotaArgs']]]]):
        pulumi.set(self, "quotas", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['MdbClickhouseClusterUserSettingsArgs']]:
        """
        Custom settings for user. The list is documented below.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['MdbClickhouseClusterUserSettingsArgs']]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class MdbClickhouseClusterUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database that the permission grants access to.
        """
elif False:
    MdbClickhouseClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class MdbClickhouseClusterUserQuotaArgsDict(TypedDict):
        interval_duration: pulumi.Input[int]
        """
        Duration of interval for quota in milliseconds.
        """
        errors: NotRequired[pulumi.Input[int]]
        """
        The number of queries that threw exception.
        """
        execution_time: NotRequired[pulumi.Input[int]]
        """
        The total query execution time, in milliseconds (wall time).
        """
        queries: NotRequired[pulumi.Input[int]]
        """
        The total number of queries.
        """
        read_rows: NotRequired[pulumi.Input[int]]
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        result_rows: NotRequired[pulumi.Input[int]]
        """
        The total number of rows given as the result.
        """
elif False:
    MdbClickhouseClusterUserQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterUserQuotaArgs:
    def __init__(__self__, *,
                 interval_duration: pulumi.Input[int],
                 errors: Optional[pulumi.Input[int]] = None,
                 execution_time: Optional[pulumi.Input[int]] = None,
                 queries: Optional[pulumi.Input[int]] = None,
                 read_rows: Optional[pulumi.Input[int]] = None,
                 result_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] interval_duration: Duration of interval for quota in milliseconds.
        :param pulumi.Input[int] errors: The number of queries that threw exception.
        :param pulumi.Input[int] execution_time: The total query execution time, in milliseconds (wall time).
        :param pulumi.Input[int] queries: The total number of queries.
        :param pulumi.Input[int] read_rows: The total number of source rows read from tables for running the query, on all remote servers.
        :param pulumi.Input[int] result_rows: The total number of rows given as the result.
        """
        pulumi.set(__self__, "interval_duration", interval_duration)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if execution_time is not None:
            pulumi.set(__self__, "execution_time", execution_time)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if read_rows is not None:
            pulumi.set(__self__, "read_rows", read_rows)
        if result_rows is not None:
            pulumi.set(__self__, "result_rows", result_rows)

    @property
    @pulumi.getter(name="intervalDuration")
    def interval_duration(self) -> pulumi.Input[int]:
        """
        Duration of interval for quota in milliseconds.
        """
        return pulumi.get(self, "interval_duration")

    @interval_duration.setter
    def interval_duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_duration", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[int]]:
        """
        The number of queries that threw exception.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> Optional[pulumi.Input[int]]:
        """
        The total query execution time, in milliseconds (wall time).
        """
        return pulumi.get(self, "execution_time")

    @execution_time.setter
    def execution_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "execution_time", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of queries.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="readRows")
    def read_rows(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        return pulumi.get(self, "read_rows")

    @read_rows.setter
    def read_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_rows", value)

    @property
    @pulumi.getter(name="resultRows")
    def result_rows(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of rows given as the result.
        """
        return pulumi.get(self, "result_rows")

    @result_rows.setter
    def result_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "result_rows", value)


if not MYPY:
    class MdbClickhouseClusterUserSettingsArgsDict(TypedDict):
        add_http_cors_header: NotRequired[pulumi.Input[bool]]
        """
        Include CORS headers in HTTP responces.
        """
        allow_ddl: NotRequired[pulumi.Input[bool]]
        """
        Allows or denies DDL queries.
        """
        allow_introspection_functions: NotRequired[pulumi.Input[bool]]
        """
        Enables introspections functions for query profiling.
        """
        allow_suspicious_low_cardinality_types: NotRequired[pulumi.Input[bool]]
        """
        Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        """
        any_join_distinct_right_table_keys: NotRequired[pulumi.Input[bool]]
        """
        enables legacy ClickHouse server behaviour in ANY INNER|LEFT JOIN operations.
        """
        async_insert: NotRequired[pulumi.Input[bool]]
        """
        Enables asynchronous inserts. Disabled by default.
        """
        async_insert_busy_timeout: NotRequired[pulumi.Input[int]]
        """
        The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        """
        async_insert_max_data_size: NotRequired[pulumi.Input[int]]
        """
        The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        """
        async_insert_stale_timeout: NotRequired[pulumi.Input[int]]
        """
        The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        """
        async_insert_threads: NotRequired[pulumi.Input[int]]
        """
        The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        """
        cancel_http_readonly_queries_on_client_close: NotRequired[pulumi.Input[bool]]
        """
        Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        """
        compile: NotRequired[pulumi.Input[bool]]
        """
        Enable compilation of queries.
        """
        compile_expressions: NotRequired[pulumi.Input[bool]]
        """
        Turn on expression compilation.
        """
        connect_timeout: NotRequired[pulumi.Input[int]]
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        connect_timeout_with_failover: NotRequired[pulumi.Input[int]]
        """
        The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        """
        count_distinct_implementation: NotRequired[pulumi.Input[str]]
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        """
        date_time_input_format: NotRequired[pulumi.Input[str]]
        """
        Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        """
        date_time_output_format: NotRequired[pulumi.Input[str]]
        """
        Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        """
        deduplicate_blocks_in_dependent_materialized_views: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the deduplication check for materialized views that receive data from Replicated* tables.
        """
        distinct_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow when using DISTINCT. Possible values:
        """
        distributed_aggregation_memory_efficient: NotRequired[pulumi.Input[bool]]
        """
        Determine the behavior of distributed subqueries.
        """
        distributed_ddl_task_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for DDL queries, in milliseconds.
        """
        distributed_product_mode: NotRequired[pulumi.Input[str]]
        """
        Changes the behaviour of distributed subqueries.
        """
        empty_result_for_aggregation_by_empty_set: NotRequired[pulumi.Input[bool]]
        """
        Allows to retunr empty result.
        """
        enable_http_compression: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        fallback_to_stale_replicas_for_distributed_queries: NotRequired[pulumi.Input[bool]]
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        flatten_nested: NotRequired[pulumi.Input[bool]]
        """
        Sets the data format of a nested columns.
        """
        force_index_by_date: NotRequired[pulumi.Input[bool]]
        """
        Disables query execution if the index cant be used by date.
        """
        force_primary_key: NotRequired[pulumi.Input[bool]]
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        format_regexp: NotRequired[pulumi.Input[str]]
        """
        Regular expression (for Regexp format).
        """
        format_regexp_skip_unmatched: NotRequired[pulumi.Input[bool]]
        """
        Skip lines unmatched by regular expression.
        """
        group_by_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow while GROUP BY operation. Possible values:
        """
        group_by_two_level_threshold: NotRequired[pulumi.Input[int]]
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        group_by_two_level_threshold_bytes: NotRequired[pulumi.Input[int]]
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        hedged_connection_timeout_ms: NotRequired[pulumi.Input[int]]
        """
        Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        """
        http_connection_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for HTTP connection in milliseconds.
        """
        http_headers_progress_interval: NotRequired[pulumi.Input[int]]
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        http_receive_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for HTTP connection in milliseconds.
        """
        http_send_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for HTTP connection in milliseconds.
        """
        idle_connection_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        """
        input_format_defaults_for_omitted_fields: NotRequired[pulumi.Input[bool]]
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        input_format_import_nested_json: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the insertion of JSON data with nested objects.
        """
        input_format_null_as_default: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        """
        input_format_parallel_parsing: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        """
        input_format_values_interpret_expressions: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        """
        input_format_with_names_use_header: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables checking the column order when inserting data.
        """
        insert_keeper_max_retries: NotRequired[pulumi.Input[int]]
        """
        The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        """
        insert_null_as_default: NotRequired[pulumi.Input[bool]]
        """
        Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        """
        insert_quorum: NotRequired[pulumi.Input[int]]
        """
        Enables the quorum writes.
        """
        insert_quorum_parallel: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables parallelism for quorum INSERT queries.
        """
        insert_quorum_timeout: NotRequired[pulumi.Input[int]]
        """
        Write to a quorum timeout in milliseconds.
        """
        join_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies which JOIN algorithm is used. Possible values:
        """
        join_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow in JOIN. Possible values:
        """
        join_use_nulls: NotRequired[pulumi.Input[bool]]
        """
        Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        joined_subquery_requires_alias: NotRequired[pulumi.Input[bool]]
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        load_balancing: NotRequired[pulumi.Input[str]]
        """
        Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        """
        local_filesystem_read_method: NotRequired[pulumi.Input[str]]
        """
        Method of reading data from local filesystem. Possible values:
        """
        log_query_threads: NotRequired[pulumi.Input[bool]]
        """
        Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: true.
        """
        low_cardinality_allow_in_native_format: NotRequired[pulumi.Input[bool]]
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        max_ast_depth: NotRequired[pulumi.Input[int]]
        """
        Maximum abstract syntax tree depth.
        """
        max_ast_elements: NotRequired[pulumi.Input[int]]
        """
        Maximum abstract syntax tree elements.
        """
        max_block_size: NotRequired[pulumi.Input[int]]
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        max_bytes_before_external_group_by: NotRequired[pulumi.Input[int]]
        """
        Limit in bytes for using memoru for GROUP BY before using swap on disk.
        """
        max_bytes_before_external_sort: NotRequired[pulumi.Input[int]]
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        max_bytes_in_distinct: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        max_bytes_in_join: NotRequired[pulumi.Input[int]]
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        max_bytes_in_set: NotRequired[pulumi.Input[int]]
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        max_bytes_to_read: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        max_bytes_to_sort: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        max_bytes_to_transfer: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        max_columns_to_read: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        max_concurrent_queries_for_user: NotRequired[pulumi.Input[int]]
        """
        The maximum number of concurrent requests per user. Default value: 0 (no limit).
        """
        max_execution_time: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum query execution time in milliseconds.
        """
        max_expanded_ast_elements: NotRequired[pulumi.Input[int]]
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        max_final_threads: NotRequired[pulumi.Input[int]]
        """
        Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        """
        max_http_get_redirects: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        """
        max_insert_block_size: NotRequired[pulumi.Input[int]]
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        max_insert_threads: NotRequired[pulumi.Input[int]]
        """
        The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        """
        max_memory_usage: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        max_memory_usage_for_user: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        max_network_bandwidth: NotRequired[pulumi.Input[int]]
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        max_network_bandwidth_for_user: NotRequired[pulumi.Input[int]]
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        max_parser_depth: NotRequired[pulumi.Input[int]]
        """
        Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        """
        max_query_size: NotRequired[pulumi.Input[int]]
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        max_read_buffer_size: NotRequired[pulumi.Input[int]]
        """
        The maximum size of the buffer to read from the filesystem.
        """
        max_replica_delay_for_distributed_queries: NotRequired[pulumi.Input[int]]
        """
        Disables lagging replicas for distributed queries.
        """
        max_result_bytes: NotRequired[pulumi.Input[int]]
        """
        Limits the number of bytes in the result.
        """
        max_result_rows: NotRequired[pulumi.Input[int]]
        """
        Limits the number of rows in the result.
        """
        max_rows_in_distinct: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        max_rows_in_join: NotRequired[pulumi.Input[int]]
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        max_rows_in_set: NotRequired[pulumi.Input[int]]
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        max_rows_to_group_by: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        max_rows_to_read: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        max_rows_to_sort: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        max_rows_to_transfer: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        max_temporary_columns: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        max_temporary_data_on_disk_size_for_query: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        """
        max_temporary_data_on_disk_size_for_user: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        """
        max_temporary_non_const_columns: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        max_threads: NotRequired[pulumi.Input[int]]
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        memory_overcommit_ratio_denominator: NotRequired[pulumi.Input[int]]
        """
        It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        memory_overcommit_ratio_denominator_for_user: NotRequired[pulumi.Input[int]]
        """
        It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        memory_profiler_sample_probability: NotRequired[pulumi.Input[float]]
        """
        Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        """
        memory_profiler_step: NotRequired[pulumi.Input[int]]
        """
        Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        """
        memory_usage_overcommit_max_wait_microseconds: NotRequired[pulumi.Input[int]]
        """
        Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        """
        merge_tree_max_bytes_to_use_cache: NotRequired[pulumi.Input[int]]
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        """
        merge_tree_max_rows_to_use_cache: NotRequired[pulumi.Input[int]]
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        """
        merge_tree_min_bytes_for_concurrent_read: NotRequired[pulumi.Input[int]]
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        merge_tree_min_rows_for_concurrent_read: NotRequired[pulumi.Input[int]]
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        min_bytes_to_use_direct_io: NotRequired[pulumi.Input[int]]
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        min_count_to_compile: NotRequired[pulumi.Input[int]]
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        min_count_to_compile_expression: NotRequired[pulumi.Input[int]]
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        min_execution_speed: NotRequired[pulumi.Input[int]]
        """
        Minimal execution speed in rows per second.
        """
        min_execution_speed_bytes: NotRequired[pulumi.Input[int]]
        """
        Minimal execution speed in bytes per second.
        """
        min_insert_block_size_bytes: NotRequired[pulumi.Input[int]]
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        min_insert_block_size_rows: NotRequired[pulumi.Input[int]]
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        output_format_json_quote64bit_integers: NotRequired[pulumi.Input[bool]]
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        output_format_json_quote_denormals: NotRequired[pulumi.Input[bool]]
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        prefer_localhost_replica: NotRequired[pulumi.Input[bool]]
        """
        Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Query priority.
        """
        quota_mode: NotRequired[pulumi.Input[str]]
        """
        Quota accounting mode.
        """
        read_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow while read. Possible values:
        """
        readonly: NotRequired[pulumi.Input[int]]
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        receive_timeout: NotRequired[pulumi.Input[int]]
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        remote_filesystem_read_method: NotRequired[pulumi.Input[str]]
        """
        Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        """
        replication_alter_partitions_sync: NotRequired[pulumi.Input[int]]
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        result_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow in result. Possible values:
        """
        select_sequential_consistency: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        send_progress_in_http_headers: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        """
        send_timeout: NotRequired[pulumi.Input[int]]
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        set_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow in the set resulting. Possible values:
        """
        skip_unavailable_shards: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables silently skipping of unavailable shards.
        """
        sort_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow while sort. Possible values:
        """
        timeout_before_checking_execution_speed: NotRequired[pulumi.Input[int]]
        """
        Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        """
        timeout_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow. Possible values:
        """
        transfer_overflow_mode: NotRequired[pulumi.Input[str]]
        """
        Sets behaviour on overflow. Possible values:
        """
        transform_null_in: NotRequired[pulumi.Input[bool]]
        """
        Enables equality of NULL values for IN operator.
        """
        use_hedged_requests: NotRequired[pulumi.Input[bool]]
        """
        Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        """
        use_uncompressed_cache: NotRequired[pulumi.Input[bool]]
        """
        Whether to use a cache of uncompressed blocks.
        """
        wait_for_async_insert: NotRequired[pulumi.Input[bool]]
        """
        Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        """
        wait_for_async_insert_timeout: NotRequired[pulumi.Input[int]]
        """
        The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
elif False:
    MdbClickhouseClusterUserSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterUserSettingsArgs:
    def __init__(__self__, *,
                 add_http_cors_header: Optional[pulumi.Input[bool]] = None,
                 allow_ddl: Optional[pulumi.Input[bool]] = None,
                 allow_introspection_functions: Optional[pulumi.Input[bool]] = None,
                 allow_suspicious_low_cardinality_types: Optional[pulumi.Input[bool]] = None,
                 any_join_distinct_right_table_keys: Optional[pulumi.Input[bool]] = None,
                 async_insert: Optional[pulumi.Input[bool]] = None,
                 async_insert_busy_timeout: Optional[pulumi.Input[int]] = None,
                 async_insert_max_data_size: Optional[pulumi.Input[int]] = None,
                 async_insert_stale_timeout: Optional[pulumi.Input[int]] = None,
                 async_insert_threads: Optional[pulumi.Input[int]] = None,
                 cancel_http_readonly_queries_on_client_close: Optional[pulumi.Input[bool]] = None,
                 compile: Optional[pulumi.Input[bool]] = None,
                 compile_expressions: Optional[pulumi.Input[bool]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 connect_timeout_with_failover: Optional[pulumi.Input[int]] = None,
                 count_distinct_implementation: Optional[pulumi.Input[str]] = None,
                 date_time_input_format: Optional[pulumi.Input[str]] = None,
                 date_time_output_format: Optional[pulumi.Input[str]] = None,
                 deduplicate_blocks_in_dependent_materialized_views: Optional[pulumi.Input[bool]] = None,
                 distinct_overflow_mode: Optional[pulumi.Input[str]] = None,
                 distributed_aggregation_memory_efficient: Optional[pulumi.Input[bool]] = None,
                 distributed_ddl_task_timeout: Optional[pulumi.Input[int]] = None,
                 distributed_product_mode: Optional[pulumi.Input[str]] = None,
                 empty_result_for_aggregation_by_empty_set: Optional[pulumi.Input[bool]] = None,
                 enable_http_compression: Optional[pulumi.Input[bool]] = None,
                 fallback_to_stale_replicas_for_distributed_queries: Optional[pulumi.Input[bool]] = None,
                 flatten_nested: Optional[pulumi.Input[bool]] = None,
                 force_index_by_date: Optional[pulumi.Input[bool]] = None,
                 force_primary_key: Optional[pulumi.Input[bool]] = None,
                 format_regexp: Optional[pulumi.Input[str]] = None,
                 format_regexp_skip_unmatched: Optional[pulumi.Input[bool]] = None,
                 group_by_overflow_mode: Optional[pulumi.Input[str]] = None,
                 group_by_two_level_threshold: Optional[pulumi.Input[int]] = None,
                 group_by_two_level_threshold_bytes: Optional[pulumi.Input[int]] = None,
                 hedged_connection_timeout_ms: Optional[pulumi.Input[int]] = None,
                 http_connection_timeout: Optional[pulumi.Input[int]] = None,
                 http_headers_progress_interval: Optional[pulumi.Input[int]] = None,
                 http_receive_timeout: Optional[pulumi.Input[int]] = None,
                 http_send_timeout: Optional[pulumi.Input[int]] = None,
                 idle_connection_timeout: Optional[pulumi.Input[int]] = None,
                 input_format_defaults_for_omitted_fields: Optional[pulumi.Input[bool]] = None,
                 input_format_import_nested_json: Optional[pulumi.Input[bool]] = None,
                 input_format_null_as_default: Optional[pulumi.Input[bool]] = None,
                 input_format_parallel_parsing: Optional[pulumi.Input[bool]] = None,
                 input_format_values_interpret_expressions: Optional[pulumi.Input[bool]] = None,
                 input_format_with_names_use_header: Optional[pulumi.Input[bool]] = None,
                 insert_keeper_max_retries: Optional[pulumi.Input[int]] = None,
                 insert_null_as_default: Optional[pulumi.Input[bool]] = None,
                 insert_quorum: Optional[pulumi.Input[int]] = None,
                 insert_quorum_parallel: Optional[pulumi.Input[bool]] = None,
                 insert_quorum_timeout: Optional[pulumi.Input[int]] = None,
                 join_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 join_overflow_mode: Optional[pulumi.Input[str]] = None,
                 join_use_nulls: Optional[pulumi.Input[bool]] = None,
                 joined_subquery_requires_alias: Optional[pulumi.Input[bool]] = None,
                 load_balancing: Optional[pulumi.Input[str]] = None,
                 local_filesystem_read_method: Optional[pulumi.Input[str]] = None,
                 log_query_threads: Optional[pulumi.Input[bool]] = None,
                 low_cardinality_allow_in_native_format: Optional[pulumi.Input[bool]] = None,
                 max_ast_depth: Optional[pulumi.Input[int]] = None,
                 max_ast_elements: Optional[pulumi.Input[int]] = None,
                 max_block_size: Optional[pulumi.Input[int]] = None,
                 max_bytes_before_external_group_by: Optional[pulumi.Input[int]] = None,
                 max_bytes_before_external_sort: Optional[pulumi.Input[int]] = None,
                 max_bytes_in_distinct: Optional[pulumi.Input[int]] = None,
                 max_bytes_in_join: Optional[pulumi.Input[int]] = None,
                 max_bytes_in_set: Optional[pulumi.Input[int]] = None,
                 max_bytes_to_read: Optional[pulumi.Input[int]] = None,
                 max_bytes_to_sort: Optional[pulumi.Input[int]] = None,
                 max_bytes_to_transfer: Optional[pulumi.Input[int]] = None,
                 max_columns_to_read: Optional[pulumi.Input[int]] = None,
                 max_concurrent_queries_for_user: Optional[pulumi.Input[int]] = None,
                 max_execution_time: Optional[pulumi.Input[int]] = None,
                 max_expanded_ast_elements: Optional[pulumi.Input[int]] = None,
                 max_final_threads: Optional[pulumi.Input[int]] = None,
                 max_http_get_redirects: Optional[pulumi.Input[int]] = None,
                 max_insert_block_size: Optional[pulumi.Input[int]] = None,
                 max_insert_threads: Optional[pulumi.Input[int]] = None,
                 max_memory_usage: Optional[pulumi.Input[int]] = None,
                 max_memory_usage_for_user: Optional[pulumi.Input[int]] = None,
                 max_network_bandwidth: Optional[pulumi.Input[int]] = None,
                 max_network_bandwidth_for_user: Optional[pulumi.Input[int]] = None,
                 max_parser_depth: Optional[pulumi.Input[int]] = None,
                 max_query_size: Optional[pulumi.Input[int]] = None,
                 max_read_buffer_size: Optional[pulumi.Input[int]] = None,
                 max_replica_delay_for_distributed_queries: Optional[pulumi.Input[int]] = None,
                 max_result_bytes: Optional[pulumi.Input[int]] = None,
                 max_result_rows: Optional[pulumi.Input[int]] = None,
                 max_rows_in_distinct: Optional[pulumi.Input[int]] = None,
                 max_rows_in_join: Optional[pulumi.Input[int]] = None,
                 max_rows_in_set: Optional[pulumi.Input[int]] = None,
                 max_rows_to_group_by: Optional[pulumi.Input[int]] = None,
                 max_rows_to_read: Optional[pulumi.Input[int]] = None,
                 max_rows_to_sort: Optional[pulumi.Input[int]] = None,
                 max_rows_to_transfer: Optional[pulumi.Input[int]] = None,
                 max_temporary_columns: Optional[pulumi.Input[int]] = None,
                 max_temporary_data_on_disk_size_for_query: Optional[pulumi.Input[int]] = None,
                 max_temporary_data_on_disk_size_for_user: Optional[pulumi.Input[int]] = None,
                 max_temporary_non_const_columns: Optional[pulumi.Input[int]] = None,
                 max_threads: Optional[pulumi.Input[int]] = None,
                 memory_overcommit_ratio_denominator: Optional[pulumi.Input[int]] = None,
                 memory_overcommit_ratio_denominator_for_user: Optional[pulumi.Input[int]] = None,
                 memory_profiler_sample_probability: Optional[pulumi.Input[float]] = None,
                 memory_profiler_step: Optional[pulumi.Input[int]] = None,
                 memory_usage_overcommit_max_wait_microseconds: Optional[pulumi.Input[int]] = None,
                 merge_tree_max_bytes_to_use_cache: Optional[pulumi.Input[int]] = None,
                 merge_tree_max_rows_to_use_cache: Optional[pulumi.Input[int]] = None,
                 merge_tree_min_bytes_for_concurrent_read: Optional[pulumi.Input[int]] = None,
                 merge_tree_min_rows_for_concurrent_read: Optional[pulumi.Input[int]] = None,
                 min_bytes_to_use_direct_io: Optional[pulumi.Input[int]] = None,
                 min_count_to_compile: Optional[pulumi.Input[int]] = None,
                 min_count_to_compile_expression: Optional[pulumi.Input[int]] = None,
                 min_execution_speed: Optional[pulumi.Input[int]] = None,
                 min_execution_speed_bytes: Optional[pulumi.Input[int]] = None,
                 min_insert_block_size_bytes: Optional[pulumi.Input[int]] = None,
                 min_insert_block_size_rows: Optional[pulumi.Input[int]] = None,
                 output_format_json_quote64bit_integers: Optional[pulumi.Input[bool]] = None,
                 output_format_json_quote_denormals: Optional[pulumi.Input[bool]] = None,
                 prefer_localhost_replica: Optional[pulumi.Input[bool]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 quota_mode: Optional[pulumi.Input[str]] = None,
                 read_overflow_mode: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[int]] = None,
                 receive_timeout: Optional[pulumi.Input[int]] = None,
                 remote_filesystem_read_method: Optional[pulumi.Input[str]] = None,
                 replication_alter_partitions_sync: Optional[pulumi.Input[int]] = None,
                 result_overflow_mode: Optional[pulumi.Input[str]] = None,
                 select_sequential_consistency: Optional[pulumi.Input[bool]] = None,
                 send_progress_in_http_headers: Optional[pulumi.Input[bool]] = None,
                 send_timeout: Optional[pulumi.Input[int]] = None,
                 set_overflow_mode: Optional[pulumi.Input[str]] = None,
                 skip_unavailable_shards: Optional[pulumi.Input[bool]] = None,
                 sort_overflow_mode: Optional[pulumi.Input[str]] = None,
                 timeout_before_checking_execution_speed: Optional[pulumi.Input[int]] = None,
                 timeout_overflow_mode: Optional[pulumi.Input[str]] = None,
                 transfer_overflow_mode: Optional[pulumi.Input[str]] = None,
                 transform_null_in: Optional[pulumi.Input[bool]] = None,
                 use_hedged_requests: Optional[pulumi.Input[bool]] = None,
                 use_uncompressed_cache: Optional[pulumi.Input[bool]] = None,
                 wait_for_async_insert: Optional[pulumi.Input[bool]] = None,
                 wait_for_async_insert_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] add_http_cors_header: Include CORS headers in HTTP responces.
        :param pulumi.Input[bool] allow_ddl: Allows or denies DDL queries.
        :param pulumi.Input[bool] allow_introspection_functions: Enables introspections functions for query profiling.
        :param pulumi.Input[bool] allow_suspicious_low_cardinality_types: Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        :param pulumi.Input[bool] any_join_distinct_right_table_keys: enables legacy ClickHouse server behaviour in ANY INNER|LEFT JOIN operations.
        :param pulumi.Input[bool] async_insert: Enables asynchronous inserts. Disabled by default.
        :param pulumi.Input[int] async_insert_busy_timeout: The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        :param pulumi.Input[int] async_insert_max_data_size: The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        :param pulumi.Input[int] async_insert_stale_timeout: The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        :param pulumi.Input[int] async_insert_threads: The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        :param pulumi.Input[bool] cancel_http_readonly_queries_on_client_close: Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        :param pulumi.Input[bool] compile: Enable compilation of queries.
        :param pulumi.Input[bool] compile_expressions: Turn on expression compilation.
        :param pulumi.Input[int] connect_timeout: Connect timeout in milliseconds on the socket used for communicating with the client.
        :param pulumi.Input[int] connect_timeout_with_failover: The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        :param pulumi.Input[str] count_distinct_implementation: Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        :param pulumi.Input[str] date_time_input_format: Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        :param pulumi.Input[str] date_time_output_format: Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        :param pulumi.Input[bool] deduplicate_blocks_in_dependent_materialized_views: Enables or disables the deduplication check for materialized views that receive data from Replicated* tables.
        :param pulumi.Input[str] distinct_overflow_mode: Sets behaviour on overflow when using DISTINCT. Possible values:
        :param pulumi.Input[bool] distributed_aggregation_memory_efficient: Determine the behavior of distributed subqueries.
        :param pulumi.Input[int] distributed_ddl_task_timeout: Timeout for DDL queries, in milliseconds.
        :param pulumi.Input[str] distributed_product_mode: Changes the behaviour of distributed subqueries.
        :param pulumi.Input[bool] empty_result_for_aggregation_by_empty_set: Allows to retunr empty result.
        :param pulumi.Input[bool] enable_http_compression: Enables or disables data compression in the response to an HTTP request.
        :param pulumi.Input[bool] fallback_to_stale_replicas_for_distributed_queries: Forces a query to an out-of-date replica if updated data is not available.
        :param pulumi.Input[bool] flatten_nested: Sets the data format of a nested columns.
        :param pulumi.Input[bool] force_index_by_date: Disables query execution if the index cant be used by date.
        :param pulumi.Input[bool] force_primary_key: Disables query execution if indexing by the primary key is not possible.
        :param pulumi.Input[str] format_regexp: Regular expression (for Regexp format).
        :param pulumi.Input[bool] format_regexp_skip_unmatched: Skip lines unmatched by regular expression.
        :param pulumi.Input[str] group_by_overflow_mode: Sets behaviour on overflow while GROUP BY operation. Possible values:
        :param pulumi.Input[int] group_by_two_level_threshold: Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        :param pulumi.Input[int] group_by_two_level_threshold_bytes: Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        :param pulumi.Input[int] hedged_connection_timeout_ms: Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        :param pulumi.Input[int] http_connection_timeout: Timeout for HTTP connection in milliseconds.
        :param pulumi.Input[int] http_headers_progress_interval: Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        :param pulumi.Input[int] http_receive_timeout: Timeout for HTTP connection in milliseconds.
        :param pulumi.Input[int] http_send_timeout: Timeout for HTTP connection in milliseconds.
        :param pulumi.Input[int] idle_connection_timeout: Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        :param pulumi.Input[bool] input_format_defaults_for_omitted_fields: When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        :param pulumi.Input[bool] input_format_import_nested_json: Enables or disables the insertion of JSON data with nested objects.
        :param pulumi.Input[bool] input_format_null_as_default: Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        :param pulumi.Input[bool] input_format_parallel_parsing: Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        :param pulumi.Input[bool] input_format_values_interpret_expressions: Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        :param pulumi.Input[bool] input_format_with_names_use_header: Enables or disables checking the column order when inserting data.
        :param pulumi.Input[int] insert_keeper_max_retries: The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        :param pulumi.Input[bool] insert_null_as_default: Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        :param pulumi.Input[int] insert_quorum: Enables the quorum writes.
        :param pulumi.Input[bool] insert_quorum_parallel: Enables or disables parallelism for quorum INSERT queries.
        :param pulumi.Input[int] insert_quorum_timeout: Write to a quorum timeout in milliseconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] join_algorithms: Specifies which JOIN algorithm is used. Possible values:
        :param pulumi.Input[str] join_overflow_mode: Sets behaviour on overflow in JOIN. Possible values:
        :param pulumi.Input[bool] join_use_nulls: Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        :param pulumi.Input[bool] joined_subquery_requires_alias: Require aliases for subselects and table functions in FROM that more than one table is present.
        :param pulumi.Input[str] load_balancing: Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        :param pulumi.Input[str] local_filesystem_read_method: Method of reading data from local filesystem. Possible values:
        :param pulumi.Input[bool] log_query_threads: Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: true.
        :param pulumi.Input[bool] low_cardinality_allow_in_native_format: Allows or restricts using the LowCardinality data type with the Native format.
        :param pulumi.Input[int] max_ast_depth: Maximum abstract syntax tree depth.
        :param pulumi.Input[int] max_ast_elements: Maximum abstract syntax tree elements.
        :param pulumi.Input[int] max_block_size: A recommendation for what size of the block (in a count of rows) to load from tables.
        :param pulumi.Input[int] max_bytes_before_external_group_by: Limit in bytes for using memoru for GROUP BY before using swap on disk.
        :param pulumi.Input[int] max_bytes_before_external_sort: This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        :param pulumi.Input[int] max_bytes_in_distinct: Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        :param pulumi.Input[int] max_bytes_in_join: Limit on maximum size of the hash table for JOIN, in bytes.
        :param pulumi.Input[int] max_bytes_in_set: Limit on the number of bytes in the set resulting from the execution of the IN section.
        :param pulumi.Input[int] max_bytes_to_read: Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        :param pulumi.Input[int] max_bytes_to_sort: Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        :param pulumi.Input[int] max_bytes_to_transfer: Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param pulumi.Input[int] max_columns_to_read: Limits the maximum number of columns that can be read from a table in a single query.
        :param pulumi.Input[int] max_concurrent_queries_for_user: The maximum number of concurrent requests per user. Default value: 0 (no limit).
        :param pulumi.Input[int] max_execution_time: Limits the maximum query execution time in milliseconds.
        :param pulumi.Input[int] max_expanded_ast_elements: Maximum abstract syntax tree depth after after expansion of aliases.
        :param pulumi.Input[int] max_final_threads: Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        :param pulumi.Input[int] max_http_get_redirects: Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        :param pulumi.Input[int] max_insert_block_size: The size of blocks (in a count of rows) to form for insertion into a table.
        :param pulumi.Input[int] max_insert_threads: The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        :param pulumi.Input[int] max_memory_usage: Limits the maximum memory usage (in bytes) for processing queries on a single server.
        :param pulumi.Input[int] max_memory_usage_for_user: Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        :param pulumi.Input[int] max_network_bandwidth: Limits the speed of the data exchange over the network in bytes per second.
        :param pulumi.Input[int] max_network_bandwidth_for_user: Limits the speed of the data exchange over the network in bytes per second.
        :param pulumi.Input[int] max_parser_depth: Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        :param pulumi.Input[int] max_query_size: The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        :param pulumi.Input[int] max_read_buffer_size: The maximum size of the buffer to read from the filesystem.
        :param pulumi.Input[int] max_replica_delay_for_distributed_queries: Disables lagging replicas for distributed queries.
        :param pulumi.Input[int] max_result_bytes: Limits the number of bytes in the result.
        :param pulumi.Input[int] max_result_rows: Limits the number of rows in the result.
        :param pulumi.Input[int] max_rows_in_distinct: Limits the maximum number of different rows when using DISTINCT.
        :param pulumi.Input[int] max_rows_in_join: Limit on maximum size of the hash table for JOIN, in rows.
        :param pulumi.Input[int] max_rows_in_set: Limit on the number of rows in the set resulting from the execution of the IN section.
        :param pulumi.Input[int] max_rows_to_group_by: Limits the maximum number of unique keys received from aggregation function.
        :param pulumi.Input[int] max_rows_to_read: Limits the maximum number of rows that can be read from a table when running a query.
        :param pulumi.Input[int] max_rows_to_sort: Limits the maximum number of rows that can be read from a table for sorting.
        :param pulumi.Input[int] max_rows_to_transfer: Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param pulumi.Input[int] max_temporary_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        :param pulumi.Input[int] max_temporary_data_on_disk_size_for_query: The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        :param pulumi.Input[int] max_temporary_data_on_disk_size_for_user: The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        :param pulumi.Input[int] max_temporary_non_const_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        :param pulumi.Input[int] max_threads: The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        :param pulumi.Input[int] memory_overcommit_ratio_denominator: It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param pulumi.Input[int] memory_overcommit_ratio_denominator_for_user: It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param pulumi.Input[float] memory_profiler_sample_probability: Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        :param pulumi.Input[int] memory_profiler_step: Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        :param pulumi.Input[int] memory_usage_overcommit_max_wait_microseconds: Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        :param pulumi.Input[int] merge_tree_max_bytes_to_use_cache: If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        :param pulumi.Input[int] merge_tree_max_rows_to_use_cache: If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        :param pulumi.Input[int] merge_tree_min_bytes_for_concurrent_read: If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        :param pulumi.Input[int] merge_tree_min_rows_for_concurrent_read: If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        :param pulumi.Input[int] min_bytes_to_use_direct_io: The minimum data volume required for using direct I/O access to the storage disk.
        :param pulumi.Input[int] min_count_to_compile: How many times to potentially use a compiled chunk of code before running compilation.
        :param pulumi.Input[int] min_count_to_compile_expression: A query waits for expression compilation process to complete prior to continuing execution.
        :param pulumi.Input[int] min_execution_speed: Minimal execution speed in rows per second.
        :param pulumi.Input[int] min_execution_speed_bytes: Minimal execution speed in bytes per second.
        :param pulumi.Input[int] min_insert_block_size_bytes: Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        :param pulumi.Input[int] min_insert_block_size_rows: Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        :param pulumi.Input[bool] output_format_json_quote64bit_integers: If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        :param pulumi.Input[bool] output_format_json_quote_denormals: Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        :param pulumi.Input[bool] prefer_localhost_replica: Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        :param pulumi.Input[int] priority: Query priority.
        :param pulumi.Input[str] quota_mode: Quota accounting mode.
        :param pulumi.Input[str] read_overflow_mode: Sets behaviour on overflow while read. Possible values:
        :param pulumi.Input[int] readonly: Restricts permissions for reading data, write data and change settings queries.
        :param pulumi.Input[int] receive_timeout: Receive timeout in milliseconds on the socket used for communicating with the client.
        :param pulumi.Input[str] remote_filesystem_read_method: Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        :param pulumi.Input[int] replication_alter_partitions_sync: For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        :param pulumi.Input[str] result_overflow_mode: Sets behaviour on overflow in result. Possible values:
        :param pulumi.Input[bool] select_sequential_consistency: Enables or disables sequential consistency for SELECT queries.
        :param pulumi.Input[bool] send_progress_in_http_headers: Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        :param pulumi.Input[int] send_timeout: Send timeout in milliseconds on the socket used for communicating with the client.
        :param pulumi.Input[str] set_overflow_mode: Sets behaviour on overflow in the set resulting. Possible values:
        :param pulumi.Input[bool] skip_unavailable_shards: Enables or disables silently skipping of unavailable shards.
        :param pulumi.Input[str] sort_overflow_mode: Sets behaviour on overflow while sort. Possible values:
        :param pulumi.Input[int] timeout_before_checking_execution_speed: Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        :param pulumi.Input[str] timeout_overflow_mode: Sets behaviour on overflow. Possible values:
        :param pulumi.Input[str] transfer_overflow_mode: Sets behaviour on overflow. Possible values:
        :param pulumi.Input[bool] transform_null_in: Enables equality of NULL values for IN operator.
        :param pulumi.Input[bool] use_hedged_requests: Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        :param pulumi.Input[bool] use_uncompressed_cache: Whether to use a cache of uncompressed blocks.
        :param pulumi.Input[bool] wait_for_async_insert: Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        :param pulumi.Input[int] wait_for_async_insert_timeout: The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        if add_http_cors_header is not None:
            pulumi.set(__self__, "add_http_cors_header", add_http_cors_header)
        if allow_ddl is not None:
            pulumi.set(__self__, "allow_ddl", allow_ddl)
        if allow_introspection_functions is not None:
            pulumi.set(__self__, "allow_introspection_functions", allow_introspection_functions)
        if allow_suspicious_low_cardinality_types is not None:
            pulumi.set(__self__, "allow_suspicious_low_cardinality_types", allow_suspicious_low_cardinality_types)
        if any_join_distinct_right_table_keys is not None:
            pulumi.set(__self__, "any_join_distinct_right_table_keys", any_join_distinct_right_table_keys)
        if async_insert is not None:
            pulumi.set(__self__, "async_insert", async_insert)
        if async_insert_busy_timeout is not None:
            pulumi.set(__self__, "async_insert_busy_timeout", async_insert_busy_timeout)
        if async_insert_max_data_size is not None:
            pulumi.set(__self__, "async_insert_max_data_size", async_insert_max_data_size)
        if async_insert_stale_timeout is not None:
            pulumi.set(__self__, "async_insert_stale_timeout", async_insert_stale_timeout)
        if async_insert_threads is not None:
            pulumi.set(__self__, "async_insert_threads", async_insert_threads)
        if cancel_http_readonly_queries_on_client_close is not None:
            pulumi.set(__self__, "cancel_http_readonly_queries_on_client_close", cancel_http_readonly_queries_on_client_close)
        if compile is not None:
            pulumi.set(__self__, "compile", compile)
        if compile_expressions is not None:
            pulumi.set(__self__, "compile_expressions", compile_expressions)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if connect_timeout_with_failover is not None:
            pulumi.set(__self__, "connect_timeout_with_failover", connect_timeout_with_failover)
        if count_distinct_implementation is not None:
            pulumi.set(__self__, "count_distinct_implementation", count_distinct_implementation)
        if date_time_input_format is not None:
            pulumi.set(__self__, "date_time_input_format", date_time_input_format)
        if date_time_output_format is not None:
            pulumi.set(__self__, "date_time_output_format", date_time_output_format)
        if deduplicate_blocks_in_dependent_materialized_views is not None:
            pulumi.set(__self__, "deduplicate_blocks_in_dependent_materialized_views", deduplicate_blocks_in_dependent_materialized_views)
        if distinct_overflow_mode is not None:
            pulumi.set(__self__, "distinct_overflow_mode", distinct_overflow_mode)
        if distributed_aggregation_memory_efficient is not None:
            pulumi.set(__self__, "distributed_aggregation_memory_efficient", distributed_aggregation_memory_efficient)
        if distributed_ddl_task_timeout is not None:
            pulumi.set(__self__, "distributed_ddl_task_timeout", distributed_ddl_task_timeout)
        if distributed_product_mode is not None:
            pulumi.set(__self__, "distributed_product_mode", distributed_product_mode)
        if empty_result_for_aggregation_by_empty_set is not None:
            pulumi.set(__self__, "empty_result_for_aggregation_by_empty_set", empty_result_for_aggregation_by_empty_set)
        if enable_http_compression is not None:
            pulumi.set(__self__, "enable_http_compression", enable_http_compression)
        if fallback_to_stale_replicas_for_distributed_queries is not None:
            pulumi.set(__self__, "fallback_to_stale_replicas_for_distributed_queries", fallback_to_stale_replicas_for_distributed_queries)
        if flatten_nested is not None:
            pulumi.set(__self__, "flatten_nested", flatten_nested)
        if force_index_by_date is not None:
            pulumi.set(__self__, "force_index_by_date", force_index_by_date)
        if force_primary_key is not None:
            pulumi.set(__self__, "force_primary_key", force_primary_key)
        if format_regexp is not None:
            pulumi.set(__self__, "format_regexp", format_regexp)
        if format_regexp_skip_unmatched is not None:
            pulumi.set(__self__, "format_regexp_skip_unmatched", format_regexp_skip_unmatched)
        if group_by_overflow_mode is not None:
            pulumi.set(__self__, "group_by_overflow_mode", group_by_overflow_mode)
        if group_by_two_level_threshold is not None:
            pulumi.set(__self__, "group_by_two_level_threshold", group_by_two_level_threshold)
        if group_by_two_level_threshold_bytes is not None:
            pulumi.set(__self__, "group_by_two_level_threshold_bytes", group_by_two_level_threshold_bytes)
        if hedged_connection_timeout_ms is not None:
            pulumi.set(__self__, "hedged_connection_timeout_ms", hedged_connection_timeout_ms)
        if http_connection_timeout is not None:
            pulumi.set(__self__, "http_connection_timeout", http_connection_timeout)
        if http_headers_progress_interval is not None:
            pulumi.set(__self__, "http_headers_progress_interval", http_headers_progress_interval)
        if http_receive_timeout is not None:
            pulumi.set(__self__, "http_receive_timeout", http_receive_timeout)
        if http_send_timeout is not None:
            pulumi.set(__self__, "http_send_timeout", http_send_timeout)
        if idle_connection_timeout is not None:
            pulumi.set(__self__, "idle_connection_timeout", idle_connection_timeout)
        if input_format_defaults_for_omitted_fields is not None:
            pulumi.set(__self__, "input_format_defaults_for_omitted_fields", input_format_defaults_for_omitted_fields)
        if input_format_import_nested_json is not None:
            pulumi.set(__self__, "input_format_import_nested_json", input_format_import_nested_json)
        if input_format_null_as_default is not None:
            pulumi.set(__self__, "input_format_null_as_default", input_format_null_as_default)
        if input_format_parallel_parsing is not None:
            pulumi.set(__self__, "input_format_parallel_parsing", input_format_parallel_parsing)
        if input_format_values_interpret_expressions is not None:
            pulumi.set(__self__, "input_format_values_interpret_expressions", input_format_values_interpret_expressions)
        if input_format_with_names_use_header is not None:
            pulumi.set(__self__, "input_format_with_names_use_header", input_format_with_names_use_header)
        if insert_keeper_max_retries is not None:
            pulumi.set(__self__, "insert_keeper_max_retries", insert_keeper_max_retries)
        if insert_null_as_default is not None:
            pulumi.set(__self__, "insert_null_as_default", insert_null_as_default)
        if insert_quorum is not None:
            pulumi.set(__self__, "insert_quorum", insert_quorum)
        if insert_quorum_parallel is not None:
            pulumi.set(__self__, "insert_quorum_parallel", insert_quorum_parallel)
        if insert_quorum_timeout is not None:
            pulumi.set(__self__, "insert_quorum_timeout", insert_quorum_timeout)
        if join_algorithms is not None:
            pulumi.set(__self__, "join_algorithms", join_algorithms)
        if join_overflow_mode is not None:
            pulumi.set(__self__, "join_overflow_mode", join_overflow_mode)
        if join_use_nulls is not None:
            pulumi.set(__self__, "join_use_nulls", join_use_nulls)
        if joined_subquery_requires_alias is not None:
            pulumi.set(__self__, "joined_subquery_requires_alias", joined_subquery_requires_alias)
        if load_balancing is not None:
            pulumi.set(__self__, "load_balancing", load_balancing)
        if local_filesystem_read_method is not None:
            pulumi.set(__self__, "local_filesystem_read_method", local_filesystem_read_method)
        if log_query_threads is not None:
            pulumi.set(__self__, "log_query_threads", log_query_threads)
        if low_cardinality_allow_in_native_format is not None:
            pulumi.set(__self__, "low_cardinality_allow_in_native_format", low_cardinality_allow_in_native_format)
        if max_ast_depth is not None:
            pulumi.set(__self__, "max_ast_depth", max_ast_depth)
        if max_ast_elements is not None:
            pulumi.set(__self__, "max_ast_elements", max_ast_elements)
        if max_block_size is not None:
            pulumi.set(__self__, "max_block_size", max_block_size)
        if max_bytes_before_external_group_by is not None:
            pulumi.set(__self__, "max_bytes_before_external_group_by", max_bytes_before_external_group_by)
        if max_bytes_before_external_sort is not None:
            pulumi.set(__self__, "max_bytes_before_external_sort", max_bytes_before_external_sort)
        if max_bytes_in_distinct is not None:
            pulumi.set(__self__, "max_bytes_in_distinct", max_bytes_in_distinct)
        if max_bytes_in_join is not None:
            pulumi.set(__self__, "max_bytes_in_join", max_bytes_in_join)
        if max_bytes_in_set is not None:
            pulumi.set(__self__, "max_bytes_in_set", max_bytes_in_set)
        if max_bytes_to_read is not None:
            pulumi.set(__self__, "max_bytes_to_read", max_bytes_to_read)
        if max_bytes_to_sort is not None:
            pulumi.set(__self__, "max_bytes_to_sort", max_bytes_to_sort)
        if max_bytes_to_transfer is not None:
            pulumi.set(__self__, "max_bytes_to_transfer", max_bytes_to_transfer)
        if max_columns_to_read is not None:
            pulumi.set(__self__, "max_columns_to_read", max_columns_to_read)
        if max_concurrent_queries_for_user is not None:
            pulumi.set(__self__, "max_concurrent_queries_for_user", max_concurrent_queries_for_user)
        if max_execution_time is not None:
            pulumi.set(__self__, "max_execution_time", max_execution_time)
        if max_expanded_ast_elements is not None:
            pulumi.set(__self__, "max_expanded_ast_elements", max_expanded_ast_elements)
        if max_final_threads is not None:
            pulumi.set(__self__, "max_final_threads", max_final_threads)
        if max_http_get_redirects is not None:
            pulumi.set(__self__, "max_http_get_redirects", max_http_get_redirects)
        if max_insert_block_size is not None:
            pulumi.set(__self__, "max_insert_block_size", max_insert_block_size)
        if max_insert_threads is not None:
            pulumi.set(__self__, "max_insert_threads", max_insert_threads)
        if max_memory_usage is not None:
            pulumi.set(__self__, "max_memory_usage", max_memory_usage)
        if max_memory_usage_for_user is not None:
            pulumi.set(__self__, "max_memory_usage_for_user", max_memory_usage_for_user)
        if max_network_bandwidth is not None:
            pulumi.set(__self__, "max_network_bandwidth", max_network_bandwidth)
        if max_network_bandwidth_for_user is not None:
            pulumi.set(__self__, "max_network_bandwidth_for_user", max_network_bandwidth_for_user)
        if max_parser_depth is not None:
            pulumi.set(__self__, "max_parser_depth", max_parser_depth)
        if max_query_size is not None:
            pulumi.set(__self__, "max_query_size", max_query_size)
        if max_read_buffer_size is not None:
            pulumi.set(__self__, "max_read_buffer_size", max_read_buffer_size)
        if max_replica_delay_for_distributed_queries is not None:
            pulumi.set(__self__, "max_replica_delay_for_distributed_queries", max_replica_delay_for_distributed_queries)
        if max_result_bytes is not None:
            pulumi.set(__self__, "max_result_bytes", max_result_bytes)
        if max_result_rows is not None:
            pulumi.set(__self__, "max_result_rows", max_result_rows)
        if max_rows_in_distinct is not None:
            pulumi.set(__self__, "max_rows_in_distinct", max_rows_in_distinct)
        if max_rows_in_join is not None:
            pulumi.set(__self__, "max_rows_in_join", max_rows_in_join)
        if max_rows_in_set is not None:
            pulumi.set(__self__, "max_rows_in_set", max_rows_in_set)
        if max_rows_to_group_by is not None:
            pulumi.set(__self__, "max_rows_to_group_by", max_rows_to_group_by)
        if max_rows_to_read is not None:
            pulumi.set(__self__, "max_rows_to_read", max_rows_to_read)
        if max_rows_to_sort is not None:
            pulumi.set(__self__, "max_rows_to_sort", max_rows_to_sort)
        if max_rows_to_transfer is not None:
            pulumi.set(__self__, "max_rows_to_transfer", max_rows_to_transfer)
        if max_temporary_columns is not None:
            pulumi.set(__self__, "max_temporary_columns", max_temporary_columns)
        if max_temporary_data_on_disk_size_for_query is not None:
            pulumi.set(__self__, "max_temporary_data_on_disk_size_for_query", max_temporary_data_on_disk_size_for_query)
        if max_temporary_data_on_disk_size_for_user is not None:
            pulumi.set(__self__, "max_temporary_data_on_disk_size_for_user", max_temporary_data_on_disk_size_for_user)
        if max_temporary_non_const_columns is not None:
            pulumi.set(__self__, "max_temporary_non_const_columns", max_temporary_non_const_columns)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if memory_overcommit_ratio_denominator is not None:
            pulumi.set(__self__, "memory_overcommit_ratio_denominator", memory_overcommit_ratio_denominator)
        if memory_overcommit_ratio_denominator_for_user is not None:
            pulumi.set(__self__, "memory_overcommit_ratio_denominator_for_user", memory_overcommit_ratio_denominator_for_user)
        if memory_profiler_sample_probability is not None:
            pulumi.set(__self__, "memory_profiler_sample_probability", memory_profiler_sample_probability)
        if memory_profiler_step is not None:
            pulumi.set(__self__, "memory_profiler_step", memory_profiler_step)
        if memory_usage_overcommit_max_wait_microseconds is not None:
            pulumi.set(__self__, "memory_usage_overcommit_max_wait_microseconds", memory_usage_overcommit_max_wait_microseconds)
        if merge_tree_max_bytes_to_use_cache is not None:
            pulumi.set(__self__, "merge_tree_max_bytes_to_use_cache", merge_tree_max_bytes_to_use_cache)
        if merge_tree_max_rows_to_use_cache is not None:
            pulumi.set(__self__, "merge_tree_max_rows_to_use_cache", merge_tree_max_rows_to_use_cache)
        if merge_tree_min_bytes_for_concurrent_read is not None:
            pulumi.set(__self__, "merge_tree_min_bytes_for_concurrent_read", merge_tree_min_bytes_for_concurrent_read)
        if merge_tree_min_rows_for_concurrent_read is not None:
            pulumi.set(__self__, "merge_tree_min_rows_for_concurrent_read", merge_tree_min_rows_for_concurrent_read)
        if min_bytes_to_use_direct_io is not None:
            pulumi.set(__self__, "min_bytes_to_use_direct_io", min_bytes_to_use_direct_io)
        if min_count_to_compile is not None:
            pulumi.set(__self__, "min_count_to_compile", min_count_to_compile)
        if min_count_to_compile_expression is not None:
            pulumi.set(__self__, "min_count_to_compile_expression", min_count_to_compile_expression)
        if min_execution_speed is not None:
            pulumi.set(__self__, "min_execution_speed", min_execution_speed)
        if min_execution_speed_bytes is not None:
            pulumi.set(__self__, "min_execution_speed_bytes", min_execution_speed_bytes)
        if min_insert_block_size_bytes is not None:
            pulumi.set(__self__, "min_insert_block_size_bytes", min_insert_block_size_bytes)
        if min_insert_block_size_rows is not None:
            pulumi.set(__self__, "min_insert_block_size_rows", min_insert_block_size_rows)
        if output_format_json_quote64bit_integers is not None:
            pulumi.set(__self__, "output_format_json_quote64bit_integers", output_format_json_quote64bit_integers)
        if output_format_json_quote_denormals is not None:
            pulumi.set(__self__, "output_format_json_quote_denormals", output_format_json_quote_denormals)
        if prefer_localhost_replica is not None:
            pulumi.set(__self__, "prefer_localhost_replica", prefer_localhost_replica)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if quota_mode is not None:
            pulumi.set(__self__, "quota_mode", quota_mode)
        if read_overflow_mode is not None:
            pulumi.set(__self__, "read_overflow_mode", read_overflow_mode)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if receive_timeout is not None:
            pulumi.set(__self__, "receive_timeout", receive_timeout)
        if remote_filesystem_read_method is not None:
            pulumi.set(__self__, "remote_filesystem_read_method", remote_filesystem_read_method)
        if replication_alter_partitions_sync is not None:
            pulumi.set(__self__, "replication_alter_partitions_sync", replication_alter_partitions_sync)
        if result_overflow_mode is not None:
            pulumi.set(__self__, "result_overflow_mode", result_overflow_mode)
        if select_sequential_consistency is not None:
            pulumi.set(__self__, "select_sequential_consistency", select_sequential_consistency)
        if send_progress_in_http_headers is not None:
            pulumi.set(__self__, "send_progress_in_http_headers", send_progress_in_http_headers)
        if send_timeout is not None:
            pulumi.set(__self__, "send_timeout", send_timeout)
        if set_overflow_mode is not None:
            pulumi.set(__self__, "set_overflow_mode", set_overflow_mode)
        if skip_unavailable_shards is not None:
            pulumi.set(__self__, "skip_unavailable_shards", skip_unavailable_shards)
        if sort_overflow_mode is not None:
            pulumi.set(__self__, "sort_overflow_mode", sort_overflow_mode)
        if timeout_before_checking_execution_speed is not None:
            pulumi.set(__self__, "timeout_before_checking_execution_speed", timeout_before_checking_execution_speed)
        if timeout_overflow_mode is not None:
            pulumi.set(__self__, "timeout_overflow_mode", timeout_overflow_mode)
        if transfer_overflow_mode is not None:
            pulumi.set(__self__, "transfer_overflow_mode", transfer_overflow_mode)
        if transform_null_in is not None:
            pulumi.set(__self__, "transform_null_in", transform_null_in)
        if use_hedged_requests is not None:
            pulumi.set(__self__, "use_hedged_requests", use_hedged_requests)
        if use_uncompressed_cache is not None:
            pulumi.set(__self__, "use_uncompressed_cache", use_uncompressed_cache)
        if wait_for_async_insert is not None:
            pulumi.set(__self__, "wait_for_async_insert", wait_for_async_insert)
        if wait_for_async_insert_timeout is not None:
            pulumi.set(__self__, "wait_for_async_insert_timeout", wait_for_async_insert_timeout)

    @property
    @pulumi.getter(name="addHttpCorsHeader")
    def add_http_cors_header(self) -> Optional[pulumi.Input[bool]]:
        """
        Include CORS headers in HTTP responces.
        """
        return pulumi.get(self, "add_http_cors_header")

    @add_http_cors_header.setter
    def add_http_cors_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_http_cors_header", value)

    @property
    @pulumi.getter(name="allowDdl")
    def allow_ddl(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows or denies DDL queries.
        """
        return pulumi.get(self, "allow_ddl")

    @allow_ddl.setter
    def allow_ddl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ddl", value)

    @property
    @pulumi.getter(name="allowIntrospectionFunctions")
    def allow_introspection_functions(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables introspections functions for query profiling.
        """
        return pulumi.get(self, "allow_introspection_functions")

    @allow_introspection_functions.setter
    def allow_introspection_functions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_introspection_functions", value)

    @property
    @pulumi.getter(name="allowSuspiciousLowCardinalityTypes")
    def allow_suspicious_low_cardinality_types(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        """
        return pulumi.get(self, "allow_suspicious_low_cardinality_types")

    @allow_suspicious_low_cardinality_types.setter
    def allow_suspicious_low_cardinality_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_suspicious_low_cardinality_types", value)

    @property
    @pulumi.getter(name="anyJoinDistinctRightTableKeys")
    def any_join_distinct_right_table_keys(self) -> Optional[pulumi.Input[bool]]:
        """
        enables legacy ClickHouse server behaviour in ANY INNER|LEFT JOIN operations.
        """
        return pulumi.get(self, "any_join_distinct_right_table_keys")

    @any_join_distinct_right_table_keys.setter
    def any_join_distinct_right_table_keys(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "any_join_distinct_right_table_keys", value)

    @property
    @pulumi.getter(name="asyncInsert")
    def async_insert(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables asynchronous inserts. Disabled by default.
        """
        return pulumi.get(self, "async_insert")

    @async_insert.setter
    def async_insert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "async_insert", value)

    @property
    @pulumi.getter(name="asyncInsertBusyTimeout")
    def async_insert_busy_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        """
        return pulumi.get(self, "async_insert_busy_timeout")

    @async_insert_busy_timeout.setter
    def async_insert_busy_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "async_insert_busy_timeout", value)

    @property
    @pulumi.getter(name="asyncInsertMaxDataSize")
    def async_insert_max_data_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        """
        return pulumi.get(self, "async_insert_max_data_size")

    @async_insert_max_data_size.setter
    def async_insert_max_data_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "async_insert_max_data_size", value)

    @property
    @pulumi.getter(name="asyncInsertStaleTimeout")
    def async_insert_stale_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        """
        return pulumi.get(self, "async_insert_stale_timeout")

    @async_insert_stale_timeout.setter
    def async_insert_stale_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "async_insert_stale_timeout", value)

    @property
    @pulumi.getter(name="asyncInsertThreads")
    def async_insert_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        """
        return pulumi.get(self, "async_insert_threads")

    @async_insert_threads.setter
    def async_insert_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "async_insert_threads", value)

    @property
    @pulumi.getter(name="cancelHttpReadonlyQueriesOnClientClose")
    def cancel_http_readonly_queries_on_client_close(self) -> Optional[pulumi.Input[bool]]:
        """
        Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        """
        return pulumi.get(self, "cancel_http_readonly_queries_on_client_close")

    @cancel_http_readonly_queries_on_client_close.setter
    def cancel_http_readonly_queries_on_client_close(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cancel_http_readonly_queries_on_client_close", value)

    @property
    @pulumi.getter
    def compile(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable compilation of queries.
        """
        return pulumi.get(self, "compile")

    @compile.setter
    def compile(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compile", value)

    @property
    @pulumi.getter(name="compileExpressions")
    def compile_expressions(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on expression compilation.
        """
        return pulumi.get(self, "compile_expressions")

    @compile_expressions.setter
    def compile_expressions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compile_expressions", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="connectTimeoutWithFailover")
    def connect_timeout_with_failover(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        """
        return pulumi.get(self, "connect_timeout_with_failover")

    @connect_timeout_with_failover.setter
    def connect_timeout_with_failover(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout_with_failover", value)

    @property
    @pulumi.getter(name="countDistinctImplementation")
    def count_distinct_implementation(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        """
        return pulumi.get(self, "count_distinct_implementation")

    @count_distinct_implementation.setter
    def count_distinct_implementation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count_distinct_implementation", value)

    @property
    @pulumi.getter(name="dateTimeInputFormat")
    def date_time_input_format(self) -> Optional[pulumi.Input[str]]:
        """
        Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        """
        return pulumi.get(self, "date_time_input_format")

    @date_time_input_format.setter
    def date_time_input_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_time_input_format", value)

    @property
    @pulumi.getter(name="dateTimeOutputFormat")
    def date_time_output_format(self) -> Optional[pulumi.Input[str]]:
        """
        Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        """
        return pulumi.get(self, "date_time_output_format")

    @date_time_output_format.setter
    def date_time_output_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_time_output_format", value)

    @property
    @pulumi.getter(name="deduplicateBlocksInDependentMaterializedViews")
    def deduplicate_blocks_in_dependent_materialized_views(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the deduplication check for materialized views that receive data from Replicated* tables.
        """
        return pulumi.get(self, "deduplicate_blocks_in_dependent_materialized_views")

    @deduplicate_blocks_in_dependent_materialized_views.setter
    def deduplicate_blocks_in_dependent_materialized_views(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deduplicate_blocks_in_dependent_materialized_views", value)

    @property
    @pulumi.getter(name="distinctOverflowMode")
    def distinct_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow when using DISTINCT. Possible values:
        """
        return pulumi.get(self, "distinct_overflow_mode")

    @distinct_overflow_mode.setter
    def distinct_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "distinct_overflow_mode", value)

    @property
    @pulumi.getter(name="distributedAggregationMemoryEfficient")
    def distributed_aggregation_memory_efficient(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_aggregation_memory_efficient")

    @distributed_aggregation_memory_efficient.setter
    def distributed_aggregation_memory_efficient(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "distributed_aggregation_memory_efficient", value)

    @property
    @pulumi.getter(name="distributedDdlTaskTimeout")
    def distributed_ddl_task_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for DDL queries, in milliseconds.
        """
        return pulumi.get(self, "distributed_ddl_task_timeout")

    @distributed_ddl_task_timeout.setter
    def distributed_ddl_task_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "distributed_ddl_task_timeout", value)

    @property
    @pulumi.getter(name="distributedProductMode")
    def distributed_product_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Changes the behaviour of distributed subqueries.
        """
        return pulumi.get(self, "distributed_product_mode")

    @distributed_product_mode.setter
    def distributed_product_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "distributed_product_mode", value)

    @property
    @pulumi.getter(name="emptyResultForAggregationByEmptySet")
    def empty_result_for_aggregation_by_empty_set(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to retunr empty result.
        """
        return pulumi.get(self, "empty_result_for_aggregation_by_empty_set")

    @empty_result_for_aggregation_by_empty_set.setter
    def empty_result_for_aggregation_by_empty_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "empty_result_for_aggregation_by_empty_set", value)

    @property
    @pulumi.getter(name="enableHttpCompression")
    def enable_http_compression(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        return pulumi.get(self, "enable_http_compression")

    @enable_http_compression.setter
    def enable_http_compression(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_http_compression", value)

    @property
    @pulumi.getter(name="fallbackToStaleReplicasForDistributedQueries")
    def fallback_to_stale_replicas_for_distributed_queries(self) -> Optional[pulumi.Input[bool]]:
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        return pulumi.get(self, "fallback_to_stale_replicas_for_distributed_queries")

    @fallback_to_stale_replicas_for_distributed_queries.setter
    def fallback_to_stale_replicas_for_distributed_queries(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fallback_to_stale_replicas_for_distributed_queries", value)

    @property
    @pulumi.getter(name="flattenNested")
    def flatten_nested(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets the data format of a nested columns.
        """
        return pulumi.get(self, "flatten_nested")

    @flatten_nested.setter
    def flatten_nested(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "flatten_nested", value)

    @property
    @pulumi.getter(name="forceIndexByDate")
    def force_index_by_date(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables query execution if the index cant be used by date.
        """
        return pulumi.get(self, "force_index_by_date")

    @force_index_by_date.setter
    def force_index_by_date(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_index_by_date", value)

    @property
    @pulumi.getter(name="forcePrimaryKey")
    def force_primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        return pulumi.get(self, "force_primary_key")

    @force_primary_key.setter
    def force_primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_primary_key", value)

    @property
    @pulumi.getter(name="formatRegexp")
    def format_regexp(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression (for Regexp format).
        """
        return pulumi.get(self, "format_regexp")

    @format_regexp.setter
    def format_regexp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_regexp", value)

    @property
    @pulumi.getter(name="formatRegexpSkipUnmatched")
    def format_regexp_skip_unmatched(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip lines unmatched by regular expression.
        """
        return pulumi.get(self, "format_regexp_skip_unmatched")

    @format_regexp_skip_unmatched.setter
    def format_regexp_skip_unmatched(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "format_regexp_skip_unmatched", value)

    @property
    @pulumi.getter(name="groupByOverflowMode")
    def group_by_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow while GROUP BY operation. Possible values:
        """
        return pulumi.get(self, "group_by_overflow_mode")

    @group_by_overflow_mode.setter
    def group_by_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_by_overflow_mode", value)

    @property
    @pulumi.getter(name="groupByTwoLevelThreshold")
    def group_by_two_level_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold")

    @group_by_two_level_threshold.setter
    def group_by_two_level_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_by_two_level_threshold", value)

    @property
    @pulumi.getter(name="groupByTwoLevelThresholdBytes")
    def group_by_two_level_threshold_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold_bytes")

    @group_by_two_level_threshold_bytes.setter
    def group_by_two_level_threshold_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_by_two_level_threshold_bytes", value)

    @property
    @pulumi.getter(name="hedgedConnectionTimeoutMs")
    def hedged_connection_timeout_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        """
        return pulumi.get(self, "hedged_connection_timeout_ms")

    @hedged_connection_timeout_ms.setter
    def hedged_connection_timeout_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hedged_connection_timeout_ms", value)

    @property
    @pulumi.getter(name="httpConnectionTimeout")
    def http_connection_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_connection_timeout")

    @http_connection_timeout.setter
    def http_connection_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_connection_timeout", value)

    @property
    @pulumi.getter(name="httpHeadersProgressInterval")
    def http_headers_progress_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        return pulumi.get(self, "http_headers_progress_interval")

    @http_headers_progress_interval.setter
    def http_headers_progress_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_headers_progress_interval", value)

    @property
    @pulumi.getter(name="httpReceiveTimeout")
    def http_receive_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_receive_timeout")

    @http_receive_timeout.setter
    def http_receive_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_receive_timeout", value)

    @property
    @pulumi.getter(name="httpSendTimeout")
    def http_send_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_send_timeout")

    @http_send_timeout.setter
    def http_send_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_send_timeout", value)

    @property
    @pulumi.getter(name="idleConnectionTimeout")
    def idle_connection_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        """
        return pulumi.get(self, "idle_connection_timeout")

    @idle_connection_timeout.setter
    def idle_connection_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_connection_timeout", value)

    @property
    @pulumi.getter(name="inputFormatDefaultsForOmittedFields")
    def input_format_defaults_for_omitted_fields(self) -> Optional[pulumi.Input[bool]]:
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        return pulumi.get(self, "input_format_defaults_for_omitted_fields")

    @input_format_defaults_for_omitted_fields.setter
    def input_format_defaults_for_omitted_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "input_format_defaults_for_omitted_fields", value)

    @property
    @pulumi.getter(name="inputFormatImportNestedJson")
    def input_format_import_nested_json(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the insertion of JSON data with nested objects.
        """
        return pulumi.get(self, "input_format_import_nested_json")

    @input_format_import_nested_json.setter
    def input_format_import_nested_json(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "input_format_import_nested_json", value)

    @property
    @pulumi.getter(name="inputFormatNullAsDefault")
    def input_format_null_as_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        """
        return pulumi.get(self, "input_format_null_as_default")

    @input_format_null_as_default.setter
    def input_format_null_as_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "input_format_null_as_default", value)

    @property
    @pulumi.getter(name="inputFormatParallelParsing")
    def input_format_parallel_parsing(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        """
        return pulumi.get(self, "input_format_parallel_parsing")

    @input_format_parallel_parsing.setter
    def input_format_parallel_parsing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "input_format_parallel_parsing", value)

    @property
    @pulumi.getter(name="inputFormatValuesInterpretExpressions")
    def input_format_values_interpret_expressions(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        """
        return pulumi.get(self, "input_format_values_interpret_expressions")

    @input_format_values_interpret_expressions.setter
    def input_format_values_interpret_expressions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "input_format_values_interpret_expressions", value)

    @property
    @pulumi.getter(name="inputFormatWithNamesUseHeader")
    def input_format_with_names_use_header(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables checking the column order when inserting data.
        """
        return pulumi.get(self, "input_format_with_names_use_header")

    @input_format_with_names_use_header.setter
    def input_format_with_names_use_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "input_format_with_names_use_header", value)

    @property
    @pulumi.getter(name="insertKeeperMaxRetries")
    def insert_keeper_max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        """
        return pulumi.get(self, "insert_keeper_max_retries")

    @insert_keeper_max_retries.setter
    def insert_keeper_max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insert_keeper_max_retries", value)

    @property
    @pulumi.getter(name="insertNullAsDefault")
    def insert_null_as_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        """
        return pulumi.get(self, "insert_null_as_default")

    @insert_null_as_default.setter
    def insert_null_as_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insert_null_as_default", value)

    @property
    @pulumi.getter(name="insertQuorum")
    def insert_quorum(self) -> Optional[pulumi.Input[int]]:
        """
        Enables the quorum writes.
        """
        return pulumi.get(self, "insert_quorum")

    @insert_quorum.setter
    def insert_quorum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insert_quorum", value)

    @property
    @pulumi.getter(name="insertQuorumParallel")
    def insert_quorum_parallel(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables parallelism for quorum INSERT queries.
        """
        return pulumi.get(self, "insert_quorum_parallel")

    @insert_quorum_parallel.setter
    def insert_quorum_parallel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insert_quorum_parallel", value)

    @property
    @pulumi.getter(name="insertQuorumTimeout")
    def insert_quorum_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Write to a quorum timeout in milliseconds.
        """
        return pulumi.get(self, "insert_quorum_timeout")

    @insert_quorum_timeout.setter
    def insert_quorum_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insert_quorum_timeout", value)

    @property
    @pulumi.getter(name="joinAlgorithms")
    def join_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies which JOIN algorithm is used. Possible values:
        """
        return pulumi.get(self, "join_algorithms")

    @join_algorithms.setter
    def join_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "join_algorithms", value)

    @property
    @pulumi.getter(name="joinOverflowMode")
    def join_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow in JOIN. Possible values:
        """
        return pulumi.get(self, "join_overflow_mode")

    @join_overflow_mode.setter
    def join_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_overflow_mode", value)

    @property
    @pulumi.getter(name="joinUseNulls")
    def join_use_nulls(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        return pulumi.get(self, "join_use_nulls")

    @join_use_nulls.setter
    def join_use_nulls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "join_use_nulls", value)

    @property
    @pulumi.getter(name="joinedSubqueryRequiresAlias")
    def joined_subquery_requires_alias(self) -> Optional[pulumi.Input[bool]]:
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        return pulumi.get(self, "joined_subquery_requires_alias")

    @joined_subquery_requires_alias.setter
    def joined_subquery_requires_alias(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "joined_subquery_requires_alias", value)

    @property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        """
        return pulumi.get(self, "load_balancing")

    @load_balancing.setter
    def load_balancing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing", value)

    @property
    @pulumi.getter(name="localFilesystemReadMethod")
    def local_filesystem_read_method(self) -> Optional[pulumi.Input[str]]:
        """
        Method of reading data from local filesystem. Possible values:
        """
        return pulumi.get(self, "local_filesystem_read_method")

    @local_filesystem_read_method.setter
    def local_filesystem_read_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_filesystem_read_method", value)

    @property
    @pulumi.getter(name="logQueryThreads")
    def log_query_threads(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: true.
        """
        return pulumi.get(self, "log_query_threads")

    @log_query_threads.setter
    def log_query_threads(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log_query_threads", value)

    @property
    @pulumi.getter(name="lowCardinalityAllowInNativeFormat")
    def low_cardinality_allow_in_native_format(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        return pulumi.get(self, "low_cardinality_allow_in_native_format")

    @low_cardinality_allow_in_native_format.setter
    def low_cardinality_allow_in_native_format(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "low_cardinality_allow_in_native_format", value)

    @property
    @pulumi.getter(name="maxAstDepth")
    def max_ast_depth(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum abstract syntax tree depth.
        """
        return pulumi.get(self, "max_ast_depth")

    @max_ast_depth.setter
    def max_ast_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ast_depth", value)

    @property
    @pulumi.getter(name="maxAstElements")
    def max_ast_elements(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum abstract syntax tree elements.
        """
        return pulumi.get(self, "max_ast_elements")

    @max_ast_elements.setter
    def max_ast_elements(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ast_elements", value)

    @property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> Optional[pulumi.Input[int]]:
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        return pulumi.get(self, "max_block_size")

    @max_block_size.setter
    def max_block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_block_size", value)

    @property
    @pulumi.getter(name="maxBytesBeforeExternalGroupBy")
    def max_bytes_before_external_group_by(self) -> Optional[pulumi.Input[int]]:
        """
        Limit in bytes for using memoru for GROUP BY before using swap on disk.
        """
        return pulumi.get(self, "max_bytes_before_external_group_by")

    @max_bytes_before_external_group_by.setter
    def max_bytes_before_external_group_by(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_before_external_group_by", value)

    @property
    @pulumi.getter(name="maxBytesBeforeExternalSort")
    def max_bytes_before_external_sort(self) -> Optional[pulumi.Input[int]]:
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        return pulumi.get(self, "max_bytes_before_external_sort")

    @max_bytes_before_external_sort.setter
    def max_bytes_before_external_sort(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_before_external_sort", value)

    @property
    @pulumi.getter(name="maxBytesInDistinct")
    def max_bytes_in_distinct(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        return pulumi.get(self, "max_bytes_in_distinct")

    @max_bytes_in_distinct.setter
    def max_bytes_in_distinct(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_in_distinct", value)

    @property
    @pulumi.getter(name="maxBytesInJoin")
    def max_bytes_in_join(self) -> Optional[pulumi.Input[int]]:
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        return pulumi.get(self, "max_bytes_in_join")

    @max_bytes_in_join.setter
    def max_bytes_in_join(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_in_join", value)

    @property
    @pulumi.getter(name="maxBytesInSet")
    def max_bytes_in_set(self) -> Optional[pulumi.Input[int]]:
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_bytes_in_set")

    @max_bytes_in_set.setter
    def max_bytes_in_set(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_in_set", value)

    @property
    @pulumi.getter(name="maxBytesToRead")
    def max_bytes_to_read(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_bytes_to_read")

    @max_bytes_to_read.setter
    def max_bytes_to_read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_to_read", value)

    @property
    @pulumi.getter(name="maxBytesToSort")
    def max_bytes_to_sort(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_bytes_to_sort")

    @max_bytes_to_sort.setter
    def max_bytes_to_sort(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_to_sort", value)

    @property
    @pulumi.getter(name="maxBytesToTransfer")
    def max_bytes_to_transfer(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_bytes_to_transfer")

    @max_bytes_to_transfer.setter
    def max_bytes_to_transfer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes_to_transfer", value)

    @property
    @pulumi.getter(name="maxColumnsToRead")
    def max_columns_to_read(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        return pulumi.get(self, "max_columns_to_read")

    @max_columns_to_read.setter
    def max_columns_to_read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_columns_to_read", value)

    @property
    @pulumi.getter(name="maxConcurrentQueriesForUser")
    def max_concurrent_queries_for_user(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of concurrent requests per user. Default value: 0 (no limit).
        """
        return pulumi.get(self, "max_concurrent_queries_for_user")

    @max_concurrent_queries_for_user.setter
    def max_concurrent_queries_for_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_queries_for_user", value)

    @property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum query execution time in milliseconds.
        """
        return pulumi.get(self, "max_execution_time")

    @max_execution_time.setter
    def max_execution_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_execution_time", value)

    @property
    @pulumi.getter(name="maxExpandedAstElements")
    def max_expanded_ast_elements(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        return pulumi.get(self, "max_expanded_ast_elements")

    @max_expanded_ast_elements.setter
    def max_expanded_ast_elements(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_expanded_ast_elements", value)

    @property
    @pulumi.getter(name="maxFinalThreads")
    def max_final_threads(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        """
        return pulumi.get(self, "max_final_threads")

    @max_final_threads.setter
    def max_final_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_final_threads", value)

    @property
    @pulumi.getter(name="maxHttpGetRedirects")
    def max_http_get_redirects(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        """
        return pulumi.get(self, "max_http_get_redirects")

    @max_http_get_redirects.setter
    def max_http_get_redirects(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_http_get_redirects", value)

    @property
    @pulumi.getter(name="maxInsertBlockSize")
    def max_insert_block_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        return pulumi.get(self, "max_insert_block_size")

    @max_insert_block_size.setter
    def max_insert_block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_insert_block_size", value)

    @property
    @pulumi.getter(name="maxInsertThreads")
    def max_insert_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        """
        return pulumi.get(self, "max_insert_threads")

    @max_insert_threads.setter
    def max_insert_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_insert_threads", value)

    @property
    @pulumi.getter(name="maxMemoryUsage")
    def max_memory_usage(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage")

    @max_memory_usage.setter
    def max_memory_usage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_usage", value)

    @property
    @pulumi.getter(name="maxMemoryUsageForUser")
    def max_memory_usage_for_user(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage_for_user")

    @max_memory_usage_for_user.setter
    def max_memory_usage_for_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_usage_for_user", value)

    @property
    @pulumi.getter(name="maxNetworkBandwidth")
    def max_network_bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth")

    @max_network_bandwidth.setter
    def max_network_bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_network_bandwidth", value)

    @property
    @pulumi.getter(name="maxNetworkBandwidthForUser")
    def max_network_bandwidth_for_user(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth_for_user")

    @max_network_bandwidth_for_user.setter
    def max_network_bandwidth_for_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_network_bandwidth_for_user", value)

    @property
    @pulumi.getter(name="maxParserDepth")
    def max_parser_depth(self) -> Optional[pulumi.Input[int]]:
        """
        Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        """
        return pulumi.get(self, "max_parser_depth")

    @max_parser_depth.setter
    def max_parser_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parser_depth", value)

    @property
    @pulumi.getter(name="maxQuerySize")
    def max_query_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        return pulumi.get(self, "max_query_size")

    @max_query_size.setter
    def max_query_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_query_size", value)

    @property
    @pulumi.getter(name="maxReadBufferSize")
    def max_read_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of the buffer to read from the filesystem.
        """
        return pulumi.get(self, "max_read_buffer_size")

    @max_read_buffer_size.setter
    def max_read_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_read_buffer_size", value)

    @property
    @pulumi.getter(name="maxReplicaDelayForDistributedQueries")
    def max_replica_delay_for_distributed_queries(self) -> Optional[pulumi.Input[int]]:
        """
        Disables lagging replicas for distributed queries.
        """
        return pulumi.get(self, "max_replica_delay_for_distributed_queries")

    @max_replica_delay_for_distributed_queries.setter
    def max_replica_delay_for_distributed_queries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replica_delay_for_distributed_queries", value)

    @property
    @pulumi.getter(name="maxResultBytes")
    def max_result_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the number of bytes in the result.
        """
        return pulumi.get(self, "max_result_bytes")

    @max_result_bytes.setter
    def max_result_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_result_bytes", value)

    @property
    @pulumi.getter(name="maxResultRows")
    def max_result_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the number of rows in the result.
        """
        return pulumi.get(self, "max_result_rows")

    @max_result_rows.setter
    def max_result_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_result_rows", value)

    @property
    @pulumi.getter(name="maxRowsInDistinct")
    def max_rows_in_distinct(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        return pulumi.get(self, "max_rows_in_distinct")

    @max_rows_in_distinct.setter
    def max_rows_in_distinct(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_in_distinct", value)

    @property
    @pulumi.getter(name="maxRowsInJoin")
    def max_rows_in_join(self) -> Optional[pulumi.Input[int]]:
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        return pulumi.get(self, "max_rows_in_join")

    @max_rows_in_join.setter
    def max_rows_in_join(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_in_join", value)

    @property
    @pulumi.getter(name="maxRowsInSet")
    def max_rows_in_set(self) -> Optional[pulumi.Input[int]]:
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_rows_in_set")

    @max_rows_in_set.setter
    def max_rows_in_set(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_in_set", value)

    @property
    @pulumi.getter(name="maxRowsToGroupBy")
    def max_rows_to_group_by(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        return pulumi.get(self, "max_rows_to_group_by")

    @max_rows_to_group_by.setter
    def max_rows_to_group_by(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_to_group_by", value)

    @property
    @pulumi.getter(name="maxRowsToRead")
    def max_rows_to_read(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_rows_to_read")

    @max_rows_to_read.setter
    def max_rows_to_read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_to_read", value)

    @property
    @pulumi.getter(name="maxRowsToSort")
    def max_rows_to_sort(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_rows_to_sort")

    @max_rows_to_sort.setter
    def max_rows_to_sort(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_to_sort", value)

    @property
    @pulumi.getter(name="maxRowsToTransfer")
    def max_rows_to_transfer(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_rows_to_transfer")

    @max_rows_to_transfer.setter
    def max_rows_to_transfer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_rows_to_transfer", value)

    @property
    @pulumi.getter(name="maxTemporaryColumns")
    def max_temporary_columns(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        return pulumi.get(self, "max_temporary_columns")

    @max_temporary_columns.setter
    def max_temporary_columns(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_temporary_columns", value)

    @property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForQuery")
    def max_temporary_data_on_disk_size_for_query(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_query")

    @max_temporary_data_on_disk_size_for_query.setter
    def max_temporary_data_on_disk_size_for_query(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_temporary_data_on_disk_size_for_query", value)

    @property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForUser")
    def max_temporary_data_on_disk_size_for_user(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_user")

    @max_temporary_data_on_disk_size_for_user.setter
    def max_temporary_data_on_disk_size_for_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_temporary_data_on_disk_size_for_user", value)

    @property
    @pulumi.getter(name="maxTemporaryNonConstColumns")
    def max_temporary_non_const_columns(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        return pulumi.get(self, "max_temporary_non_const_columns")

    @max_temporary_non_const_columns.setter
    def max_temporary_non_const_columns(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_temporary_non_const_columns", value)

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        return pulumi.get(self, "max_threads")

    @max_threads.setter
    def max_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_threads", value)

    @property
    @pulumi.getter(name="memoryOvercommitRatioDenominator")
    def memory_overcommit_ratio_denominator(self) -> Optional[pulumi.Input[int]]:
        """
        It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator")

    @memory_overcommit_ratio_denominator.setter
    def memory_overcommit_ratio_denominator(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_overcommit_ratio_denominator", value)

    @property
    @pulumi.getter(name="memoryOvercommitRatioDenominatorForUser")
    def memory_overcommit_ratio_denominator_for_user(self) -> Optional[pulumi.Input[int]]:
        """
        It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator_for_user")

    @memory_overcommit_ratio_denominator_for_user.setter
    def memory_overcommit_ratio_denominator_for_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_overcommit_ratio_denominator_for_user", value)

    @property
    @pulumi.getter(name="memoryProfilerSampleProbability")
    def memory_profiler_sample_probability(self) -> Optional[pulumi.Input[float]]:
        """
        Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        """
        return pulumi.get(self, "memory_profiler_sample_probability")

    @memory_profiler_sample_probability.setter
    def memory_profiler_sample_probability(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_profiler_sample_probability", value)

    @property
    @pulumi.getter(name="memoryProfilerStep")
    def memory_profiler_step(self) -> Optional[pulumi.Input[int]]:
        """
        Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        """
        return pulumi.get(self, "memory_profiler_step")

    @memory_profiler_step.setter
    def memory_profiler_step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_profiler_step", value)

    @property
    @pulumi.getter(name="memoryUsageOvercommitMaxWaitMicroseconds")
    def memory_usage_overcommit_max_wait_microseconds(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        """
        return pulumi.get(self, "memory_usage_overcommit_max_wait_microseconds")

    @memory_usage_overcommit_max_wait_microseconds.setter
    def memory_usage_overcommit_max_wait_microseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_usage_overcommit_max_wait_microseconds", value)

    @property
    @pulumi.getter(name="mergeTreeMaxBytesToUseCache")
    def merge_tree_max_bytes_to_use_cache(self) -> Optional[pulumi.Input[int]]:
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_bytes_to_use_cache")

    @merge_tree_max_bytes_to_use_cache.setter
    def merge_tree_max_bytes_to_use_cache(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_tree_max_bytes_to_use_cache", value)

    @property
    @pulumi.getter(name="mergeTreeMaxRowsToUseCache")
    def merge_tree_max_rows_to_use_cache(self) -> Optional[pulumi.Input[int]]:
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_rows_to_use_cache")

    @merge_tree_max_rows_to_use_cache.setter
    def merge_tree_max_rows_to_use_cache(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_tree_max_rows_to_use_cache", value)

    @property
    @pulumi.getter(name="mergeTreeMinBytesForConcurrentRead")
    def merge_tree_min_bytes_for_concurrent_read(self) -> Optional[pulumi.Input[int]]:
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        return pulumi.get(self, "merge_tree_min_bytes_for_concurrent_read")

    @merge_tree_min_bytes_for_concurrent_read.setter
    def merge_tree_min_bytes_for_concurrent_read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_tree_min_bytes_for_concurrent_read", value)

    @property
    @pulumi.getter(name="mergeTreeMinRowsForConcurrentRead")
    def merge_tree_min_rows_for_concurrent_read(self) -> Optional[pulumi.Input[int]]:
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        return pulumi.get(self, "merge_tree_min_rows_for_concurrent_read")

    @merge_tree_min_rows_for_concurrent_read.setter
    def merge_tree_min_rows_for_concurrent_read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "merge_tree_min_rows_for_concurrent_read", value)

    @property
    @pulumi.getter(name="minBytesToUseDirectIo")
    def min_bytes_to_use_direct_io(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        return pulumi.get(self, "min_bytes_to_use_direct_io")

    @min_bytes_to_use_direct_io.setter
    def min_bytes_to_use_direct_io(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_bytes_to_use_direct_io", value)

    @property
    @pulumi.getter(name="minCountToCompile")
    def min_count_to_compile(self) -> Optional[pulumi.Input[int]]:
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        return pulumi.get(self, "min_count_to_compile")

    @min_count_to_compile.setter
    def min_count_to_compile(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_count_to_compile", value)

    @property
    @pulumi.getter(name="minCountToCompileExpression")
    def min_count_to_compile_expression(self) -> Optional[pulumi.Input[int]]:
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        return pulumi.get(self, "min_count_to_compile_expression")

    @min_count_to_compile_expression.setter
    def min_count_to_compile_expression(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_count_to_compile_expression", value)

    @property
    @pulumi.getter(name="minExecutionSpeed")
    def min_execution_speed(self) -> Optional[pulumi.Input[int]]:
        """
        Minimal execution speed in rows per second.
        """
        return pulumi.get(self, "min_execution_speed")

    @min_execution_speed.setter
    def min_execution_speed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_execution_speed", value)

    @property
    @pulumi.getter(name="minExecutionSpeedBytes")
    def min_execution_speed_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Minimal execution speed in bytes per second.
        """
        return pulumi.get(self, "min_execution_speed_bytes")

    @min_execution_speed_bytes.setter
    def min_execution_speed_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_execution_speed_bytes", value)

    @property
    @pulumi.getter(name="minInsertBlockSizeBytes")
    def min_insert_block_size_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_bytes")

    @min_insert_block_size_bytes.setter
    def min_insert_block_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_insert_block_size_bytes", value)

    @property
    @pulumi.getter(name="minInsertBlockSizeRows")
    def min_insert_block_size_rows(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_rows")

    @min_insert_block_size_rows.setter
    def min_insert_block_size_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_insert_block_size_rows", value)

    @property
    @pulumi.getter(name="outputFormatJsonQuote64bitIntegers")
    def output_format_json_quote64bit_integers(self) -> Optional[pulumi.Input[bool]]:
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        return pulumi.get(self, "output_format_json_quote64bit_integers")

    @output_format_json_quote64bit_integers.setter
    def output_format_json_quote64bit_integers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "output_format_json_quote64bit_integers", value)

    @property
    @pulumi.getter(name="outputFormatJsonQuoteDenormals")
    def output_format_json_quote_denormals(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        return pulumi.get(self, "output_format_json_quote_denormals")

    @output_format_json_quote_denormals.setter
    def output_format_json_quote_denormals(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "output_format_json_quote_denormals", value)

    @property
    @pulumi.getter(name="preferLocalhostReplica")
    def prefer_localhost_replica(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        """
        return pulumi.get(self, "prefer_localhost_replica")

    @prefer_localhost_replica.setter
    def prefer_localhost_replica(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prefer_localhost_replica", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Query priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="quotaMode")
    def quota_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Quota accounting mode.
        """
        return pulumi.get(self, "quota_mode")

    @quota_mode.setter
    def quota_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quota_mode", value)

    @property
    @pulumi.getter(name="readOverflowMode")
    def read_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow while read. Possible values:
        """
        return pulumi.get(self, "read_overflow_mode")

    @read_overflow_mode.setter
    def read_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_overflow_mode", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[int]]:
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "receive_timeout")

    @receive_timeout.setter
    def receive_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "receive_timeout", value)

    @property
    @pulumi.getter(name="remoteFilesystemReadMethod")
    def remote_filesystem_read_method(self) -> Optional[pulumi.Input[str]]:
        """
        Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        """
        return pulumi.get(self, "remote_filesystem_read_method")

    @remote_filesystem_read_method.setter
    def remote_filesystem_read_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_filesystem_read_method", value)

    @property
    @pulumi.getter(name="replicationAlterPartitionsSync")
    def replication_alter_partitions_sync(self) -> Optional[pulumi.Input[int]]:
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        return pulumi.get(self, "replication_alter_partitions_sync")

    @replication_alter_partitions_sync.setter
    def replication_alter_partitions_sync(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replication_alter_partitions_sync", value)

    @property
    @pulumi.getter(name="resultOverflowMode")
    def result_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow in result. Possible values:
        """
        return pulumi.get(self, "result_overflow_mode")

    @result_overflow_mode.setter
    def result_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "result_overflow_mode", value)

    @property
    @pulumi.getter(name="selectSequentialConsistency")
    def select_sequential_consistency(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        return pulumi.get(self, "select_sequential_consistency")

    @select_sequential_consistency.setter
    def select_sequential_consistency(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "select_sequential_consistency", value)

    @property
    @pulumi.getter(name="sendProgressInHttpHeaders")
    def send_progress_in_http_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        """
        return pulumi.get(self, "send_progress_in_http_headers")

    @send_progress_in_http_headers.setter
    def send_progress_in_http_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_progress_in_http_headers", value)

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "send_timeout")

    @send_timeout.setter
    def send_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "send_timeout", value)

    @property
    @pulumi.getter(name="setOverflowMode")
    def set_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow in the set resulting. Possible values:
        """
        return pulumi.get(self, "set_overflow_mode")

    @set_overflow_mode.setter
    def set_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "set_overflow_mode", value)

    @property
    @pulumi.getter(name="skipUnavailableShards")
    def skip_unavailable_shards(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables silently skipping of unavailable shards.
        """
        return pulumi.get(self, "skip_unavailable_shards")

    @skip_unavailable_shards.setter
    def skip_unavailable_shards(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unavailable_shards", value)

    @property
    @pulumi.getter(name="sortOverflowMode")
    def sort_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow while sort. Possible values:
        """
        return pulumi.get(self, "sort_overflow_mode")

    @sort_overflow_mode.setter
    def sort_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_overflow_mode", value)

    @property
    @pulumi.getter(name="timeoutBeforeCheckingExecutionSpeed")
    def timeout_before_checking_execution_speed(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        """
        return pulumi.get(self, "timeout_before_checking_execution_speed")

    @timeout_before_checking_execution_speed.setter
    def timeout_before_checking_execution_speed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_before_checking_execution_speed", value)

    @property
    @pulumi.getter(name="timeoutOverflowMode")
    def timeout_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "timeout_overflow_mode")

    @timeout_overflow_mode.setter
    def timeout_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_overflow_mode", value)

    @property
    @pulumi.getter(name="transferOverflowMode")
    def transfer_overflow_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "transfer_overflow_mode")

    @transfer_overflow_mode.setter
    def transfer_overflow_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transfer_overflow_mode", value)

    @property
    @pulumi.getter(name="transformNullIn")
    def transform_null_in(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables equality of NULL values for IN operator.
        """
        return pulumi.get(self, "transform_null_in")

    @transform_null_in.setter
    def transform_null_in(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "transform_null_in", value)

    @property
    @pulumi.getter(name="useHedgedRequests")
    def use_hedged_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        """
        return pulumi.get(self, "use_hedged_requests")

    @use_hedged_requests.setter
    def use_hedged_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_hedged_requests", value)

    @property
    @pulumi.getter(name="useUncompressedCache")
    def use_uncompressed_cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use a cache of uncompressed blocks.
        """
        return pulumi.get(self, "use_uncompressed_cache")

    @use_uncompressed_cache.setter
    def use_uncompressed_cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_uncompressed_cache", value)

    @property
    @pulumi.getter(name="waitForAsyncInsert")
    def wait_for_async_insert(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        """
        return pulumi.get(self, "wait_for_async_insert")

    @wait_for_async_insert.setter
    def wait_for_async_insert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_for_async_insert", value)

    @property
    @pulumi.getter(name="waitForAsyncInsertTimeout")
    def wait_for_async_insert_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        return pulumi.get(self, "wait_for_async_insert_timeout")

    @wait_for_async_insert_timeout.setter
    def wait_for_async_insert_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_for_async_insert_timeout", value)


if not MYPY:
    class MdbClickhouseClusterZookeeperArgsDict(TypedDict):
        resources: NotRequired[pulumi.Input['MdbClickhouseClusterZookeeperResourcesArgsDict']]
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
elif False:
    MdbClickhouseClusterZookeeperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterZookeeperArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['MdbClickhouseClusterZookeeperResourcesArgs']] = None):
        """
        :param pulumi.Input['MdbClickhouseClusterZookeeperResourcesArgs'] resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MdbClickhouseClusterZookeeperResourcesArgs']]:
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MdbClickhouseClusterZookeeperResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbClickhouseClusterZookeeperResourcesArgsDict(TypedDict):
        disk_size: NotRequired[pulumi.Input[int]]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of hosts.
        """
        resource_preset_id: NotRequired[pulumi.Input[str]]
elif False:
    MdbClickhouseClusterZookeeperResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbClickhouseClusterZookeeperResourcesArgs:
    def __init__(__self__, *,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type_id: Optional[pulumi.Input[str]] = None,
                 resource_preset_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of hosts.
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbElasticsearchClusterConfigArgsDict(TypedDict):
        admin_password: pulumi.Input[str]
        """
        Password for admin user of Elasticsearch.
        """
        data_node: pulumi.Input['MdbElasticsearchClusterConfigDataNodeArgsDict']
        """
        Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        """
        edition: NotRequired[pulumi.Input[str]]
        """
        Edition of Elasticsearch. For more information, see [the official documentation](https://yandex.cloud/docs/managed-elasticsearch/concepts/es-editions).
        """
        master_node: NotRequired[pulumi.Input['MdbElasticsearchClusterConfigMasterNodeArgsDict']]
        """
        Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Elasticsearch plugins to install.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of Elasticsearch.
        """
elif False:
    MdbElasticsearchClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterConfigArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 data_node: pulumi.Input['MdbElasticsearchClusterConfigDataNodeArgs'],
                 edition: Optional[pulumi.Input[str]] = None,
                 master_node: Optional[pulumi.Input['MdbElasticsearchClusterConfigMasterNodeArgs']] = None,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: Password for admin user of Elasticsearch.
        :param pulumi.Input['MdbElasticsearchClusterConfigDataNodeArgs'] data_node: Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        :param pulumi.Input[str] edition: Edition of Elasticsearch. For more information, see [the official documentation](https://yandex.cloud/docs/managed-elasticsearch/concepts/es-editions).
        :param pulumi.Input['MdbElasticsearchClusterConfigMasterNodeArgs'] master_node: Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] plugins: A set of Elasticsearch plugins to install.
        :param pulumi.Input[str] version: Version of Elasticsearch.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "data_node", data_node)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if master_node is not None:
            pulumi.set(__self__, "master_node", master_node)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        Password for admin user of Elasticsearch.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="dataNode")
    def data_node(self) -> pulumi.Input['MdbElasticsearchClusterConfigDataNodeArgs']:
        """
        Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "data_node")

    @data_node.setter
    def data_node(self, value: pulumi.Input['MdbElasticsearchClusterConfigDataNodeArgs']):
        pulumi.set(self, "data_node", value)

    @property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[str]]:
        """
        Edition of Elasticsearch. For more information, see [the official documentation](https://yandex.cloud/docs/managed-elasticsearch/concepts/es-editions).
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "edition", value)

    @property
    @pulumi.getter(name="masterNode")
    def master_node(self) -> Optional[pulumi.Input['MdbElasticsearchClusterConfigMasterNodeArgs']]:
        """
        Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "master_node")

    @master_node.setter
    def master_node(self, value: Optional[pulumi.Input['MdbElasticsearchClusterConfigMasterNodeArgs']]):
        pulumi.set(self, "master_node", value)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Elasticsearch plugins to install.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "plugins", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of Elasticsearch.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MdbElasticsearchClusterConfigDataNodeArgsDict(TypedDict):
        resources: pulumi.Input['MdbElasticsearchClusterConfigDataNodeResourcesArgsDict']
        """
        Resources allocated to hosts of the Elasticsearch data nodes subcluster. The structure is documented below.
        """
elif False:
    MdbElasticsearchClusterConfigDataNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterConfigDataNodeArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['MdbElasticsearchClusterConfigDataNodeResourcesArgs']):
        """
        :param pulumi.Input['MdbElasticsearchClusterConfigDataNodeResourcesArgs'] resources: Resources allocated to hosts of the Elasticsearch data nodes subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MdbElasticsearchClusterConfigDataNodeResourcesArgs']:
        """
        Resources allocated to hosts of the Elasticsearch data nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MdbElasticsearchClusterConfigDataNodeResourcesArgs']):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbElasticsearchClusterConfigDataNodeResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of Elasticsearch hosts.
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbElasticsearchClusterConfigDataNodeResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterConfigDataNodeResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of Elasticsearch hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of Elasticsearch hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbElasticsearchClusterConfigMasterNodeArgsDict(TypedDict):
        resources: pulumi.Input['MdbElasticsearchClusterConfigMasterNodeResourcesArgsDict']
        """
        Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
elif False:
    MdbElasticsearchClusterConfigMasterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterConfigMasterNodeArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['MdbElasticsearchClusterConfigMasterNodeResourcesArgs']):
        """
        :param pulumi.Input['MdbElasticsearchClusterConfigMasterNodeResourcesArgs'] resources: Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MdbElasticsearchClusterConfigMasterNodeResourcesArgs']:
        """
        Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MdbElasticsearchClusterConfigMasterNodeResourcesArgs']):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbElasticsearchClusterConfigMasterNodeResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of Elasticsearch hosts.
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbElasticsearchClusterConfigMasterNodeResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterConfigMasterNodeResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of Elasticsearch hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of Elasticsearch hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbElasticsearchClusterHostArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        User defined host name.
        """
        type: pulumi.Input[str]
        """
        The type of the host to be deployed. Can be either `DATA_NODE` or `MASTER_NODE`.
        """
        zone: pulumi.Input[str]
        """
        The availability zone where the Elasticsearch host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
elif False:
    MdbElasticsearchClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterHostArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 zone: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: User defined host name.
        :param pulumi.Input[str] type: The type of the host to be deployed. Can be either `DATA_NODE` or `MASTER_NODE`.
        :param pulumi.Input[str] zone: The availability zone where the Elasticsearch host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param pulumi.Input[bool] assign_public_ip: Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        :param pulumi.Input[str] fqdn: The fully qualified domain name of the host.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User defined host name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the host to be deployed. Can be either `DATA_NODE` or `MASTER_NODE`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        The availability zone where the Elasticsearch host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MdbElasticsearchClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
elif False:
    MdbElasticsearchClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbElasticsearchClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param pulumi.Input[int] hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbGreenplumClusterAccessArgsDict(TypedDict):
        data_lens: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        data_transfer: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        web_sql: NotRequired[pulumi.Input[bool]]
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        yandex_query: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [Yandex Query](https://cloud.yandex.com/services/query)
        """
elif False:
    MdbGreenplumClusterAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[pulumi.Input[bool]] = None,
                 data_transfer: Optional[pulumi.Input[bool]] = None,
                 web_sql: Optional[pulumi.Input[bool]] = None,
                 yandex_query: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param pulumi.Input[bool] data_transfer: Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        :param pulumi.Input[bool] web_sql: Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        :param pulumi.Input[bool] yandex_query: Allow access for [Yandex Query](https://cloud.yandex.com/services/query)
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)
        if yandex_query is not None:
            pulumi.set(__self__, "yandex_query", yandex_query)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_transfer", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_sql", value)

    @property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [Yandex Query](https://cloud.yandex.com/services/query)
        """
        return pulumi.get(self, "yandex_query")

    @yandex_query.setter
    def yandex_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "yandex_query", value)


if not MYPY:
    class MdbGreenplumClusterBackgroundActivityArgsDict(TypedDict):
        analyze_and_vacuums: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict']]]]
        """
        Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        """
        query_killer_idle_in_transactions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict']]]]
        """
        block to configure script that kills long running queries that are in `idle in transaction` state.
        """
        query_killer_idles: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict']]]]
        """
        Block to configure script that kills long running queries that are in `idle` state.
        """
        query_killer_long_runnings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict']]]]
        """
        block to configure script that kills long running queries (in any state).
        """
elif False:
    MdbGreenplumClusterBackgroundActivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterBackgroundActivityArgs:
    def __init__(__self__, *,
                 analyze_and_vacuums: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs']]]] = None,
                 query_killer_idle_in_transactions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs']]]] = None,
                 query_killer_idles: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs']]]] = None,
                 query_killer_long_runnings: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs']]] analyze_and_vacuums: Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        :param pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs']]] query_killer_idle_in_transactions: block to configure script that kills long running queries that are in `idle in transaction` state.
        :param pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs']]] query_killer_idles: Block to configure script that kills long running queries that are in `idle` state.
        :param pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']]] query_killer_long_runnings: block to configure script that kills long running queries (in any state).
        """
        if analyze_and_vacuums is not None:
            pulumi.set(__self__, "analyze_and_vacuums", analyze_and_vacuums)
        if query_killer_idle_in_transactions is not None:
            pulumi.set(__self__, "query_killer_idle_in_transactions", query_killer_idle_in_transactions)
        if query_killer_idles is not None:
            pulumi.set(__self__, "query_killer_idles", query_killer_idles)
        if query_killer_long_runnings is not None:
            pulumi.set(__self__, "query_killer_long_runnings", query_killer_long_runnings)

    @property
    @pulumi.getter(name="analyzeAndVacuums")
    def analyze_and_vacuums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs']]]]:
        """
        Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        """
        return pulumi.get(self, "analyze_and_vacuums")

    @analyze_and_vacuums.setter
    def analyze_and_vacuums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs']]]]):
        pulumi.set(self, "analyze_and_vacuums", value)

    @property
    @pulumi.getter(name="queryKillerIdleInTransactions")
    def query_killer_idle_in_transactions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs']]]]:
        """
        block to configure script that kills long running queries that are in `idle in transaction` state.
        """
        return pulumi.get(self, "query_killer_idle_in_transactions")

    @query_killer_idle_in_transactions.setter
    def query_killer_idle_in_transactions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs']]]]):
        pulumi.set(self, "query_killer_idle_in_transactions", value)

    @property
    @pulumi.getter(name="queryKillerIdles")
    def query_killer_idles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs']]]]:
        """
        Block to configure script that kills long running queries that are in `idle` state.
        """
        return pulumi.get(self, "query_killer_idles")

    @query_killer_idles.setter
    def query_killer_idles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs']]]]):
        pulumi.set(self, "query_killer_idles", value)

    @property
    @pulumi.getter(name="queryKillerLongRunnings")
    def query_killer_long_runnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']]]]:
        """
        block to configure script that kills long running queries (in any state).
        """
        return pulumi.get(self, "query_killer_long_runnings")

    @query_killer_long_runnings.setter
    def query_killer_long_runnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']]]]):
        pulumi.set(self, "query_killer_long_runnings", value)


if not MYPY:
    class MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict(TypedDict):
        analyze_timeout: NotRequired[pulumi.Input[int]]
        """
        Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Time of day in 'HH:MM' format when scripts should run.
        """
        vacuum_timeout: NotRequired[pulumi.Input[int]]
        """
        Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
elif False:
    MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs:
    def __init__(__self__, *,
                 analyze_timeout: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 vacuum_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] analyze_timeout: Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        :param pulumi.Input[str] start_time: Time of day in 'HH:MM' format when scripts should run.
        :param pulumi.Input[int] vacuum_timeout: Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        if analyze_timeout is not None:
            pulumi.set(__self__, "analyze_timeout", analyze_timeout)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if vacuum_timeout is not None:
            pulumi.set(__self__, "vacuum_timeout", vacuum_timeout)

    @property
    @pulumi.getter(name="analyzeTimeout")
    def analyze_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        """
        return pulumi.get(self, "analyze_timeout")

    @analyze_timeout.setter
    def analyze_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "analyze_timeout", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Time of day in 'HH:MM' format when scripts should run.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="vacuumTimeout")
    def vacuum_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        return pulumi.get(self, "vacuum_timeout")

    @vacuum_timeout.setter
    def vacuum_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vacuum_timeout", value)


if not MYPY:
    class MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether script is enabled.
        """
        ignore_users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of users to ignore when considering queries to terminate.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        Maximum duration for this type of queries (in seconds).
        """
elif False:
    MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 ignore_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enable: Flag that indicates whether script is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ignore_users: List of users to ignore when considering queries to terminate.
        :param pulumi.Input[int] max_age: Maximum duration for this type of queries (in seconds).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if ignore_users is not None:
            pulumi.set(__self__, "ignore_users", ignore_users)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @ignore_users.setter
    def ignore_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ignore_users", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether script is enabled.
        """
        ignore_users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of users to ignore when considering queries to terminate.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        Maximum duration for this type of queries (in seconds).
        """
elif False:
    MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 ignore_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enable: Flag that indicates whether script is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ignore_users: List of users to ignore when considering queries to terminate.
        :param pulumi.Input[int] max_age: Maximum duration for this type of queries (in seconds).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if ignore_users is not None:
            pulumi.set(__self__, "ignore_users", ignore_users)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @ignore_users.setter
    def ignore_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ignore_users", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether script is enabled.
        """
        ignore_users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of users to ignore when considering queries to terminate.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        Maximum duration for this type of queries (in seconds).
        """
elif False:
    MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 ignore_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enable: Flag that indicates whether script is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ignore_users: List of users to ignore when considering queries to terminate.
        :param pulumi.Input[int] max_age: Maximum duration for this type of queries (in seconds).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if ignore_users is not None:
            pulumi.set(__self__, "ignore_users", ignore_users)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @ignore_users.setter
    def ignore_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ignore_users", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class MdbGreenplumClusterBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started (UTC).
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started (UTC).
        """
elif False:
    MdbGreenplumClusterBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started (UTC).
        :param pulumi.Input[int] minutes: The minute at which backup will be started (UTC).
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbGreenplumClusterCloudStorageArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        """
        Whether to use cloud storage or not.
        """
elif False:
    MdbGreenplumClusterCloudStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterCloudStorageArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable: Whether to use cloud storage or not.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use cloud storage or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class MdbGreenplumClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
elif False:
    MdbGreenplumClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param pulumi.Input[int] hour: Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbGreenplumClusterMasterHostArgsDict(TypedDict):
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the master hosts should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        (Computed) The fully qualified domain name of the host.
        """
elif False:
    MdbGreenplumClusterMasterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterMasterHostArgs:
    def __init__(__self__, *,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_public_ip: Sets whether the master hosts should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        :param pulumi.Input[str] fqdn: (Computed) The fully qualified domain name of the host.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the master hosts should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class MdbGreenplumClusterMasterSubclusterArgsDict(TypedDict):
        resources: pulumi.Input['MdbGreenplumClusterMasterSubclusterResourcesArgsDict']
        """
        Resources allocated to hosts for master subcluster of the Greenplum cluster. The structure is documented below.
        """
elif False:
    MdbGreenplumClusterMasterSubclusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterMasterSubclusterArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['MdbGreenplumClusterMasterSubclusterResourcesArgs']):
        """
        :param pulumi.Input['MdbGreenplumClusterMasterSubclusterResourcesArgs'] resources: Resources allocated to hosts for master subcluster of the Greenplum cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MdbGreenplumClusterMasterSubclusterResourcesArgs']:
        """
        Resources allocated to hosts for master subcluster of the Greenplum cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MdbGreenplumClusterMasterSubclusterResourcesArgs']):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbGreenplumClusterMasterSubclusterResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        disk_type_id: pulumi.Input[str]
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbGreenplumClusterMasterSubclusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterMasterSubclusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbGreenplumClusterPoolerConfigArgsDict(TypedDict):
        pool_client_idle_timeout: NotRequired[pulumi.Input[int]]
        """
        Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        """
        pool_size: NotRequired[pulumi.Input[int]]
        """
        Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        """
        pooling_mode: NotRequired[pulumi.Input[str]]
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
elif False:
    MdbGreenplumClusterPoolerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterPoolerConfigArgs:
    def __init__(__self__, *,
                 pool_client_idle_timeout: Optional[pulumi.Input[int]] = None,
                 pool_size: Optional[pulumi.Input[int]] = None,
                 pooling_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] pool_client_idle_timeout: Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        :param pulumi.Input[int] pool_size: Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        :param pulumi.Input[str] pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        if pool_client_idle_timeout is not None:
            pulumi.set(__self__, "pool_client_idle_timeout", pool_client_idle_timeout)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="poolClientIdleTimeout")
    def pool_client_idle_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        """
        return pulumi.get(self, "pool_client_idle_timeout")

    @pool_client_idle_timeout.setter
    def pool_client_idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_client_idle_timeout", value)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        """
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_size", value)

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")

    @pooling_mode.setter
    def pooling_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pooling_mode", value)


if not MYPY:
    class MdbGreenplumClusterPxfConfigArgsDict(TypedDict):
        connection_timeout: NotRequired[pulumi.Input[int]]
        """
        The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        """
        max_threads: NotRequired[pulumi.Input[int]]
        """
        The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        """
        pool_allow_core_thread_timeout: NotRequired[pulumi.Input[bool]]
        """
        Identifies whether or not core streaming threads are allowed to time out.
        """
        pool_core_size: NotRequired[pulumi.Input[int]]
        """
        The number of core streaming threads. Value is between 1 and 1024.
        """
        pool_max_size: NotRequired[pulumi.Input[int]]
        """
        The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        """
        pool_queue_capacity: NotRequired[pulumi.Input[int]]
        """
        The capacity of the core streaming thread pool queue. Value is positive.
        """
        upload_timeout: NotRequired[pulumi.Input[int]]
        """
        The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        """
        xms: NotRequired[pulumi.Input[int]]
        """
        Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        xmx: NotRequired[pulumi.Input[int]]
        """
        Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
elif False:
    MdbGreenplumClusterPxfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterPxfConfigArgs:
    def __init__(__self__, *,
                 connection_timeout: Optional[pulumi.Input[int]] = None,
                 max_threads: Optional[pulumi.Input[int]] = None,
                 pool_allow_core_thread_timeout: Optional[pulumi.Input[bool]] = None,
                 pool_core_size: Optional[pulumi.Input[int]] = None,
                 pool_max_size: Optional[pulumi.Input[int]] = None,
                 pool_queue_capacity: Optional[pulumi.Input[int]] = None,
                 upload_timeout: Optional[pulumi.Input[int]] = None,
                 xms: Optional[pulumi.Input[int]] = None,
                 xmx: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] connection_timeout: The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        :param pulumi.Input[int] max_threads: The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        :param pulumi.Input[bool] pool_allow_core_thread_timeout: Identifies whether or not core streaming threads are allowed to time out.
        :param pulumi.Input[int] pool_core_size: The number of core streaming threads. Value is between 1 and 1024.
        :param pulumi.Input[int] pool_max_size: The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        :param pulumi.Input[int] pool_queue_capacity: The capacity of the core streaming thread pool queue. Value is positive.
        :param pulumi.Input[int] upload_timeout: The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        :param pulumi.Input[int] xms: Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        :param pulumi.Input[int] xmx: Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if pool_allow_core_thread_timeout is not None:
            pulumi.set(__self__, "pool_allow_core_thread_timeout", pool_allow_core_thread_timeout)
        if pool_core_size is not None:
            pulumi.set(__self__, "pool_core_size", pool_core_size)
        if pool_max_size is not None:
            pulumi.set(__self__, "pool_max_size", pool_max_size)
        if pool_queue_capacity is not None:
            pulumi.set(__self__, "pool_queue_capacity", pool_queue_capacity)
        if upload_timeout is not None:
            pulumi.set(__self__, "upload_timeout", upload_timeout)
        if xms is not None:
            pulumi.set(__self__, "xms", xms)
        if xmx is not None:
            pulumi.set(__self__, "xmx", xmx)

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_timeout", value)

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "max_threads")

    @max_threads.setter
    def max_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_threads", value)

    @property
    @pulumi.getter(name="poolAllowCoreThreadTimeout")
    def pool_allow_core_thread_timeout(self) -> Optional[pulumi.Input[bool]]:
        """
        Identifies whether or not core streaming threads are allowed to time out.
        """
        return pulumi.get(self, "pool_allow_core_thread_timeout")

    @pool_allow_core_thread_timeout.setter
    def pool_allow_core_thread_timeout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pool_allow_core_thread_timeout", value)

    @property
    @pulumi.getter(name="poolCoreSize")
    def pool_core_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_core_size")

    @pool_core_size.setter
    def pool_core_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_core_size", value)

    @property
    @pulumi.getter(name="poolMaxSize")
    def pool_max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_max_size")

    @pool_max_size.setter
    def pool_max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_max_size", value)

    @property
    @pulumi.getter(name="poolQueueCapacity")
    def pool_queue_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The capacity of the core streaming thread pool queue. Value is positive.
        """
        return pulumi.get(self, "pool_queue_capacity")

    @pool_queue_capacity.setter
    def pool_queue_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_queue_capacity", value)

    @property
    @pulumi.getter(name="uploadTimeout")
    def upload_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "upload_timeout")

    @upload_timeout.setter
    def upload_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "upload_timeout", value)

    @property
    @pulumi.getter
    def xms(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xms")

    @xms.setter
    def xms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "xms", value)

    @property
    @pulumi.getter
    def xmx(self) -> Optional[pulumi.Input[int]]:
        """
        Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xmx")

    @xmx.setter
    def xmx(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "xmx", value)


if not MYPY:
    class MdbGreenplumClusterSegmentHostArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[str]]
        """
        (Computed) The fully qualified domain name of the host.
        """
elif False:
    MdbGreenplumClusterSegmentHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterSegmentHostArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] fqdn: (Computed) The fully qualified domain name of the host.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class MdbGreenplumClusterSegmentSubclusterArgsDict(TypedDict):
        resources: pulumi.Input['MdbGreenplumClusterSegmentSubclusterResourcesArgsDict']
        """
        Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
elif False:
    MdbGreenplumClusterSegmentSubclusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterSegmentSubclusterArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['MdbGreenplumClusterSegmentSubclusterResourcesArgs']):
        """
        :param pulumi.Input['MdbGreenplumClusterSegmentSubclusterResourcesArgs'] resources: Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MdbGreenplumClusterSegmentSubclusterResourcesArgs']:
        """
        Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MdbGreenplumClusterSegmentSubclusterResourcesArgs']):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbGreenplumClusterSegmentSubclusterResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        disk_type_id: pulumi.Input[str]
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbGreenplumClusterSegmentSubclusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbGreenplumClusterSegmentSubclusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbKafkaClusterConfigArgsDict(TypedDict):
        kafka: pulumi.Input['MdbKafkaClusterConfigKafkaArgsDict']
        """
        Configuration of the Kafka subcluster. The structure is documented below.
        """
        version: pulumi.Input[str]
        """
        Version of the Kafka server software.
        """
        zones: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of availability zones.
        """
        access: NotRequired[pulumi.Input['MdbKafkaClusterConfigAccessArgsDict']]
        """
        Access policy to the Kafka cluster. The structure is documented below.
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Determines whether each broker will be assigned a public IP address. The default is `false`.
        """
        brokers_count: NotRequired[pulumi.Input[int]]
        """
        Count of brokers per availability zone. The default is `1`.
        """
        disk_size_autoscaling: NotRequired[pulumi.Input['MdbKafkaClusterConfigDiskSizeAutoscalingArgsDict']]
        kraft: NotRequired[pulumi.Input['MdbKafkaClusterConfigKraftArgsDict']]
        """
        Configuration of the KRaft-controller subcluster. The structure is documented below.
        """
        schema_registry: NotRequired[pulumi.Input[bool]]
        """
        Enables managed schema registry on cluster. The default is `false`.
        """
        unmanaged_topics: NotRequired[pulumi.Input[bool]]
        zookeeper: NotRequired[pulumi.Input['MdbKafkaClusterConfigZookeeperArgsDict']]
        """
        Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
elif False:
    MdbKafkaClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigArgs:
    def __init__(__self__, *,
                 kafka: pulumi.Input['MdbKafkaClusterConfigKafkaArgs'],
                 version: pulumi.Input[str],
                 zones: pulumi.Input[Sequence[pulumi.Input[str]]],
                 access: Optional[pulumi.Input['MdbKafkaClusterConfigAccessArgs']] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 brokers_count: Optional[pulumi.Input[int]] = None,
                 disk_size_autoscaling: Optional[pulumi.Input['MdbKafkaClusterConfigDiskSizeAutoscalingArgs']] = None,
                 kraft: Optional[pulumi.Input['MdbKafkaClusterConfigKraftArgs']] = None,
                 schema_registry: Optional[pulumi.Input[bool]] = None,
                 unmanaged_topics: Optional[pulumi.Input[bool]] = None,
                 zookeeper: Optional[pulumi.Input['MdbKafkaClusterConfigZookeeperArgs']] = None):
        """
        :param pulumi.Input['MdbKafkaClusterConfigKafkaArgs'] kafka: Configuration of the Kafka subcluster. The structure is documented below.
        :param pulumi.Input[str] version: Version of the Kafka server software.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: List of availability zones.
        :param pulumi.Input['MdbKafkaClusterConfigAccessArgs'] access: Access policy to the Kafka cluster. The structure is documented below.
        :param pulumi.Input[bool] assign_public_ip: Determines whether each broker will be assigned a public IP address. The default is `false`.
        :param pulumi.Input[int] brokers_count: Count of brokers per availability zone. The default is `1`.
        :param pulumi.Input['MdbKafkaClusterConfigKraftArgs'] kraft: Configuration of the KRaft-controller subcluster. The structure is documented below.
        :param pulumi.Input[bool] schema_registry: Enables managed schema registry on cluster. The default is `false`.
        :param pulumi.Input['MdbKafkaClusterConfigZookeeperArgs'] zookeeper: Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zones", zones)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if brokers_count is not None:
            pulumi.set(__self__, "brokers_count", brokers_count)
        if disk_size_autoscaling is not None:
            pulumi.set(__self__, "disk_size_autoscaling", disk_size_autoscaling)
        if kraft is not None:
            pulumi.set(__self__, "kraft", kraft)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if unmanaged_topics is not None:
            warnings.warn("""The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""", DeprecationWarning)
            pulumi.log.warn("""unmanaged_topics is deprecated: The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""")
        if unmanaged_topics is not None:
            pulumi.set(__self__, "unmanaged_topics", unmanaged_topics)
        if zookeeper is not None:
            pulumi.set(__self__, "zookeeper", zookeeper)

    @property
    @pulumi.getter
    def kafka(self) -> pulumi.Input['MdbKafkaClusterConfigKafkaArgs']:
        """
        Configuration of the Kafka subcluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: pulumi.Input['MdbKafkaClusterConfigKafkaArgs']):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the Kafka server software.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def zones(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of availability zones.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "zones", value)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigAccessArgs']]:
        """
        Access policy to the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether each broker will be assigned a public IP address. The default is `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="brokersCount")
    def brokers_count(self) -> Optional[pulumi.Input[int]]:
        """
        Count of brokers per availability zone. The default is `1`.
        """
        return pulumi.get(self, "brokers_count")

    @brokers_count.setter
    def brokers_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "brokers_count", value)

    @property
    @pulumi.getter(name="diskSizeAutoscaling")
    def disk_size_autoscaling(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigDiskSizeAutoscalingArgs']]:
        return pulumi.get(self, "disk_size_autoscaling")

    @disk_size_autoscaling.setter
    def disk_size_autoscaling(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigDiskSizeAutoscalingArgs']]):
        pulumi.set(self, "disk_size_autoscaling", value)

    @property
    @pulumi.getter
    def kraft(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigKraftArgs']]:
        """
        Configuration of the KRaft-controller subcluster. The structure is documented below.
        """
        return pulumi.get(self, "kraft")

    @kraft.setter
    def kraft(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigKraftArgs']]):
        pulumi.set(self, "kraft", value)

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables managed schema registry on cluster. The default is `false`.
        """
        return pulumi.get(self, "schema_registry")

    @schema_registry.setter
    def schema_registry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schema_registry", value)

    @property
    @pulumi.getter(name="unmanagedTopics")
    @_utilities.deprecated("""The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""")
    def unmanaged_topics(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "unmanaged_topics")

    @unmanaged_topics.setter
    def unmanaged_topics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unmanaged_topics", value)

    @property
    @pulumi.getter
    def zookeeper(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigZookeeperArgs']]:
        """
        Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "zookeeper")

    @zookeeper.setter
    def zookeeper(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigZookeeperArgs']]):
        pulumi.set(self, "zookeeper", value)


if not MYPY:
    class MdbKafkaClusterConfigAccessArgsDict(TypedDict):
        data_transfer: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
elif False:
    MdbKafkaClusterConfigAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigAccessArgs:
    def __init__(__self__, *,
                 data_transfer: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_transfer: Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_transfer", value)


if not MYPY:
    class MdbKafkaClusterConfigDiskSizeAutoscalingArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Maximum possible size of disk in bytes.
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned_usage_threshold' value.
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
elif False:
    MdbKafkaClusterConfigDiskSizeAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigDiskSizeAutoscalingArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Maximum possible size of disk in bytes.
        :param pulumi.Input[int] emergency_usage_threshold: Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned_usage_threshold' value.
        :param pulumi.Input[int] planned_usage_threshold: Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Maximum possible size of disk in bytes.
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned_usage_threshold' value.
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbKafkaClusterConfigKafkaArgsDict(TypedDict):
        resources: pulumi.Input['MdbKafkaClusterConfigKafkaResourcesArgsDict']
        """
        Resources allocated to hosts of the Kafka subcluster. The structure is documented below.
        """
        kafka_config: NotRequired[pulumi.Input['MdbKafkaClusterConfigKafkaKafkaConfigArgsDict']]
        """
        User-defined settings for the Kafka cluster. The structure is documented below.
        """
elif False:
    MdbKafkaClusterConfigKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigKafkaArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['MdbKafkaClusterConfigKafkaResourcesArgs'],
                 kafka_config: Optional[pulumi.Input['MdbKafkaClusterConfigKafkaKafkaConfigArgs']] = None):
        """
        :param pulumi.Input['MdbKafkaClusterConfigKafkaResourcesArgs'] resources: Resources allocated to hosts of the Kafka subcluster. The structure is documented below.
        :param pulumi.Input['MdbKafkaClusterConfigKafkaKafkaConfigArgs'] kafka_config: User-defined settings for the Kafka cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)
        if kafka_config is not None:
            pulumi.set(__self__, "kafka_config", kafka_config)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MdbKafkaClusterConfigKafkaResourcesArgs']:
        """
        Resources allocated to hosts of the Kafka subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MdbKafkaClusterConfigKafkaResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="kafkaConfig")
    def kafka_config(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigKafkaKafkaConfigArgs']]:
        """
        User-defined settings for the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka_config")

    @kafka_config.setter
    def kafka_config(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigKafkaKafkaConfigArgs']]):
        pulumi.set(self, "kafka_config", value)


if not MYPY:
    class MdbKafkaClusterConfigKafkaKafkaConfigArgsDict(TypedDict):
        auto_create_topics_enable: NotRequired[pulumi.Input[bool]]
        compression_type: NotRequired[pulumi.Input[str]]
        """
        , `log_flush_interval_messages`, `log_flush_interval_ms`, `log_flush_scheduler_interval_ms`, `log_retention_bytes`, `log_retention_hours`, `log_retention_minutes`, `log_retention_ms`, `log_segment_bytes`, `log_preallocate`, `socket_send_buffer_bytes`, `socket_receive_buffer_bytes`, `auto_create_topics_enable`, `num_partitions`, `default_replication_factor`, `message_max_bytes`, `replica_fetch_max_bytes`, `ssl_cipher_suites`, `offsets_retention_minutes`, `sasl_enabled_mechanisms` - (Optional) Kafka server settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        default_replication_factor: NotRequired[pulumi.Input[str]]
        log_flush_interval_messages: NotRequired[pulumi.Input[str]]
        log_flush_interval_ms: NotRequired[pulumi.Input[str]]
        log_flush_scheduler_interval_ms: NotRequired[pulumi.Input[str]]
        log_preallocate: NotRequired[pulumi.Input[bool]]
        log_retention_bytes: NotRequired[pulumi.Input[str]]
        log_retention_hours: NotRequired[pulumi.Input[str]]
        log_retention_minutes: NotRequired[pulumi.Input[str]]
        log_retention_ms: NotRequired[pulumi.Input[str]]
        log_segment_bytes: NotRequired[pulumi.Input[str]]
        message_max_bytes: NotRequired[pulumi.Input[str]]
        num_partitions: NotRequired[pulumi.Input[str]]
        offsets_retention_minutes: NotRequired[pulumi.Input[str]]
        replica_fetch_max_bytes: NotRequired[pulumi.Input[str]]
        sasl_enabled_mechanisms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        socket_receive_buffer_bytes: NotRequired[pulumi.Input[str]]
        socket_send_buffer_bytes: NotRequired[pulumi.Input[str]]
        ssl_cipher_suites: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    MdbKafkaClusterConfigKafkaKafkaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigKafkaKafkaConfigArgs:
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[pulumi.Input[bool]] = None,
                 compression_type: Optional[pulumi.Input[str]] = None,
                 default_replication_factor: Optional[pulumi.Input[str]] = None,
                 log_flush_interval_messages: Optional[pulumi.Input[str]] = None,
                 log_flush_interval_ms: Optional[pulumi.Input[str]] = None,
                 log_flush_scheduler_interval_ms: Optional[pulumi.Input[str]] = None,
                 log_preallocate: Optional[pulumi.Input[bool]] = None,
                 log_retention_bytes: Optional[pulumi.Input[str]] = None,
                 log_retention_hours: Optional[pulumi.Input[str]] = None,
                 log_retention_minutes: Optional[pulumi.Input[str]] = None,
                 log_retention_ms: Optional[pulumi.Input[str]] = None,
                 log_segment_bytes: Optional[pulumi.Input[str]] = None,
                 message_max_bytes: Optional[pulumi.Input[str]] = None,
                 num_partitions: Optional[pulumi.Input[str]] = None,
                 offsets_retention_minutes: Optional[pulumi.Input[str]] = None,
                 replica_fetch_max_bytes: Optional[pulumi.Input[str]] = None,
                 sasl_enabled_mechanisms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 socket_receive_buffer_bytes: Optional[pulumi.Input[str]] = None,
                 socket_send_buffer_bytes: Optional[pulumi.Input[str]] = None,
                 ssl_cipher_suites: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] compression_type: , `log_flush_interval_messages`, `log_flush_interval_ms`, `log_flush_scheduler_interval_ms`, `log_retention_bytes`, `log_retention_hours`, `log_retention_minutes`, `log_retention_ms`, `log_segment_bytes`, `log_preallocate`, `socket_send_buffer_bytes`, `socket_receive_buffer_bytes`, `auto_create_topics_enable`, `num_partitions`, `default_replication_factor`, `message_max_bytes`, `replica_fetch_max_bytes`, `ssl_cipher_suites`, `offsets_retention_minutes`, `sasl_enabled_mechanisms` - (Optional) Kafka server settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_flush_scheduler_interval_ms is not None:
            pulumi.set(__self__, "log_flush_scheduler_interval_ms", log_flush_scheduler_interval_ms)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_minutes is not None:
            pulumi.set(__self__, "log_retention_minutes", log_retention_minutes)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if sasl_enabled_mechanisms is not None:
            pulumi.set(__self__, "sasl_enabled_mechanisms", sasl_enabled_mechanisms)
        if socket_receive_buffer_bytes is not None:
            pulumi.set(__self__, "socket_receive_buffer_bytes", socket_receive_buffer_bytes)
        if socket_send_buffer_bytes is not None:
            pulumi.set(__self__, "socket_send_buffer_bytes", socket_send_buffer_bytes)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_create_topics_enable")

    @auto_create_topics_enable.setter
    def auto_create_topics_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_create_topics_enable", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        , `log_flush_interval_messages`, `log_flush_interval_ms`, `log_flush_scheduler_interval_ms`, `log_retention_bytes`, `log_retention_hours`, `log_retention_minutes`, `log_retention_ms`, `log_segment_bytes`, `log_preallocate`, `socket_send_buffer_bytes`, `socket_receive_buffer_bytes`, `auto_create_topics_enable`, `num_partitions`, `default_replication_factor`, `message_max_bytes`, `replica_fetch_max_bytes`, `ssl_cipher_suites`, `offsets_retention_minutes`, `sasl_enabled_mechanisms` - (Optional) Kafka server settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_replication_factor")

    @default_replication_factor.setter
    def default_replication_factor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_replication_factor", value)

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_flush_interval_messages")

    @log_flush_interval_messages.setter
    def log_flush_interval_messages(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_flush_interval_messages", value)

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_flush_interval_ms")

    @log_flush_interval_ms.setter
    def log_flush_interval_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_flush_interval_ms", value)

    @property
    @pulumi.getter(name="logFlushSchedulerIntervalMs")
    def log_flush_scheduler_interval_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_flush_scheduler_interval_ms")

    @log_flush_scheduler_interval_ms.setter
    def log_flush_scheduler_interval_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_flush_scheduler_interval_ms", value)

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "log_preallocate")

    @log_preallocate.setter
    def log_preallocate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log_preallocate", value)

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_retention_bytes")

    @log_retention_bytes.setter
    def log_retention_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_retention_bytes", value)

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_retention_hours")

    @log_retention_hours.setter
    def log_retention_hours(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_retention_hours", value)

    @property
    @pulumi.getter(name="logRetentionMinutes")
    def log_retention_minutes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_retention_minutes")

    @log_retention_minutes.setter
    def log_retention_minutes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_retention_minutes", value)

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_retention_ms")

    @log_retention_ms.setter
    def log_retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_retention_ms", value)

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_segment_bytes")

    @log_segment_bytes.setter
    def log_segment_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_segment_bytes", value)

    @property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message_max_bytes")

    @message_max_bytes.setter
    def message_max_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_max_bytes", value)

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "num_partitions")

    @num_partitions.setter
    def num_partitions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "num_partitions", value)

    @property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "offsets_retention_minutes")

    @offsets_retention_minutes.setter
    def offsets_retention_minutes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offsets_retention_minutes", value)

    @property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "replica_fetch_max_bytes")

    @replica_fetch_max_bytes.setter
    def replica_fetch_max_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_fetch_max_bytes", value)

    @property
    @pulumi.getter(name="saslEnabledMechanisms")
    def sasl_enabled_mechanisms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sasl_enabled_mechanisms")

    @sasl_enabled_mechanisms.setter
    def sasl_enabled_mechanisms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sasl_enabled_mechanisms", value)

    @property
    @pulumi.getter(name="socketReceiveBufferBytes")
    def socket_receive_buffer_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "socket_receive_buffer_bytes")

    @socket_receive_buffer_bytes.setter
    def socket_receive_buffer_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "socket_receive_buffer_bytes", value)

    @property
    @pulumi.getter(name="socketSendBufferBytes")
    def socket_send_buffer_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "socket_send_buffer_bytes")

    @socket_send_buffer_bytes.setter
    def socket_send_buffer_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "socket_send_buffer_bytes", value)

    @property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssl_cipher_suites")

    @ssl_cipher_suites.setter
    def ssl_cipher_suites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssl_cipher_suites", value)


if not MYPY:
    class MdbKafkaClusterConfigKafkaResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbKafkaClusterConfigKafkaResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigKafkaResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbKafkaClusterConfigKraftArgsDict(TypedDict):
        resources: NotRequired[pulumi.Input['MdbKafkaClusterConfigKraftResourcesArgsDict']]
        """
        Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
elif False:
    MdbKafkaClusterConfigKraftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigKraftArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['MdbKafkaClusterConfigKraftResourcesArgs']] = None):
        """
        :param pulumi.Input['MdbKafkaClusterConfigKraftResourcesArgs'] resources: Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigKraftResourcesArgs']]:
        """
        Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigKraftResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbKafkaClusterConfigKraftResourcesArgsDict(TypedDict):
        disk_size: NotRequired[pulumi.Input[int]]
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        resource_preset_id: NotRequired[pulumi.Input[str]]
elif False:
    MdbKafkaClusterConfigKraftResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigKraftResourcesArgs:
    def __init__(__self__, *,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type_id: Optional[pulumi.Input[str]] = None,
                 resource_preset_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbKafkaClusterConfigZookeeperArgsDict(TypedDict):
        resources: NotRequired[pulumi.Input['MdbKafkaClusterConfigZookeeperResourcesArgsDict']]
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
elif False:
    MdbKafkaClusterConfigZookeeperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigZookeeperArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['MdbKafkaClusterConfigZookeeperResourcesArgs']] = None):
        """
        :param pulumi.Input['MdbKafkaClusterConfigZookeeperResourcesArgs'] resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MdbKafkaClusterConfigZookeeperResourcesArgs']]:
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MdbKafkaClusterConfigZookeeperResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MdbKafkaClusterConfigZookeeperResourcesArgsDict(TypedDict):
        disk_size: NotRequired[pulumi.Input[int]]
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        resource_preset_id: NotRequired[pulumi.Input[str]]
elif False:
    MdbKafkaClusterConfigZookeeperResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterConfigZookeeperResourcesArgs:
    def __init__(__self__, *,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type_id: Optional[pulumi.Input[str]] = None,
                 resource_preset_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbKafkaClusterHostArgsDict(TypedDict):
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        health: NotRequired[pulumi.Input[str]]
        """
        Health of the host.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Kafka cluster. Provided by the client when the cluster is created.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Role of the host in the cluster.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        The availability zone where the Kafka host was created.
        """
elif False:
    MdbKafkaClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterHostArgs:
    def __init__(__self__, *,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 health: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_public_ip: The flag that defines whether a public IP address is assigned to the node.
        :param pulumi.Input[str] health: Health of the host.
        :param pulumi.Input[str] name: Name of the Kafka cluster. Provided by the client when the cluster is created.
        :param pulumi.Input[str] role: Role of the host in the cluster.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs.
        :param pulumi.Input[str] zone_id: The availability zone where the Kafka host was created.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input[str]]:
        """
        Health of the host.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Kafka cluster. Provided by the client when the cluster is created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The availability zone where the Kafka host was created.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class MdbKafkaClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
elif False:
    MdbKafkaClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param pulumi.Input[int] hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbKafkaClusterTopicArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the topic.
        """
        partitions: pulumi.Input[int]
        """
        The number of the topic's partitions.
        """
        replication_factor: pulumi.Input[int]
        """
        Amount of data copies (replicas) for the topic in the cluster.
        """
        topic_config: NotRequired[pulumi.Input['MdbKafkaClusterTopicTopicConfigArgsDict']]
        """
        User-defined settings for the topic. The structure is documented below.
        """
elif False:
    MdbKafkaClusterTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterTopicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 partitions: pulumi.Input[int],
                 replication_factor: pulumi.Input[int],
                 topic_config: Optional[pulumi.Input['MdbKafkaClusterTopicTopicConfigArgs']] = None):
        """
        :param pulumi.Input[str] name: The name of the topic.
        :param pulumi.Input[int] partitions: The number of the topic's partitions.
        :param pulumi.Input[int] replication_factor: Amount of data copies (replicas) for the topic in the cluster.
        :param pulumi.Input['MdbKafkaClusterTopicTopicConfigArgs'] topic_config: User-defined settings for the topic. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replication_factor", replication_factor)
        if topic_config is not None:
            pulumi.set(__self__, "topic_config", topic_config)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[int]:
        """
        The number of the topic's partitions.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[int]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> pulumi.Input[int]:
        """
        Amount of data copies (replicas) for the topic in the cluster.
        """
        return pulumi.get(self, "replication_factor")

    @replication_factor.setter
    def replication_factor(self, value: pulumi.Input[int]):
        pulumi.set(self, "replication_factor", value)

    @property
    @pulumi.getter(name="topicConfig")
    def topic_config(self) -> Optional[pulumi.Input['MdbKafkaClusterTopicTopicConfigArgs']]:
        """
        User-defined settings for the topic. The structure is documented below.
        """
        return pulumi.get(self, "topic_config")

    @topic_config.setter
    def topic_config(self, value: Optional[pulumi.Input['MdbKafkaClusterTopicTopicConfigArgs']]):
        pulumi.set(self, "topic_config", value)


if not MYPY:
    class MdbKafkaClusterTopicTopicConfigArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        compression_type: NotRequired[pulumi.Input[str]]
        """
        , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        delete_retention_ms: NotRequired[pulumi.Input[str]]
        file_delete_delay_ms: NotRequired[pulumi.Input[str]]
        flush_messages: NotRequired[pulumi.Input[str]]
        flush_ms: NotRequired[pulumi.Input[str]]
        max_message_bytes: NotRequired[pulumi.Input[str]]
        min_compaction_lag_ms: NotRequired[pulumi.Input[str]]
        min_insync_replicas: NotRequired[pulumi.Input[str]]
        preallocate: NotRequired[pulumi.Input[bool]]
        retention_bytes: NotRequired[pulumi.Input[str]]
        retention_ms: NotRequired[pulumi.Input[str]]
        segment_bytes: NotRequired[pulumi.Input[str]]
elif False:
    MdbKafkaClusterTopicTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterTopicTopicConfigArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 compression_type: Optional[pulumi.Input[str]] = None,
                 delete_retention_ms: Optional[pulumi.Input[str]] = None,
                 file_delete_delay_ms: Optional[pulumi.Input[str]] = None,
                 flush_messages: Optional[pulumi.Input[str]] = None,
                 flush_ms: Optional[pulumi.Input[str]] = None,
                 max_message_bytes: Optional[pulumi.Input[str]] = None,
                 min_compaction_lag_ms: Optional[pulumi.Input[str]] = None,
                 min_insync_replicas: Optional[pulumi.Input[str]] = None,
                 preallocate: Optional[pulumi.Input[bool]] = None,
                 retention_bytes: Optional[pulumi.Input[str]] = None,
                 retention_ms: Optional[pulumi.Input[str]] = None,
                 segment_bytes: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "delete_retention_ms")

    @delete_retention_ms.setter
    def delete_retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_retention_ms", value)

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_delete_delay_ms")

    @file_delete_delay_ms.setter
    def file_delete_delay_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_delete_delay_ms", value)

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flush_messages")

    @flush_messages.setter
    def flush_messages(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flush_messages", value)

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flush_ms")

    @flush_ms.setter
    def flush_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flush_ms", value)

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_message_bytes")

    @max_message_bytes.setter
    def max_message_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_message_bytes", value)

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @min_compaction_lag_ms.setter
    def min_compaction_lag_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_compaction_lag_ms", value)

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_insync_replicas")

    @min_insync_replicas.setter
    def min_insync_replicas(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_insync_replicas", value)

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preallocate")

    @preallocate.setter
    def preallocate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preallocate", value)

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_bytes")

    @retention_bytes.setter
    def retention_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_bytes", value)

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_ms")

    @retention_ms.setter
    def retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_ms", value)

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segment_bytes")

    @segment_bytes.setter
    def segment_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_bytes", value)


if not MYPY:
    class MdbKafkaClusterUserArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the user.
        """
        password: pulumi.Input[str]
        """
        The password of the user.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbKafkaClusterUserPermissionArgsDict']]]]
        """
        Set of permissions granted to the user. The structure is documented below.
        """
elif False:
    MdbKafkaClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaClusterUserPermissionArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the user.
        :param pulumi.Input[str] password: The password of the user.
        :param pulumi.Input[Sequence[pulumi.Input['MdbKafkaClusterUserPermissionArgs']]] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaClusterUserPermissionArgs']]]]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaClusterUserPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class MdbKafkaClusterUserPermissionArgsDict(TypedDict):
        role: pulumi.Input[str]
        """
        The role type to grant to the topic.
        """
        topic_name: pulumi.Input[str]
        """
        The name of the topic that the permission grants access to.
        """
        allow_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of hosts, to which this permission grants access to.
        """
elif False:
    MdbKafkaClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaClusterUserPermissionArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[str],
                 topic_name: pulumi.Input[str],
                 allow_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] role: The role type to grant to the topic.
        :param pulumi.Input[str] topic_name: The name of the topic that the permission grants access to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_hosts: Set of hosts, to which this permission grants access to.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)
        if allow_hosts is not None:
            pulumi.set(__self__, "allow_hosts", allow_hosts)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[str]:
        """
        The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of hosts, to which this permission grants access to.
        """
        return pulumi.get(self, "allow_hosts")

    @allow_hosts.setter
    def allow_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_hosts", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerArgsDict(TypedDict):
        replication_factor: pulumi.Input[int]
        """
        Replication factor for topics created in target cluster
        """
        source_cluster: pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgsDict']
        """
        Settings for source cluster. The structure is documented below.
        """
        target_cluster: pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgsDict']
        """
        Settings for target cluster. The structure is documented below.
        """
        topics: pulumi.Input[str]
        """
        The pattern for topic names to be replicated.
        """
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerArgs:
    def __init__(__self__, *,
                 replication_factor: pulumi.Input[int],
                 source_cluster: pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs'],
                 target_cluster: pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs'],
                 topics: pulumi.Input[str]):
        """
        :param pulumi.Input[int] replication_factor: Replication factor for topics created in target cluster
        :param pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs'] source_cluster: Settings for source cluster. The structure is documented below.
        :param pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs'] target_cluster: Settings for target cluster. The structure is documented below.
        :param pulumi.Input[str] topics: The pattern for topic names to be replicated.
        """
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "source_cluster", source_cluster)
        pulumi.set(__self__, "target_cluster", target_cluster)
        pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> pulumi.Input[int]:
        """
        Replication factor for topics created in target cluster
        """
        return pulumi.get(self, "replication_factor")

    @replication_factor.setter
    def replication_factor(self, value: pulumi.Input[int]):
        pulumi.set(self, "replication_factor", value)

    @property
    @pulumi.getter(name="sourceCluster")
    def source_cluster(self) -> pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs']:
        """
        Settings for source cluster. The structure is documented below.
        """
        return pulumi.get(self, "source_cluster")

    @source_cluster.setter
    def source_cluster(self, value: pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs']):
        pulumi.set(self, "source_cluster", value)

    @property
    @pulumi.getter(name="targetCluster")
    def target_cluster(self) -> pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs']:
        """
        Settings for target cluster. The structure is documented below.
        """
        return pulumi.get(self, "target_cluster")

    @target_cluster.setter
    def target_cluster(self, value: pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs']):
        pulumi.set(self, "target_cluster", value)

    @property
    @pulumi.getter
    def topics(self) -> pulumi.Input[str]:
        """
        The pattern for topic names to be replicated.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: pulumi.Input[str]):
        pulumi.set(self, "topics", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgsDict(TypedDict):
        alias: NotRequired[pulumi.Input[str]]
        """
        Name of the cluster. Used also as a topic prefix
        """
        external_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgsDict']]]]
        """
        Connection params for external cluster
        """
        this_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgsDict']]]]
        """
        Using this section in the cluster definition (source or target) means it's this cluster

        The `external_cluster` blocks support:
        """
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[str]] = None,
                 external_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs']]]] = None,
                 this_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs']]]] = None):
        """
        :param pulumi.Input[str] alias: Name of the cluster. Used also as a topic prefix
        :param pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs']]] external_clusters: Connection params for external cluster
        :param pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs']]] this_clusters: Using this section in the cluster definition (source or target) means it's this cluster
               
               The `external_cluster` blocks support:
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if external_clusters is not None:
            pulumi.set(__self__, "external_clusters", external_clusters)
        if this_clusters is not None:
            pulumi.set(__self__, "this_clusters", this_clusters)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster. Used also as a topic prefix
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="externalClusters")
    def external_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs']]]]:
        """
        Connection params for external cluster
        """
        return pulumi.get(self, "external_clusters")

    @external_clusters.setter
    def external_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs']]]]):
        pulumi.set(self, "external_clusters", value)

    @property
    @pulumi.getter(name="thisClusters")
    def this_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs']]]]:
        """
        Using this section in the cluster definition (source or target) means it's this cluster

        The `external_cluster` blocks support:
        """
        return pulumi.get(self, "this_clusters")

    @this_clusters.setter
    def this_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs']]]]):
        pulumi.set(self, "this_clusters", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgsDict(TypedDict):
        bootstrap_servers: pulumi.Input[str]
        """
        List of bootstrap servers to connect to cluster
        """
        sasl_mechanism: NotRequired[pulumi.Input[str]]
        """
        Type of SASL authentification mechanism to use
        """
        sasl_password: NotRequired[pulumi.Input[str]]
        """
        Password to use in SASL authentification mechanism
        """
        sasl_username: NotRequired[pulumi.Input[str]]
        """
        Username to use in SASL authentification mechanism
        """
        security_protocol: NotRequired[pulumi.Input[str]]
        """
        Security protocol to use

        The `connector_config_s3_sink` block supports:
        """
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[str],
                 sasl_mechanism: Optional[pulumi.Input[str]] = None,
                 sasl_password: Optional[pulumi.Input[str]] = None,
                 sasl_username: Optional[pulumi.Input[str]] = None,
                 security_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bootstrap_servers: List of bootstrap servers to connect to cluster
        :param pulumi.Input[str] sasl_mechanism: Type of SASL authentification mechanism to use
        :param pulumi.Input[str] sasl_password: Password to use in SASL authentification mechanism
        :param pulumi.Input[str] sasl_username: Username to use in SASL authentification mechanism
        :param pulumi.Input[str] security_protocol: Security protocol to use
               
               The `connector_config_s3_sink` block supports:
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[str]:
        """
        List of bootstrap servers to connect to cluster
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[str]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        Type of SASL authentification mechanism to use
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_mechanism", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Security protocol to use

        The `connector_config_s3_sink` block supports:
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_protocol", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgsDict(TypedDict):
        pass
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgsDict(TypedDict):
        alias: NotRequired[pulumi.Input[str]]
        """
        Name of the cluster. Used also as a topic prefix
        """
        external_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgsDict']]]]
        """
        Connection params for external cluster
        """
        this_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgsDict']]]]
        """
        Using this section in the cluster definition (source or target) means it's this cluster

        The `external_cluster` blocks support:
        """
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[str]] = None,
                 external_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs']]]] = None,
                 this_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs']]]] = None):
        """
        :param pulumi.Input[str] alias: Name of the cluster. Used also as a topic prefix
        :param pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs']]] external_clusters: Connection params for external cluster
        :param pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs']]] this_clusters: Using this section in the cluster definition (source or target) means it's this cluster
               
               The `external_cluster` blocks support:
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if external_clusters is not None:
            pulumi.set(__self__, "external_clusters", external_clusters)
        if this_clusters is not None:
            pulumi.set(__self__, "this_clusters", this_clusters)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster. Used also as a topic prefix
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="externalClusters")
    def external_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs']]]]:
        """
        Connection params for external cluster
        """
        return pulumi.get(self, "external_clusters")

    @external_clusters.setter
    def external_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs']]]]):
        pulumi.set(self, "external_clusters", value)

    @property
    @pulumi.getter(name="thisClusters")
    def this_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs']]]]:
        """
        Using this section in the cluster definition (source or target) means it's this cluster

        The `external_cluster` blocks support:
        """
        return pulumi.get(self, "this_clusters")

    @this_clusters.setter
    def this_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs']]]]):
        pulumi.set(self, "this_clusters", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgsDict(TypedDict):
        bootstrap_servers: pulumi.Input[str]
        """
        List of bootstrap servers to connect to cluster
        """
        sasl_mechanism: NotRequired[pulumi.Input[str]]
        """
        Type of SASL authentification mechanism to use
        """
        sasl_password: NotRequired[pulumi.Input[str]]
        """
        Password to use in SASL authentification mechanism
        """
        sasl_username: NotRequired[pulumi.Input[str]]
        """
        Username to use in SASL authentification mechanism
        """
        security_protocol: NotRequired[pulumi.Input[str]]
        """
        Security protocol to use

        The `connector_config_s3_sink` block supports:
        """
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[str],
                 sasl_mechanism: Optional[pulumi.Input[str]] = None,
                 sasl_password: Optional[pulumi.Input[str]] = None,
                 sasl_username: Optional[pulumi.Input[str]] = None,
                 security_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bootstrap_servers: List of bootstrap servers to connect to cluster
        :param pulumi.Input[str] sasl_mechanism: Type of SASL authentification mechanism to use
        :param pulumi.Input[str] sasl_password: Password to use in SASL authentification mechanism
        :param pulumi.Input[str] sasl_username: Username to use in SASL authentification mechanism
        :param pulumi.Input[str] security_protocol: Security protocol to use
               
               The `connector_config_s3_sink` block supports:
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[str]:
        """
        List of bootstrap servers to connect to cluster
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[str]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        Type of SASL authentification mechanism to use
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_mechanism", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Security protocol to use

        The `connector_config_s3_sink` block supports:
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_protocol", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgsDict(TypedDict):
        pass
elif False:
    MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MdbKafkaConnectorConnectorConfigS3SinkArgsDict(TypedDict):
        file_compression_type: pulumi.Input[str]
        """
        ompression type for messages. Cannot be changed.
        """
        s3_connection: pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgsDict']
        """
        Settings for connection to s3-compatible storage. The structure is documented below.

        The `s3_connection` block supports:
        """
        topics: pulumi.Input[str]
        file_max_records: NotRequired[pulumi.Input[int]]
        """
        Max records per file.
        """
elif False:
    MdbKafkaConnectorConnectorConfigS3SinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigS3SinkArgs:
    def __init__(__self__, *,
                 file_compression_type: pulumi.Input[str],
                 s3_connection: pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs'],
                 topics: pulumi.Input[str],
                 file_max_records: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] file_compression_type: ompression type for messages. Cannot be changed.
        :param pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs'] s3_connection: Settings for connection to s3-compatible storage. The structure is documented below.
               
               The `s3_connection` block supports:
        :param pulumi.Input[int] file_max_records: Max records per file.
        """
        pulumi.set(__self__, "file_compression_type", file_compression_type)
        pulumi.set(__self__, "s3_connection", s3_connection)
        pulumi.set(__self__, "topics", topics)
        if file_max_records is not None:
            pulumi.set(__self__, "file_max_records", file_max_records)

    @property
    @pulumi.getter(name="fileCompressionType")
    def file_compression_type(self) -> pulumi.Input[str]:
        """
        ompression type for messages. Cannot be changed.
        """
        return pulumi.get(self, "file_compression_type")

    @file_compression_type.setter
    def file_compression_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_compression_type", value)

    @property
    @pulumi.getter(name="s3Connection")
    def s3_connection(self) -> pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs']:
        """
        Settings for connection to s3-compatible storage. The structure is documented below.

        The `s3_connection` block supports:
        """
        return pulumi.get(self, "s3_connection")

    @s3_connection.setter
    def s3_connection(self, value: pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs']):
        pulumi.set(self, "s3_connection", value)

    @property
    @pulumi.getter
    def topics(self) -> pulumi.Input[str]:
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: pulumi.Input[str]):
        pulumi.set(self, "topics", value)

    @property
    @pulumi.getter(name="fileMaxRecords")
    def file_max_records(self) -> Optional[pulumi.Input[int]]:
        """
        Max records per file.
        """
        return pulumi.get(self, "file_max_records")

    @file_max_records.setter
    def file_max_records(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_max_records", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        Name of the bucket in s3-compatible storage.
        """
        external_s3s: pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3ArgsDict']]]
        """
        Connection params for external s3-compatible storage. The structure is documented below.

        The `external_s3` blocks support:
        """
elif False:
    MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 external_s3s: pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args']]]):
        """
        :param pulumi.Input[str] bucket_name: Name of the bucket in s3-compatible storage.
        :param pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args']]] external_s3s: Connection params for external s3-compatible storage. The structure is documented below.
               
               The `external_s3` blocks support:
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "external_s3s", external_s3s)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Name of the bucket in s3-compatible storage.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="externalS3s")
    def external_s3s(self) -> pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args']]]:
        """
        Connection params for external s3-compatible storage. The structure is documented below.

        The `external_s3` blocks support:
        """
        return pulumi.get(self, "external_s3s")

    @external_s3s.setter
    def external_s3s(self, value: pulumi.Input[Sequence[pulumi.Input['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args']]]):
        pulumi.set(self, "external_s3s", value)


if not MYPY:
    class MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3ArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        URL of s3-compatible storage.
        """
        access_key_id: NotRequired[pulumi.Input[str]]
        """
        ID of aws-compatible static key.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        """
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        Secret key of aws-compatible static key.
        """
elif False:
    MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint: URL of s3-compatible storage.
        :param pulumi.Input[str] access_key_id: ID of aws-compatible static key.
        :param pulumi.Input[str] region: region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        :param pulumi.Input[str] secret_access_key: Secret key of aws-compatible static key.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        URL of s3-compatible storage.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of aws-compatible static key.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Secret key of aws-compatible static key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class MdbKafkaTopicTopicConfigArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        , `compression_type`, `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate` - (Optional) Kafka topic settings. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/settings-list#topic-settings) and [the Kafka documentation](https://kafka.apache.org/documentation/#topicconfigs).
        """
        compression_type: NotRequired[pulumi.Input[str]]
        delete_retention_ms: NotRequired[pulumi.Input[str]]
        file_delete_delay_ms: NotRequired[pulumi.Input[str]]
        flush_messages: NotRequired[pulumi.Input[str]]
        flush_ms: NotRequired[pulumi.Input[str]]
        max_message_bytes: NotRequired[pulumi.Input[str]]
        min_compaction_lag_ms: NotRequired[pulumi.Input[str]]
        min_insync_replicas: NotRequired[pulumi.Input[str]]
        preallocate: NotRequired[pulumi.Input[bool]]
        retention_bytes: NotRequired[pulumi.Input[str]]
        retention_ms: NotRequired[pulumi.Input[str]]
        segment_bytes: NotRequired[pulumi.Input[str]]
elif False:
    MdbKafkaTopicTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaTopicTopicConfigArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 compression_type: Optional[pulumi.Input[str]] = None,
                 delete_retention_ms: Optional[pulumi.Input[str]] = None,
                 file_delete_delay_ms: Optional[pulumi.Input[str]] = None,
                 flush_messages: Optional[pulumi.Input[str]] = None,
                 flush_ms: Optional[pulumi.Input[str]] = None,
                 max_message_bytes: Optional[pulumi.Input[str]] = None,
                 min_compaction_lag_ms: Optional[pulumi.Input[str]] = None,
                 min_insync_replicas: Optional[pulumi.Input[str]] = None,
                 preallocate: Optional[pulumi.Input[bool]] = None,
                 retention_bytes: Optional[pulumi.Input[str]] = None,
                 retention_ms: Optional[pulumi.Input[str]] = None,
                 segment_bytes: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cleanup_policy: , `compression_type`, `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate` - (Optional) Kafka topic settings. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/settings-list#topic-settings) and [the Kafka documentation](https://kafka.apache.org/documentation/#topicconfigs).
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        , `compression_type`, `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate` - (Optional) Kafka topic settings. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/settings-list#topic-settings) and [the Kafka documentation](https://kafka.apache.org/documentation/#topicconfigs).
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "delete_retention_ms")

    @delete_retention_ms.setter
    def delete_retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_retention_ms", value)

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_delete_delay_ms")

    @file_delete_delay_ms.setter
    def file_delete_delay_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_delete_delay_ms", value)

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flush_messages")

    @flush_messages.setter
    def flush_messages(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flush_messages", value)

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "flush_ms")

    @flush_ms.setter
    def flush_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flush_ms", value)

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_message_bytes")

    @max_message_bytes.setter
    def max_message_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_message_bytes", value)

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @min_compaction_lag_ms.setter
    def min_compaction_lag_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_compaction_lag_ms", value)

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_insync_replicas")

    @min_insync_replicas.setter
    def min_insync_replicas(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_insync_replicas", value)

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preallocate")

    @preallocate.setter
    def preallocate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preallocate", value)

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_bytes")

    @retention_bytes.setter
    def retention_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_bytes", value)

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_ms")

    @retention_ms.setter
    def retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_ms", value)

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "segment_bytes")

    @segment_bytes.setter
    def segment_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_bytes", value)


if not MYPY:
    class MdbKafkaUserPermissionArgsDict(TypedDict):
        role: pulumi.Input[str]
        """
        The role type to grant to the topic.
        """
        topic_name: pulumi.Input[str]
        """
        The name of the topic that the permission grants access to.
        """
        allow_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of hosts, to which this permission grants access to.
        """
elif False:
    MdbKafkaUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbKafkaUserPermissionArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[str],
                 topic_name: pulumi.Input[str],
                 allow_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] role: The role type to grant to the topic.
        :param pulumi.Input[str] topic_name: The name of the topic that the permission grants access to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_hosts: Set of hosts, to which this permission grants access to.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)
        if allow_hosts is not None:
            pulumi.set(__self__, "allow_hosts", allow_hosts)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[str]:
        """
        The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of hosts, to which this permission grants access to.
        """
        return pulumi.get(self, "allow_hosts")

    @allow_hosts.setter
    def allow_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_hosts", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigArgsDict(TypedDict):
        version: pulumi.Input[str]
        """
        Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        """
        access: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigAccessArgsDict']]
        """
        Access policy to the MongoDB cluster. The structure is documented below.
        """
        backup_retain_period_days: NotRequired[pulumi.Input[int]]
        """
        Retain period of automatically created backup in days.
        """
        backup_window_start: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigBackupWindowStartArgsDict']]
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        feature_compatibility_version: NotRequired[pulumi.Input[str]]
        """
        Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        """
        mongocfg: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgArgsDict']]
        """
        Configuration of the mongocfg service. The structure is documented below.
        """
        mongod: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodArgsDict']]
        """
        Configuration of the mongod service. The structure is documented below.
        """
        mongos: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongosArgsDict']]
        """
        Configuration of the mongos service. The structure is documented below.
        """
        performance_diagnostics: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict']]
        """
        Performance diagnostics to the MongoDB cluster. The structure is documented below.
        """
elif False:
    MdbMongodbClusterClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 access: Optional[pulumi.Input['MdbMongodbClusterClusterConfigAccessArgs']] = None,
                 backup_retain_period_days: Optional[pulumi.Input[int]] = None,
                 backup_window_start: Optional[pulumi.Input['MdbMongodbClusterClusterConfigBackupWindowStartArgs']] = None,
                 feature_compatibility_version: Optional[pulumi.Input[str]] = None,
                 mongocfg: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgArgs']] = None,
                 mongod: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodArgs']] = None,
                 mongos: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongosArgs']] = None,
                 performance_diagnostics: Optional[pulumi.Input['MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs']] = None):
        """
        :param pulumi.Input[str] version: Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        :param pulumi.Input['MdbMongodbClusterClusterConfigAccessArgs'] access: Access policy to the MongoDB cluster. The structure is documented below.
        :param pulumi.Input[int] backup_retain_period_days: Retain period of automatically created backup in days.
        :param pulumi.Input['MdbMongodbClusterClusterConfigBackupWindowStartArgs'] backup_window_start: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param pulumi.Input[str] feature_compatibility_version: Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongocfgArgs'] mongocfg: Configuration of the mongocfg service. The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodArgs'] mongod: Configuration of the mongod service. The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongosArgs'] mongos: Configuration of the mongos service. The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs'] performance_diagnostics: Performance diagnostics to the MongoDB cluster. The structure is documented below.
        """
        pulumi.set(__self__, "version", version)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if backup_retain_period_days is not None:
            pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if feature_compatibility_version is not None:
            pulumi.set(__self__, "feature_compatibility_version", feature_compatibility_version)
        if mongocfg is not None:
            pulumi.set(__self__, "mongocfg", mongocfg)
        if mongod is not None:
            pulumi.set(__self__, "mongod", mongod)
        if mongos is not None:
            pulumi.set(__self__, "mongos", mongos)
        if performance_diagnostics is not None:
            pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigAccessArgs']]:
        """
        Access policy to the MongoDB cluster. The structure is documented below.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retain period of automatically created backup in days.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @backup_retain_period_days.setter
    def backup_retain_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_retain_period_days", value)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigBackupWindowStartArgs']]:
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_start")

    @backup_window_start.setter
    def backup_window_start(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigBackupWindowStartArgs']]):
        pulumi.set(self, "backup_window_start", value)

    @property
    @pulumi.getter(name="featureCompatibilityVersion")
    def feature_compatibility_version(self) -> Optional[pulumi.Input[str]]:
        """
        Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        """
        return pulumi.get(self, "feature_compatibility_version")

    @feature_compatibility_version.setter
    def feature_compatibility_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "feature_compatibility_version", value)

    @property
    @pulumi.getter
    def mongocfg(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgArgs']]:
        """
        Configuration of the mongocfg service. The structure is documented below.
        """
        return pulumi.get(self, "mongocfg")

    @mongocfg.setter
    def mongocfg(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgArgs']]):
        pulumi.set(self, "mongocfg", value)

    @property
    @pulumi.getter
    def mongod(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodArgs']]:
        """
        Configuration of the mongod service. The structure is documented below.
        """
        return pulumi.get(self, "mongod")

    @mongod.setter
    def mongod(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodArgs']]):
        pulumi.set(self, "mongod", value)

    @property
    @pulumi.getter
    def mongos(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongosArgs']]:
        """
        Configuration of the mongos service. The structure is documented below.
        """
        return pulumi.get(self, "mongos")

    @mongos.setter
    def mongos(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongosArgs']]):
        pulumi.set(self, "mongos", value)

    @property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs']]:
        """
        Performance diagnostics to the MongoDB cluster. The structure is documented below.
        """
        return pulumi.get(self, "performance_diagnostics")

    @performance_diagnostics.setter
    def performance_diagnostics(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs']]):
        pulumi.set(self, "performance_diagnostics", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigAccessArgsDict(TypedDict):
        data_lens: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        data_transfer: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
elif False:
    MdbMongodbClusterClusterConfigAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[pulumi.Input[bool]] = None,
                 data_transfer: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param pulumi.Input[bool] data_transfer: Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_transfer", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started.
        """
elif False:
    MdbMongodbClusterClusterConfigBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started.
        :param pulumi.Input[int] minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongocfgArgsDict(TypedDict):
        net: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgNetArgsDict']]
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
        operation_profiling: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict']]
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option). The structure is documented below.
        """
        storage: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageArgsDict']]
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option). The structure is documented below.
        """
elif False:
    MdbMongodbClusterClusterConfigMongocfgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongocfgArgs:
    def __init__(__self__, *,
                 net: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgNetArgs']] = None,
                 operation_profiling: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs']] = None,
                 storage: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageArgs']] = None):
        """
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongocfgNetArgs'] net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs'] operation_profiling: A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option). The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageArgs'] storage: A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option). The structure is documented below.
        """
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def net(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgNetArgs']]:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
        return pulumi.get(self, "net")

    @net.setter
    def net(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgNetArgs']]):
        pulumi.set(self, "net", value)

    @property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs']]:
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option). The structure is documented below.
        """
        return pulumi.get(self, "operation_profiling")

    @operation_profiling.setter
    def operation_profiling(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs']]):
        pulumi.set(self, "operation_profiling", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageArgs']]:
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option). The structure is documented below.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongocfgNetArgsDict(TypedDict):
        max_incoming_connections: NotRequired[pulumi.Input[int]]
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongocfgNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongocfgNetArgs:
    def __init__(__self__, *,
                 max_incoming_connections: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")

    @max_incoming_connections.setter
    def max_incoming_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_incoming_connections", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        slow_op_threshold: NotRequired[pulumi.Input[int]]
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 slow_op_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        :param pulumi.Input[int] slow_op_threshold: The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_threshold")

    @slow_op_threshold.setter
    def slow_op_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slow_op_threshold", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongocfgStorageArgsDict(TypedDict):
        wired_tiger: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict']]
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts. The structure is documented below.
        """
elif False:
    MdbMongodbClusterClusterConfigMongocfgStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongocfgStorageArgs:
    def __init__(__self__, *,
                 wired_tiger: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs']] = None):
        """
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs'] wired_tiger: The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts. The structure is documented below.
        """
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs']]:
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts. The structure is documented below.
        """
        return pulumi.get(self, "wired_tiger")

    @wired_tiger.setter
    def wired_tiger(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs']]):
        pulumi.set(self, "wired_tiger", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict(TypedDict):
        cache_size_gb: NotRequired[pulumi.Input[float]]
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs:
    def __init__(__self__, *,
                 cache_size_gb: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] cache_size_gb: Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)

    @property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        return pulumi.get(self, "cache_size_gb")

    @cache_size_gb.setter
    def cache_size_gb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cache_size_gb", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodArgsDict(TypedDict):
        audit_log: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodAuditLogArgsDict']]
        """
        A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). The structure is documented below. Available only in enterprise edition.
        """
        net: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodNetArgsDict']]
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
        operation_profiling: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict']]
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option). The structure is documented below.
        """
        security: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityArgsDict']]
        """
        A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). The structure is documented below. Available only in enterprise edition.
        """
        set_parameter: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodSetParameterArgsDict']]
        """
        A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option). The structure is documented below.
        """
        storage: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageArgsDict']]
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option). The structure is documented below.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodArgs:
    def __init__(__self__, *,
                 audit_log: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodAuditLogArgs']] = None,
                 net: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodNetArgs']] = None,
                 operation_profiling: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodOperationProfilingArgs']] = None,
                 security: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityArgs']] = None,
                 set_parameter: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSetParameterArgs']] = None,
                 storage: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageArgs']] = None):
        """
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodAuditLogArgs'] audit_log: A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). The structure is documented below. Available only in enterprise edition.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodNetArgs'] net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodOperationProfilingArgs'] operation_profiling: A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option). The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityArgs'] security: A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). The structure is documented below. Available only in enterprise edition.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodSetParameterArgs'] set_parameter: A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option). The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageArgs'] storage: A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option). The structure is documented below.
        """
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if security is not None:
            pulumi.set(__self__, "security", security)
        if set_parameter is not None:
            pulumi.set(__self__, "set_parameter", set_parameter)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodAuditLogArgs']]:
        """
        A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_log")

    @audit_log.setter
    def audit_log(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodAuditLogArgs']]):
        pulumi.set(self, "audit_log", value)

    @property
    @pulumi.getter
    def net(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodNetArgs']]:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
        return pulumi.get(self, "net")

    @net.setter
    def net(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodNetArgs']]):
        pulumi.set(self, "net", value)

    @property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodOperationProfilingArgs']]:
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option). The structure is documented below.
        """
        return pulumi.get(self, "operation_profiling")

    @operation_profiling.setter
    def operation_profiling(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodOperationProfilingArgs']]):
        pulumi.set(self, "operation_profiling", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityArgs']]:
        """
        A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityArgs']]):
        pulumi.set(self, "security", value)

    @property
    @pulumi.getter(name="setParameter")
    def set_parameter(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSetParameterArgs']]:
        """
        A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option). The structure is documented below.
        """
        return pulumi.get(self, "set_parameter")

    @set_parameter.setter
    def set_parameter(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSetParameterArgs']]):
        pulumi.set(self, "set_parameter", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageArgs']]:
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option). The structure is documented below.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodAuditLogArgsDict(TypedDict):
        filter: NotRequired[pulumi.Input[str]]
        """
        Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        runtime_configuration: NotRequired[pulumi.Input[bool]]
        """
        Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodAuditLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodAuditLogArgs:
    def __init__(__self__, *,
                 filter: Optional[pulumi.Input[str]] = None,
                 runtime_configuration: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] filter: Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        :param pulumi.Input[bool] runtime_configuration: Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if runtime_configuration is not None:
            pulumi.set(__self__, "runtime_configuration", runtime_configuration)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="runtimeConfiguration")
    def runtime_configuration(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "runtime_configuration")

    @runtime_configuration.setter
    def runtime_configuration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_configuration", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodNetArgsDict(TypedDict):
        compressors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make "disabled" the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        max_incoming_connections: NotRequired[pulumi.Input[int]]
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodNetArgs:
    def __init__(__self__, *,
                 compressors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_incoming_connections: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compressors: Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make "disabled" the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        :param pulumi.Input[int] max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @property
    @pulumi.getter
    def compressors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make "disabled" the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        return pulumi.get(self, "compressors")

    @compressors.setter
    def compressors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compressors", value)

    @property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")

    @max_incoming_connections.setter
    def max_incoming_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_incoming_connections", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        slow_op_sample_rate: NotRequired[pulumi.Input[float]]
        """
        The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        """
        slow_op_threshold: NotRequired[pulumi.Input[int]]
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodOperationProfilingArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 slow_op_sample_rate: Optional[pulumi.Input[float]] = None,
                 slow_op_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        :param pulumi.Input[float] slow_op_sample_rate: The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        :param pulumi.Input[int] slow_op_threshold: The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_sample_rate is not None:
            pulumi.set(__self__, "slow_op_sample_rate", slow_op_sample_rate)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="slowOpSampleRate")
    def slow_op_sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_sample_rate")

    @slow_op_sample_rate.setter
    def slow_op_sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "slow_op_sample_rate", value)

    @property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_threshold")

    @slow_op_threshold.setter
    def slow_op_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slow_op_threshold", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodSecurityArgsDict(TypedDict):
        enable_encryption: NotRequired[pulumi.Input[bool]]
        """
        Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        kmip: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict']]
        """
        Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodSecurityArgs:
    def __init__(__self__, *,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 kmip: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityKmipArgs']] = None):
        """
        :param pulumi.Input[bool] enable_encryption: Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityKmipArgs'] kmip: Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if kmip is not None:
            pulumi.set(__self__, "kmip", kmip)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter
    def kmip(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityKmipArgs']]:
        """
        Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "kmip")

    @kmip.setter
    def kmip(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodSecurityKmipArgs']]):
        pulumi.set(self, "kmip", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict(TypedDict):
        client_certificate: NotRequired[pulumi.Input[str]]
        """
        String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        """
        key_identifier: NotRequired[pulumi.Input[str]]
        """
        Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        """
        server_ca: NotRequired[pulumi.Input[str]]
        """
        Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        """
        server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodSecurityKmipArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 key_identifier: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 server_ca: Optional[pulumi.Input[str]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        :param pulumi.Input[str] key_identifier: Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        :param pulumi.Input[int] port: Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        :param pulumi.Input[str] server_ca: Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        :param pulumi.Input[str] server_name: Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_ca is not None:
            pulumi.set(__self__, "server_ca", server_ca)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serverCa")
    def server_ca(self) -> Optional[pulumi.Input[str]]:
        """
        Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        """
        return pulumi.get(self, "server_ca")

    @server_ca.setter
    def server_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_ca", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodSetParameterArgsDict(TypedDict):
        audit_authorization_success: NotRequired[pulumi.Input[bool]]
        """
        Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        enable_flow_control: NotRequired[pulumi.Input[bool]]
        """
        Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        """
        min_snapshot_history_window_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodSetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodSetParameterArgs:
    def __init__(__self__, *,
                 audit_authorization_success: Optional[pulumi.Input[bool]] = None,
                 enable_flow_control: Optional[pulumi.Input[bool]] = None,
                 min_snapshot_history_window_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] audit_authorization_success: Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        :param pulumi.Input[bool] enable_flow_control: Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        :param pulumi.Input[int] min_snapshot_history_window_in_seconds: The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
        if audit_authorization_success is not None:
            pulumi.set(__self__, "audit_authorization_success", audit_authorization_success)
        if enable_flow_control is not None:
            pulumi.set(__self__, "enable_flow_control", enable_flow_control)
        if min_snapshot_history_window_in_seconds is not None:
            pulumi.set(__self__, "min_snapshot_history_window_in_seconds", min_snapshot_history_window_in_seconds)

    @property
    @pulumi.getter(name="auditAuthorizationSuccess")
    def audit_authorization_success(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_authorization_success")

    @audit_authorization_success.setter
    def audit_authorization_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "audit_authorization_success", value)

    @property
    @pulumi.getter(name="enableFlowControl")
    def enable_flow_control(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        """
        return pulumi.get(self, "enable_flow_control")

    @enable_flow_control.setter
    def enable_flow_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_flow_control", value)

    @property
    @pulumi.getter(name="minSnapshotHistoryWindowInSeconds")
    def min_snapshot_history_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
        return pulumi.get(self, "min_snapshot_history_window_in_seconds")

    @min_snapshot_history_window_in_seconds.setter
    def min_snapshot_history_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_snapshot_history_window_in_seconds", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodStorageArgsDict(TypedDict):
        journal: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageJournalArgsDict']]
        """
        The durability journal to ensure data files remain valid and recoverable. The structure is documented below.
        """
        wired_tiger: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict']]
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts. The structure is documented below.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodStorageArgs:
    def __init__(__self__, *,
                 journal: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageJournalArgs']] = None,
                 wired_tiger: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs']] = None):
        """
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageJournalArgs'] journal: The durability journal to ensure data files remain valid and recoverable. The structure is documented below.
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs'] wired_tiger: The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts. The structure is documented below.
        """
        if journal is not None:
            pulumi.set(__self__, "journal", journal)
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @property
    @pulumi.getter
    def journal(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageJournalArgs']]:
        """
        The durability journal to ensure data files remain valid and recoverable. The structure is documented below.
        """
        return pulumi.get(self, "journal")

    @journal.setter
    def journal(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageJournalArgs']]):
        pulumi.set(self, "journal", value)

    @property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs']]:
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts. The structure is documented below.
        """
        return pulumi.get(self, "wired_tiger")

    @wired_tiger.setter
    def wired_tiger(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs']]):
        pulumi.set(self, "wired_tiger", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodStorageJournalArgsDict(TypedDict):
        commit_interval: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodStorageJournalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodStorageJournalArgs:
    def __init__(__self__, *,
                 commit_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] commit_interval: The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
        if commit_interval is not None:
            pulumi.set(__self__, "commit_interval", commit_interval)

    @property
    @pulumi.getter(name="commitInterval")
    def commit_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
        return pulumi.get(self, "commit_interval")

    @commit_interval.setter
    def commit_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "commit_interval", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict(TypedDict):
        block_compressor: NotRequired[pulumi.Input[str]]
        """
        Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        """
        cache_size_gb: NotRequired[pulumi.Input[float]]
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        prefix_compression: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs:
    def __init__(__self__, *,
                 block_compressor: Optional[pulumi.Input[str]] = None,
                 cache_size_gb: Optional[pulumi.Input[float]] = None,
                 prefix_compression: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] block_compressor: Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        :param pulumi.Input[float] cache_size_gb: Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        :param pulumi.Input[bool] prefix_compression: Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
        if block_compressor is not None:
            pulumi.set(__self__, "block_compressor", block_compressor)
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)
        if prefix_compression is not None:
            pulumi.set(__self__, "prefix_compression", prefix_compression)

    @property
    @pulumi.getter(name="blockCompressor")
    def block_compressor(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        """
        return pulumi.get(self, "block_compressor")

    @block_compressor.setter
    def block_compressor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_compressor", value)

    @property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        return pulumi.get(self, "cache_size_gb")

    @cache_size_gb.setter
    def cache_size_gb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cache_size_gb", value)

    @property
    @pulumi.getter(name="prefixCompression")
    def prefix_compression(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
        return pulumi.get(self, "prefix_compression")

    @prefix_compression.setter
    def prefix_compression(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prefix_compression", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongosArgsDict(TypedDict):
        net: NotRequired[pulumi.Input['MdbMongodbClusterClusterConfigMongosNetArgsDict']]
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
elif False:
    MdbMongodbClusterClusterConfigMongosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongosArgs:
    def __init__(__self__, *,
                 net: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongosNetArgs']] = None):
        """
        :param pulumi.Input['MdbMongodbClusterClusterConfigMongosNetArgs'] net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
        if net is not None:
            pulumi.set(__self__, "net", net)

    @property
    @pulumi.getter
    def net(self) -> Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongosNetArgs']]:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option). The structure is documented below.
        """
        return pulumi.get(self, "net")

    @net.setter
    def net(self, value: Optional[pulumi.Input['MdbMongodbClusterClusterConfigMongosNetArgs']]):
        pulumi.set(self, "net", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigMongosNetArgsDict(TypedDict):
        compressors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make "disabled" the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        max_incoming_connections: NotRequired[pulumi.Input[int]]
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
elif False:
    MdbMongodbClusterClusterConfigMongosNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigMongosNetArgs:
    def __init__(__self__, *,
                 compressors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_incoming_connections: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compressors: Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make "disabled" the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        :param pulumi.Input[int] max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @property
    @pulumi.getter
    def compressors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make "disabled" the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        return pulumi.get(self, "compressors")

    @compressors.setter
    def compressors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compressors", value)

    @property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")

    @max_incoming_connections.setter
    def max_incoming_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_incoming_connections", value)


if not MYPY:
    class MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable performance diagnostics.
        """
elif False:
    MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable or disable performance diagnostics.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable performance diagnostics.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class MdbMongodbClusterDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the database.
        """
elif False:
    MdbMongodbClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MdbMongodbClusterDiskSizeAutoscalingMongocfgArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    MdbMongodbClusterDiskSizeAutoscalingMongocfgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterDiskSizeAutoscalingMongocfgArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param pulumi.Input[int] emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param pulumi.Input[int] planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbMongodbClusterDiskSizeAutoscalingMongodArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    MdbMongodbClusterDiskSizeAutoscalingMongodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterDiskSizeAutoscalingMongodArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param pulumi.Input[int] emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param pulumi.Input[int] planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbMongodbClusterDiskSizeAutoscalingMongoinfraArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    MdbMongodbClusterDiskSizeAutoscalingMongoinfraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterDiskSizeAutoscalingMongoinfraArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param pulumi.Input[int] emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param pulumi.Input[int] planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbMongodbClusterDiskSizeAutoscalingMongosArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    MdbMongodbClusterDiskSizeAutoscalingMongosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterDiskSizeAutoscalingMongosArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param pulumi.Input[int] emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param pulumi.Input[int] planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbMongodbClusterHostArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        zone_id: pulumi.Input[str]
        """
        The availability zone where the MongoDB host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Should this host have assigned public IP assigned. Can be either `true` or `false`.
        """
        health: NotRequired[pulumi.Input[str]]
        """
        The health of the host.
        """
        host_parameters: NotRequired[pulumi.Input['MdbMongodbClusterHostHostParametersArgsDict']]
        """
        The parameters of mongod host in replicaset.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host. Computed on server side.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        shard_name: NotRequired[pulumi.Input[str]]
        """
        The name of the shard to which the host belongs. Only for sharded cluster.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to mongod.
        """
elif False:
    MdbMongodbClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterHostArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 zone_id: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 health: Optional[pulumi.Input[str]] = None,
                 host_parameters: Optional[pulumi.Input['MdbMongodbClusterHostHostParametersArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 shard_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param pulumi.Input[str] zone_id: The availability zone where the MongoDB host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param pulumi.Input[bool] assign_public_ip: Should this host have assigned public IP assigned. Can be either `true` or `false`.
        :param pulumi.Input[str] health: The health of the host.
        :param pulumi.Input['MdbMongodbClusterHostHostParametersArgs'] host_parameters: The parameters of mongod host in replicaset.
        :param pulumi.Input[str] name: The fully qualified domain name of the host. Computed on server side.
        :param pulumi.Input[str] role: The role of the cluster (either PRIMARY or SECONDARY).
        :param pulumi.Input[str] shard_name: The name of the shard to which the host belongs. Only for sharded cluster.
        :param pulumi.Input[str] type: type of mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to mongod.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if host_parameters is not None:
            pulumi.set(__self__, "host_parameters", host_parameters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> pulumi.Input[str]:
        """
        The availability zone where the MongoDB host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this host have assigned public IP assigned. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input[str]]:
        """
        The health of the host.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="hostParameters")
    def host_parameters(self) -> Optional[pulumi.Input['MdbMongodbClusterHostHostParametersArgs']]:
        """
        The parameters of mongod host in replicaset.
        """
        return pulumi.get(self, "host_parameters")

    @host_parameters.setter
    def host_parameters(self, value: Optional[pulumi.Input['MdbMongodbClusterHostHostParametersArgs']]):
        pulumi.set(self, "host_parameters", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host. Computed on server side.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the shard to which the host belongs. Only for sharded cluster.
        """
        return pulumi.get(self, "shard_name")

    @shard_name.setter
    def shard_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shard_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to mongod.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MdbMongodbClusterHostHostParametersArgsDict(TypedDict):
        hidden: NotRequired[pulumi.Input[bool]]
        """
        Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden)
        """
        priority: NotRequired[pulumi.Input[float]]
        """
        A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority)
        """
        secondary_delay_secs: NotRequired[pulumi.Input[int]]
        """
        The number of seconds "behind" the primary that this replica set member should "lag". For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs)
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags)
        """
elif False:
    MdbMongodbClusterHostHostParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterHostHostParametersArgs:
    def __init__(__self__, *,
                 hidden: Optional[pulumi.Input[bool]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 secondary_delay_secs: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] hidden: Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden)
        :param pulumi.Input[float] priority: A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority)
        :param pulumi.Input[int] secondary_delay_secs: The number of seconds "behind" the primary that this replica set member should "lag". For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags)
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if secondary_delay_secs is not None:
            pulumi.set(__self__, "secondary_delay_secs", secondary_delay_secs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden)
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hidden", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority)
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="secondaryDelaySecs")
    def secondary_delay_secs(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds "behind" the primary that this replica set member should "lag". For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs)
        """
        return pulumi.get(self, "secondary_delay_secs")

    @secondary_delay_secs.setter
    def secondary_delay_secs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "secondary_delay_secs", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class MdbMongodbClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
elif False:
    MdbMongodbClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param pulumi.Input[int] hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbMongodbClusterResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbMongodbClusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
               
               The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbMongodbClusterResourcesMongocfgArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbMongodbClusterResourcesMongocfgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterResourcesMongocfgArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
               
               The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbMongodbClusterResourcesMongodArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbMongodbClusterResourcesMongodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterResourcesMongodArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
               
               The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbMongodbClusterResourcesMongoinfraArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbMongodbClusterResourcesMongoinfraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterResourcesMongoinfraArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
               
               The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbMongodbClusterResourcesMongosArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbMongodbClusterResourcesMongosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterResourcesMongosArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
               
               The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).

        The `disk_size_autoscaling_mongod`, `disk_size_autoscaling_mongos`, `disk_size_autoscaling_mongoinfra`, `disk_size_autoscaling_mongocfg` blocks support:
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbMongodbClusterRestoreArgsDict(TypedDict):
        backup_id: pulumi.Input[str]
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups)
        """
        time: NotRequired[pulumi.Input[str]]
        """
        Timestamp of the moment to which the MongoDB cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
elif False:
    MdbMongodbClusterRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterRestoreArgs:
    def __init__(__self__, *,
                 backup_id: pulumi.Input[str],
                 time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups)
        :param pulumi.Input[str] time: Timestamp of the moment to which the MongoDB cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> pulumi.Input[str]:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups)
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp of the moment to which the MongoDB cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class MdbMongodbClusterUserArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the user.
        """
        password: pulumi.Input[str]
        """
        The password of the user.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbMongodbClusterUserPermissionArgsDict']]]]
        """
        Set of permissions granted to the user. The structure is documented below.
        """
elif False:
    MdbMongodbClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbMongodbClusterUserPermissionArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the user.
        :param pulumi.Input[str] password: The password of the user.
        :param pulumi.Input[Sequence[pulumi.Input['MdbMongodbClusterUserPermissionArgs']]] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbMongodbClusterUserPermissionArgs']]]]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbMongodbClusterUserPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class MdbMongodbClusterUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database that the permission grants access to.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
elif False:
    MdbMongodbClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMongodbClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database that the permission grants access to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class MdbMysqlClusterAccessArgsDict(TypedDict):
        data_lens: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        data_transfer: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        web_sql: NotRequired[pulumi.Input[bool]]
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
elif False:
    MdbMysqlClusterAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[pulumi.Input[bool]] = None,
                 data_transfer: Optional[pulumi.Input[bool]] = None,
                 web_sql: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param pulumi.Input[bool] data_transfer: Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        :param pulumi.Input[bool] web_sql: Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_transfer", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_sql", value)


if not MYPY:
    class MdbMysqlClusterBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started.
        """
elif False:
    MdbMysqlClusterBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started.
        :param pulumi.Input[int] minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbMysqlClusterDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the database.
        """
elif False:
    MdbMysqlClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MdbMysqlClusterHostArgsDict(TypedDict):
        zone: pulumi.Input[str]
        """
        The availability zone where the MySQL host will be created.
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        """
        backup_priority: NotRequired[pulumi.Input[int]]
        """
        Host backup priority. Value is between 0 and 100, default is 0.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Host master promotion priority. Value is between 0 and 100, default is 0.
        """
        replication_source: NotRequired[pulumi.Input[str]]
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        replication_source_name: NotRequired[pulumi.Input[str]]
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
elif False:
    MdbMysqlClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterHostArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 backup_priority: Optional[pulumi.Input[int]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 replication_source: Optional[pulumi.Input[str]] = None,
                 replication_source_name: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] zone: The availability zone where the MySQL host will be created.
        :param pulumi.Input[bool] assign_public_ip: Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        :param pulumi.Input[int] backup_priority: Host backup priority. Value is between 0 and 100, default is 0.
        :param pulumi.Input[str] fqdn: The fully qualified domain name of the host.
        :param pulumi.Input[str] name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        :param pulumi.Input[int] priority: Host master promotion priority. Value is between 0 and 100, default is 0.
        :param pulumi.Input[str] replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param pulumi.Input[str] replication_source_name: Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if backup_priority is not None:
            pulumi.set(__self__, "backup_priority", backup_priority)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if replication_source is not None:
            pulumi.set(__self__, "replication_source", replication_source)
        if replication_source_name is not None:
            pulumi.set(__self__, "replication_source_name", replication_source_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        The availability zone where the MySQL host will be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="backupPriority")
    def backup_priority(self) -> Optional[pulumi.Input[int]]:
        """
        Host backup priority. Value is between 0 and 100, default is 0.
        """
        return pulumi.get(self, "backup_priority")

    @backup_priority.setter
    def backup_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_priority", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Host master promotion priority. Value is between 0 and 100, default is 0.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> Optional[pulumi.Input[str]]:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @replication_source.setter
    def replication_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_source", value)

    @property
    @pulumi.getter(name="replicationSourceName")
    def replication_source_name(self) -> Optional[pulumi.Input[str]]:
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "replication_source_name")

    @replication_source_name.setter
    def replication_source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_source_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MdbMysqlClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
elif False:
    MdbMysqlClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param pulumi.Input[int] hour: Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbMysqlClusterPerformanceDiagnosticsArgsDict(TypedDict):
        sessions_sampling_interval: pulumi.Input[int]
        """
        Interval (in seconds) for my_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        statements_sampling_interval: pulumi.Input[int]
        """
        Interval (in seconds) for my_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable performance diagnostics
        """
elif False:
    MdbMysqlClusterPerformanceDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterPerformanceDiagnosticsArgs:
    def __init__(__self__, *,
                 sessions_sampling_interval: pulumi.Input[int],
                 statements_sampling_interval: pulumi.Input[int],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] sessions_sampling_interval: Interval (in seconds) for my_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        :param pulumi.Input[int] statements_sampling_interval: Interval (in seconds) for my_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        :param pulumi.Input[bool] enabled: Enable performance diagnostics
        """
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> pulumi.Input[int]:
        """
        Interval (in seconds) for my_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @sessions_sampling_interval.setter
    def sessions_sampling_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "sessions_sampling_interval", value)

    @property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> pulumi.Input[int]:
        """
        Interval (in seconds) for my_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")

    @statements_sampling_interval.setter
    def statements_sampling_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "statements_sampling_interval", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable performance diagnostics
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class MdbMysqlClusterResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a MySQL host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of MySQL hosts.
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbMysqlClusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a MySQL host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of MySQL hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a MySQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of MySQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbMysqlClusterRestoreArgsDict(TypedDict):
        backup_id: pulumi.Input[str]
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://cloud.yandex.com/docs/managed-mysql/operations/cluster-backups).
        """
        time: NotRequired[pulumi.Input[str]]
        """
        Timestamp of the moment to which the MySQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
elif False:
    MdbMysqlClusterRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterRestoreArgs:
    def __init__(__self__, *,
                 backup_id: pulumi.Input[str],
                 time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://cloud.yandex.com/docs/managed-mysql/operations/cluster-backups).
        :param pulumi.Input[str] time: Timestamp of the moment to which the MySQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> pulumi.Input[str]:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://cloud.yandex.com/docs/managed-mysql/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp of the moment to which the MySQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class MdbMysqlClusterUserArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the user.
        """
        password: pulumi.Input[str]
        """
        The password of the user.
        """
        authentication_plugin: NotRequired[pulumi.Input[str]]
        """
        Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`)
        """
        connection_limits: NotRequired[pulumi.Input['MdbMysqlClusterUserConnectionLimitsArgsDict']]
        """
        User's connection limits. The structure is documented below. If the attribute is not specified there will be no changes.
        """
        global_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List user's global permissions 
        Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` for clear list use empty list. If the attribute is not specified there will be no changes.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbMysqlClusterUserPermissionArgsDict']]]]
        """
        Set of permissions granted to the user. The structure is documented below.
        """
elif False:
    MdbMysqlClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 authentication_plugin: Optional[pulumi.Input[str]] = None,
                 connection_limits: Optional[pulumi.Input['MdbMysqlClusterUserConnectionLimitsArgs']] = None,
                 global_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbMysqlClusterUserPermissionArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the user.
        :param pulumi.Input[str] password: The password of the user.
        :param pulumi.Input[str] authentication_plugin: Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`)
        :param pulumi.Input['MdbMysqlClusterUserConnectionLimitsArgs'] connection_limits: User's connection limits. The structure is documented below. If the attribute is not specified there will be no changes.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] global_permissions: List user's global permissions 
               Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` for clear list use empty list. If the attribute is not specified there will be no changes.
        :param pulumi.Input[Sequence[pulumi.Input['MdbMysqlClusterUserPermissionArgs']]] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if authentication_plugin is not None:
            pulumi.set(__self__, "authentication_plugin", authentication_plugin)
        if connection_limits is not None:
            pulumi.set(__self__, "connection_limits", connection_limits)
        if global_permissions is not None:
            pulumi.set(__self__, "global_permissions", global_permissions)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="authenticationPlugin")
    def authentication_plugin(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`)
        """
        return pulumi.get(self, "authentication_plugin")

    @authentication_plugin.setter
    def authentication_plugin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_plugin", value)

    @property
    @pulumi.getter(name="connectionLimits")
    def connection_limits(self) -> Optional[pulumi.Input['MdbMysqlClusterUserConnectionLimitsArgs']]:
        """
        User's connection limits. The structure is documented below. If the attribute is not specified there will be no changes.
        """
        return pulumi.get(self, "connection_limits")

    @connection_limits.setter
    def connection_limits(self, value: Optional[pulumi.Input['MdbMysqlClusterUserConnectionLimitsArgs']]):
        pulumi.set(self, "connection_limits", value)

    @property
    @pulumi.getter(name="globalPermissions")
    def global_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List user's global permissions 
        Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` for clear list use empty list. If the attribute is not specified there will be no changes.
        """
        return pulumi.get(self, "global_permissions")

    @global_permissions.setter
    def global_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "global_permissions", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbMysqlClusterUserPermissionArgs']]]]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbMysqlClusterUserPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class MdbMysqlClusterUserConnectionLimitsArgsDict(TypedDict):
        max_connections_per_hour: NotRequired[pulumi.Input[int]]
        """
        Max connections per hour.
        """
        max_questions_per_hour: NotRequired[pulumi.Input[int]]
        """
        Max questions per hour.
        """
        max_updates_per_hour: NotRequired[pulumi.Input[int]]
        """
        Max updates per hour.
        """
        max_user_connections: NotRequired[pulumi.Input[int]]
        """
        Max user connections.
        """
elif False:
    MdbMysqlClusterUserConnectionLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterUserConnectionLimitsArgs:
    def __init__(__self__, *,
                 max_connections_per_hour: Optional[pulumi.Input[int]] = None,
                 max_questions_per_hour: Optional[pulumi.Input[int]] = None,
                 max_updates_per_hour: Optional[pulumi.Input[int]] = None,
                 max_user_connections: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_connections_per_hour: Max connections per hour.
        :param pulumi.Input[int] max_questions_per_hour: Max questions per hour.
        :param pulumi.Input[int] max_updates_per_hour: Max updates per hour.
        :param pulumi.Input[int] max_user_connections: Max user connections.
        """
        if max_connections_per_hour is not None:
            pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        if max_questions_per_hour is not None:
            pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        if max_updates_per_hour is not None:
            pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        if max_user_connections is not None:
            pulumi.set(__self__, "max_user_connections", max_user_connections)

    @property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @max_connections_per_hour.setter
    def max_connections_per_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections_per_hour", value)

    @property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @max_questions_per_hour.setter
    def max_questions_per_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_questions_per_hour", value)

    @property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @max_updates_per_hour.setter
    def max_updates_per_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_updates_per_hour", value)

    @property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")

    @max_user_connections.setter
    def max_user_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_user_connections", value)


if not MYPY:
    class MdbMysqlClusterUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database that the permission grants access to.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
elif False:
    MdbMysqlClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database that the permission grants access to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class MdbMysqlUserConnectionLimitsArgsDict(TypedDict):
        max_connections_per_hour: NotRequired[pulumi.Input[int]]
        """
        Max connections per hour.
        """
        max_questions_per_hour: NotRequired[pulumi.Input[int]]
        """
        Max questions per hour.
        """
        max_updates_per_hour: NotRequired[pulumi.Input[int]]
        """
        Max updates per hour.
        """
        max_user_connections: NotRequired[pulumi.Input[int]]
        """
        Max user connections.
        """
elif False:
    MdbMysqlUserConnectionLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlUserConnectionLimitsArgs:
    def __init__(__self__, *,
                 max_connections_per_hour: Optional[pulumi.Input[int]] = None,
                 max_questions_per_hour: Optional[pulumi.Input[int]] = None,
                 max_updates_per_hour: Optional[pulumi.Input[int]] = None,
                 max_user_connections: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_connections_per_hour: Max connections per hour.
        :param pulumi.Input[int] max_questions_per_hour: Max questions per hour.
        :param pulumi.Input[int] max_updates_per_hour: Max updates per hour.
        :param pulumi.Input[int] max_user_connections: Max user connections.
        """
        if max_connections_per_hour is not None:
            pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        if max_questions_per_hour is not None:
            pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        if max_updates_per_hour is not None:
            pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        if max_user_connections is not None:
            pulumi.set(__self__, "max_user_connections", max_user_connections)

    @property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @max_connections_per_hour.setter
    def max_connections_per_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections_per_hour", value)

    @property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @max_questions_per_hour.setter
    def max_questions_per_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_questions_per_hour", value)

    @property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @max_updates_per_hour.setter
    def max_updates_per_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_updates_per_hour", value)

    @property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")

    @max_user_connections.setter
    def max_user_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_user_connections", value)


if not MYPY:
    class MdbMysqlUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database that the permission grants access to.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
elif False:
    MdbMysqlUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbMysqlUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database that the permission grants access to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class MdbPostgresqlClusterConfigArgsDict(TypedDict):
        resources: pulumi.Input['MdbPostgresqlClusterConfigResourcesArgsDict']
        """
        Resources allocated to hosts of the PostgreSQL cluster. The structure is documented below.
        """
        version: pulumi.Input[str]
        """
        Version of the PostgreSQL cluster. (allowed versions are: 10, 10-1c, 11, 11-1c, 12, 12-1c, 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17)
        """
        access: NotRequired[pulumi.Input['MdbPostgresqlClusterConfigAccessArgsDict']]
        """
        Access policy to the PostgreSQL cluster. The structure is documented below.
        """
        autofailover: NotRequired[pulumi.Input[bool]]
        """
        Configuration setting which enables/disables autofailover in cluster.
        """
        backup_retain_period_days: NotRequired[pulumi.Input[int]]
        """
        The period in days during which backups are stored.
        """
        backup_window_start: NotRequired[pulumi.Input['MdbPostgresqlClusterConfigBackupWindowStartArgsDict']]
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        disk_size_autoscaling: NotRequired[pulumi.Input['MdbPostgresqlClusterConfigDiskSizeAutoscalingArgsDict']]
        """
        Cluster disk size autoscaling settings. The structure is documented below.
        """
        performance_diagnostics: NotRequired[pulumi.Input['MdbPostgresqlClusterConfigPerformanceDiagnosticsArgsDict']]
        """
        Cluster performance diagnostics settings. The structure is documented below. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics)
        """
        pooler_config: NotRequired[pulumi.Input['MdbPostgresqlClusterConfigPoolerConfigArgsDict']]
        """
        Configuration of the connection pooler. The structure is documented below.
        """
        postgresql_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        PostgreSQL cluster config. Detail info in "postresql config" section (documented below).
        """
elif False:
    MdbPostgresqlClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['MdbPostgresqlClusterConfigResourcesArgs'],
                 version: pulumi.Input[str],
                 access: Optional[pulumi.Input['MdbPostgresqlClusterConfigAccessArgs']] = None,
                 autofailover: Optional[pulumi.Input[bool]] = None,
                 backup_retain_period_days: Optional[pulumi.Input[int]] = None,
                 backup_window_start: Optional[pulumi.Input['MdbPostgresqlClusterConfigBackupWindowStartArgs']] = None,
                 disk_size_autoscaling: Optional[pulumi.Input['MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs']] = None,
                 performance_diagnostics: Optional[pulumi.Input['MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs']] = None,
                 pooler_config: Optional[pulumi.Input['MdbPostgresqlClusterConfigPoolerConfigArgs']] = None,
                 postgresql_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['MdbPostgresqlClusterConfigResourcesArgs'] resources: Resources allocated to hosts of the PostgreSQL cluster. The structure is documented below.
        :param pulumi.Input[str] version: Version of the PostgreSQL cluster. (allowed versions are: 10, 10-1c, 11, 11-1c, 12, 12-1c, 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17)
        :param pulumi.Input['MdbPostgresqlClusterConfigAccessArgs'] access: Access policy to the PostgreSQL cluster. The structure is documented below.
        :param pulumi.Input[bool] autofailover: Configuration setting which enables/disables autofailover in cluster.
        :param pulumi.Input[int] backup_retain_period_days: The period in days during which backups are stored.
        :param pulumi.Input['MdbPostgresqlClusterConfigBackupWindowStartArgs'] backup_window_start: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param pulumi.Input['MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs'] disk_size_autoscaling: Cluster disk size autoscaling settings. The structure is documented below.
        :param pulumi.Input['MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs'] performance_diagnostics: Cluster performance diagnostics settings. The structure is documented below. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics)
        :param pulumi.Input['MdbPostgresqlClusterConfigPoolerConfigArgs'] pooler_config: Configuration of the connection pooler. The structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] postgresql_config: PostgreSQL cluster config. Detail info in "postresql config" section (documented below).
        """
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "version", version)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if autofailover is not None:
            pulumi.set(__self__, "autofailover", autofailover)
        if backup_retain_period_days is not None:
            pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if disk_size_autoscaling is not None:
            pulumi.set(__self__, "disk_size_autoscaling", disk_size_autoscaling)
        if performance_diagnostics is not None:
            pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)
        if pooler_config is not None:
            pulumi.set(__self__, "pooler_config", pooler_config)
        if postgresql_config is not None:
            pulumi.set(__self__, "postgresql_config", postgresql_config)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MdbPostgresqlClusterConfigResourcesArgs']:
        """
        Resources allocated to hosts of the PostgreSQL cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MdbPostgresqlClusterConfigResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the PostgreSQL cluster. (allowed versions are: 10, 10-1c, 11, 11-1c, 12, 12-1c, 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17)
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['MdbPostgresqlClusterConfigAccessArgs']]:
        """
        Access policy to the PostgreSQL cluster. The structure is documented below.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['MdbPostgresqlClusterConfigAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def autofailover(self) -> Optional[pulumi.Input[bool]]:
        """
        Configuration setting which enables/disables autofailover in cluster.
        """
        return pulumi.get(self, "autofailover")

    @autofailover.setter
    def autofailover(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autofailover", value)

    @property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        The period in days during which backups are stored.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @backup_retain_period_days.setter
    def backup_retain_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_retain_period_days", value)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional[pulumi.Input['MdbPostgresqlClusterConfigBackupWindowStartArgs']]:
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_start")

    @backup_window_start.setter
    def backup_window_start(self, value: Optional[pulumi.Input['MdbPostgresqlClusterConfigBackupWindowStartArgs']]):
        pulumi.set(self, "backup_window_start", value)

    @property
    @pulumi.getter(name="diskSizeAutoscaling")
    def disk_size_autoscaling(self) -> Optional[pulumi.Input['MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs']]:
        """
        Cluster disk size autoscaling settings. The structure is documented below.
        """
        return pulumi.get(self, "disk_size_autoscaling")

    @disk_size_autoscaling.setter
    def disk_size_autoscaling(self, value: Optional[pulumi.Input['MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs']]):
        pulumi.set(self, "disk_size_autoscaling", value)

    @property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> Optional[pulumi.Input['MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs']]:
        """
        Cluster performance diagnostics settings. The structure is documented below. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics)
        """
        return pulumi.get(self, "performance_diagnostics")

    @performance_diagnostics.setter
    def performance_diagnostics(self, value: Optional[pulumi.Input['MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs']]):
        pulumi.set(self, "performance_diagnostics", value)

    @property
    @pulumi.getter(name="poolerConfig")
    def pooler_config(self) -> Optional[pulumi.Input['MdbPostgresqlClusterConfigPoolerConfigArgs']]:
        """
        Configuration of the connection pooler. The structure is documented below.
        """
        return pulumi.get(self, "pooler_config")

    @pooler_config.setter
    def pooler_config(self, value: Optional[pulumi.Input['MdbPostgresqlClusterConfigPoolerConfigArgs']]):
        pulumi.set(self, "pooler_config", value)

    @property
    @pulumi.getter(name="postgresqlConfig")
    def postgresql_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        PostgreSQL cluster config. Detail info in "postresql config" section (documented below).
        """
        return pulumi.get(self, "postgresql_config")

    @postgresql_config.setter
    def postgresql_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "postgresql_config", value)


if not MYPY:
    class MdbPostgresqlClusterConfigAccessArgsDict(TypedDict):
        data_lens: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        data_transfer: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        serverless: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [connection to managed databases from functions](https://cloud.yandex.com/docs/functions/operations/database-connection)
        """
        web_sql: NotRequired[pulumi.Input[bool]]
        """
        Allow access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-postgresql/operations/web-sql-query)
        """
elif False:
    MdbPostgresqlClusterConfigAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[pulumi.Input[bool]] = None,
                 data_transfer: Optional[pulumi.Input[bool]] = None,
                 serverless: Optional[pulumi.Input[bool]] = None,
                 web_sql: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param pulumi.Input[bool] data_transfer: Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        :param pulumi.Input[bool] serverless: Allow access for [connection to managed databases from functions](https://cloud.yandex.com/docs/functions/operations/database-connection)
        :param pulumi.Input[bool] web_sql: Allow access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-postgresql/operations/web-sql-query)
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_transfer", value)

    @property
    @pulumi.getter
    def serverless(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [connection to managed databases from functions](https://cloud.yandex.com/docs/functions/operations/database-connection)
        """
        return pulumi.get(self, "serverless")

    @serverless.setter
    def serverless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serverless", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-postgresql/operations/web-sql-query)
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_sql", value)


if not MYPY:
    class MdbPostgresqlClusterConfigBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started (UTC).
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started (UTC).
        """
elif False:
    MdbPostgresqlClusterConfigBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started (UTC).
        :param pulumi.Input[int] minutes: The minute at which backup will be started (UTC).
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbPostgresqlClusterConfigDiskSizeAutoscalingArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    MdbPostgresqlClusterConfigDiskSizeAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param pulumi.Input[int] emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param pulumi.Input[int] planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbPostgresqlClusterConfigPerformanceDiagnosticsArgsDict(TypedDict):
        sessions_sampling_interval: pulumi.Input[int]
        """
        Interval (in seconds) for pg_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        statements_sampling_interval: pulumi.Input[int]
        """
        Interval (in seconds) for pg_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable performance diagnostics
        """
elif False:
    MdbPostgresqlClusterConfigPerformanceDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs:
    def __init__(__self__, *,
                 sessions_sampling_interval: pulumi.Input[int],
                 statements_sampling_interval: pulumi.Input[int],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] sessions_sampling_interval: Interval (in seconds) for pg_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        :param pulumi.Input[int] statements_sampling_interval: Interval (in seconds) for pg_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        :param pulumi.Input[bool] enabled: Enable performance diagnostics
        """
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> pulumi.Input[int]:
        """
        Interval (in seconds) for pg_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @sessions_sampling_interval.setter
    def sessions_sampling_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "sessions_sampling_interval", value)

    @property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> pulumi.Input[int]:
        """
        Interval (in seconds) for pg_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")

    @statements_sampling_interval.setter
    def statements_sampling_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "statements_sampling_interval", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable performance diagnostics
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class MdbPostgresqlClusterConfigPoolerConfigArgsDict(TypedDict):
        pool_discard: NotRequired[pulumi.Input[bool]]
        """
        Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        """
        pooling_mode: NotRequired[pulumi.Input[str]]
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
elif False:
    MdbPostgresqlClusterConfigPoolerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigPoolerConfigArgs:
    def __init__(__self__, *,
                 pool_discard: Optional[pulumi.Input[bool]] = None,
                 pooling_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] pool_discard: Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        :param pulumi.Input[str] pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        if pool_discard is not None:
            pulumi.set(__self__, "pool_discard", pool_discard)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="poolDiscard")
    def pool_discard(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        """
        return pulumi.get(self, "pool_discard")

    @pool_discard.setter
    def pool_discard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pool_discard", value)

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")

    @pooling_mode.setter
    def pooling_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pooling_mode", value)


if not MYPY:
    class MdbPostgresqlClusterConfigResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a PostgreSQL host, in gigabytes.
        """
        resource_preset_id: pulumi.Input[str]
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of PostgreSQL hosts.
        """
elif False:
    MdbPostgresqlClusterConfigResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterConfigResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 resource_preset_id: pulumi.Input[str],
                 disk_type_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a PostgreSQL host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of PostgreSQL hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a PostgreSQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of PostgreSQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)


if not MYPY:
    class MdbPostgresqlClusterDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        owner: pulumi.Input[str]
        extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterDatabaseExtensionArgsDict']]]]
        lc_collate: NotRequired[pulumi.Input[str]]
        lc_type: NotRequired[pulumi.Input[str]]
        template_db: NotRequired[pulumi.Input[str]]
elif False:
    MdbPostgresqlClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 owner: pulumi.Input[str],
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterDatabaseExtensionArgs']]]] = None,
                 lc_collate: Optional[pulumi.Input[str]] = None,
                 lc_type: Optional[pulumi.Input[str]] = None,
                 template_db: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if lc_collate is not None:
            pulumi.set(__self__, "lc_collate", lc_collate)
        if lc_type is not None:
            pulumi.set(__self__, "lc_type", lc_type)
        if template_db is not None:
            pulumi.set(__self__, "template_db", template_db)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> pulumi.Input[str]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterDatabaseExtensionArgs']]]]:
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterDatabaseExtensionArgs']]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter(name="lcCollate")
    def lc_collate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lc_collate")

    @lc_collate.setter
    def lc_collate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lc_collate", value)

    @property
    @pulumi.getter(name="lcType")
    def lc_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lc_type")

    @lc_type.setter
    def lc_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lc_type", value)

    @property
    @pulumi.getter(name="templateDb")
    def template_db(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "template_db")

    @template_db.setter
    def template_db(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_db", value)


if not MYPY:
    class MdbPostgresqlClusterDatabaseExtensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the PostgreSQL cluster. (allowed versions are: 10, 10-1c, 11, 11-1c, 12, 12-1c, 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17)
        """
elif False:
    MdbPostgresqlClusterDatabaseExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterDatabaseExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        :param pulumi.Input[str] version: Version of the PostgreSQL cluster. (allowed versions are: 10, 10-1c, 11, 11-1c, 12, 12-1c, 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17)
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the PostgreSQL cluster. (allowed versions are: 10, 10-1c, 11, 11-1c, 12, 12-1c, 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17)
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MdbPostgresqlClusterHostArgsDict(TypedDict):
        zone: pulumi.Input[str]
        """
        The availability zone where the PostgreSQL host will be created.
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the host should get a public IP address on creation. It can be changed on the fly only when `name` is set.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please see `replication_source_name` parameter.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Host priority in HA group. It works only when `name` is set.
        """
        replication_source: NotRequired[pulumi.Input[str]]
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        replication_source_name: NotRequired[pulumi.Input[str]]
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        role: NotRequired[pulumi.Input[str]]
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
elif False:
    MdbPostgresqlClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterHostArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 replication_source: Optional[pulumi.Input[str]] = None,
                 replication_source_name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] zone: The availability zone where the PostgreSQL host will be created.
        :param pulumi.Input[bool] assign_public_ip: Sets whether the host should get a public IP address on creation. It can be changed on the fly only when `name` is set.
        :param pulumi.Input[str] fqdn: The fully qualified domain name of the host.
        :param pulumi.Input[str] name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please see `replication_source_name` parameter.
        :param pulumi.Input[int] priority: Host priority in HA group. It works only when `name` is set.
        :param pulumi.Input[str] replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param pulumi.Input[str] replication_source_name: Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            warnings.warn("""The field has not affected anything. You can safely delete it.""", DeprecationWarning)
            pulumi.log.warn("""priority is deprecated: The field has not affected anything. You can safely delete it.""")
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if replication_source is not None:
            pulumi.set(__self__, "replication_source", replication_source)
        if replication_source_name is not None:
            pulumi.set(__self__, "replication_source_name", replication_source_name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        The availability zone where the PostgreSQL host will be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the host should get a public IP address on creation. It can be changed on the fly only when `name` is set.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please see `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The field has not affected anything. You can safely delete it.""")
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Host priority in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> Optional[pulumi.Input[str]]:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @replication_source.setter
    def replication_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_source", value)

    @property
    @pulumi.getter(name="replicationSourceName")
    def replication_source_name(self) -> Optional[pulumi.Input[str]]:
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "replication_source_name")

    @replication_source_name.setter
    def replication_source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_source_name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MdbPostgresqlClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
elif False:
    MdbPostgresqlClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param pulumi.Input[int] hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbPostgresqlClusterRestoreArgsDict(TypedDict):
        backup_id: pulumi.Input[str]
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://cloud.yandex.com/docs/managed-postgresql/operations/cluster-backups).
        """
        time: NotRequired[pulumi.Input[str]]
        """
        Timestamp of the moment to which the PostgreSQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        time_inclusive: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether a database should be restored to the first backup point available just after the timestamp specified in the [time] field instead of just before.
        Possible values:
        - false (default)  the restore point refers to the first backup moment before [time].
        - true  the restore point refers to the first backup point after [time].
        """
elif False:
    MdbPostgresqlClusterRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterRestoreArgs:
    def __init__(__self__, *,
                 backup_id: pulumi.Input[str],
                 time: Optional[pulumi.Input[str]] = None,
                 time_inclusive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://cloud.yandex.com/docs/managed-postgresql/operations/cluster-backups).
        :param pulumi.Input[str] time: Timestamp of the moment to which the PostgreSQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        :param pulumi.Input[bool] time_inclusive: Flag that indicates whether a database should be restored to the first backup point available just after the timestamp specified in the [time] field instead of just before.
               Possible values:
               - false (default)  the restore point refers to the first backup moment before [time].
               - true  the restore point refers to the first backup point after [time].
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if time_inclusive is not None:
            pulumi.set(__self__, "time_inclusive", time_inclusive)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> pulumi.Input[str]:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://cloud.yandex.com/docs/managed-postgresql/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp of the moment to which the PostgreSQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter(name="timeInclusive")
    def time_inclusive(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether a database should be restored to the first backup point available just after the timestamp specified in the [time] field instead of just before.
        Possible values:
        - false (default)  the restore point refers to the first backup moment before [time].
        - true  the restore point refers to the first backup point after [time].
        """
        return pulumi.get(self, "time_inclusive")

    @time_inclusive.setter
    def time_inclusive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "time_inclusive", value)


if not MYPY:
    class MdbPostgresqlClusterUserArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        password: pulumi.Input[str]
        conn_limit: NotRequired[pulumi.Input[int]]
        grants: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        login: NotRequired[pulumi.Input[bool]]
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterUserPermissionArgsDict']]]]
        settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    MdbPostgresqlClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 conn_limit: Optional[pulumi.Input[int]] = None,
                 grants: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login: Optional[pulumi.Input[bool]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterUserPermissionArgs']]]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if conn_limit is not None:
            pulumi.set(__self__, "conn_limit", conn_limit)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the PostgreSQL cluster. Provided by the client when the cluster is created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="connLimit")
    def conn_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "conn_limit")

    @conn_limit.setter
    def conn_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "conn_limit", value)

    @property
    @pulumi.getter
    def grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "grants")

    @grants.setter
    def grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grants", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterUserPermissionArgs']]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbPostgresqlClusterUserPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class MdbPostgresqlClusterUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
elif False:
    MdbPostgresqlClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str]):
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class MdbPostgresqlDatabaseExtensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the database extension. For more information on available extensions see [the official documentation](https://cloud.yandex.com/docs/managed-postgresql/operations/cluster-extensions).
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the extension.
        """
elif False:
    MdbPostgresqlDatabaseExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlDatabaseExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the database extension. For more information on available extensions see [the official documentation](https://cloud.yandex.com/docs/managed-postgresql/operations/cluster-extensions).
        :param pulumi.Input[str] version: Version of the extension.
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the database extension. For more information on available extensions see [the official documentation](https://cloud.yandex.com/docs/managed-postgresql/operations/cluster-extensions).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the extension.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MdbPostgresqlUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database that the permission grants access to.
        """
elif False:
    MdbPostgresqlUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbPostgresqlUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class MdbRedisClusterAccessArgsDict(TypedDict):
        data_lens: NotRequired[pulumi.Input[bool]]
        """
        Allow access for DataLens. Can be either `true` or `false`.
        """
        web_sql: NotRequired[pulumi.Input[bool]]
        """
        Allow access for Web SQL. Can be either `true` or `false`.
        """
elif False:
    MdbRedisClusterAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[pulumi.Input[bool]] = None,
                 web_sql: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] data_lens: Allow access for DataLens. Can be either `true` or `false`.
        :param pulumi.Input[bool] web_sql: Allow access for Web SQL. Can be either `true` or `false`.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for DataLens. Can be either `true` or `false`.
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow access for Web SQL. Can be either `true` or `false`.
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_sql", value)


if not MYPY:
    class MdbRedisClusterConfigArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        Password for the Redis cluster.
        """
        version: pulumi.Input[str]
        """
        Version of Redis (6.2).
        """
        allow_data_loss: NotRequired[pulumi.Input[bool]]
        """
        Allows some data to be lost in favor of faster switchover/restart by RDSync.
        """
        backup_window_start: NotRequired[pulumi.Input['MdbRedisClusterConfigBackupWindowStartArgsDict']]
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        client_output_buffer_limit_normal: NotRequired[pulumi.Input[str]]
        """
        Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        """
        client_output_buffer_limit_pubsub: NotRequired[pulumi.Input[str]]
        """
        Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        """
        cluster_allow_pubsubshard_when_down: NotRequired[pulumi.Input[bool]]
        """
        Permits Pub/Sub shard operations when cluster is down.
        """
        cluster_allow_reads_when_down: NotRequired[pulumi.Input[bool]]
        """
        Allows read operations when cluster is down.
        """
        cluster_require_full_coverage: NotRequired[pulumi.Input[bool]]
        """
        Controls whether all hash slots must be covered by nodes.
        """
        databases: NotRequired[pulumi.Input[int]]
        """
        Number of databases (changing requires redis-server restart).
        """
        io_threads_allowed: NotRequired[pulumi.Input[bool]]
        """
        Allow Redis to use io-threads.
        """
        lfu_decay_time: NotRequired[pulumi.Input[int]]
        """
        The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        """
        lfu_log_factor: NotRequired[pulumi.Input[int]]
        """
        Determines how the frequency counter represents key hits.
        """
        lua_time_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum time in milliseconds for Lua scripts.
        """
        maxmemory_percent: NotRequired[pulumi.Input[int]]
        """
        Redis maxmemory usage in percent
        """
        maxmemory_policy: NotRequired[pulumi.Input[str]]
        """
        Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        """
        notify_keyspace_events: NotRequired[pulumi.Input[str]]
        """
        Select the events that Redis will notify among a set of classes.
        """
        repl_backlog_size_percent: NotRequired[pulumi.Input[int]]
        """
        Replication backlog size as a percentage of flavor maxmemory.
        """
        slowlog_log_slower_than: NotRequired[pulumi.Input[int]]
        """
        Log slow queries below this number in microseconds.
        """
        slowlog_max_len: NotRequired[pulumi.Input[int]]
        """
        Slow queries log length.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        Close the connection after a client is idle for N seconds.
        """
        turn_before_switchover: NotRequired[pulumi.Input[bool]]
        """
        Allows to turn before switchover in RDSync.
        """
        use_luajit: NotRequired[pulumi.Input[bool]]
        """
        Use JIT for lua scripts and functions.
        """
elif False:
    MdbRedisClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterConfigArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 version: pulumi.Input[str],
                 allow_data_loss: Optional[pulumi.Input[bool]] = None,
                 backup_window_start: Optional[pulumi.Input['MdbRedisClusterConfigBackupWindowStartArgs']] = None,
                 client_output_buffer_limit_normal: Optional[pulumi.Input[str]] = None,
                 client_output_buffer_limit_pubsub: Optional[pulumi.Input[str]] = None,
                 cluster_allow_pubsubshard_when_down: Optional[pulumi.Input[bool]] = None,
                 cluster_allow_reads_when_down: Optional[pulumi.Input[bool]] = None,
                 cluster_require_full_coverage: Optional[pulumi.Input[bool]] = None,
                 databases: Optional[pulumi.Input[int]] = None,
                 io_threads_allowed: Optional[pulumi.Input[bool]] = None,
                 lfu_decay_time: Optional[pulumi.Input[int]] = None,
                 lfu_log_factor: Optional[pulumi.Input[int]] = None,
                 lua_time_limit: Optional[pulumi.Input[int]] = None,
                 maxmemory_percent: Optional[pulumi.Input[int]] = None,
                 maxmemory_policy: Optional[pulumi.Input[str]] = None,
                 notify_keyspace_events: Optional[pulumi.Input[str]] = None,
                 repl_backlog_size_percent: Optional[pulumi.Input[int]] = None,
                 slowlog_log_slower_than: Optional[pulumi.Input[int]] = None,
                 slowlog_max_len: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 turn_before_switchover: Optional[pulumi.Input[bool]] = None,
                 use_luajit: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] password: Password for the Redis cluster.
        :param pulumi.Input[str] version: Version of Redis (6.2).
        :param pulumi.Input[bool] allow_data_loss: Allows some data to be lost in favor of faster switchover/restart by RDSync.
        :param pulumi.Input['MdbRedisClusterConfigBackupWindowStartArgs'] backup_window_start: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param pulumi.Input[str] client_output_buffer_limit_normal: Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        :param pulumi.Input[str] client_output_buffer_limit_pubsub: Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        :param pulumi.Input[bool] cluster_allow_pubsubshard_when_down: Permits Pub/Sub shard operations when cluster is down.
        :param pulumi.Input[bool] cluster_allow_reads_when_down: Allows read operations when cluster is down.
        :param pulumi.Input[bool] cluster_require_full_coverage: Controls whether all hash slots must be covered by nodes.
        :param pulumi.Input[int] databases: Number of databases (changing requires redis-server restart).
        :param pulumi.Input[bool] io_threads_allowed: Allow Redis to use io-threads.
        :param pulumi.Input[int] lfu_decay_time: The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        :param pulumi.Input[int] lfu_log_factor: Determines how the frequency counter represents key hits.
        :param pulumi.Input[int] lua_time_limit: Maximum time in milliseconds for Lua scripts.
        :param pulumi.Input[int] maxmemory_percent: Redis maxmemory usage in percent
        :param pulumi.Input[str] maxmemory_policy: Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        :param pulumi.Input[str] notify_keyspace_events: Select the events that Redis will notify among a set of classes.
        :param pulumi.Input[int] repl_backlog_size_percent: Replication backlog size as a percentage of flavor maxmemory.
        :param pulumi.Input[int] slowlog_log_slower_than: Log slow queries below this number in microseconds.
        :param pulumi.Input[int] slowlog_max_len: Slow queries log length.
        :param pulumi.Input[int] timeout: Close the connection after a client is idle for N seconds.
        :param pulumi.Input[bool] turn_before_switchover: Allows to turn before switchover in RDSync.
        :param pulumi.Input[bool] use_luajit: Use JIT for lua scripts and functions.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "version", version)
        if allow_data_loss is not None:
            pulumi.set(__self__, "allow_data_loss", allow_data_loss)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if client_output_buffer_limit_normal is not None:
            pulumi.set(__self__, "client_output_buffer_limit_normal", client_output_buffer_limit_normal)
        if client_output_buffer_limit_pubsub is not None:
            pulumi.set(__self__, "client_output_buffer_limit_pubsub", client_output_buffer_limit_pubsub)
        if cluster_allow_pubsubshard_when_down is not None:
            pulumi.set(__self__, "cluster_allow_pubsubshard_when_down", cluster_allow_pubsubshard_when_down)
        if cluster_allow_reads_when_down is not None:
            pulumi.set(__self__, "cluster_allow_reads_when_down", cluster_allow_reads_when_down)
        if cluster_require_full_coverage is not None:
            pulumi.set(__self__, "cluster_require_full_coverage", cluster_require_full_coverage)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if io_threads_allowed is not None:
            pulumi.set(__self__, "io_threads_allowed", io_threads_allowed)
        if lfu_decay_time is not None:
            pulumi.set(__self__, "lfu_decay_time", lfu_decay_time)
        if lfu_log_factor is not None:
            pulumi.set(__self__, "lfu_log_factor", lfu_log_factor)
        if lua_time_limit is not None:
            pulumi.set(__self__, "lua_time_limit", lua_time_limit)
        if maxmemory_percent is not None:
            pulumi.set(__self__, "maxmemory_percent", maxmemory_percent)
        if maxmemory_policy is not None:
            pulumi.set(__self__, "maxmemory_policy", maxmemory_policy)
        if notify_keyspace_events is not None:
            pulumi.set(__self__, "notify_keyspace_events", notify_keyspace_events)
        if repl_backlog_size_percent is not None:
            pulumi.set(__self__, "repl_backlog_size_percent", repl_backlog_size_percent)
        if slowlog_log_slower_than is not None:
            pulumi.set(__self__, "slowlog_log_slower_than", slowlog_log_slower_than)
        if slowlog_max_len is not None:
            pulumi.set(__self__, "slowlog_max_len", slowlog_max_len)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if turn_before_switchover is not None:
            pulumi.set(__self__, "turn_before_switchover", turn_before_switchover)
        if use_luajit is not None:
            pulumi.set(__self__, "use_luajit", use_luajit)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the Redis cluster.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of Redis (6.2).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="allowDataLoss")
    def allow_data_loss(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows some data to be lost in favor of faster switchover/restart by RDSync.
        """
        return pulumi.get(self, "allow_data_loss")

    @allow_data_loss.setter
    def allow_data_loss(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_data_loss", value)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional[pulumi.Input['MdbRedisClusterConfigBackupWindowStartArgs']]:
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_start")

    @backup_window_start.setter
    def backup_window_start(self, value: Optional[pulumi.Input['MdbRedisClusterConfigBackupWindowStartArgs']]):
        pulumi.set(self, "backup_window_start", value)

    @property
    @pulumi.getter(name="clientOutputBufferLimitNormal")
    def client_output_buffer_limit_normal(self) -> Optional[pulumi.Input[str]]:
        """
        Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        """
        return pulumi.get(self, "client_output_buffer_limit_normal")

    @client_output_buffer_limit_normal.setter
    def client_output_buffer_limit_normal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_output_buffer_limit_normal", value)

    @property
    @pulumi.getter(name="clientOutputBufferLimitPubsub")
    def client_output_buffer_limit_pubsub(self) -> Optional[pulumi.Input[str]]:
        """
        Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        """
        return pulumi.get(self, "client_output_buffer_limit_pubsub")

    @client_output_buffer_limit_pubsub.setter
    def client_output_buffer_limit_pubsub(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_output_buffer_limit_pubsub", value)

    @property
    @pulumi.getter(name="clusterAllowPubsubshardWhenDown")
    def cluster_allow_pubsubshard_when_down(self) -> Optional[pulumi.Input[bool]]:
        """
        Permits Pub/Sub shard operations when cluster is down.
        """
        return pulumi.get(self, "cluster_allow_pubsubshard_when_down")

    @cluster_allow_pubsubshard_when_down.setter
    def cluster_allow_pubsubshard_when_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_allow_pubsubshard_when_down", value)

    @property
    @pulumi.getter(name="clusterAllowReadsWhenDown")
    def cluster_allow_reads_when_down(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows read operations when cluster is down.
        """
        return pulumi.get(self, "cluster_allow_reads_when_down")

    @cluster_allow_reads_when_down.setter
    def cluster_allow_reads_when_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_allow_reads_when_down", value)

    @property
    @pulumi.getter(name="clusterRequireFullCoverage")
    def cluster_require_full_coverage(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether all hash slots must be covered by nodes.
        """
        return pulumi.get(self, "cluster_require_full_coverage")

    @cluster_require_full_coverage.setter
    def cluster_require_full_coverage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_require_full_coverage", value)

    @property
    @pulumi.getter
    def databases(self) -> Optional[pulumi.Input[int]]:
        """
        Number of databases (changing requires redis-server restart).
        """
        return pulumi.get(self, "databases")

    @databases.setter
    def databases(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "databases", value)

    @property
    @pulumi.getter(name="ioThreadsAllowed")
    def io_threads_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow Redis to use io-threads.
        """
        return pulumi.get(self, "io_threads_allowed")

    @io_threads_allowed.setter
    def io_threads_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "io_threads_allowed", value)

    @property
    @pulumi.getter(name="lfuDecayTime")
    def lfu_decay_time(self) -> Optional[pulumi.Input[int]]:
        """
        The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        """
        return pulumi.get(self, "lfu_decay_time")

    @lfu_decay_time.setter
    def lfu_decay_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lfu_decay_time", value)

    @property
    @pulumi.getter(name="lfuLogFactor")
    def lfu_log_factor(self) -> Optional[pulumi.Input[int]]:
        """
        Determines how the frequency counter represents key hits.
        """
        return pulumi.get(self, "lfu_log_factor")

    @lfu_log_factor.setter
    def lfu_log_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lfu_log_factor", value)

    @property
    @pulumi.getter(name="luaTimeLimit")
    def lua_time_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum time in milliseconds for Lua scripts.
        """
        return pulumi.get(self, "lua_time_limit")

    @lua_time_limit.setter
    def lua_time_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lua_time_limit", value)

    @property
    @pulumi.getter(name="maxmemoryPercent")
    def maxmemory_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Redis maxmemory usage in percent
        """
        return pulumi.get(self, "maxmemory_percent")

    @maxmemory_percent.setter
    def maxmemory_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maxmemory_percent", value)

    @property
    @pulumi.getter(name="maxmemoryPolicy")
    def maxmemory_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        """
        return pulumi.get(self, "maxmemory_policy")

    @maxmemory_policy.setter
    def maxmemory_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maxmemory_policy", value)

    @property
    @pulumi.getter(name="notifyKeyspaceEvents")
    def notify_keyspace_events(self) -> Optional[pulumi.Input[str]]:
        """
        Select the events that Redis will notify among a set of classes.
        """
        return pulumi.get(self, "notify_keyspace_events")

    @notify_keyspace_events.setter
    def notify_keyspace_events(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_keyspace_events", value)

    @property
    @pulumi.getter(name="replBacklogSizePercent")
    def repl_backlog_size_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Replication backlog size as a percentage of flavor maxmemory.
        """
        return pulumi.get(self, "repl_backlog_size_percent")

    @repl_backlog_size_percent.setter
    def repl_backlog_size_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "repl_backlog_size_percent", value)

    @property
    @pulumi.getter(name="slowlogLogSlowerThan")
    def slowlog_log_slower_than(self) -> Optional[pulumi.Input[int]]:
        """
        Log slow queries below this number in microseconds.
        """
        return pulumi.get(self, "slowlog_log_slower_than")

    @slowlog_log_slower_than.setter
    def slowlog_log_slower_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slowlog_log_slower_than", value)

    @property
    @pulumi.getter(name="slowlogMaxLen")
    def slowlog_max_len(self) -> Optional[pulumi.Input[int]]:
        """
        Slow queries log length.
        """
        return pulumi.get(self, "slowlog_max_len")

    @slowlog_max_len.setter
    def slowlog_max_len(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slowlog_max_len", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Close the connection after a client is idle for N seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="turnBeforeSwitchover")
    def turn_before_switchover(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to turn before switchover in RDSync.
        """
        return pulumi.get(self, "turn_before_switchover")

    @turn_before_switchover.setter
    def turn_before_switchover(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "turn_before_switchover", value)

    @property
    @pulumi.getter(name="useLuajit")
    def use_luajit(self) -> Optional[pulumi.Input[bool]]:
        """
        Use JIT for lua scripts and functions.
        """
        return pulumi.get(self, "use_luajit")

    @use_luajit.setter
    def use_luajit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_luajit", value)


if not MYPY:
    class MdbRedisClusterConfigBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started.
        """
elif False:
    MdbRedisClusterConfigBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterConfigBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started.
        :param pulumi.Input[int] minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbRedisClusterDiskSizeAutoscalingArgsDict(TypedDict):
        disk_size_limit: pulumi.Input[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[pulumi.Input[int]]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    MdbRedisClusterDiskSizeAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterDiskSizeAutoscalingArgs:
    def __init__(__self__, *,
                 disk_size_limit: pulumi.Input[int],
                 emergency_usage_threshold: Optional[pulumi.Input[int]] = None,
                 planned_usage_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param pulumi.Input[int] emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param pulumi.Input[int] planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> pulumi.Input[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class MdbRedisClusterHostArgsDict(TypedDict):
        zone: pulumi.Input[str]
        """
        The availability zone where the Redis host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the host should get a public IP address or not.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host.
        """
        replica_priority: NotRequired[pulumi.Input[int]]
        """
        Replica priority of a current replica (usable for non-sharded only).
        """
        shard_name: NotRequired[pulumi.Input[str]]
        """
        The name of the shard to which the host belongs.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
elif False:
    MdbRedisClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterHostArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 replica_priority: Optional[pulumi.Input[int]] = None,
                 shard_name: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] zone: The availability zone where the Redis host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param pulumi.Input[bool] assign_public_ip: Sets whether the host should get a public IP address or not.
        :param pulumi.Input[str] fqdn: The fully qualified domain name of the host.
        :param pulumi.Input[int] replica_priority: Replica priority of a current replica (usable for non-sharded only).
        :param pulumi.Input[str] shard_name: The name of the shard to which the host belongs.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if replica_priority is not None:
            pulumi.set(__self__, "replica_priority", replica_priority)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        The availability zone where the Redis host will be created. For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the host should get a public IP address or not.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="replicaPriority")
    def replica_priority(self) -> Optional[pulumi.Input[int]]:
        """
        Replica priority of a current replica (usable for non-sharded only).
        """
        return pulumi.get(self, "replica_priority")

    @replica_priority.setter
    def replica_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replica_priority", value)

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @shard_name.setter
    def shard_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shard_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MdbRedisClusterMaintenanceWindowArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
elif False:
    MdbRedisClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param pulumi.Input[str] day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param pulumi.Input[int] hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MdbRedisClusterResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        resource_preset_id: pulumi.Input[str]
        disk_type_id: NotRequired[pulumi.Input[str]]
        """
        Type of the storage of Redis hosts - environment default is used if missing.
        """
elif False:
    MdbRedisClusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbRedisClusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 resource_preset_id: pulumi.Input[str],
                 disk_type_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of Redis hosts - environment default is used if missing.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the storage of Redis hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type_id", value)


if not MYPY:
    class MdbSqlserverClusterBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        The minute at which backup will be started.
        """
elif False:
    MdbSqlserverClusterBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbSqlserverClusterBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: The hour at which backup will be started.
        :param pulumi.Input[int] minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class MdbSqlserverClusterDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the database.
        """
elif False:
    MdbSqlserverClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbSqlserverClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MdbSqlserverClusterHostArgsDict(TypedDict):
        zone: pulumi.Input[str]
        """
        The availability zone where the SQLServer host will be created.
        """
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        The fully qualified domain name of the host.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
elif False:
    MdbSqlserverClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbSqlserverClusterHostArgs:
    def __init__(__self__, *,
                 zone: pulumi.Input[str],
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] zone: The availability zone where the SQLServer host will be created.
        :param pulumi.Input[bool] assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        :param pulumi.Input[str] fqdn: The fully qualified domain name of the host.
        :param pulumi.Input[str] subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        The availability zone where the SQLServer host will be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class MdbSqlserverClusterResourcesArgsDict(TypedDict):
        disk_size: pulumi.Input[int]
        """
        Volume of the storage available to a SQLServer host, in gigabytes.
        """
        disk_type_id: pulumi.Input[str]
        """
        Type of the storage of SQLServer hosts.
        """
        resource_preset_id: pulumi.Input[str]
elif False:
    MdbSqlserverClusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbSqlserverClusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: pulumi.Input[int],
                 disk_type_id: pulumi.Input[str],
                 resource_preset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] disk_size: Volume of the storage available to a SQLServer host, in gigabytes.
        :param pulumi.Input[str] disk_type_id: Type of the storage of SQLServer hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> pulumi.Input[int]:
        """
        Volume of the storage available to a SQLServer host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> pulumi.Input[str]:
        """
        Type of the storage of SQLServer hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class MdbSqlserverClusterUserArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the user.
        """
        password: pulumi.Input[str]
        """
        The password of the user.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MdbSqlserverClusterUserPermissionArgsDict']]]]
        """
        Set of permissions granted to the user. The structure is documented below.
        """
elif False:
    MdbSqlserverClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbSqlserverClusterUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['MdbSqlserverClusterUserPermissionArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the user.
        :param pulumi.Input[str] password: The password of the user.
        :param pulumi.Input[Sequence[pulumi.Input['MdbSqlserverClusterUserPermissionArgs']]] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MdbSqlserverClusterUserPermissionArgs']]]]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MdbSqlserverClusterUserPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class MdbSqlserverClusterUserPermissionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database that the permission grants access to.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
elif False:
    MdbSqlserverClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MdbSqlserverClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database that the permission grants access to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class MonitoringDashboardParametrizationArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterArgsDict']]]]
        """
        parameters list.
        """
        selectors: NotRequired[pulumi.Input[str]]
        """
        dashboard predefined parameters selector.
        """
elif False:
    MonitoringDashboardParametrizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardParametrizationArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterArgs']]]] = None,
                 selectors: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterArgs']]] parameters: parameters list.
        :param pulumi.Input[str] selectors: dashboard predefined parameters selector.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterArgs']]]]:
        """
        parameters list.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[str]]:
        """
        dashboard predefined parameters selector.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class MonitoringDashboardParametrizationParameterArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Parameter identifier
        """
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterCustomArgsDict']]]]
        """
        Custom values parameter. Oneof: label_values, custom, text.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Parameter description.
        """
        hidden: NotRequired[pulumi.Input[bool]]
        """
        UI-visibility.
        """
        label_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterLabelValueArgsDict']]]]
        """
        Label values parameter. Oneof: label_values, custom, text.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterTextArgsDict']]]]
        """
        Text parameter. Oneof: label_values, custom, text.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        UI-visible title of the parameter.
        """
elif False:
    MonitoringDashboardParametrizationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardParametrizationParameterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterCustomArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 hidden: Optional[pulumi.Input[bool]] = None,
                 label_values: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterLabelValueArgs']]]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterTextArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Parameter identifier
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterCustomArgs']]] customs: Custom values parameter. Oneof: label_values, custom, text.
        :param pulumi.Input[str] description: Parameter description.
        :param pulumi.Input[bool] hidden: UI-visibility.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterLabelValueArgs']]] label_values: Label values parameter. Oneof: label_values, custom, text.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterTextArgs']]] texts: Text parameter. Oneof: label_values, custom, text.
        :param pulumi.Input[str] title: UI-visible title of the parameter.
        """
        pulumi.set(__self__, "id", id)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if label_values is not None:
            pulumi.set(__self__, "label_values", label_values)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Parameter identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterCustomArgs']]]]:
        """
        Custom values parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        UI-visibility.
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hidden", value)

    @property
    @pulumi.getter(name="labelValues")
    def label_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterLabelValueArgs']]]]:
        """
        Label values parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "label_values")

    @label_values.setter
    def label_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterLabelValueArgs']]]]):
        pulumi.set(self, "label_values", value)

    @property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterTextArgs']]]]:
        """
        Text parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardParametrizationParameterTextArgs']]]]):
        pulumi.set(self, "texts", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        UI-visible title of the parameter.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class MonitoringDashboardParametrizationParameterCustomArgsDict(TypedDict):
        default_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Default value.
        """
        multiselectable: NotRequired[pulumi.Input[bool]]
        """
        Specifies the multiselectable values of parameter.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameter values.
        """
elif False:
    MonitoringDashboardParametrizationParameterCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardParametrizationParameterCustomArgs:
    def __init__(__self__, *,
                 default_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 multiselectable: Optional[pulumi.Input[bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_values: Default value.
        :param pulumi.Input[bool] multiselectable: Specifies the multiselectable values of parameter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if multiselectable is not None:
            pulumi.set(__self__, "multiselectable", multiselectable)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default value.
        """
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_values", value)

    @property
    @pulumi.getter
    def multiselectable(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies the multiselectable values of parameter.
        """
        return pulumi.get(self, "multiselectable")

    @multiselectable.setter
    def multiselectable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multiselectable", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MonitoringDashboardParametrizationParameterLabelValueArgsDict(TypedDict):
        label_key: pulumi.Input[str]
        """
        Label key to list label values.
        """
        default_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Default value.
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Labels folder ID.
        """
        multiselectable: NotRequired[pulumi.Input[bool]]
        """
        Specifies the multiselectable values of parameter.
        """
        selectors: NotRequired[pulumi.Input[str]]
        """
        Selectors to select metric label values.
        """
elif False:
    MonitoringDashboardParametrizationParameterLabelValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardParametrizationParameterLabelValueArgs:
    def __init__(__self__, *,
                 label_key: pulumi.Input[str],
                 default_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 multiselectable: Optional[pulumi.Input[bool]] = None,
                 selectors: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] label_key: Label key to list label values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_values: Default value.
        :param pulumi.Input[str] folder_id: Labels folder ID.
        :param pulumi.Input[bool] multiselectable: Specifies the multiselectable values of parameter.
        :param pulumi.Input[str] selectors: Selectors to select metric label values.
        """
        pulumi.set(__self__, "label_key", label_key)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if multiselectable is not None:
            pulumi.set(__self__, "multiselectable", multiselectable)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter(name="labelKey")
    def label_key(self) -> pulumi.Input[str]:
        """
        Label key to list label values.
        """
        return pulumi.get(self, "label_key")

    @label_key.setter
    def label_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_key", value)

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default value.
        """
        return pulumi.get(self, "default_values")

    @default_values.setter
    def default_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_values", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Labels folder ID.
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter
    def multiselectable(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies the multiselectable values of parameter.
        """
        return pulumi.get(self, "multiselectable")

    @multiselectable.setter
    def multiselectable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multiselectable", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[str]]:
        """
        Selectors to select metric label values.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class MonitoringDashboardParametrizationParameterTextArgsDict(TypedDict):
        default_value: NotRequired[pulumi.Input[str]]
        """
        Default value.
        """
elif False:
    MonitoringDashboardParametrizationParameterTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardParametrizationParameterTextArgs:
    def __init__(__self__, *,
                 default_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_value: Default value.
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        Default value.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)


if not MYPY:
    class MonitoringDashboardWidgetArgsDict(TypedDict):
        charts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartArgsDict']]]]
        """
        Chart widget settings. Oneof: text, title or chart.
        """
        positions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetPositionArgsDict']]]]
        """
        Widget position.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTextArgsDict']]]]
        """
        Text widget settings. Oneof: text, title or chart.
        """
        titles: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTitleArgsDict']]]]
        """
        Title widget settings. Oneof: text, title or chart.
        """
elif False:
    MonitoringDashboardWidgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetArgs:
    def __init__(__self__, *,
                 charts: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartArgs']]]] = None,
                 positions: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetPositionArgs']]]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTextArgs']]]] = None,
                 titles: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTitleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartArgs']]] charts: Chart widget settings. Oneof: text, title or chart.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetPositionArgs']]] positions: Widget position.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTextArgs']]] texts: Text widget settings. Oneof: text, title or chart.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTitleArgs']]] titles: Title widget settings. Oneof: text, title or chart.
        """
        if charts is not None:
            pulumi.set(__self__, "charts", charts)
        if positions is not None:
            pulumi.set(__self__, "positions", positions)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)
        if titles is not None:
            pulumi.set(__self__, "titles", titles)

    @property
    @pulumi.getter
    def charts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartArgs']]]]:
        """
        Chart widget settings. Oneof: text, title or chart.
        """
        return pulumi.get(self, "charts")

    @charts.setter
    def charts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartArgs']]]]):
        pulumi.set(self, "charts", value)

    @property
    @pulumi.getter
    def positions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetPositionArgs']]]]:
        """
        Widget position.
        """
        return pulumi.get(self, "positions")

    @positions.setter
    def positions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetPositionArgs']]]]):
        pulumi.set(self, "positions", value)

    @property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTextArgs']]]]:
        """
        Text widget settings. Oneof: text, title or chart.
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTextArgs']]]]):
        pulumi.set(self, "texts", value)

    @property
    @pulumi.getter
    def titles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTitleArgs']]]]:
        """
        Title widget settings. Oneof: text, title or chart.
        """
        return pulumi.get(self, "titles")

    @titles.setter
    def titles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetTitleArgs']]]]):
        pulumi.set(self, "titles", value)


if not MYPY:
    class MonitoringDashboardWidgetChartArgsDict(TypedDict):
        chart_id: NotRequired[pulumi.Input[str]]
        """
        Chart ID.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Chart description in dashboard (not enabled in UI).
        """
        display_legend: NotRequired[pulumi.Input[bool]]
        """
        Enable legend under chart.
        """
        freeze: NotRequired[pulumi.Input[str]]
        """
        Fixed time interval for chart. Values:
        - FREEZE_DURATION_HOUR: Last hour.
        - FREEZE_DURATION_DAY: Last day = last 24 hours.
        - FREEZE_DURATION_WEEK: Last 7 days.
        - FREEZE_DURATION_MONTH: Last 31 days.
        """
        name_hiding_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartNameHidingSettingArgsDict']]]]
        """
        Names settings.
        """
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryArgsDict']]]]
        """
        Queries settings.
        """
        series_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideArgsDict']]]]
        """
        Time series settings.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Chart widget title.
        """
        visualization_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingArgsDict']]]]
        """
        Visualization settings.
        """
elif False:
    MonitoringDashboardWidgetChartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartArgs:
    def __init__(__self__, *,
                 chart_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_legend: Optional[pulumi.Input[bool]] = None,
                 freeze: Optional[pulumi.Input[str]] = None,
                 name_hiding_settings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartNameHidingSettingArgs']]]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryArgs']]]] = None,
                 series_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 visualization_settings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingArgs']]]] = None):
        """
        :param pulumi.Input[str] chart_id: Chart ID.
        :param pulumi.Input[str] description: Chart description in dashboard (not enabled in UI).
        :param pulumi.Input[bool] display_legend: Enable legend under chart.
        :param pulumi.Input[str] freeze: Fixed time interval for chart. Values:
               - FREEZE_DURATION_HOUR: Last hour.
               - FREEZE_DURATION_DAY: Last day = last 24 hours.
               - FREEZE_DURATION_WEEK: Last 7 days.
               - FREEZE_DURATION_MONTH: Last 31 days.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartNameHidingSettingArgs']]] name_hiding_settings: Names settings.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryArgs']]] queries: Queries settings.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideArgs']]] series_overrides: Time series settings.
        :param pulumi.Input[str] title: Chart widget title.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingArgs']]] visualization_settings: Visualization settings.
        """
        if chart_id is not None:
            pulumi.set(__self__, "chart_id", chart_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_legend is not None:
            pulumi.set(__self__, "display_legend", display_legend)
        if freeze is not None:
            pulumi.set(__self__, "freeze", freeze)
        if name_hiding_settings is not None:
            pulumi.set(__self__, "name_hiding_settings", name_hiding_settings)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if series_overrides is not None:
            pulumi.set(__self__, "series_overrides", series_overrides)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visualization_settings is not None:
            pulumi.set(__self__, "visualization_settings", visualization_settings)

    @property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> Optional[pulumi.Input[str]]:
        """
        Chart ID.
        """
        return pulumi.get(self, "chart_id")

    @chart_id.setter
    def chart_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chart_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Chart description in dashboard (not enabled in UI).
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayLegend")
    def display_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable legend under chart.
        """
        return pulumi.get(self, "display_legend")

    @display_legend.setter
    def display_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "display_legend", value)

    @property
    @pulumi.getter
    def freeze(self) -> Optional[pulumi.Input[str]]:
        """
        Fixed time interval for chart. Values:
        - FREEZE_DURATION_HOUR: Last hour.
        - FREEZE_DURATION_DAY: Last day = last 24 hours.
        - FREEZE_DURATION_WEEK: Last 7 days.
        - FREEZE_DURATION_MONTH: Last 31 days.
        """
        return pulumi.get(self, "freeze")

    @freeze.setter
    def freeze(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze", value)

    @property
    @pulumi.getter(name="nameHidingSettings")
    def name_hiding_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartNameHidingSettingArgs']]]]:
        """
        Names settings.
        """
        return pulumi.get(self, "name_hiding_settings")

    @name_hiding_settings.setter
    def name_hiding_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartNameHidingSettingArgs']]]]):
        pulumi.set(self, "name_hiding_settings", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryArgs']]]]:
        """
        Queries settings.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="seriesOverrides")
    def series_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideArgs']]]]:
        """
        Time series settings.
        """
        return pulumi.get(self, "series_overrides")

    @series_overrides.setter
    def series_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideArgs']]]]):
        pulumi.set(self, "series_overrides", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Chart widget title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="visualizationSettings")
    def visualization_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingArgs']]]]:
        """
        Visualization settings.
        """
        return pulumi.get(self, "visualization_settings")

    @visualization_settings.setter
    def visualization_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingArgs']]]]):
        pulumi.set(self, "visualization_settings", value)


if not MYPY:
    class MonitoringDashboardWidgetChartNameHidingSettingArgsDict(TypedDict):
        names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Series name.
        """
        positive: NotRequired[pulumi.Input[bool]]
        """
        True if we want to show concrete series names only, false if we want to hide concrete series names.
        """
elif False:
    MonitoringDashboardWidgetChartNameHidingSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartNameHidingSettingArgs:
    def __init__(__self__, *,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 positive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: Series name.
        :param pulumi.Input[bool] positive: True if we want to show concrete series names only, false if we want to hide concrete series names.
        """
        if names is not None:
            pulumi.set(__self__, "names", names)
        if positive is not None:
            pulumi.set(__self__, "positive", positive)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Series name.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)

    @property
    @pulumi.getter
    def positive(self) -> Optional[pulumi.Input[bool]]:
        """
        True if we want to show concrete series names only, false if we want to hide concrete series names.
        """
        return pulumi.get(self, "positive")

    @positive.setter
    def positive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "positive", value)


if not MYPY:
    class MonitoringDashboardWidgetChartQueryArgsDict(TypedDict):
        downsamplings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryDownsamplingArgsDict']]]]
        """
        Downsamplang settings.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryTargetArgsDict']]]]
        """
        Query targets.
        """
elif False:
    MonitoringDashboardWidgetChartQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartQueryArgs:
    def __init__(__self__, *,
                 downsamplings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryDownsamplingArgs']]]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryTargetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryDownsamplingArgs']]] downsamplings: Downsamplang settings.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryTargetArgs']]] targets: Query targets.
        """
        if downsamplings is not None:
            pulumi.set(__self__, "downsamplings", downsamplings)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def downsamplings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryDownsamplingArgs']]]]:
        """
        Downsamplang settings.
        """
        return pulumi.get(self, "downsamplings")

    @downsamplings.setter
    def downsamplings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryDownsamplingArgs']]]]):
        pulumi.set(self, "downsamplings", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryTargetArgs']]]]:
        """
        Query targets.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartQueryTargetArgs']]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class MonitoringDashboardWidgetChartQueryDownsamplingArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Disable downsampling.
        """
        gap_filling: NotRequired[pulumi.Input[str]]
        """
        Parameters for filling gaps in data.
        """
        grid_aggregation: NotRequired[pulumi.Input[str]]
        """
        Function that is used for downsampling.
        """
        grid_interval: NotRequired[pulumi.Input[int]]
        """
        Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        """
        max_points: NotRequired[pulumi.Input[int]]
        """
        Maximum number of points to be returned.
        """
elif False:
    MonitoringDashboardWidgetChartQueryDownsamplingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartQueryDownsamplingArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 gap_filling: Optional[pulumi.Input[str]] = None,
                 grid_aggregation: Optional[pulumi.Input[str]] = None,
                 grid_interval: Optional[pulumi.Input[int]] = None,
                 max_points: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: Disable downsampling.
        :param pulumi.Input[str] gap_filling: Parameters for filling gaps in data.
        :param pulumi.Input[str] grid_aggregation: Function that is used for downsampling.
        :param pulumi.Input[int] grid_interval: Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        :param pulumi.Input[int] max_points: Maximum number of points to be returned.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gap_filling is not None:
            pulumi.set(__self__, "gap_filling", gap_filling)
        if grid_aggregation is not None:
            pulumi.set(__self__, "grid_aggregation", grid_aggregation)
        if grid_interval is not None:
            pulumi.set(__self__, "grid_interval", grid_interval)
        if max_points is not None:
            pulumi.set(__self__, "max_points", max_points)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable downsampling.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="gapFilling")
    def gap_filling(self) -> Optional[pulumi.Input[str]]:
        """
        Parameters for filling gaps in data.
        """
        return pulumi.get(self, "gap_filling")

    @gap_filling.setter
    def gap_filling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gap_filling", value)

    @property
    @pulumi.getter(name="gridAggregation")
    def grid_aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        Function that is used for downsampling.
        """
        return pulumi.get(self, "grid_aggregation")

    @grid_aggregation.setter
    def grid_aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grid_aggregation", value)

    @property
    @pulumi.getter(name="gridInterval")
    def grid_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        """
        return pulumi.get(self, "grid_interval")

    @grid_interval.setter
    def grid_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grid_interval", value)

    @property
    @pulumi.getter(name="maxPoints")
    def max_points(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of points to be returned.
        """
        return pulumi.get(self, "max_points")

    @max_points.setter
    def max_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_points", value)


if not MYPY:
    class MonitoringDashboardWidgetChartQueryTargetArgsDict(TypedDict):
        hidden: NotRequired[pulumi.Input[bool]]
        """
        Checks that target is visible or invisible.
        """
        query: NotRequired[pulumi.Input[str]]
        """
        Query.
        """
        text_mode: NotRequired[pulumi.Input[bool]]
        """
        Text mode enabled.
        """
elif False:
    MonitoringDashboardWidgetChartQueryTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartQueryTargetArgs:
    def __init__(__self__, *,
                 hidden: Optional[pulumi.Input[bool]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 text_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] hidden: Checks that target is visible or invisible.
        :param pulumi.Input[str] query: Query.
        :param pulumi.Input[bool] text_mode: Text mode enabled.
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if text_mode is not None:
            pulumi.set(__self__, "text_mode", text_mode)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        Checks that target is visible or invisible.
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hidden", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        Query.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="textMode")
    def text_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Text mode enabled.
        """
        return pulumi.get(self, "text_mode")

    @text_mode.setter
    def text_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "text_mode", value)


if not MYPY:
    class MonitoringDashboardWidgetChartSeriesOverrideArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Series name. Oneof: name or target_index.
        """
        settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideSettingArgsDict']]]]
        """
        Override settings.
        """
        target_index: NotRequired[pulumi.Input[str]]
        """
        Series index. Oneof: name or target_index.
        """
elif False:
    MonitoringDashboardWidgetChartSeriesOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartSeriesOverrideArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideSettingArgs']]]] = None,
                 target_index: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Series name. Oneof: name or target_index.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideSettingArgs']]] settings: Override settings.
        :param pulumi.Input[str] target_index: Series index. Oneof: name or target_index.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if target_index is not None:
            pulumi.set(__self__, "target_index", target_index)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Series name. Oneof: name or target_index.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideSettingArgs']]]]:
        """
        Override settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartSeriesOverrideSettingArgs']]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter(name="targetIndex")
    def target_index(self) -> Optional[pulumi.Input[str]]:
        """
        Series index. Oneof: name or target_index.
        """
        return pulumi.get(self, "target_index")

    @target_index.setter
    def target_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_index", value)


if not MYPY:
    class MonitoringDashboardWidgetChartSeriesOverrideSettingArgsDict(TypedDict):
        color: NotRequired[pulumi.Input[str]]
        """
        Series color or empty.
        """
        grow_down: NotRequired[pulumi.Input[bool]]
        """
        Stack grow down.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Series name or empty.
        """
        stack_name: NotRequired[pulumi.Input[str]]
        """
        Stack name or empty.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type.
        """
        yaxis_position: NotRequired[pulumi.Input[str]]
        """
        Yaxis position.
        """
elif False:
    MonitoringDashboardWidgetChartSeriesOverrideSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartSeriesOverrideSettingArgs:
    def __init__(__self__, *,
                 color: Optional[pulumi.Input[str]] = None,
                 grow_down: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 stack_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 yaxis_position: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color: Series color or empty.
        :param pulumi.Input[bool] grow_down: Stack grow down.
        :param pulumi.Input[str] name: Series name or empty.
        :param pulumi.Input[str] stack_name: Stack name or empty.
        :param pulumi.Input[str] type: Type.
        :param pulumi.Input[str] yaxis_position: Yaxis position.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if grow_down is not None:
            pulumi.set(__self__, "grow_down", grow_down)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stack_name is not None:
            pulumi.set(__self__, "stack_name", stack_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if yaxis_position is not None:
            pulumi.set(__self__, "yaxis_position", yaxis_position)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Series color or empty.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="growDown")
    def grow_down(self) -> Optional[pulumi.Input[bool]]:
        """
        Stack grow down.
        """
        return pulumi.get(self, "grow_down")

    @grow_down.setter
    def grow_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "grow_down", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Series name or empty.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="stackName")
    def stack_name(self) -> Optional[pulumi.Input[str]]:
        """
        Stack name or empty.
        """
        return pulumi.get(self, "stack_name")

    @stack_name.setter
    def stack_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="yaxisPosition")
    def yaxis_position(self) -> Optional[pulumi.Input[str]]:
        """
        Yaxis position.
        """
        return pulumi.get(self, "yaxis_position")

    @yaxis_position.setter
    def yaxis_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "yaxis_position", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingArgsDict(TypedDict):
        aggregation: NotRequired[pulumi.Input[str]]
        """
        Aggregation. Values:
        - SERIES_AGGREGATION_UNSPECIFIED: Not specified (avg by default).
        - SERIES_AGGREGATION_AVG: Average.
        - SERIES_AGGREGATION_MIN: Minimum.
        - SERIES_AGGREGATION_MAX: Maximum.
        - SERIES_AGGREGATION_LAST: Last non-NaN value.
        - SERIES_AGGREGATION_SUM: Sum.
        """
        color_scheme_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgsDict']]]]
        """
        Color settings.
        """
        heatmap_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgsDict']]]]
        """
        Heatmap settings.
        """
        interpolate: NotRequired[pulumi.Input[str]]
        """
        Interpolate values. Values:
        - INTERPOLATE_UNSPECIFIED: Not specified (linear by default).
        - INTERPOLATE_LINEAR: Linear.
        - INTERPOLATE_LEFT: Left.
        - INTERPOLATE_RIGHT: Right.
        """
        normalize: NotRequired[pulumi.Input[bool]]
        """
        Normalize values.
        """
        show_labels: NotRequired[pulumi.Input[bool]]
        """
        Show chart labels.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Inside chart title.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Visualization type. Values:
        - VISUALIZATION_TYPE_UNSPECIFIED: Not specified (line by default).
        - VISUALIZATION_TYPE_LINE: Line chart.
        - VISUALIZATION_TYPE_STACK: Stack chart.
        - VISUALIZATION_TYPE_COLUMN: Points as columns chart.
        - VISUALIZATION_TYPE_POINTS: Points.
        - VISUALIZATION_TYPE_PIE: Pie aggregation chart.
        - VISUALIZATION_TYPE_BARS: Bars aggregation chart.
        - VISUALIZATION_TYPE_DISTRIBUTION: Distribution aggregation chart.
        - VISUALIZATION_TYPE_HEATMAP: Heatmap aggregation chart.
        """
        yaxis_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgsDict']]]]
        """
        Y axis settings.
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingArgs:
    def __init__(__self__, *,
                 aggregation: Optional[pulumi.Input[str]] = None,
                 color_scheme_settings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs']]]] = None,
                 heatmap_settings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs']]]] = None,
                 interpolate: Optional[pulumi.Input[str]] = None,
                 normalize: Optional[pulumi.Input[bool]] = None,
                 show_labels: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 yaxis_settings: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs']]]] = None):
        """
        :param pulumi.Input[str] aggregation: Aggregation. Values:
               - SERIES_AGGREGATION_UNSPECIFIED: Not specified (avg by default).
               - SERIES_AGGREGATION_AVG: Average.
               - SERIES_AGGREGATION_MIN: Minimum.
               - SERIES_AGGREGATION_MAX: Maximum.
               - SERIES_AGGREGATION_LAST: Last non-NaN value.
               - SERIES_AGGREGATION_SUM: Sum.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs']]] color_scheme_settings: Color settings.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs']]] heatmap_settings: Heatmap settings.
        :param pulumi.Input[str] interpolate: Interpolate values. Values:
               - INTERPOLATE_UNSPECIFIED: Not specified (linear by default).
               - INTERPOLATE_LINEAR: Linear.
               - INTERPOLATE_LEFT: Left.
               - INTERPOLATE_RIGHT: Right.
        :param pulumi.Input[bool] normalize: Normalize values.
        :param pulumi.Input[bool] show_labels: Show chart labels.
        :param pulumi.Input[str] title: Inside chart title.
        :param pulumi.Input[str] type: Visualization type. Values:
               - VISUALIZATION_TYPE_UNSPECIFIED: Not specified (line by default).
               - VISUALIZATION_TYPE_LINE: Line chart.
               - VISUALIZATION_TYPE_STACK: Stack chart.
               - VISUALIZATION_TYPE_COLUMN: Points as columns chart.
               - VISUALIZATION_TYPE_POINTS: Points.
               - VISUALIZATION_TYPE_PIE: Pie aggregation chart.
               - VISUALIZATION_TYPE_BARS: Bars aggregation chart.
               - VISUALIZATION_TYPE_DISTRIBUTION: Distribution aggregation chart.
               - VISUALIZATION_TYPE_HEATMAP: Heatmap aggregation chart.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs']]] yaxis_settings: Y axis settings.
        """
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if color_scheme_settings is not None:
            pulumi.set(__self__, "color_scheme_settings", color_scheme_settings)
        if heatmap_settings is not None:
            pulumi.set(__self__, "heatmap_settings", heatmap_settings)
        if interpolate is not None:
            pulumi.set(__self__, "interpolate", interpolate)
        if normalize is not None:
            pulumi.set(__self__, "normalize", normalize)
        if show_labels is not None:
            pulumi.set(__self__, "show_labels", show_labels)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if yaxis_settings is not None:
            pulumi.set(__self__, "yaxis_settings", yaxis_settings)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        Aggregation. Values:
        - SERIES_AGGREGATION_UNSPECIFIED: Not specified (avg by default).
        - SERIES_AGGREGATION_AVG: Average.
        - SERIES_AGGREGATION_MIN: Minimum.
        - SERIES_AGGREGATION_MAX: Maximum.
        - SERIES_AGGREGATION_LAST: Last non-NaN value.
        - SERIES_AGGREGATION_SUM: Sum.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="colorSchemeSettings")
    def color_scheme_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs']]]]:
        """
        Color settings.
        """
        return pulumi.get(self, "color_scheme_settings")

    @color_scheme_settings.setter
    def color_scheme_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs']]]]):
        pulumi.set(self, "color_scheme_settings", value)

    @property
    @pulumi.getter(name="heatmapSettings")
    def heatmap_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs']]]]:
        """
        Heatmap settings.
        """
        return pulumi.get(self, "heatmap_settings")

    @heatmap_settings.setter
    def heatmap_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs']]]]):
        pulumi.set(self, "heatmap_settings", value)

    @property
    @pulumi.getter
    def interpolate(self) -> Optional[pulumi.Input[str]]:
        """
        Interpolate values. Values:
        - INTERPOLATE_UNSPECIFIED: Not specified (linear by default).
        - INTERPOLATE_LINEAR: Linear.
        - INTERPOLATE_LEFT: Left.
        - INTERPOLATE_RIGHT: Right.
        """
        return pulumi.get(self, "interpolate")

    @interpolate.setter
    def interpolate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interpolate", value)

    @property
    @pulumi.getter
    def normalize(self) -> Optional[pulumi.Input[bool]]:
        """
        Normalize values.
        """
        return pulumi.get(self, "normalize")

    @normalize.setter
    def normalize(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "normalize", value)

    @property
    @pulumi.getter(name="showLabels")
    def show_labels(self) -> Optional[pulumi.Input[bool]]:
        """
        Show chart labels.
        """
        return pulumi.get(self, "show_labels")

    @show_labels.setter
    def show_labels(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_labels", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Inside chart title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Visualization type. Values:
        - VISUALIZATION_TYPE_UNSPECIFIED: Not specified (line by default).
        - VISUALIZATION_TYPE_LINE: Line chart.
        - VISUALIZATION_TYPE_STACK: Stack chart.
        - VISUALIZATION_TYPE_COLUMN: Points as columns chart.
        - VISUALIZATION_TYPE_POINTS: Points.
        - VISUALIZATION_TYPE_PIE: Pie aggregation chart.
        - VISUALIZATION_TYPE_BARS: Bars aggregation chart.
        - VISUALIZATION_TYPE_DISTRIBUTION: Distribution aggregation chart.
        - VISUALIZATION_TYPE_HEATMAP: Heatmap aggregation chart.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="yaxisSettings")
    def yaxis_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs']]]]:
        """
        Y axis settings.
        """
        return pulumi.get(self, "yaxis_settings")

    @yaxis_settings.setter
    def yaxis_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs']]]]):
        pulumi.set(self, "yaxis_settings", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgsDict(TypedDict):
        automatics: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgsDict']]]]
        """
        Automatic color scheme. Oneof: automatic, standard or gradient.
        """
        gradients: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgsDict']]]]
        """
        Gradient color scheme. Oneof: automatic, standard or gradient.
        """
        standards: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgsDict']]]]
        """
        Standard color scheme. Oneof: automatic, standard or gradient.
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs:
    def __init__(__self__, *,
                 automatics: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs']]]] = None,
                 gradients: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs']]]] = None,
                 standards: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs']]] automatics: Automatic color scheme. Oneof: automatic, standard or gradient.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs']]] gradients: Gradient color scheme. Oneof: automatic, standard or gradient.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs']]] standards: Standard color scheme. Oneof: automatic, standard or gradient.
        """
        if automatics is not None:
            pulumi.set(__self__, "automatics", automatics)
        if gradients is not None:
            pulumi.set(__self__, "gradients", gradients)
        if standards is not None:
            pulumi.set(__self__, "standards", standards)

    @property
    @pulumi.getter
    def automatics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs']]]]:
        """
        Automatic color scheme. Oneof: automatic, standard or gradient.
        """
        return pulumi.get(self, "automatics")

    @automatics.setter
    def automatics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs']]]]):
        pulumi.set(self, "automatics", value)

    @property
    @pulumi.getter
    def gradients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs']]]]:
        """
        Gradient color scheme. Oneof: automatic, standard or gradient.
        """
        return pulumi.get(self, "gradients")

    @gradients.setter
    def gradients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs']]]]):
        pulumi.set(self, "gradients", value)

    @property
    @pulumi.getter
    def standards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs']]]]:
        """
        Standard color scheme. Oneof: automatic, standard or gradient.
        """
        return pulumi.get(self, "standards")

    @standards.setter
    def standards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs']]]]):
        pulumi.set(self, "standards", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgsDict(TypedDict):
        pass
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgsDict(TypedDict):
        green_value: NotRequired[pulumi.Input[str]]
        """
        Gradient green value.
        """
        red_value: NotRequired[pulumi.Input[str]]
        """
        Gradient red value.
        """
        violet_value: NotRequired[pulumi.Input[str]]
        """
        Gradient violet value.
        """
        yellow_value: NotRequired[pulumi.Input[str]]
        """
        Gradient yellow value.
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs:
    def __init__(__self__, *,
                 green_value: Optional[pulumi.Input[str]] = None,
                 red_value: Optional[pulumi.Input[str]] = None,
                 violet_value: Optional[pulumi.Input[str]] = None,
                 yellow_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] green_value: Gradient green value.
        :param pulumi.Input[str] red_value: Gradient red value.
        :param pulumi.Input[str] violet_value: Gradient violet value.
        :param pulumi.Input[str] yellow_value: Gradient yellow value.
        """
        if green_value is not None:
            pulumi.set(__self__, "green_value", green_value)
        if red_value is not None:
            pulumi.set(__self__, "red_value", red_value)
        if violet_value is not None:
            pulumi.set(__self__, "violet_value", violet_value)
        if yellow_value is not None:
            pulumi.set(__self__, "yellow_value", yellow_value)

    @property
    @pulumi.getter(name="greenValue")
    def green_value(self) -> Optional[pulumi.Input[str]]:
        """
        Gradient green value.
        """
        return pulumi.get(self, "green_value")

    @green_value.setter
    def green_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "green_value", value)

    @property
    @pulumi.getter(name="redValue")
    def red_value(self) -> Optional[pulumi.Input[str]]:
        """
        Gradient red value.
        """
        return pulumi.get(self, "red_value")

    @red_value.setter
    def red_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "red_value", value)

    @property
    @pulumi.getter(name="violetValue")
    def violet_value(self) -> Optional[pulumi.Input[str]]:
        """
        Gradient violet value.
        """
        return pulumi.get(self, "violet_value")

    @violet_value.setter
    def violet_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "violet_value", value)

    @property
    @pulumi.getter(name="yellowValue")
    def yellow_value(self) -> Optional[pulumi.Input[str]]:
        """
        Gradient yellow value.
        """
        return pulumi.get(self, "yellow_value")

    @yellow_value.setter
    def yellow_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "yellow_value", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgsDict(TypedDict):
        pass
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgsDict(TypedDict):
        green_value: NotRequired[pulumi.Input[str]]
        """
        Heatmap green value.
        """
        red_value: NotRequired[pulumi.Input[str]]
        """
        Heatmap red value.
        """
        violet_value: NotRequired[pulumi.Input[str]]
        """
        Heatmap violet value.
        """
        yellow_value: NotRequired[pulumi.Input[str]]
        """
        Heatmap yellow value.
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs:
    def __init__(__self__, *,
                 green_value: Optional[pulumi.Input[str]] = None,
                 red_value: Optional[pulumi.Input[str]] = None,
                 violet_value: Optional[pulumi.Input[str]] = None,
                 yellow_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] green_value: Heatmap green value.
        :param pulumi.Input[str] red_value: Heatmap red value.
        :param pulumi.Input[str] violet_value: Heatmap violet value.
        :param pulumi.Input[str] yellow_value: Heatmap yellow value.
        """
        if green_value is not None:
            pulumi.set(__self__, "green_value", green_value)
        if red_value is not None:
            pulumi.set(__self__, "red_value", red_value)
        if violet_value is not None:
            pulumi.set(__self__, "violet_value", violet_value)
        if yellow_value is not None:
            pulumi.set(__self__, "yellow_value", yellow_value)

    @property
    @pulumi.getter(name="greenValue")
    def green_value(self) -> Optional[pulumi.Input[str]]:
        """
        Heatmap green value.
        """
        return pulumi.get(self, "green_value")

    @green_value.setter
    def green_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "green_value", value)

    @property
    @pulumi.getter(name="redValue")
    def red_value(self) -> Optional[pulumi.Input[str]]:
        """
        Heatmap red value.
        """
        return pulumi.get(self, "red_value")

    @red_value.setter
    def red_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "red_value", value)

    @property
    @pulumi.getter(name="violetValue")
    def violet_value(self) -> Optional[pulumi.Input[str]]:
        """
        Heatmap violet value.
        """
        return pulumi.get(self, "violet_value")

    @violet_value.setter
    def violet_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "violet_value", value)

    @property
    @pulumi.getter(name="yellowValue")
    def yellow_value(self) -> Optional[pulumi.Input[str]]:
        """
        Heatmap yellow value.
        """
        return pulumi.get(self, "yellow_value")

    @yellow_value.setter
    def yellow_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "yellow_value", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgsDict(TypedDict):
        lefts: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgsDict']]]]
        """
        Left yaxis config.
        """
        rights: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgsDict']]]]
        """
        Right yaxis config.
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs:
    def __init__(__self__, *,
                 lefts: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs']]]] = None,
                 rights: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs']]] lefts: Left yaxis config.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs']]] rights: Right yaxis config.
        """
        if lefts is not None:
            pulumi.set(__self__, "lefts", lefts)
        if rights is not None:
            pulumi.set(__self__, "rights", rights)

    @property
    @pulumi.getter
    def lefts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs']]]]:
        """
        Left yaxis config.
        """
        return pulumi.get(self, "lefts")

    @lefts.setter
    def lefts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs']]]]):
        pulumi.set(self, "lefts", value)

    @property
    @pulumi.getter
    def rights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs']]]]:
        """
        Right yaxis config.
        """
        return pulumi.get(self, "rights")

    @rights.setter
    def rights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs']]]]):
        pulumi.set(self, "rights", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[str]]
        """
        Max value in extended number format or empty.
        """
        min: NotRequired[pulumi.Input[str]]
        """
        Min value in extended number format or empty.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        Tick value precision (null as default, 0-7 in other cases).
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Title or empty.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type. Values:
        - YAXIS_TYPE_UNSPECIFIED: Not specified (linear by default).
        - YAXIS_TYPE_LINEAR: Linear.
        - YAXIS_TYPE_LOGARITHMIC: Logarithmic.
        """
        unit_format: NotRequired[pulumi.Input[str]]
        """
        Unit format. Values:
        - UNIT_NONE: Misc. None (show tick values as-is).
        - UNIT_COUNT: Count.
        - UNIT_PERCENT: Percent (0-100).
        - UNIT_PERCENT_UNIT: Percent (0-1).
        - UNIT_NANOSECONDS: Time. Nanoseconds (ns).
        - UNIT_MICROSECONDS: Microseconds (s).
        - UNIT_MILLISECONDS: Milliseconds (ms).
        - UNIT_SECONDS: Seconds (s).
        - UNIT_MINUTES: Minutes (m).
        - UNIT_HOURS: Hours (h).
        - UNIT_DAYS: Days (d).
        - UNIT_BITS_SI: Data (SI). Bits (SI).
        - UNIT_BYTES_SI: Bytes (SI).
        - UNIT_KILOBYTES: Kilobytes (KB).
        - UNIT_MEGABYTES: Megabytes (MB).
        - UNIT_GIGABYTES: Gigabytes (GB).
        - UNIT_TERABYTES: Terabytes (TB)
        - UNIT_PETABYTES: Petabytes (PB).
        - UNIT_EXABYTES: Exabytes (EB).
        - UNIT_BITS_IEC: Data (IEC). Bits (IEC).
        - UNIT_BYTES_IEC: Bytes (IEC).
        - UNIT_KIBIBYTES: Kibibytes (KiB).
        - UNIT_MEBIBYTES: Mebibytes (MiB).
        - UNIT_GIBIBYTES: Gigibytes (GiB).
        - UNIT_TEBIBYTES: Tebibytes (TiB).
        - UNIT_PEBIBYTES: Pebibytes (PiB).
        - UNIT_EXBIBYTES: Exbibytes (EiB).
        - UNIT_REQUESTS_PER_SECOND: Throughput. Requests per second (reqps).
        - UNIT_OPERATIONS_PER_SECOND: Operations per second (ops).
        - UNIT_WRITES_PER_SECOND: Writes per second (wps).
        - UNIT_READS_PER_SECOND: Reads per second (rps).
        - UNIT_PACKETS_PER_SECOND: Packets per second (pps).
        - UNIT_IO_OPERATIONS_PER_SECOND: IO operations per second (iops).
        - UNIT_COUNTS_PER_SECOND: Counts per second (counts/sec).
        - UNIT_BITS_SI_PER_SECOND: Data Rate (SI). Bits (SI) per second (bits/sec).
        - UNIT_BYTES_SI_PER_SECOND: Bytes (SI) per second (bytes/sec).
        - UNIT_KILOBITS_PER_SECOND: Kilobits per second (KBits/sec).
        - UNIT_KILOBYTES_PER_SECOND: Kilobytes per second (KB/sec).
        - UNIT_MEGABITS_PER_SECOND: Megabits per second (MBits/sec).
        - UNIT_MEGABYTES_PER_SECOND: Megabytes per second (MB/sec).
        - UNIT_GIGABITS_PER_SECOND: Gigabits per second (GBits/sec).
        - UNIT_GIGABYTES_PER_SECOND: Gigabytes per second (GB/sec).
        - UNIT_TERABITS_PER_SECOND: Terabits per second (TBits/sec).
        - UNIT_TERABYTES_PER_SECOND: Terabytes per second (TB/sec).
        - UNIT_PETABITS_PER_SECOND: Petabits per second (Pbits/sec).
        - UNIT_PETABYTES_PER_SECOND: Petabytes per second (PB/sec).
        - UNIT_BITS_IEC_PER_SECOND: Data Rate (IEC). Bits (IEC) per second (bits/sec).
        - UNIT_BYTES_IEC_PER_SECOND: Bytes (IEC) per second (bytes/sec).
        - UNIT_KIBIBITS_PER_SECOND: Kibibits per second (KiBits/sec).
        - UNIT_KIBIBYTES_PER_SECOND: Kibibytes per second (KiB/sec).
        - UNIT_MEBIBITS_PER_SECOND: Mebibits per second (MiBits/sec).
        - UNIT_MEBIBYTES_PER_SECOND: Mebibytes per second (MiB/sec).
        - UNIT_GIBIBITS_PER_SECOND: Gibibits per second (GiBits/sec).
        - UNIT_GIBIBYTES_PER_SECOND: Gibibytes per second (GiB/sec).
        - UNIT_TEBIBITS_PER_SECOND: Tebibits per second (TiBits/sec).
        - UNIT_TEBIBYTES_PER_SECOND: Tebibytes per second (TiB/sec).
        - UNIT_PEBIBITS_PER_SECOND: Pebibits per second (PiBits/sec).
        - UNIT_PEBIBYTES_PER_SECOND: Pebibytes per second (PiB/sec).
        - UNIT_DATETIME_UTC: Date & time. Datetime (UTC).
        - UNIT_DATETIME_LOCAL: Datetime (local).
        - UNIT_HERTZ: Frequency. Hertz (Hz).
        - UNIT_KILOHERTZ: Kilohertz (KHz).
        - UNIT_MEGAHERTZ: Megahertz (MHz).
        - UNIT_GIGAHERTZ: Gigahertz (GHz).
        - UNIT_DOLLAR: Currency. Dollar.
        - UNIT_EURO: Euro.
        - UNIT_ROUBLE: Rouble.
        - UNIT_CELSIUS: Temperature. Celsius (C).
        - UNIT_FAHRENHEIT: Fahrenheit (F).
        - UNIT_KELVIN: Kelvin (K).
        - UNIT_FLOP_PER_SECOND: Computation. Flop per second (FLOP/sec).
        - UNIT_KILOFLOP_PER_SECOND: Kiloflop per second (KFLOP/sec).
        - UNIT_MEGAFLOP_PER_SECOND: Megaflop per second (MFLOP/sec).
        - UNIT_GIGAFLOP_PER_SECOND: Gigaflop per second (GFLOP/sec).
        - UNIT_PETAFLOP_PER_SECOND: Petaflop per second (PFLOP/sec).
        - UNIT_EXAFLOP_PER_SECOND: Exaflop per second (EFLOP/sec).
        - UNIT_METERS_PER_SECOND: Velocity. Meters per second (m/sec).
        - UNIT_KILOMETERS_PER_HOUR: Kilometers per hour (km/h).
        - UNIT_MILES_PER_HOUR: Miles per hour (mi/h).
        - UNIT_MILLIMETER: Length. Millimeter.
        - UNIT_CENTIMETER: Centimeter.
        - UNIT_METER: Meter.
        - UNIT_KILOMETER: Kilometer.
        - UNIT_MILE: Mile.
        - UNIT_PPM: Concentration. Parts per million (ppm).
        - UNIT_EVENTS_PER_SECOND: Events per second
        - UNIT_PACKETS: Packets
        - UNIT_DBM: dBm (dbm)
        - UNIT_VIRTUAL_CPU: Virtual CPU cores based on CPU time (vcpu)
        - UNIT_MESSAGES_PER_SECOND: Messages per second (mps)
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unit_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] max: Max value in extended number format or empty.
        :param pulumi.Input[str] min: Min value in extended number format or empty.
        :param pulumi.Input[int] precision: Tick value precision (null as default, 0-7 in other cases).
        :param pulumi.Input[str] title: Title or empty.
        :param pulumi.Input[str] type: Type. Values:
               - YAXIS_TYPE_UNSPECIFIED: Not specified (linear by default).
               - YAXIS_TYPE_LINEAR: Linear.
               - YAXIS_TYPE_LOGARITHMIC: Logarithmic.
        :param pulumi.Input[str] unit_format: Unit format. Values:
               - UNIT_NONE: Misc. None (show tick values as-is).
               - UNIT_COUNT: Count.
               - UNIT_PERCENT: Percent (0-100).
               - UNIT_PERCENT_UNIT: Percent (0-1).
               - UNIT_NANOSECONDS: Time. Nanoseconds (ns).
               - UNIT_MICROSECONDS: Microseconds (s).
               - UNIT_MILLISECONDS: Milliseconds (ms).
               - UNIT_SECONDS: Seconds (s).
               - UNIT_MINUTES: Minutes (m).
               - UNIT_HOURS: Hours (h).
               - UNIT_DAYS: Days (d).
               - UNIT_BITS_SI: Data (SI). Bits (SI).
               - UNIT_BYTES_SI: Bytes (SI).
               - UNIT_KILOBYTES: Kilobytes (KB).
               - UNIT_MEGABYTES: Megabytes (MB).
               - UNIT_GIGABYTES: Gigabytes (GB).
               - UNIT_TERABYTES: Terabytes (TB)
               - UNIT_PETABYTES: Petabytes (PB).
               - UNIT_EXABYTES: Exabytes (EB).
               - UNIT_BITS_IEC: Data (IEC). Bits (IEC).
               - UNIT_BYTES_IEC: Bytes (IEC).
               - UNIT_KIBIBYTES: Kibibytes (KiB).
               - UNIT_MEBIBYTES: Mebibytes (MiB).
               - UNIT_GIBIBYTES: Gigibytes (GiB).
               - UNIT_TEBIBYTES: Tebibytes (TiB).
               - UNIT_PEBIBYTES: Pebibytes (PiB).
               - UNIT_EXBIBYTES: Exbibytes (EiB).
               - UNIT_REQUESTS_PER_SECOND: Throughput. Requests per second (reqps).
               - UNIT_OPERATIONS_PER_SECOND: Operations per second (ops).
               - UNIT_WRITES_PER_SECOND: Writes per second (wps).
               - UNIT_READS_PER_SECOND: Reads per second (rps).
               - UNIT_PACKETS_PER_SECOND: Packets per second (pps).
               - UNIT_IO_OPERATIONS_PER_SECOND: IO operations per second (iops).
               - UNIT_COUNTS_PER_SECOND: Counts per second (counts/sec).
               - UNIT_BITS_SI_PER_SECOND: Data Rate (SI). Bits (SI) per second (bits/sec).
               - UNIT_BYTES_SI_PER_SECOND: Bytes (SI) per second (bytes/sec).
               - UNIT_KILOBITS_PER_SECOND: Kilobits per second (KBits/sec).
               - UNIT_KILOBYTES_PER_SECOND: Kilobytes per second (KB/sec).
               - UNIT_MEGABITS_PER_SECOND: Megabits per second (MBits/sec).
               - UNIT_MEGABYTES_PER_SECOND: Megabytes per second (MB/sec).
               - UNIT_GIGABITS_PER_SECOND: Gigabits per second (GBits/sec).
               - UNIT_GIGABYTES_PER_SECOND: Gigabytes per second (GB/sec).
               - UNIT_TERABITS_PER_SECOND: Terabits per second (TBits/sec).
               - UNIT_TERABYTES_PER_SECOND: Terabytes per second (TB/sec).
               - UNIT_PETABITS_PER_SECOND: Petabits per second (Pbits/sec).
               - UNIT_PETABYTES_PER_SECOND: Petabytes per second (PB/sec).
               - UNIT_BITS_IEC_PER_SECOND: Data Rate (IEC). Bits (IEC) per second (bits/sec).
               - UNIT_BYTES_IEC_PER_SECOND: Bytes (IEC) per second (bytes/sec).
               - UNIT_KIBIBITS_PER_SECOND: Kibibits per second (KiBits/sec).
               - UNIT_KIBIBYTES_PER_SECOND: Kibibytes per second (KiB/sec).
               - UNIT_MEBIBITS_PER_SECOND: Mebibits per second (MiBits/sec).
               - UNIT_MEBIBYTES_PER_SECOND: Mebibytes per second (MiB/sec).
               - UNIT_GIBIBITS_PER_SECOND: Gibibits per second (GiBits/sec).
               - UNIT_GIBIBYTES_PER_SECOND: Gibibytes per second (GiB/sec).
               - UNIT_TEBIBITS_PER_SECOND: Tebibits per second (TiBits/sec).
               - UNIT_TEBIBYTES_PER_SECOND: Tebibytes per second (TiB/sec).
               - UNIT_PEBIBITS_PER_SECOND: Pebibits per second (PiBits/sec).
               - UNIT_PEBIBYTES_PER_SECOND: Pebibytes per second (PiB/sec).
               - UNIT_DATETIME_UTC: Date & time. Datetime (UTC).
               - UNIT_DATETIME_LOCAL: Datetime (local).
               - UNIT_HERTZ: Frequency. Hertz (Hz).
               - UNIT_KILOHERTZ: Kilohertz (KHz).
               - UNIT_MEGAHERTZ: Megahertz (MHz).
               - UNIT_GIGAHERTZ: Gigahertz (GHz).
               - UNIT_DOLLAR: Currency. Dollar.
               - UNIT_EURO: Euro.
               - UNIT_ROUBLE: Rouble.
               - UNIT_CELSIUS: Temperature. Celsius (C).
               - UNIT_FAHRENHEIT: Fahrenheit (F).
               - UNIT_KELVIN: Kelvin (K).
               - UNIT_FLOP_PER_SECOND: Computation. Flop per second (FLOP/sec).
               - UNIT_KILOFLOP_PER_SECOND: Kiloflop per second (KFLOP/sec).
               - UNIT_MEGAFLOP_PER_SECOND: Megaflop per second (MFLOP/sec).
               - UNIT_GIGAFLOP_PER_SECOND: Gigaflop per second (GFLOP/sec).
               - UNIT_PETAFLOP_PER_SECOND: Petaflop per second (PFLOP/sec).
               - UNIT_EXAFLOP_PER_SECOND: Exaflop per second (EFLOP/sec).
               - UNIT_METERS_PER_SECOND: Velocity. Meters per second (m/sec).
               - UNIT_KILOMETERS_PER_HOUR: Kilometers per hour (km/h).
               - UNIT_MILES_PER_HOUR: Miles per hour (mi/h).
               - UNIT_MILLIMETER: Length. Millimeter.
               - UNIT_CENTIMETER: Centimeter.
               - UNIT_METER: Meter.
               - UNIT_KILOMETER: Kilometer.
               - UNIT_MILE: Mile.
               - UNIT_PPM: Concentration. Parts per million (ppm).
               - UNIT_EVENTS_PER_SECOND: Events per second
               - UNIT_PACKETS: Packets
               - UNIT_DBM: dBm (dbm)
               - UNIT_VIRTUAL_CPU: Virtual CPU cores based on CPU time (vcpu)
               - UNIT_MESSAGES_PER_SECOND: Messages per second (mps)
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit_format is not None:
            pulumi.set(__self__, "unit_format", unit_format)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Max value in extended number format or empty.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Min value in extended number format or empty.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        Tick value precision (null as default, 0-7 in other cases).
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title or empty.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type. Values:
        - YAXIS_TYPE_UNSPECIFIED: Not specified (linear by default).
        - YAXIS_TYPE_LINEAR: Linear.
        - YAXIS_TYPE_LOGARITHMIC: Logarithmic.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unitFormat")
    def unit_format(self) -> Optional[pulumi.Input[str]]:
        """
        Unit format. Values:
        - UNIT_NONE: Misc. None (show tick values as-is).
        - UNIT_COUNT: Count.
        - UNIT_PERCENT: Percent (0-100).
        - UNIT_PERCENT_UNIT: Percent (0-1).
        - UNIT_NANOSECONDS: Time. Nanoseconds (ns).
        - UNIT_MICROSECONDS: Microseconds (s).
        - UNIT_MILLISECONDS: Milliseconds (ms).
        - UNIT_SECONDS: Seconds (s).
        - UNIT_MINUTES: Minutes (m).
        - UNIT_HOURS: Hours (h).
        - UNIT_DAYS: Days (d).
        - UNIT_BITS_SI: Data (SI). Bits (SI).
        - UNIT_BYTES_SI: Bytes (SI).
        - UNIT_KILOBYTES: Kilobytes (KB).
        - UNIT_MEGABYTES: Megabytes (MB).
        - UNIT_GIGABYTES: Gigabytes (GB).
        - UNIT_TERABYTES: Terabytes (TB)
        - UNIT_PETABYTES: Petabytes (PB).
        - UNIT_EXABYTES: Exabytes (EB).
        - UNIT_BITS_IEC: Data (IEC). Bits (IEC).
        - UNIT_BYTES_IEC: Bytes (IEC).
        - UNIT_KIBIBYTES: Kibibytes (KiB).
        - UNIT_MEBIBYTES: Mebibytes (MiB).
        - UNIT_GIBIBYTES: Gigibytes (GiB).
        - UNIT_TEBIBYTES: Tebibytes (TiB).
        - UNIT_PEBIBYTES: Pebibytes (PiB).
        - UNIT_EXBIBYTES: Exbibytes (EiB).
        - UNIT_REQUESTS_PER_SECOND: Throughput. Requests per second (reqps).
        - UNIT_OPERATIONS_PER_SECOND: Operations per second (ops).
        - UNIT_WRITES_PER_SECOND: Writes per second (wps).
        - UNIT_READS_PER_SECOND: Reads per second (rps).
        - UNIT_PACKETS_PER_SECOND: Packets per second (pps).
        - UNIT_IO_OPERATIONS_PER_SECOND: IO operations per second (iops).
        - UNIT_COUNTS_PER_SECOND: Counts per second (counts/sec).
        - UNIT_BITS_SI_PER_SECOND: Data Rate (SI). Bits (SI) per second (bits/sec).
        - UNIT_BYTES_SI_PER_SECOND: Bytes (SI) per second (bytes/sec).
        - UNIT_KILOBITS_PER_SECOND: Kilobits per second (KBits/sec).
        - UNIT_KILOBYTES_PER_SECOND: Kilobytes per second (KB/sec).
        - UNIT_MEGABITS_PER_SECOND: Megabits per second (MBits/sec).
        - UNIT_MEGABYTES_PER_SECOND: Megabytes per second (MB/sec).
        - UNIT_GIGABITS_PER_SECOND: Gigabits per second (GBits/sec).
        - UNIT_GIGABYTES_PER_SECOND: Gigabytes per second (GB/sec).
        - UNIT_TERABITS_PER_SECOND: Terabits per second (TBits/sec).
        - UNIT_TERABYTES_PER_SECOND: Terabytes per second (TB/sec).
        - UNIT_PETABITS_PER_SECOND: Petabits per second (Pbits/sec).
        - UNIT_PETABYTES_PER_SECOND: Petabytes per second (PB/sec).
        - UNIT_BITS_IEC_PER_SECOND: Data Rate (IEC). Bits (IEC) per second (bits/sec).
        - UNIT_BYTES_IEC_PER_SECOND: Bytes (IEC) per second (bytes/sec).
        - UNIT_KIBIBITS_PER_SECOND: Kibibits per second (KiBits/sec).
        - UNIT_KIBIBYTES_PER_SECOND: Kibibytes per second (KiB/sec).
        - UNIT_MEBIBITS_PER_SECOND: Mebibits per second (MiBits/sec).
        - UNIT_MEBIBYTES_PER_SECOND: Mebibytes per second (MiB/sec).
        - UNIT_GIBIBITS_PER_SECOND: Gibibits per second (GiBits/sec).
        - UNIT_GIBIBYTES_PER_SECOND: Gibibytes per second (GiB/sec).
        - UNIT_TEBIBITS_PER_SECOND: Tebibits per second (TiBits/sec).
        - UNIT_TEBIBYTES_PER_SECOND: Tebibytes per second (TiB/sec).
        - UNIT_PEBIBITS_PER_SECOND: Pebibits per second (PiBits/sec).
        - UNIT_PEBIBYTES_PER_SECOND: Pebibytes per second (PiB/sec).
        - UNIT_DATETIME_UTC: Date & time. Datetime (UTC).
        - UNIT_DATETIME_LOCAL: Datetime (local).
        - UNIT_HERTZ: Frequency. Hertz (Hz).
        - UNIT_KILOHERTZ: Kilohertz (KHz).
        - UNIT_MEGAHERTZ: Megahertz (MHz).
        - UNIT_GIGAHERTZ: Gigahertz (GHz).
        - UNIT_DOLLAR: Currency. Dollar.
        - UNIT_EURO: Euro.
        - UNIT_ROUBLE: Rouble.
        - UNIT_CELSIUS: Temperature. Celsius (C).
        - UNIT_FAHRENHEIT: Fahrenheit (F).
        - UNIT_KELVIN: Kelvin (K).
        - UNIT_FLOP_PER_SECOND: Computation. Flop per second (FLOP/sec).
        - UNIT_KILOFLOP_PER_SECOND: Kiloflop per second (KFLOP/sec).
        - UNIT_MEGAFLOP_PER_SECOND: Megaflop per second (MFLOP/sec).
        - UNIT_GIGAFLOP_PER_SECOND: Gigaflop per second (GFLOP/sec).
        - UNIT_PETAFLOP_PER_SECOND: Petaflop per second (PFLOP/sec).
        - UNIT_EXAFLOP_PER_SECOND: Exaflop per second (EFLOP/sec).
        - UNIT_METERS_PER_SECOND: Velocity. Meters per second (m/sec).
        - UNIT_KILOMETERS_PER_HOUR: Kilometers per hour (km/h).
        - UNIT_MILES_PER_HOUR: Miles per hour (mi/h).
        - UNIT_MILLIMETER: Length. Millimeter.
        - UNIT_CENTIMETER: Centimeter.
        - UNIT_METER: Meter.
        - UNIT_KILOMETER: Kilometer.
        - UNIT_MILE: Mile.
        - UNIT_PPM: Concentration. Parts per million (ppm).
        - UNIT_EVENTS_PER_SECOND: Events per second
        - UNIT_PACKETS: Packets
        - UNIT_DBM: dBm (dbm)
        - UNIT_VIRTUAL_CPU: Virtual CPU cores based on CPU time (vcpu)
        - UNIT_MESSAGES_PER_SECOND: Messages per second (mps)
        """
        return pulumi.get(self, "unit_format")

    @unit_format.setter
    def unit_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit_format", value)


if not MYPY:
    class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[str]]
        """
        Max value in extended number format or empty.
        """
        min: NotRequired[pulumi.Input[str]]
        """
        Min value in extended number format or empty.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        Tick value precision (null as default, 0-7 in other cases).
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Title or empty.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type.
        """
        unit_format: NotRequired[pulumi.Input[str]]
        """
        Unit format.
        """
elif False:
    MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unit_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] max: Max value in extended number format or empty.
        :param pulumi.Input[str] min: Min value in extended number format or empty.
        :param pulumi.Input[int] precision: Tick value precision (null as default, 0-7 in other cases).
        :param pulumi.Input[str] title: Title or empty.
        :param pulumi.Input[str] type: Type.
        :param pulumi.Input[str] unit_format: Unit format.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit_format is not None:
            pulumi.set(__self__, "unit_format", unit_format)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Max value in extended number format or empty.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Min value in extended number format or empty.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        Tick value precision (null as default, 0-7 in other cases).
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title or empty.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unitFormat")
    def unit_format(self) -> Optional[pulumi.Input[str]]:
        """
        Unit format.
        """
        return pulumi.get(self, "unit_format")

    @unit_format.setter
    def unit_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit_format", value)


if not MYPY:
    class MonitoringDashboardWidgetPositionArgsDict(TypedDict):
        h: NotRequired[pulumi.Input[int]]
        """
        Height.
        """
        w: NotRequired[pulumi.Input[int]]
        """
        Width.
        """
        x: NotRequired[pulumi.Input[int]]
        """
        X-axis top-left corner coordinate.
        """
        y: NotRequired[pulumi.Input[int]]
        """
        Y-axis top-left corner coordinate.
        """
elif False:
    MonitoringDashboardWidgetPositionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetPositionArgs:
    def __init__(__self__, *,
                 h: Optional[pulumi.Input[int]] = None,
                 w: Optional[pulumi.Input[int]] = None,
                 x: Optional[pulumi.Input[int]] = None,
                 y: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] h: Height.
        :param pulumi.Input[int] w: Width.
        :param pulumi.Input[int] x: X-axis top-left corner coordinate.
        :param pulumi.Input[int] y: Y-axis top-left corner coordinate.
        """
        if h is not None:
            pulumi.set(__self__, "h", h)
        if w is not None:
            pulumi.set(__self__, "w", w)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def h(self) -> Optional[pulumi.Input[int]]:
        """
        Height.
        """
        return pulumi.get(self, "h")

    @h.setter
    def h(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "h", value)

    @property
    @pulumi.getter
    def w(self) -> Optional[pulumi.Input[int]]:
        """
        Width.
        """
        return pulumi.get(self, "w")

    @w.setter
    def w(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "w", value)

    @property
    @pulumi.getter
    def x(self) -> Optional[pulumi.Input[int]]:
        """
        X-axis top-left corner coordinate.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> Optional[pulumi.Input[int]]:
        """
        Y-axis top-left corner coordinate.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y", value)


if not MYPY:
    class MonitoringDashboardWidgetTextArgsDict(TypedDict):
        text: NotRequired[pulumi.Input[str]]
        """
        Widget text.
        """
elif False:
    MonitoringDashboardWidgetTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetTextArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: Widget text.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Widget text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class MonitoringDashboardWidgetTitleArgsDict(TypedDict):
        text: pulumi.Input[str]
        """
        Title text.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        Title size. Values:
        - TITLE_SIZE_XS: Extra small size.
        - TITLE_SIZE_S: Small size.
        - TITLE_SIZE_M: Middle size.
        - TITLE_SIZE_L: Large size.
        """
elif False:
    MonitoringDashboardWidgetTitleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringDashboardWidgetTitleArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: Title text.
        :param pulumi.Input[str] size: Title size. Values:
               - TITLE_SIZE_XS: Extra small size.
               - TITLE_SIZE_S: Small size.
               - TITLE_SIZE_M: Middle size.
               - TITLE_SIZE_L: Large size.
        """
        pulumi.set(__self__, "text", text)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        Title text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Title size. Values:
        - TITLE_SIZE_XS: Extra small size.
        - TITLE_SIZE_S: Small size.
        - TITLE_SIZE_M: Middle size.
        - TITLE_SIZE_L: Large size.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class OrganizationmanagerOsLoginSettingsSshCertificateSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables usage of ssh certificates signed by trusted CA.
        """
elif False:
    OrganizationmanagerOsLoginSettingsSshCertificateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationmanagerOsLoginSettingsSshCertificateSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enables or disables usage of ssh certificates signed by trusted CA.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables usage of ssh certificates signed by trusted CA.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class OrganizationmanagerOsLoginSettingsUserSshKeySettingsArgsDict(TypedDict):
        allow_manage_own_keys: NotRequired[pulumi.Input[bool]]
        """
        If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables usage of ssh keys assigned to a specific subject.
        """
elif False:
    OrganizationmanagerOsLoginSettingsUserSshKeySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationmanagerOsLoginSettingsUserSshKeySettingsArgs:
    def __init__(__self__, *,
                 allow_manage_own_keys: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_manage_own_keys: If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        :param pulumi.Input[bool] enabled: Enables or disables usage of ssh keys assigned to a specific subject.
        """
        if allow_manage_own_keys is not None:
            pulumi.set(__self__, "allow_manage_own_keys", allow_manage_own_keys)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="allowManageOwnKeys")
    def allow_manage_own_keys(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        """
        return pulumi.get(self, "allow_manage_own_keys")

    @allow_manage_own_keys.setter
    def allow_manage_own_keys(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_manage_own_keys", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables usage of ssh keys assigned to a specific subject.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class OrganizationmanagerSamlFederationSecuritySettingsArgsDict(TypedDict):
        encrypted_assertions: NotRequired[pulumi.Input[bool]]
        """
        Enable encrypted assertions.
        """
        force_authn: NotRequired[pulumi.Input[bool]]
        """
        Force authentication on session expiration
        """
elif False:
    OrganizationmanagerSamlFederationSecuritySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationmanagerSamlFederationSecuritySettingsArgs:
    def __init__(__self__, *,
                 encrypted_assertions: Optional[pulumi.Input[bool]] = None,
                 force_authn: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] encrypted_assertions: Enable encrypted assertions.
        :param pulumi.Input[bool] force_authn: Force authentication on session expiration
        """
        if encrypted_assertions is not None:
            pulumi.set(__self__, "encrypted_assertions", encrypted_assertions)
        if force_authn is not None:
            pulumi.set(__self__, "force_authn", force_authn)

    @property
    @pulumi.getter(name="encryptedAssertions")
    def encrypted_assertions(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable encrypted assertions.
        """
        return pulumi.get(self, "encrypted_assertions")

    @encrypted_assertions.setter
    def encrypted_assertions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted_assertions", value)

    @property
    @pulumi.getter(name="forceAuthn")
    def force_authn(self) -> Optional[pulumi.Input[bool]]:
        """
        Force authentication on session expiration
        """
        return pulumi.get(self, "force_authn")

    @force_authn.setter
    def force_authn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_authn", value)


if not MYPY:
    class ServerlessContainerConnectivityArgsDict(TypedDict):
        network_id: pulumi.Input[str]
elif False:
    ServerlessContainerConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerConnectivityArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[str]):
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class ServerlessContainerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        Invoke URL for the Yandex Cloud Serverless Container
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        digest: NotRequired[pulumi.Input[str]]
        environment: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        work_dir: NotRequired[pulumi.Input[str]]
elif False:
    ServerlessContainerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 digest: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 work_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Invoke URL for the Yandex Cloud Serverless Container
        """
        pulumi.set(__self__, "url", url)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if work_dir is not None:
            pulumi.set(__self__, "work_dir", work_dir)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Invoke URL for the Yandex Cloud Serverless Container
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="workDir")
    def work_dir(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_dir")

    @work_dir.setter
    def work_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_dir", value)


if not MYPY:
    class ServerlessContainerLogOptionsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Is logging from container disabled
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Folder ID for the Yandex Cloud Serverless Container
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Log entries are written to specified log group
        """
        min_level: NotRequired[pulumi.Input[str]]
        """
        Minimum log entry level
        """
elif False:
    ServerlessContainerLogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerLogOptionsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 min_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: Is logging from container disabled
        :param pulumi.Input[str] folder_id: Folder ID for the Yandex Cloud Serverless Container
        :param pulumi.Input[str] log_group_id: Log entries are written to specified log group
        :param pulumi.Input[str] min_level: Minimum log entry level
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is logging from container disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Folder ID for the Yandex Cloud Serverless Container
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log entries are written to specified log group
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum log entry level
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)


if not MYPY:
    class ServerlessContainerMountArgsDict(TypedDict):
        mount_point_path: pulumi.Input[str]
        ephemeral_disk: NotRequired[pulumi.Input['ServerlessContainerMountEphemeralDiskArgsDict']]
        mode: NotRequired[pulumi.Input[str]]
        object_storage: NotRequired[pulumi.Input['ServerlessContainerMountObjectStorageArgsDict']]
elif False:
    ServerlessContainerMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerMountArgs:
    def __init__(__self__, *,
                 mount_point_path: pulumi.Input[str],
                 ephemeral_disk: Optional[pulumi.Input['ServerlessContainerMountEphemeralDiskArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 object_storage: Optional[pulumi.Input['ServerlessContainerMountObjectStorageArgs']] = None):
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mount_point_path")

    @mount_point_path.setter
    def mount_point_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point_path", value)

    @property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional[pulumi.Input['ServerlessContainerMountEphemeralDiskArgs']]:
        return pulumi.get(self, "ephemeral_disk")

    @ephemeral_disk.setter
    def ephemeral_disk(self, value: Optional[pulumi.Input['ServerlessContainerMountEphemeralDiskArgs']]):
        pulumi.set(self, "ephemeral_disk", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional[pulumi.Input['ServerlessContainerMountObjectStorageArgs']]:
        return pulumi.get(self, "object_storage")

    @object_storage.setter
    def object_storage(self, value: Optional[pulumi.Input['ServerlessContainerMountObjectStorageArgs']]):
        pulumi.set(self, "object_storage", value)


if not MYPY:
    class ServerlessContainerMountEphemeralDiskArgsDict(TypedDict):
        size_gb: pulumi.Input[int]
        block_size_kb: NotRequired[pulumi.Input[int]]
elif False:
    ServerlessContainerMountEphemeralDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerMountEphemeralDiskArgs:
    def __init__(__self__, *,
                 size_gb: pulumi.Input[int],
                 block_size_kb: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "size_gb", size_gb)
        if block_size_kb is not None:
            pulumi.set(__self__, "block_size_kb", block_size_kb)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_gb", value)

    @property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "block_size_kb")

    @block_size_kb.setter
    def block_size_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size_kb", value)


if not MYPY:
    class ServerlessContainerMountObjectStorageArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        prefix: NotRequired[pulumi.Input[str]]
elif False:
    ServerlessContainerMountObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerMountObjectStorageArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ServerlessContainerProvisionPolicyArgsDict(TypedDict):
        min_instances: pulumi.Input[int]
elif False:
    ServerlessContainerProvisionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerProvisionPolicyArgs:
    def __init__(__self__, *,
                 min_instances: pulumi.Input[int]):
        pulumi.set(__self__, "min_instances", min_instances)

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min_instances")

    @min_instances.setter
    def min_instances(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_instances", value)


if not MYPY:
    class ServerlessContainerRuntimeArgsDict(TypedDict):
        type: pulumi.Input[str]
elif False:
    ServerlessContainerRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerRuntimeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerlessContainerSecretArgsDict(TypedDict):
        environment_variable: pulumi.Input[str]
        """
        (Required) Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        id: pulumi.Input[str]
        """
        (Required) Secret's id
        """
        key: pulumi.Input[str]
        """
        (Required) Secret's entries key which value will be stored in environment variable
        """
        version_id: pulumi.Input[str]
        """
        (Required) Secret's version id
        """
elif False:
    ServerlessContainerSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerSecretArgs:
    def __init__(__self__, *,
                 environment_variable: pulumi.Input[str],
                 id: pulumi.Input[str],
                 key: pulumi.Input[str],
                 version_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] environment_variable: (Required) Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        :param pulumi.Input[str] id: (Required) Secret's id
        :param pulumi.Input[str] key: (Required) Secret's entries key which value will be stored in environment variable
        :param pulumi.Input[str] version_id: (Required) Secret's version id
        """
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> pulumi.Input[str]:
        """
        (Required) Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment_variable")

    @environment_variable.setter
    def environment_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_variable", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Required) Secret's id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        (Required) Secret's entries key which value will be stored in environment variable
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> pulumi.Input[str]:
        """
        (Required) Secret's version id
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class ServerlessContainerStorageMountArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        mount_point_path: pulumi.Input[str]
        prefix: NotRequired[pulumi.Input[str]]
        read_only: NotRequired[pulumi.Input[bool]]
elif False:
    ServerlessContainerStorageMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessContainerStorageMountArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 mount_point_path: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mount_point_path")

    @mount_point_path.setter
    def mount_point_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class ServerlessEventrouterConnectorYdArgsDict(TypedDict):
        consumer: pulumi.Input[str]
        """
        Consumer name
        """
        database: pulumi.Input[str]
        """
        Stream database
        """
        service_account_id: pulumi.Input[str]
        """
        Service account which has read permission on the stream
        """
        stream_name: pulumi.Input[str]
        """
        Stream name, absolute or relative
        """
elif False:
    ServerlessEventrouterConnectorYdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterConnectorYdArgs:
    def __init__(__self__, *,
                 consumer: pulumi.Input[str],
                 database: pulumi.Input[str],
                 service_account_id: pulumi.Input[str],
                 stream_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer: Consumer name
        :param pulumi.Input[str] database: Stream database
        :param pulumi.Input[str] service_account_id: Service account which has read permission on the stream
        :param pulumi.Input[str] stream_name: Stream name, absolute or relative
        """
        pulumi.set(__self__, "consumer", consumer)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter
    def consumer(self) -> pulumi.Input[str]:
        """
        Consumer name
        """
        return pulumi.get(self, "consumer")

    @consumer.setter
    def consumer(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Stream database
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account which has read permission on the stream
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        Stream name, absolute or relative
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class ServerlessEventrouterConnectorYmqArgsDict(TypedDict):
        queue_arn: pulumi.Input[str]
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        service_account_id: pulumi.Input[str]
        """
        Service account which has read access to the queue
        """
        batch_size: NotRequired[pulumi.Input[int]]
        """
        Batch size for polling
        """
        polling_timeout: NotRequired[pulumi.Input[str]]
        """
        Queue polling timeout
        """
        visibility_timeout: NotRequired[pulumi.Input[str]]
        """
        Queue visibility timeout override
        """
elif False:
    ServerlessEventrouterConnectorYmqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterConnectorYmqArgs:
    def __init__(__self__, *,
                 queue_arn: pulumi.Input[str],
                 service_account_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 polling_timeout: Optional[pulumi.Input[str]] = None,
                 visibility_timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] queue_arn: Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        :param pulumi.Input[str] service_account_id: Service account which has read access to the queue
        :param pulumi.Input[int] batch_size: Batch size for polling
        :param pulumi.Input[str] polling_timeout: Queue polling timeout
        :param pulumi.Input[str] visibility_timeout: Queue visibility timeout override
        """
        pulumi.set(__self__, "queue_arn", queue_arn)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if polling_timeout is not None:
            pulumi.set(__self__, "polling_timeout", polling_timeout)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> pulumi.Input[str]:
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        return pulumi.get(self, "queue_arn")

    @queue_arn.setter
    def queue_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_arn", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account which has read access to the queue
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Batch size for polling
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="pollingTimeout")
    def polling_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Queue polling timeout
        """
        return pulumi.get(self, "polling_timeout")

    @polling_timeout.setter
    def polling_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polling_timeout", value)

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Queue visibility timeout override
        """
        return pulumi.get(self, "visibility_timeout")

    @visibility_timeout.setter
    def visibility_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visibility_timeout", value)


if not MYPY:
    class ServerlessEventrouterRuleContainerArgsDict(TypedDict):
        container_id: pulumi.Input[str]
        """
        Container ID
        """
        batch_settings: NotRequired[pulumi.Input['ServerlessEventrouterRuleContainerBatchSettingsArgsDict']]
        """
        Batch settings
        """
        container_revision_id: NotRequired[pulumi.Input[str]]
        """
        Container revision ID
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Endpoint HTTP path to invoke
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        Service account which should be used to call a container
        """
elif False:
    ServerlessEventrouterRuleContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleContainerArgs:
    def __init__(__self__, *,
                 container_id: pulumi.Input[str],
                 batch_settings: Optional[pulumi.Input['ServerlessEventrouterRuleContainerBatchSettingsArgs']] = None,
                 container_revision_id: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container_id: Container ID
        :param pulumi.Input['ServerlessEventrouterRuleContainerBatchSettingsArgs'] batch_settings: Batch settings
        :param pulumi.Input[str] container_revision_id: Container revision ID
        :param pulumi.Input[str] path: Endpoint HTTP path to invoke
        :param pulumi.Input[str] service_account_id: Service account which should be used to call a container
        """
        pulumi.set(__self__, "container_id", container_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)
        if container_revision_id is not None:
            pulumi.set(__self__, "container_revision_id", container_revision_id)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> pulumi.Input[str]:
        """
        Container ID
        """
        return pulumi.get(self, "container_id")

    @container_id.setter
    def container_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_id", value)

    @property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional[pulumi.Input['ServerlessEventrouterRuleContainerBatchSettingsArgs']]:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @batch_settings.setter
    def batch_settings(self, value: Optional[pulumi.Input['ServerlessEventrouterRuleContainerBatchSettingsArgs']]):
        pulumi.set(self, "batch_settings", value)

    @property
    @pulumi.getter(name="containerRevisionId")
    def container_revision_id(self) -> Optional[pulumi.Input[str]]:
        """
        Container revision ID
        """
        return pulumi.get(self, "container_revision_id")

    @container_revision_id.setter
    def container_revision_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_revision_id", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint HTTP path to invoke
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        Service account which should be used to call a container
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class ServerlessEventrouterRuleContainerBatchSettingsArgsDict(TypedDict):
        cutoff: pulumi.Input[str]
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        max_bytes: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        max_count: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
elif False:
    ServerlessEventrouterRuleContainerBatchSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleContainerBatchSettingsArgs:
    def __init__(__self__, *,
                 cutoff: pulumi.Input[str],
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param pulumi.Input[int] max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param pulumi.Input[int] max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @property
    @pulumi.getter
    def cutoff(self) -> pulumi.Input[str]:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @cutoff.setter
    def cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "cutoff", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)


if not MYPY:
    class ServerlessEventrouterRuleFunctionArgsDict(TypedDict):
        function_id: pulumi.Input[str]
        """
        Function ID
        """
        batch_settings: NotRequired[pulumi.Input['ServerlessEventrouterRuleFunctionBatchSettingsArgsDict']]
        """
        Batch settings
        """
        function_tag: NotRequired[pulumi.Input[str]]
        """
        Function tag
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        Service account which has call permission on the function
        """
elif False:
    ServerlessEventrouterRuleFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleFunctionArgs:
    def __init__(__self__, *,
                 function_id: pulumi.Input[str],
                 batch_settings: Optional[pulumi.Input['ServerlessEventrouterRuleFunctionBatchSettingsArgs']] = None,
                 function_tag: Optional[pulumi.Input[str]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] function_id: Function ID
        :param pulumi.Input['ServerlessEventrouterRuleFunctionBatchSettingsArgs'] batch_settings: Batch settings
        :param pulumi.Input[str] function_tag: Function tag
        :param pulumi.Input[str] service_account_id: Service account which has call permission on the function
        """
        pulumi.set(__self__, "function_id", function_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)
        if function_tag is not None:
            pulumi.set(__self__, "function_tag", function_tag)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> pulumi.Input[str]:
        """
        Function ID
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional[pulumi.Input['ServerlessEventrouterRuleFunctionBatchSettingsArgs']]:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @batch_settings.setter
    def batch_settings(self, value: Optional[pulumi.Input['ServerlessEventrouterRuleFunctionBatchSettingsArgs']]):
        pulumi.set(self, "batch_settings", value)

    @property
    @pulumi.getter(name="functionTag")
    def function_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Function tag
        """
        return pulumi.get(self, "function_tag")

    @function_tag.setter
    def function_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_tag", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        Service account which has call permission on the function
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class ServerlessEventrouterRuleFunctionBatchSettingsArgsDict(TypedDict):
        cutoff: pulumi.Input[str]
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        max_bytes: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        max_count: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
elif False:
    ServerlessEventrouterRuleFunctionBatchSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleFunctionBatchSettingsArgs:
    def __init__(__self__, *,
                 cutoff: pulumi.Input[str],
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param pulumi.Input[int] max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param pulumi.Input[int] max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @property
    @pulumi.getter
    def cutoff(self) -> pulumi.Input[str]:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @cutoff.setter
    def cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "cutoff", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)


if not MYPY:
    class ServerlessEventrouterRuleGatewayWebsocketBroadcastArgsDict(TypedDict):
        gateway_id: pulumi.Input[str]
        """
        Gateway ID
        """
        path: pulumi.Input[str]
        """
        Path
        """
        service_account_id: pulumi.Input[str]
        """
        Service account which has permission for writing to websockets
        """
        batch_settings: NotRequired[pulumi.Input['ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgsDict']]
        """
        Batch settings
        """
elif False:
    ServerlessEventrouterRuleGatewayWebsocketBroadcastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleGatewayWebsocketBroadcastArgs:
    def __init__(__self__, *,
                 gateway_id: pulumi.Input[str],
                 path: pulumi.Input[str],
                 service_account_id: pulumi.Input[str],
                 batch_settings: Optional[pulumi.Input['ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs']] = None):
        """
        :param pulumi.Input[str] gateway_id: Gateway ID
        :param pulumi.Input[str] path: Path
        :param pulumi.Input[str] service_account_id: Service account which has permission for writing to websockets
        :param pulumi.Input['ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs'] batch_settings: Batch settings
        """
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> pulumi.Input[str]:
        """
        Gateway ID
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account which has permission for writing to websockets
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional[pulumi.Input['ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs']]:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @batch_settings.setter
    def batch_settings(self, value: Optional[pulumi.Input['ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs']]):
        pulumi.set(self, "batch_settings", value)


if not MYPY:
    class ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgsDict(TypedDict):
        cutoff: pulumi.Input[str]
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        max_bytes: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        max_count: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
elif False:
    ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs:
    def __init__(__self__, *,
                 cutoff: pulumi.Input[str],
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param pulumi.Input[int] max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param pulumi.Input[int] max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @property
    @pulumi.getter
    def cutoff(self) -> pulumi.Input[str]:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @cutoff.setter
    def cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "cutoff", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)


if not MYPY:
    class ServerlessEventrouterRuleLoggingArgsDict(TypedDict):
        service_account_id: pulumi.Input[str]
        """
        Service account which has permission for writing logs
        """
        folder_id: NotRequired[pulumi.Input[str]]
        """
        Folder ID
        """
        log_group_id: NotRequired[pulumi.Input[str]]
        """
        Log group ID
        """
elif False:
    ServerlessEventrouterRuleLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleLoggingArgs:
    def __init__(__self__, *,
                 service_account_id: pulumi.Input[str],
                 folder_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_account_id: Service account which has permission for writing logs
        :param pulumi.Input[str] folder_id: Folder ID
        :param pulumi.Input[str] log_group_id: Log group ID
        """
        pulumi.set(__self__, "service_account_id", service_account_id)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account which has permission for writing logs
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        Folder ID
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log group ID
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)


if not MYPY:
    class ServerlessEventrouterRuleWorkflowArgsDict(TypedDict):
        service_account_id: pulumi.Input[str]
        """
        Service account which should be used to start workflow
        """
        workflow_id: pulumi.Input[str]
        """
        Workflow ID
        """
        batch_settings: NotRequired[pulumi.Input['ServerlessEventrouterRuleWorkflowBatchSettingsArgsDict']]
        """
        Batch settings
        """
elif False:
    ServerlessEventrouterRuleWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleWorkflowArgs:
    def __init__(__self__, *,
                 service_account_id: pulumi.Input[str],
                 workflow_id: pulumi.Input[str],
                 batch_settings: Optional[pulumi.Input['ServerlessEventrouterRuleWorkflowBatchSettingsArgs']] = None):
        """
        :param pulumi.Input[str] service_account_id: Service account which should be used to start workflow
        :param pulumi.Input[str] workflow_id: Workflow ID
        :param pulumi.Input['ServerlessEventrouterRuleWorkflowBatchSettingsArgs'] batch_settings: Batch settings
        """
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account which should be used to start workflow
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> pulumi.Input[str]:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @workflow_id.setter
    def workflow_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workflow_id", value)

    @property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional[pulumi.Input['ServerlessEventrouterRuleWorkflowBatchSettingsArgs']]:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @batch_settings.setter
    def batch_settings(self, value: Optional[pulumi.Input['ServerlessEventrouterRuleWorkflowBatchSettingsArgs']]):
        pulumi.set(self, "batch_settings", value)


if not MYPY:
    class ServerlessEventrouterRuleWorkflowBatchSettingsArgsDict(TypedDict):
        cutoff: pulumi.Input[str]
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        max_bytes: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        max_count: NotRequired[pulumi.Input[int]]
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
elif False:
    ServerlessEventrouterRuleWorkflowBatchSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleWorkflowBatchSettingsArgs:
    def __init__(__self__, *,
                 cutoff: pulumi.Input[str],
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param pulumi.Input[int] max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param pulumi.Input[int] max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @property
    @pulumi.getter
    def cutoff(self) -> pulumi.Input[str]:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @cutoff.setter
    def cutoff(self, value: pulumi.Input[str]):
        pulumi.set(self, "cutoff", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)


if not MYPY:
    class ServerlessEventrouterRuleYdArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Stream database
        """
        service_account_id: pulumi.Input[str]
        """
        Service account, which has write permission on the stream
        """
        stream_name: pulumi.Input[str]
        """
        Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
elif False:
    ServerlessEventrouterRuleYdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleYdArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 service_account_id: pulumi.Input[str],
                 stream_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database: Stream database
        :param pulumi.Input[str] service_account_id: Service account, which has write permission on the stream
        :param pulumi.Input[str] stream_name: Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Stream database
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account, which has write permission on the stream
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class ServerlessEventrouterRuleYmqArgsDict(TypedDict):
        queue_arn: pulumi.Input[str]
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        service_account_id: pulumi.Input[str]
        """
        Service account which has write access to the queue
        """
elif False:
    ServerlessEventrouterRuleYmqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessEventrouterRuleYmqArgs:
    def __init__(__self__, *,
                 queue_arn: pulumi.Input[str],
                 service_account_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] queue_arn: Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        :param pulumi.Input[str] service_account_id: Service account which has write access to the queue
        """
        pulumi.set(__self__, "queue_arn", queue_arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> pulumi.Input[str]:
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        return pulumi.get(self, "queue_arn")

    @queue_arn.setter
    def queue_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_arn", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[str]:
        """
        Service account which has write access to the queue
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class SmartcaptchaCaptchaOverrideVariantArgsDict(TypedDict):
        challenge_type: NotRequired[pulumi.Input[str]]
        """
        Additional task type of the captcha. Possible values are documented below.
        """
        complexity: NotRequired[pulumi.Input[str]]
        """
        Complexity of the captcha.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Optional description of the rule. 0-512 characters long.
        """
        pre_check_type: NotRequired[pulumi.Input[str]]
        """
        Additional task type of the captcha.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the variant.
        """
elif False:
    SmartcaptchaCaptchaOverrideVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaOverrideVariantArgs:
    def __init__(__self__, *,
                 challenge_type: Optional[pulumi.Input[str]] = None,
                 complexity: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 pre_check_type: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] challenge_type: Additional task type of the captcha. Possible values are documented below.
        :param pulumi.Input[str] complexity: Complexity of the captcha.
        :param pulumi.Input[str] description: Optional description of the rule. 0-512 characters long.
        :param pulumi.Input[str] pre_check_type: Additional task type of the captcha.
        :param pulumi.Input[str] uuid: Unique identifier of the variant.
        """
        if challenge_type is not None:
            pulumi.set(__self__, "challenge_type", challenge_type)
        if complexity is not None:
            pulumi.set(__self__, "complexity", complexity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pre_check_type is not None:
            pulumi.set(__self__, "pre_check_type", pre_check_type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="challengeType")
    def challenge_type(self) -> Optional[pulumi.Input[str]]:
        """
        Additional task type of the captcha. Possible values are documented below.
        """
        return pulumi.get(self, "challenge_type")

    @challenge_type.setter
    def challenge_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "challenge_type", value)

    @property
    @pulumi.getter
    def complexity(self) -> Optional[pulumi.Input[str]]:
        """
        Complexity of the captcha.
        """
        return pulumi.get(self, "complexity")

    @complexity.setter
    def complexity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "complexity", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="preCheckType")
    def pre_check_type(self) -> Optional[pulumi.Input[str]]:
        """
        Additional task type of the captcha.
        """
        return pulumi.get(self, "pre_check_type")

    @pre_check_type.setter
    def pre_check_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_check_type", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the variant.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionArgsDict']]
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Optional description of the rule. 0-512 characters long.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the rule. The name is unique within the captcha. 1-50 characters long.
        """
        override_variant_uuid: NotRequired[pulumi.Input[str]]
        """
        Variant UUID to show in case of match the rule. Keep empty to use defaults.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority of the rule. Lower value means higher priority.
        """
elif False:
    SmartcaptchaCaptchaSecurityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 override_variant_uuid: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionArgs'] condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        :param pulumi.Input[str] description: Optional description of the rule. 0-512 characters long.
        :param pulumi.Input[str] name: Name of the rule. The name is unique within the captcha. 1-50 characters long.
        :param pulumi.Input[str] override_variant_uuid: Variant UUID to show in case of match the rule. Keep empty to use defaults.
        :param pulumi.Input[int] priority: Priority of the rule. Lower value means higher priority.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_variant_uuid is not None:
            pulumi.set(__self__, "override_variant_uuid", override_variant_uuid)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionArgs']]:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule. The name is unique within the captcha. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideVariantUuid")
    def override_variant_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        Variant UUID to show in case of match the rule. Keep empty to use defaults.
        """
        return pulumi.get(self, "override_variant_uuid")

    @override_variant_uuid.setter
    def override_variant_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_variant_uuid", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of the rule. Lower value means higher priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderArgsDict']]]]
        host: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostArgsDict']]
        source_ip: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgsDict']]
        uri: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriArgsDict']]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderArgs']]]] = None,
                 host: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostArgs']] = None,
                 source_ip: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgs']] = None,
                 uri: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriArgs']] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostArgs']]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostArgs']]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriArgs']]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriArgs']]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the captcha. The name must be unique within the folder.
        """
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the captcha. The name must be unique within the folder.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the captcha. The name must be unique within the folder.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionHostArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostHostArgsDict']]]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionHostArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostHostArgs']]]] = None):
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostHostArgs']]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionHostHostArgs']]]]):
        pulumi.set(self, "hosts", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionHostHostArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionHostHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionHostHostArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgsDict']]]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgsDict']
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgs']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartcaptchaCaptchaSecurityRuleConditionUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class StorageBucketAnonymousAccessFlagsArgsDict(TypedDict):
        config_read: NotRequired[pulumi.Input[bool]]
        list: NotRequired[pulumi.Input[bool]]
        """
        Allows to list object in bucket anonymously.
        """
        read: NotRequired[pulumi.Input[bool]]
        """
        Allows to read objects in bucket anonymously.
        """
elif False:
    StorageBucketAnonymousAccessFlagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketAnonymousAccessFlagsArgs:
    def __init__(__self__, *,
                 config_read: Optional[pulumi.Input[bool]] = None,
                 list: Optional[pulumi.Input[bool]] = None,
                 read: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] list: Allows to list object in bucket anonymously.
        :param pulumi.Input[bool] read: Allows to read objects in bucket anonymously.
        """
        if config_read is not None:
            pulumi.set(__self__, "config_read", config_read)
        if list is not None:
            pulumi.set(__self__, "list", list)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter(name="configRead")
    def config_read(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "config_read")

    @config_read.setter
    def config_read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "config_read", value)

    @property
    @pulumi.getter
    def list(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to list object in bucket anonymously.
        """
        return pulumi.get(self, "list")

    @list.setter
    def list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "list", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to read objects in bucket anonymously.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class StorageBucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies which origins are allowed.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies which headers are allowed.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies expose header in the response.
        """
        max_age_seconds: NotRequired[pulumi.Input[int]]
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
elif False:
    StorageBucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies which origins are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Specifies which headers are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Specifies expose header in the response.
        :param pulumi.Input[int] max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies expose header in the response.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class StorageBucketGrantArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `FULL_CONTROL`.
        """
        type: pulumi.Input[str]
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Canonical user id to grant for. Used only when type is `CanonicalUser`.
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        Uri address to grant for. Used only when type is Group.

        > To manage `grant` argument, service account with `storage.admin` role should be used.
        """
elif False:
    StorageBucketGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketGrantArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permissions: List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `FULL_CONTROL`.
        :param pulumi.Input[str] type: Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`.
        :param pulumi.Input[str] id: Canonical user id to grant for. Used only when type is `CanonicalUser`.
        :param pulumi.Input[str] uri: Uri address to grant for. Used only when type is Group.
               
               > To manage `grant` argument, service account with `storage.admin` role should be used.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `FULL_CONTROL`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Canonical user id to grant for. Used only when type is `CanonicalUser`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        Uri address to grant for. Used only when type is Group.

        > To manage `grant` argument, service account with `storage.admin` role should be used.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class StorageBucketHttpsArgsDict(TypedDict):
        certificate_id: pulumi.Input[str]
        """
         Id of the certificate in Certificate Manager, that will be used for bucket.

        The `tags` object for setting tags (or labels) for bucket. See [tags](https://yandex.cloud/docs/storage/concepts/tags) for more information.
        """
elif False:
    StorageBucketHttpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketHttpsArgs:
    def __init__(__self__, *,
                 certificate_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_id:  Id of the certificate in Certificate Manager, that will be used for bucket.
               
               The `tags` object for setting tags (or labels) for bucket. See [tags](https://yandex.cloud/docs/storage/concepts/tags) for more information.
        """
        pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> pulumi.Input[str]:
        """
         Id of the certificate in Certificate Manager, that will be used for bucket.

        The `tags` object for setting tags (or labels) for bucket. See [tags](https://yandex.cloud/docs/storage/concepts/tags) for more information.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class StorageBucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Specifies lifecycle rule status.
        """
        abort_incomplete_multipart_upload_days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        expiration: NotRequired[pulumi.Input['StorageBucketLifecycleRuleExpirationArgsDict']]
        """
        Specifies a period in the object's expire (documented below).
        """
        filter: NotRequired[pulumi.Input['StorageBucketLifecycleRuleFilterArgsDict']]
        """
        Filter block identifies one or more objects to which the rule applies. A Filter must have exactly one of Prefix, Tag, or And specified. The filter supports the following options:

        - object_size_greater_than - (Optional) Minimum object size to which the rule applies.
        - object_size_less_than - (Optional) Maximum object size to which the rule applies.
        - prefix - (Optional) Object key prefix identifying one or more objects to which the rule applies.
        - tag - (Optional) A key and value pair for filtering objects. E.g.: key=key1, value=value1.
        - and - (Optional) A logical `and` operator applied to one or more filter parameters. It should be used when two or more of the above parameters are used. It supports the following parameters:

        - object_size_greater_than - (Optional) Minimum object size to which the rule applies.
        - object_size_less_than - (Optional) Maximum object size to which the rule applies.
        - prefix - (Optional) Object key prefix identifying one or more objects to which the rule applies.
        - tags - (Optional) Key-value pairs for filtering objects. All of these tags must exist in the object's tags to apply the rule. E.g.: key1=value1, key2=value2
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionExpirationArgsDict']]
        """
        Specifies when noncurrent object versions expire (documented below).
        """
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgsDict']]]]
        """
        Specifies when noncurrent object versions transitions (documented below).

        At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition`, `noncurrent_version_expiration`, `noncurrent_version_transition` must be specified.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleTransitionArgsDict']]]]
        """
        Specifies a period in the object's transitions (documented below).
        """
elif False:
    StorageBucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[int]] = None,
                 expiration: Optional[pulumi.Input['StorageBucketLifecycleRuleExpirationArgs']] = None,
                 filter: Optional[pulumi.Input['StorageBucketLifecycleRuleFilterArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs']] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        :param pulumi.Input['StorageBucketLifecycleRuleExpirationArgs'] expiration: Specifies a period in the object's expire (documented below).
        :param pulumi.Input['StorageBucketLifecycleRuleFilterArgs'] filter: Filter block identifies one or more objects to which the rule applies. A Filter must have exactly one of Prefix, Tag, or And specified. The filter supports the following options:
               
               - object_size_greater_than - (Optional) Minimum object size to which the rule applies.
               - object_size_less_than - (Optional) Maximum object size to which the rule applies.
               - prefix - (Optional) Object key prefix identifying one or more objects to which the rule applies.
               - tag - (Optional) A key and value pair for filtering objects. E.g.: key=key1, value=value1.
               - and - (Optional) A logical `and` operator applied to one or more filter parameters. It should be used when two or more of the above parameters are used. It supports the following parameters:
               
               - object_size_greater_than - (Optional) Minimum object size to which the rule applies.
               - object_size_less_than - (Optional) Maximum object size to which the rule applies.
               - prefix - (Optional) Object key prefix identifying one or more objects to which the rule applies.
               - tags - (Optional) Key-value pairs for filtering objects. All of these tags must exist in the object's tags to apply the rule. E.g.: key1=value1, key2=value2
        :param pulumi.Input[str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Specifies when noncurrent object versions expire (documented below).
        :param pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs']]] noncurrent_version_transitions: Specifies when noncurrent object versions transitions (documented below).
               
               At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition`, `noncurrent_version_expiration`, `noncurrent_version_transition` must be specified.
        :param pulumi.Input[str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleTransitionArgs']]] transitions: Specifies a period in the object's transitions (documented below).
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            warnings.warn("""Use filter instead""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Use filter instead""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['StorageBucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a period in the object's expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['StorageBucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['StorageBucketLifecycleRuleFilterArgs']]:
        """
        Filter block identifies one or more objects to which the rule applies. A Filter must have exactly one of Prefix, Tag, or And specified. The filter supports the following options:

        - object_size_greater_than - (Optional) Minimum object size to which the rule applies.
        - object_size_less_than - (Optional) Maximum object size to which the rule applies.
        - prefix - (Optional) Object key prefix identifying one or more objects to which the rule applies.
        - tag - (Optional) A key and value pair for filtering objects. E.g.: key=key1, value=value1.
        - and - (Optional) A logical `and` operator applied to one or more filter parameters. It should be used when two or more of the above parameters are used. It supports the following parameters:

        - object_size_greater_than - (Optional) Minimum object size to which the rule applies.
        - object_size_less_than - (Optional) Maximum object size to which the rule applies.
        - prefix - (Optional) Object key prefix identifying one or more objects to which the rule applies.
        - tags - (Optional) Key-value pairs for filtering objects. All of these tags must exist in the object's tags to apply the rule. E.g.: key1=value1, key2=value2
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['StorageBucketLifecycleRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs']]:
        """
        Specifies when noncurrent object versions expire (documented below).
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]:
        """
        Specifies when noncurrent object versions transitions (documented below).

        At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition`, `noncurrent_version_expiration`, `noncurrent_version_transition` must be specified.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use filter instead""")
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleTransitionArgs']]]]:
        """
        Specifies a period in the object's transitions (documented below).
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageBucketLifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class StorageBucketLifecycleRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[str]]
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[bool]]
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
elif False:
    StorageBucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] date: Specifies the date after which you want the corresponding action to take effect.
        :param pulumi.Input[int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        :param pulumi.Input[bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class StorageBucketLifecycleRuleFilterArgsDict(TypedDict):
        and_: NotRequired[pulumi.Input['StorageBucketLifecycleRuleFilterAndArgsDict']]
        object_size_greater_than: NotRequired[pulumi.Input[int]]
        object_size_less_than: NotRequired[pulumi.Input[int]]
        prefix: NotRequired[pulumi.Input[str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        tag: NotRequired[pulumi.Input['StorageBucketLifecycleRuleFilterTagArgsDict']]
elif False:
    StorageBucketLifecycleRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleFilterArgs:
    def __init__(__self__, *,
                 and_: Optional[pulumi.Input['StorageBucketLifecycleRuleFilterAndArgs']] = None,
                 object_size_greater_than: Optional[pulumi.Input[int]] = None,
                 object_size_less_than: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input['StorageBucketLifecycleRuleFilterTagArgs']] = None):
        """
        :param pulumi.Input[str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[pulumi.Input['StorageBucketLifecycleRuleFilterAndArgs']]:
        return pulumi.get(self, "and_")

    @and_.setter
    def and_(self, value: Optional[pulumi.Input['StorageBucketLifecycleRuleFilterAndArgs']]):
        pulumi.set(self, "and_", value)

    @property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_size_less_than", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['StorageBucketLifecycleRuleFilterTagArgs']]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['StorageBucketLifecycleRuleFilterTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class StorageBucketLifecycleRuleFilterAndArgsDict(TypedDict):
        object_size_greater_than: NotRequired[pulumi.Input[int]]
        object_size_less_than: NotRequired[pulumi.Input[int]]
        prefix: NotRequired[pulumi.Input[str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    StorageBucketLifecycleRuleFilterAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleFilterAndArgs:
    def __init__(__self__, *,
                 object_size_greater_than: Optional[pulumi.Input[int]] = None,
                 object_size_less_than: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        """
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_size_less_than", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class StorageBucketLifecycleRuleFilterTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    StorageBucketLifecycleRuleFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleFilterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class StorageBucketLifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days noncurrent object versions expire.
        """
elif False:
    StorageBucketLifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days noncurrent object versions expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class StorageBucketLifecycleRuleNoncurrentVersionTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[str]
        """
        Specifies the storage class to which you want the noncurrent object versions to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days noncurrent object versions transition.
        """
elif False:
    StorageBucketLifecycleRuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[str],
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] storage_class: Specifies the storage class to which you want the noncurrent object versions to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions transition.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        Specifies the storage class to which you want the noncurrent object versions to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class StorageBucketLifecycleRuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[str]
        """
        Specifies the storage class to which you want the object to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        """
        date: NotRequired[pulumi.Input[str]]
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
elif False:
    StorageBucketLifecycleRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[str],
                 date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] storage_class: Specifies the storage class to which you want the object to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        :param pulumi.Input[str] date: Specifies the date after which you want the corresponding action to take effect.
        :param pulumi.Input[int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        Specifies the storage class to which you want the object to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class StorageBucketLoggingArgsDict(TypedDict):
        target_bucket: pulumi.Input[str]
        """
        The name of the bucket that will receive the log objects.
        """
        target_prefix: NotRequired[pulumi.Input[str]]
        """
        To specify a key prefix for log objects.
        """
elif False:
    StorageBucketLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketLoggingArgs:
    def __init__(__self__, *,
                 target_bucket: pulumi.Input[str],
                 target_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_bucket: The name of the bucket that will receive the log objects.
        :param pulumi.Input[str] target_prefix: To specify a key prefix for log objects.
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> pulumi.Input[str]:
        """
        The name of the bucket that will receive the log objects.
        """
        return pulumi.get(self, "target_bucket")

    @target_bucket.setter
    def target_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_bucket", value)

    @property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        To specify a key prefix for log objects.
        """
        return pulumi.get(self, "target_prefix")

    @target_prefix.setter
    def target_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_prefix", value)


if not MYPY:
    class StorageBucketObjectLockConfigurationArgsDict(TypedDict):
        object_lock_enabled: NotRequired[pulumi.Input[str]]
        """
        Enable object locking in a bucket. Require versioning to be enabled.
        """
        rule: NotRequired[pulumi.Input['StorageBucketObjectLockConfigurationRuleArgsDict']]
        """
        Specifies a default locking configuration for added objects. Require object_lock_enabled to be enabled.
        """
elif False:
    StorageBucketObjectLockConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketObjectLockConfigurationArgs:
    def __init__(__self__, *,
                 object_lock_enabled: Optional[pulumi.Input[str]] = None,
                 rule: Optional[pulumi.Input['StorageBucketObjectLockConfigurationRuleArgs']] = None):
        """
        :param pulumi.Input[str] object_lock_enabled: Enable object locking in a bucket. Require versioning to be enabled.
        :param pulumi.Input['StorageBucketObjectLockConfigurationRuleArgs'] rule: Specifies a default locking configuration for added objects. Require object_lock_enabled to be enabled.
        """
        if object_lock_enabled is not None:
            pulumi.set(__self__, "object_lock_enabled", object_lock_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter(name="objectLockEnabled")
    def object_lock_enabled(self) -> Optional[pulumi.Input[str]]:
        """
        Enable object locking in a bucket. Require versioning to be enabled.
        """
        return pulumi.get(self, "object_lock_enabled")

    @object_lock_enabled.setter
    def object_lock_enabled(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_lock_enabled", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input['StorageBucketObjectLockConfigurationRuleArgs']]:
        """
        Specifies a default locking configuration for added objects. Require object_lock_enabled to be enabled.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input['StorageBucketObjectLockConfigurationRuleArgs']]):
        pulumi.set(self, "rule", value)


if not MYPY:
    class StorageBucketObjectLockConfigurationRuleArgsDict(TypedDict):
        default_retention: pulumi.Input['StorageBucketObjectLockConfigurationRuleDefaultRetentionArgsDict']
elif False:
    StorageBucketObjectLockConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketObjectLockConfigurationRuleArgs:
    def __init__(__self__, *,
                 default_retention: pulumi.Input['StorageBucketObjectLockConfigurationRuleDefaultRetentionArgs']):
        pulumi.set(__self__, "default_retention", default_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> pulumi.Input['StorageBucketObjectLockConfigurationRuleDefaultRetentionArgs']:
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: pulumi.Input['StorageBucketObjectLockConfigurationRuleDefaultRetentionArgs']):
        pulumi.set(self, "default_retention", value)


if not MYPY:
    class StorageBucketObjectLockConfigurationRuleDefaultRetentionArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        Specifies a type of object lock. One of `["GOVERNANCE", "COMPLIANCE"]`.
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies a retention period in days after uploading an object version. It must be a positive integer. You can't set it simultaneously with `years`.
        """
        years: NotRequired[pulumi.Input[int]]
        """
        Specifies a retention period in years after uploading an object version. It must be a positive integer. You can't set it simultaneously with `days`.
        """
elif False:
    StorageBucketObjectLockConfigurationRuleDefaultRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketObjectLockConfigurationRuleDefaultRetentionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 days: Optional[pulumi.Input[int]] = None,
                 years: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: Specifies a type of object lock. One of `["GOVERNANCE", "COMPLIANCE"]`.
        :param pulumi.Input[int] days: Specifies a retention period in days after uploading an object version. It must be a positive integer. You can't set it simultaneously with `years`.
        :param pulumi.Input[int] years: Specifies a retention period in years after uploading an object version. It must be a positive integer. You can't set it simultaneously with `days`.
        """
        pulumi.set(__self__, "mode", mode)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Specifies a type of object lock. One of `["GOVERNANCE", "COMPLIANCE"]`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a retention period in days after uploading an object version. It must be a positive integer. You can't set it simultaneously with `years`.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a retention period in years after uploading an object version. It must be a positive integer. You can't set it simultaneously with `days`.
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class StorageBucketServerSideEncryptionConfigurationArgsDict(TypedDict):
        rule: pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleArgsDict']
        """
        A single object for server-side encryption by default configuration. (documented below)
        """
elif False:
    StorageBucketServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 rule: pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleArgs']):
        """
        :param pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleArgs'] rule: A single object for server-side encryption by default configuration. (documented below)
        """
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleArgs']:
        """
        A single object for server-side encryption by default configuration. (documented below)
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleArgs']):
        pulumi.set(self, "rule", value)


if not MYPY:
    class StorageBucketServerSideEncryptionConfigurationRuleArgsDict(TypedDict):
        apply_server_side_encryption_by_default: pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict']
        """
        A single object for setting server-side encryption by default. (documented below)
        """
elif False:
    StorageBucketServerSideEncryptionConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketServerSideEncryptionConfigurationRuleArgs:
    def __init__(__self__, *,
                 apply_server_side_encryption_by_default: pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']):
        """
        :param pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs'] apply_server_side_encryption_by_default: A single object for setting server-side encryption by default. (documented below)
        """
        pulumi.set(__self__, "apply_server_side_encryption_by_default", apply_server_side_encryption_by_default)

    @property
    @pulumi.getter(name="applyServerSideEncryptionByDefault")
    def apply_server_side_encryption_by_default(self) -> pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']:
        """
        A single object for setting server-side encryption by default. (documented below)
        """
        return pulumi.get(self, "apply_server_side_encryption_by_default")

    @apply_server_side_encryption_by_default.setter
    def apply_server_side_encryption_by_default(self, value: pulumi.Input['StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']):
        pulumi.set(self, "apply_server_side_encryption_by_default", value)


if not MYPY:
    class StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict(TypedDict):
        kms_master_key_id: pulumi.Input[str]
        """
        The KMS master key ID used for the SSE-KMS encryption.

        The `policy` object should contain the only field with the text of the policy. See [policy documentation](https://cloud.yandex.com/docs/storage/concepts/policy) for more information on policy format.

        Extended parameters of the bucket:

        > for this parameters, authorization by `IAM-token` will be used.
        """
        sse_algorithm: pulumi.Input[str]
        """
        The server-side encryption algorithm to use. Single valid value is `aws:kms`
        """
elif False:
    StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs:
    def __init__(__self__, *,
                 kms_master_key_id: pulumi.Input[str],
                 sse_algorithm: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_master_key_id: The KMS master key ID used for the SSE-KMS encryption.
               
               The `policy` object should contain the only field with the text of the policy. See [policy documentation](https://cloud.yandex.com/docs/storage/concepts/policy) for more information on policy format.
               
               Extended parameters of the bucket:
               
               > for this parameters, authorization by `IAM-token` will be used.
        :param pulumi.Input[str] sse_algorithm: The server-side encryption algorithm to use. Single valid value is `aws:kms`
        """
        pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> pulumi.Input[str]:
        """
        The KMS master key ID used for the SSE-KMS encryption.

        The `policy` object should contain the only field with the text of the policy. See [policy documentation](https://cloud.yandex.com/docs/storage/concepts/policy) for more information on policy format.

        Extended parameters of the bucket:

        > for this parameters, authorization by `IAM-token` will be used.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_master_key_id", value)

    @property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[str]:
        """
        The server-side encryption algorithm to use. Single valid value is `aws:kms`
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "sse_algorithm", value)


if not MYPY:
    class StorageBucketVersioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
elif False:
    StorageBucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class StorageBucketWebsiteArgsDict(TypedDict):
        error_document: NotRequired[pulumi.Input[str]]
        """
        An absolute path to the document to return in case of a 4XX error.
        """
        index_document: NotRequired[pulumi.Input[str]]
        """
        Storage returns this index document when requests are made to the root domain or any of the subfolders.
        """
        redirect_all_requests_to: NotRequired[pulumi.Input[str]]
        """
        A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        routing_rules: NotRequired[pulumi.Input[str]]
        """
        A json array containing [routing rules](https://cloud.yandex.com/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.

        The `CORS` object supports the following:
        """
elif False:
    StorageBucketWebsiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBucketWebsiteArgs:
    def __init__(__self__, *,
                 error_document: Optional[pulumi.Input[str]] = None,
                 index_document: Optional[pulumi.Input[str]] = None,
                 redirect_all_requests_to: Optional[pulumi.Input[str]] = None,
                 routing_rules: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] error_document: An absolute path to the document to return in case of a 4XX error.
        :param pulumi.Input[str] index_document: Storage returns this index document when requests are made to the root domain or any of the subfolders.
        :param pulumi.Input[str] redirect_all_requests_to: A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        :param pulumi.Input[str] routing_rules: A json array containing [routing rules](https://cloud.yandex.com/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.
               
               The `CORS` object supports the following:
        """
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[str]]:
        """
        An absolute path to the document to return in case of a 4XX error.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_document", value)

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[str]]:
        """
        Storage returns this index document when requests are made to the root domain or any of the subfolders.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_document", value)

    @property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[pulumi.Input[str]]:
        """
        A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "redirect_all_requests_to")

    @redirect_all_requests_to.setter
    def redirect_all_requests_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_all_requests_to", value)

    @property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[pulumi.Input[str]]:
        """
        A json array containing [routing rules](https://cloud.yandex.com/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.

        The `CORS` object supports the following:
        """
        return pulumi.get(self, "routing_rules")

    @routing_rules.setter
    def routing_rules(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_rules", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Optional description of the rule. 0-512 characters long.
        """
        dry_run: NotRequired[pulumi.Input[bool]]
        """
        This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        """
        dynamic_quota: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgsDict']]
        """
        Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups. The structure is documented below.

        > Exactly one rule specifier: `static_quota` or `dynamic_quota` should be specified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        """
        static_quota: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgsDict']]
        """
        Static quota. Counting each request individually. The structure is documented below.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dry_run: Optional[pulumi.Input[bool]] = None,
                 dynamic_quota: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 static_quota: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs']] = None):
        """
        :param pulumi.Input[str] description: Optional description of the rule. 0-512 characters long.
        :param pulumi.Input[bool] dry_run: This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs'] dynamic_quota: Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups. The structure is documented below.
               
               > Exactly one rule specifier: `static_quota` or `dynamic_quota` should be specified.
        :param pulumi.Input[str] name: Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        :param pulumi.Input[int] priority: Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs'] static_quota: Static quota. Counting each request individually. The structure is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if dynamic_quota is not None:
            pulumi.set(__self__, "dynamic_quota", dynamic_quota)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if static_quota is not None:
            pulumi.set(__self__, "static_quota", static_quota)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[pulumi.Input[bool]]:
        """
        This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        """
        return pulumi.get(self, "dry_run")

    @dry_run.setter
    def dry_run(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dry_run", value)

    @property
    @pulumi.getter(name="dynamicQuota")
    def dynamic_quota(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs']]:
        """
        Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups. The structure is documented below.

        > Exactly one rule specifier: `static_quota` or `dynamic_quota` should be specified.
        """
        return pulumi.get(self, "dynamic_quota")

    @dynamic_quota.setter
    def dynamic_quota(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs']]):
        pulumi.set(self, "dynamic_quota", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="staticQuota")
    def static_quota(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs']]:
        """
        Static quota. Counting each request individually. The structure is documented below.
        """
        return pulumi.get(self, "static_quota")

    @static_quota.setter
    def static_quota(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs']]):
        pulumi.set(self, "static_quota", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        characteristics: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgsDict']]]]
        condition: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgsDict']]
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        limit: NotRequired[pulumi.Input[int]]
        """
        Desired maximum number of requests per period.
        """
        period: NotRequired[pulumi.Input[int]]
        """
        Period of time in seconds.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 characteristics: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs']]]] = None,
                 condition: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs']] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 period: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: Action in case of exceeding this quota. Possible values: `DENY`.
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs'] condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param pulumi.Input[int] limit: Desired maximum number of requests per period.
        :param pulumi.Input[int] period: Period of time in seconds.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def characteristics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs']]]]:
        return pulumi.get(self, "characteristics")

    @characteristics.setter
    def characteristics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs']]]]):
        pulumi.set(self, "characteristics", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs']]:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Desired maximum number of requests per period.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        Period of time in seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgsDict(TypedDict):
        case_insensitive: NotRequired[pulumi.Input[bool]]
        """
        Determines case-sensitive or case-insensitive keys matching.

        > Exactly one characteristic specifier: `simple_characteristic` or `key_characteristic` should be specified.
        """
        key_characteristic: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgsDict']]
        """
        Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/arl#requests-counting) for more details. The structure is documented below.
        """
        simple_characteristic: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgsDict']]
        """
        Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/arl#requests-counting) for more details. The structure is documented below.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs:
    def __init__(__self__, *,
                 case_insensitive: Optional[pulumi.Input[bool]] = None,
                 key_characteristic: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs']] = None,
                 simple_characteristic: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs']] = None):
        """
        :param pulumi.Input[bool] case_insensitive: Determines case-sensitive or case-insensitive keys matching.
               
               > Exactly one characteristic specifier: `simple_characteristic` or `key_characteristic` should be specified.
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs'] key_characteristic: Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/arl#requests-counting) for more details. The structure is documented below.
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs'] simple_characteristic: Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/arl#requests-counting) for more details. The structure is documented below.
        """
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if key_characteristic is not None:
            pulumi.set(__self__, "key_characteristic", key_characteristic)
        if simple_characteristic is not None:
            pulumi.set(__self__, "simple_characteristic", simple_characteristic)

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines case-sensitive or case-insensitive keys matching.

        > Exactly one characteristic specifier: `simple_characteristic` or `key_characteristic` should be specified.
        """
        return pulumi.get(self, "case_insensitive")

    @case_insensitive.setter
    def case_insensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_insensitive", value)

    @property
    @pulumi.getter(name="keyCharacteristic")
    def key_characteristic(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs']]:
        """
        Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/arl#requests-counting) for more details. The structure is documented below.
        """
        return pulumi.get(self, "key_characteristic")

    @key_characteristic.setter
    def key_characteristic(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs']]):
        pulumi.set(self, "key_characteristic", value)

    @property
    @pulumi.getter(name="simpleCharacteristic")
    def simple_characteristic(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs']]:
        """
        Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/arl#requests-counting) for more details. The structure is documented below.
        """
        return pulumi.get(self, "simple_characteristic")

    @simple_characteristic.setter
    def simple_characteristic(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs']]):
        pulumi.set(self, "simple_characteristic", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value of the key.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        :param pulumi.Input[str] value: String value of the key.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgsDict']]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgsDict']]
        request_uri: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgsDict']]
        source_ip: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgsDict']]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgs']] = None,
                 request_uri: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgs']] = None,
                 source_ip: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgs']] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgs']]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgs']]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgs']]:
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgs']]):
        pulumi.set(self, "request_uri", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgsDict(TypedDict):
        authorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgsDict']]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityArgs:
    def __init__(__self__, *,
                 authorities: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgs']]]] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @property
    @pulumi.getter
    def authorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgs']]]]:
        return pulumi.get(self, "authorities")

    @authorities.setter
    def authorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgs']]]]):
        pulumi.set(self, "authorities", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgsDict']
        """
        String value of the key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the ARL profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgs'] value: String value of the key.
        :param pulumi.Input[str] name: Name of the ARL profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgs']:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ARL profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgsDict']]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgs']]]] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgs']]]]:
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgsDict']]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgsDict']
        """
        String value of the key.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgs']):
        """
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgs'] value: String value of the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgs']:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        condition: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgsDict']]
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        limit: NotRequired[pulumi.Input[int]]
        """
        Desired maximum number of requests per period.
        """
        period: NotRequired[pulumi.Input[int]]
        """
        Period of time in seconds.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 condition: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs']] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 period: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: Action in case of exceeding this quota. Possible values: `DENY`.
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs'] condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param pulumi.Input[int] limit: Desired maximum number of requests per period.
        :param pulumi.Input[int] period: Period of time in seconds.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs']]:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Desired maximum number of requests per period.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        Period of time in seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgsDict']]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgsDict']]
        request_uri: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgsDict']]
        source_ip: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgsDict']]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgs']] = None,
                 request_uri: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgs']] = None,
                 source_ip: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgs']] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgs']]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgs']]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgs']]:
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgs']]):
        pulumi.set(self, "request_uri", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgsDict(TypedDict):
        authorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgsDict']]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityArgs:
    def __init__(__self__, *,
                 authorities: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgs']]]] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @property
    @pulumi.getter
    def authorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgs']]]]:
        return pulumi.get(self, "authorities")

    @authorities.setter
    def authorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgs']]]]):
        pulumi.set(self, "authorities", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgsDict']
        """
        String value of the key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the ARL profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgs'] value: String value of the key.
        :param pulumi.Input[str] name: Name of the ARL profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgs']:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ARL profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgsDict']]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgs']]]] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgs']]]]:
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgsDict']]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgsDict']
        """
        String value of the key.
        """
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgs']):
        """
        :param pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgs'] value: String value of the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgs']:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Optional description of the rule. 0-512 characters long.
        """
        dry_run: NotRequired[pulumi.Input[bool]]
        """
        This mode allows you to test your security profile or a single rule.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the rule. The name is unique within the security profile. 1-50 characters long.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Determines the priority for checking the incoming traffic.
        """
        rule_condition: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionArgsDict']]
        """
        Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action). The structure is documented below.
        """
        smart_protection: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionArgsDict']]
        """
        Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules). The structure is documented below.
        """
        waf: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafArgsDict']]
        """
        Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules). The structure is documented below.

        > Exactly one rule specifier: `smart_protection` or `rule_condition` or `waf` should be specified.
        """
elif False:
    SwsSecurityProfileSecurityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dry_run: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 rule_condition: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionArgs']] = None,
                 smart_protection: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionArgs']] = None,
                 waf: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafArgs']] = None):
        """
        :param pulumi.Input[str] description: Optional description of the rule. 0-512 characters long.
        :param pulumi.Input[bool] dry_run: This mode allows you to test your security profile or a single rule.
        :param pulumi.Input[str] name: Name of the rule. The name is unique within the security profile. 1-50 characters long.
        :param pulumi.Input[int] priority: Determines the priority for checking the incoming traffic.
        :param pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionArgs'] rule_condition: Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action). The structure is documented below.
        :param pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionArgs'] smart_protection: Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules). The structure is documented below.
        :param pulumi.Input['SwsSecurityProfileSecurityRuleWafArgs'] waf: Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules). The structure is documented below.
               
               > Exactly one rule specifier: `smart_protection` or `rule_condition` or `waf` should be specified.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_condition is not None:
            pulumi.set(__self__, "rule_condition", rule_condition)
        if smart_protection is not None:
            pulumi.set(__self__, "smart_protection", smart_protection)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[pulumi.Input[bool]]:
        """
        This mode allows you to test your security profile or a single rule.
        """
        return pulumi.get(self, "dry_run")

    @dry_run.setter
    def dry_run(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dry_run", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule. The name is unique within the security profile. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the priority for checking the incoming traffic.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="ruleCondition")
    def rule_condition(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionArgs']]:
        """
        Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action). The structure is documented below.
        """
        return pulumi.get(self, "rule_condition")

    @rule_condition.setter
    def rule_condition(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionArgs']]):
        pulumi.set(self, "rule_condition", value)

    @property
    @pulumi.getter(name="smartProtection")
    def smart_protection(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionArgs']]:
        """
        Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules). The structure is documented below.
        """
        return pulumi.get(self, "smart_protection")

    @smart_protection.setter
    def smart_protection(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionArgs']]):
        pulumi.set(self, "smart_protection", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafArgs']]:
        """
        Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules). The structure is documented below.

        > Exactly one rule specifier: `smart_protection` or `rule_condition` or `waf` should be specified.
        """
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafArgs']]):
        pulumi.set(self, "waf", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        """
        condition: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionArgsDict']]
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 condition: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionArgs']] = None):
        """
        :param pulumi.Input[str] action: Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        :param pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionArgs'] condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionArgs']]:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgsDict']]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgsDict']]
        request_uri: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgsDict']]
        source_ip: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgsDict']]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgs']] = None,
                 request_uri: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgs']] = None,
                 source_ip: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgs']] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgs']]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgs']]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgs']]:
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgs']]):
        pulumi.set(self, "request_uri", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgsDict(TypedDict):
        authorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityArgs:
    def __init__(__self__, *,
                 authorities: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgs']]]] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @property
    @pulumi.getter
    def authorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgs']]]]:
        return pulumi.get(self, "authorities")

    @authorities.setter
    def authorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgs']]]]):
        pulumi.set(self, "authorities", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgs']]]] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgs']]]]:
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgsDict']
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgs']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionArgsDict']]
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs'] condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param pulumi.Input[str] mode: Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs']]:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgsDict']]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgsDict']]
        request_uri: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgsDict']]
        source_ip: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgsDict']]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgs']] = None,
                 request_uri: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgs']] = None,
                 source_ip: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgs']] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgs']]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgs']]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgs']]:
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgs']]):
        pulumi.set(self, "request_uri", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgsDict(TypedDict):
        authorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityArgs:
    def __init__(__self__, *,
                 authorities: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgs']]]] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @property
    @pulumi.getter
    def authorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgs']]]]:
        return pulumi.get(self, "authorities")

    @authorities.setter
    def authorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgs']]]]):
        pulumi.set(self, "authorities", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgs']]]] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgs']]]]:
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgsDict']
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgs']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafArgsDict(TypedDict):
        waf_profile_id: pulumi.Input[str]
        """
        ID of WAF profile to use in this rule.
        """
        condition: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionArgsDict']]
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
elif False:
    SwsSecurityProfileSecurityRuleWafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafArgs:
    def __init__(__self__, *,
                 waf_profile_id: pulumi.Input[str],
                 condition: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] waf_profile_id: ID of WAF profile to use in this rule.
        :param pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionArgs'] condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param pulumi.Input[str] mode: Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        pulumi.set(__self__, "waf_profile_id", waf_profile_id)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="wafProfileId")
    def waf_profile_id(self) -> pulumi.Input[str]:
        """
        ID of WAF profile to use in this rule.
        """
        return pulumi.get(self, "waf_profile_id")

    @waf_profile_id.setter
    def waf_profile_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "waf_profile_id", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionArgs']]:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityArgsDict']]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgsDict']]
        request_uri: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriArgsDict']]
        source_ip: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpArgsDict']]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgs']] = None,
                 request_uri: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriArgs']] = None,
                 source_ip: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpArgs']] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityArgs']]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityArgs']]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriArgs']]:
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriArgs']]):
        pulumi.set(self, "request_uri", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionAuthorityArgsDict(TypedDict):
        authorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionAuthorityArgs:
    def __init__(__self__, *,
                 authorities: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgs']]]] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @property
    @pulumi.getter
    def authorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgs']]]]:
        return pulumi.get(self, "authorities")

    @authorities.setter
    def authorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgs']]]]):
        pulumi.set(self, "authorities", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsSecurityProfileSecurityRuleWafConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the security profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionHttpMethodArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgs']]]] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgs']]]]:
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionRequestUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgsDict']]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionRequestUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgsDict']
elif False:
    SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgs']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsWafProfileAnalyzeRequestBodyArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Possible to turn analyzer on and turn if off.
        """
        size_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum size of body to pass to analyzer. In kilobytes.
        """
        size_limit_action: NotRequired[pulumi.Input[str]]
        """
        Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
elif False:
    SwsWafProfileAnalyzeRequestBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileAnalyzeRequestBodyArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 size_limit: Optional[pulumi.Input[int]] = None,
                 size_limit_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: Possible to turn analyzer on and turn if off.
        :param pulumi.Input[int] size_limit: Maximum size of body to pass to analyzer. In kilobytes.
        :param pulumi.Input[str] size_limit_action: Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)
        if size_limit_action is not None:
            pulumi.set(__self__, "size_limit_action", size_limit_action)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Possible to turn analyzer on and turn if off.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum size of body to pass to analyzer. In kilobytes.
        """
        return pulumi.get(self, "size_limit")

    @size_limit.setter
    def size_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_limit", value)

    @property
    @pulumi.getter(name="sizeLimitAction")
    def size_limit_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
        return pulumi.get(self, "size_limit_action")

    @size_limit_action.setter
    def size_limit_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_limit_action", value)


if not MYPY:
    class SwsWafProfileCoreRuleSetArgsDict(TypedDict):
        rule_set: pulumi.Input['SwsWafProfileCoreRuleSetRuleSetArgsDict']
        inbound_anomaly_score: NotRequired[pulumi.Input[int]]
        """
        Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        """
        paranoia_level: NotRequired[pulumi.Input[int]]
        """
        Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        """
elif False:
    SwsWafProfileCoreRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileCoreRuleSetArgs:
    def __init__(__self__, *,
                 rule_set: pulumi.Input['SwsWafProfileCoreRuleSetRuleSetArgs'],
                 inbound_anomaly_score: Optional[pulumi.Input[int]] = None,
                 paranoia_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] inbound_anomaly_score: Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        :param pulumi.Input[int] paranoia_level: Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        """
        pulumi.set(__self__, "rule_set", rule_set)
        if inbound_anomaly_score is not None:
            pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        if paranoia_level is not None:
            pulumi.set(__self__, "paranoia_level", paranoia_level)

    @property
    @pulumi.getter(name="ruleSet")
    def rule_set(self) -> pulumi.Input['SwsWafProfileCoreRuleSetRuleSetArgs']:
        return pulumi.get(self, "rule_set")

    @rule_set.setter
    def rule_set(self, value: pulumi.Input['SwsWafProfileCoreRuleSetRuleSetArgs']):
        pulumi.set(self, "rule_set", value)

    @property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> Optional[pulumi.Input[int]]:
        """
        Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @inbound_anomaly_score.setter
    def inbound_anomaly_score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "inbound_anomaly_score", value)

    @property
    @pulumi.getter(name="paranoiaLevel")
    def paranoia_level(self) -> Optional[pulumi.Input[int]]:
        """
        Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        """
        return pulumi.get(self, "paranoia_level")

    @paranoia_level.setter
    def paranoia_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "paranoia_level", value)


if not MYPY:
    class SwsWafProfileCoreRuleSetRuleSetArgsDict(TypedDict):
        version: pulumi.Input[str]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the WAF profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsWafProfileCoreRuleSetRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileCoreRuleSetRuleSetArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the WAF profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "version", version)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the WAF profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsWafProfileExclusionRuleArgsDict(TypedDict):
        exclude_rules: pulumi.Input['SwsWafProfileExclusionRuleExcludeRulesArgsDict']
        """
        Exclude rules. The structure is documented below.
        """
        condition: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionArgsDict']]
        description: NotRequired[pulumi.Input[str]]
        """
        Optional description of the rule. 0-512 characters long.
        """
        log_excluded: NotRequired[pulumi.Input[bool]]
        """
        Records the fact that an exception rule is triggered.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of exclusion rule.
        """
elif False:
    SwsWafProfileExclusionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleArgs:
    def __init__(__self__, *,
                 exclude_rules: pulumi.Input['SwsWafProfileExclusionRuleExcludeRulesArgs'],
                 condition: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 log_excluded: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SwsWafProfileExclusionRuleExcludeRulesArgs'] exclude_rules: Exclude rules. The structure is documented below.
        :param pulumi.Input[str] description: Optional description of the rule. 0-512 characters long.
        :param pulumi.Input[bool] log_excluded: Records the fact that an exception rule is triggered.
        :param pulumi.Input[str] name: Name of exclusion rule.
        """
        pulumi.set(__self__, "exclude_rules", exclude_rules)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if log_excluded is not None:
            pulumi.set(__self__, "log_excluded", log_excluded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="excludeRules")
    def exclude_rules(self) -> pulumi.Input['SwsWafProfileExclusionRuleExcludeRulesArgs']:
        """
        Exclude rules. The structure is documented below.
        """
        return pulumi.get(self, "exclude_rules")

    @exclude_rules.setter
    def exclude_rules(self, value: pulumi.Input['SwsWafProfileExclusionRuleExcludeRulesArgs']):
        pulumi.set(self, "exclude_rules", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionArgs']]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="logExcluded")
    def log_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        Records the fact that an exception rule is triggered.
        """
        return pulumi.get(self, "log_excluded")

    @log_excluded.setter
    def log_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log_excluded", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of exclusion rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityArgsDict']]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodArgsDict']]
        request_uri: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriArgsDict']]
        source_ip: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpArgsDict']]
elif False:
    SwsWafProfileExclusionRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodArgs']] = None,
                 request_uri: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriArgs']] = None,
                 source_ip: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpArgs']] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityArgs']]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityArgs']]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriArgs']]:
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriArgs']]):
        pulumi.set(self, "request_uri", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpArgs']]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpArgs']]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionAuthorityArgsDict(TypedDict):
        authorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgsDict']]]]
elif False:
    SwsWafProfileExclusionRuleConditionAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionAuthorityArgs:
    def __init__(__self__, *,
                 authorities: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgs']]]] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @property
    @pulumi.getter
    def authorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgs']]]]:
        return pulumi.get(self, "authorities")

    @authorities.setter
    def authorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgs']]]]):
        pulumi.set(self, "authorities", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionAuthorityAuthorityArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionHeaderArgsDict(TypedDict):
        value: pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderValueArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the WAF profile. The name is unique within the folder. 1-50 characters long.
        """
elif False:
    SwsWafProfileExclusionRuleConditionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionHeaderArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderValueArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the WAF profile. The name is unique within the folder. 1-50 characters long.
        """
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsWafProfileExclusionRuleConditionHeaderValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the WAF profile. The name is unique within the folder. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionHeaderValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsWafProfileExclusionRuleConditionHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionHeaderValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionHttpMethodArgsDict(TypedDict):
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgsDict']]]]
elif False:
    SwsWafProfileExclusionRuleConditionHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionHttpMethodArgs:
    def __init__(__self__, *,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgs']]]] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgs']]]]:
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionHttpMethodHttpMethodArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionRequestUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriPathArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryArgsDict']]]]
elif False:
    SwsWafProfileExclusionRuleConditionRequestUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionRequestUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriPathArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryArgs']]]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryArgs']]]]):
        pulumi.set(self, "queries", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionRequestUriPathArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsWafProfileExclusionRuleConditionRequestUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionRequestUriPathArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionRequestUriQueryArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgsDict']
elif False:
    SwsWafProfileExclusionRuleConditionRequestUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionRequestUriQueryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgs']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgsDict(TypedDict):
        exact_match: NotRequired[pulumi.Input[str]]
        exact_not_match: NotRequired[pulumi.Input[str]]
        pire_regex_match: NotRequired[pulumi.Input[str]]
        pire_regex_not_match: NotRequired[pulumi.Input[str]]
        prefix_match: NotRequired[pulumi.Input[str]]
        prefix_not_match: NotRequired[pulumi.Input[str]]
elif False:
    SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionRequestUriQueryValueArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[str]] = None,
                 exact_not_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_match: Optional[pulumi.Input[str]] = None,
                 pire_regex_not_match: Optional[pulumi.Input[str]] = None,
                 prefix_match: Optional[pulumi.Input[str]] = None,
                 prefix_not_match: Optional[pulumi.Input[str]] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exact_not_match")

    @exact_not_match.setter
    def exact_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact_not_match", value)

    @property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_match")

    @pire_regex_match.setter
    def pire_regex_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_match", value)

    @property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pire_regex_not_match")

    @pire_regex_not_match.setter
    def pire_regex_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pire_regex_not_match", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_not_match")

    @prefix_not_match.setter
    def prefix_not_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_not_match", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionSourceIpArgsDict(TypedDict):
        geo_ip_match: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgsDict']]
        geo_ip_not_match: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgsDict']]
        ip_ranges_match: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgsDict']]
        ip_ranges_not_match: NotRequired[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgsDict']]
elif False:
    SwsWafProfileExclusionRuleConditionSourceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionSourceIpArgs:
    def __init__(__self__, *,
                 geo_ip_match: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs']] = None,
                 geo_ip_not_match: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs']] = None,
                 ip_ranges_match: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs']] = None,
                 ip_ranges_not_match: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs']] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs']]:
        return pulumi.get(self, "geo_ip_match")

    @geo_ip_match.setter
    def geo_ip_match(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs']]):
        pulumi.set(self, "geo_ip_match", value)

    @property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs']]:
        return pulumi.get(self, "geo_ip_not_match")

    @geo_ip_not_match.setter
    def geo_ip_not_match(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs']]):
        pulumi.set(self, "geo_ip_not_match", value)

    @property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs']]:
        return pulumi.get(self, "ip_ranges_match")

    @ip_ranges_match.setter
    def ip_ranges_match(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs']]):
        pulumi.set(self, "ip_ranges_match", value)

    @property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs']]:
        return pulumi.get(self, "ip_ranges_not_match")

    @ip_ranges_not_match.setter
    def ip_ranges_not_match(self, value: Optional[pulumi.Input['SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs']]):
        pulumi.set(self, "ip_ranges_not_match", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgsDict(TypedDict):
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs:
    def __init__(__self__, *,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_ranges", value)


if not MYPY:
    class SwsWafProfileExclusionRuleExcludeRulesArgsDict(TypedDict):
        exclude_all: NotRequired[pulumi.Input[bool]]
        """
        Set this option true to exclude all rules.
        """
        rule_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of rules to exclude.
        """
elif False:
    SwsWafProfileExclusionRuleExcludeRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileExclusionRuleExcludeRulesArgs:
    def __init__(__self__, *,
                 exclude_all: Optional[pulumi.Input[bool]] = None,
                 rule_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] exclude_all: Set this option true to exclude all rules.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] rule_ids: List of rules to exclude.
        """
        if exclude_all is not None:
            pulumi.set(__self__, "exclude_all", exclude_all)
        if rule_ids is not None:
            pulumi.set(__self__, "rule_ids", rule_ids)

    @property
    @pulumi.getter(name="excludeAll")
    def exclude_all(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option true to exclude all rules.
        """
        return pulumi.get(self, "exclude_all")

    @exclude_all.setter
    def exclude_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_all", value)

    @property
    @pulumi.getter(name="ruleIds")
    def rule_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of rules to exclude.
        """
        return pulumi.get(self, "rule_ids")

    @rule_ids.setter
    def rule_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "rule_ids", value)


if not MYPY:
    class SwsWafProfileRuleArgsDict(TypedDict):
        rule_id: pulumi.Input[str]
        """
        Rule ID.
        """
        is_blocking: NotRequired[pulumi.Input[bool]]
        """
        Determines is it rule blocking or not.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines is it rule enabled or not.
        """
elif False:
    SwsWafProfileRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwsWafProfileRuleArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[str],
                 is_blocking: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] rule_id: Rule ID.
        :param pulumi.Input[bool] is_blocking: Determines is it rule blocking or not.
        :param pulumi.Input[bool] is_enabled: Determines is it rule enabled or not.
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if is_blocking is not None:
            pulumi.set(__self__, "is_blocking", is_blocking)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[str]:
        """
        Rule ID.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="isBlocking")
    def is_blocking(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines is it rule blocking or not.
        """
        return pulumi.get(self, "is_blocking")

    @is_blocking.setter
    def is_blocking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_blocking", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines is it rule enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class VpcAddressDnsRecordArgsDict(TypedDict):
        dns_zone_id: pulumi.Input[str]
        """
        DNS zone id to create record at.
        """
        fqdn: pulumi.Input[str]
        """
        FQDN for record to address
        """
        ptr: NotRequired[pulumi.Input[bool]]
        """
        If PTR record is needed
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        TTL of DNS record
        """
elif False:
    VpcAddressDnsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcAddressDnsRecordArgs:
    def __init__(__self__, *,
                 dns_zone_id: pulumi.Input[str],
                 fqdn: pulumi.Input[str],
                 ptr: Optional[pulumi.Input[bool]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] dns_zone_id: DNS zone id to create record at.
        :param pulumi.Input[str] fqdn: FQDN for record to address
        :param pulumi.Input[bool] ptr: If PTR record is needed
        :param pulumi.Input[int] ttl: TTL of DNS record
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> pulumi.Input[str]:
        """
        DNS zone id to create record at.
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        FQDN for record to address
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter
    def ptr(self) -> Optional[pulumi.Input[bool]]:
        """
        If PTR record is needed
        """
        return pulumi.get(self, "ptr")

    @ptr.setter
    def ptr(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ptr", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        TTL of DNS record
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class VpcAddressExternalIpv4AddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Allocated IP address.
        """
        ddos_protection_provider: NotRequired[pulumi.Input[str]]
        """
        Enable DDOS protection. Possible values are: "qrator"
        """
        outgoing_smtp_capability: NotRequired[pulumi.Input[str]]
        """
        Wanted outgoing smtp capability.

        > Either one `address` or `zone_id` arguments can be specified. > Either one `ddos_protection_provider` or `outgoing_smtp_capability` arguments can be specified. > Change any argument in `external_ipv4_address` will cause an address recreate
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        Zone for allocating address.
        """
elif False:
    VpcAddressExternalIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcAddressExternalIpv4AddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 ddos_protection_provider: Optional[pulumi.Input[str]] = None,
                 outgoing_smtp_capability: Optional[pulumi.Input[str]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Allocated IP address.
        :param pulumi.Input[str] ddos_protection_provider: Enable DDOS protection. Possible values are: "qrator"
        :param pulumi.Input[str] outgoing_smtp_capability: Wanted outgoing smtp capability.
               
               > Either one `address` or `zone_id` arguments can be specified. > Either one `ddos_protection_provider` or `outgoing_smtp_capability` arguments can be specified. > Change any argument in `external_ipv4_address` will cause an address recreate
        :param pulumi.Input[str] zone_id: Zone for allocating address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ddos_protection_provider is not None:
            pulumi.set(__self__, "ddos_protection_provider", ddos_protection_provider)
        if outgoing_smtp_capability is not None:
            pulumi.set(__self__, "outgoing_smtp_capability", outgoing_smtp_capability)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Allocated IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="ddosProtectionProvider")
    def ddos_protection_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Enable DDOS protection. Possible values are: "qrator"
        """
        return pulumi.get(self, "ddos_protection_provider")

    @ddos_protection_provider.setter
    def ddos_protection_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ddos_protection_provider", value)

    @property
    @pulumi.getter(name="outgoingSmtpCapability")
    def outgoing_smtp_capability(self) -> Optional[pulumi.Input[str]]:
        """
        Wanted outgoing smtp capability.

        > Either one `address` or `zone_id` arguments can be specified. > Either one `ddos_protection_provider` or `outgoing_smtp_capability` arguments can be specified. > Change any argument in `external_ipv4_address` will cause an address recreate
        """
        return pulumi.get(self, "outgoing_smtp_capability")

    @outgoing_smtp_capability.setter
    def outgoing_smtp_capability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outgoing_smtp_capability", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Zone for allocating address.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class VpcDefaultSecurityGroupEgressArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the security group.
        """
        from_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Minimum port number.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Id of the security group.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels to assign to this security group.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Port number (if applied to a single port).
        """
        predefined_target: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        security_group_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Target security group ID for this rule.
        """
        to_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Maximum port number.
        """
        v4_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        v6_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
elif False:
    VpcDefaultSecurityGroupEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcDefaultSecurityGroupEgressArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 from_port: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 predefined_target: Optional[pulumi.Input[str]] = None,
                 security_group_id: Optional[pulumi.Input[str]] = None,
                 to_port: Optional[pulumi.Input[int]] = None,
                 v4_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 v6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] protocol: (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param pulumi.Input[str] description: Description of the security group.
        :param pulumi.Input[int] from_port: (Optional) - Minimum port number.
        :param pulumi.Input[str] id: Id of the security group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels to assign to this security group.
        :param pulumi.Input[int] port: (Optional) - Port number (if applied to a single port).
        :param pulumi.Input[str] predefined_target: (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        :param pulumi.Input[str] security_group_id: (Optional) - Target security group ID for this rule.
        :param pulumi.Input[int] to_port: (Optional) - Maximum port number.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v4_cidr_blocks: (Optional) - The blocks of IPv4 addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v6_cidr_blocks: (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the security group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @predefined_target.setter
    def predefined_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "predefined_target", value)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @v4_cidr_blocks.setter
    def v4_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v4_cidr_blocks", value)

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")

    @v6_cidr_blocks.setter
    def v6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v6_cidr_blocks", value)


if not MYPY:
    class VpcDefaultSecurityGroupIngressArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the security group.
        """
        from_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Minimum port number.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Id of the security group.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels to assign to this security group.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Port number (if applied to a single port).
        """
        predefined_target: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        security_group_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Target security group ID for this rule.
        """
        to_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Maximum port number.
        """
        v4_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        v6_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
elif False:
    VpcDefaultSecurityGroupIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcDefaultSecurityGroupIngressArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 from_port: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 predefined_target: Optional[pulumi.Input[str]] = None,
                 security_group_id: Optional[pulumi.Input[str]] = None,
                 to_port: Optional[pulumi.Input[int]] = None,
                 v4_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 v6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] protocol: (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param pulumi.Input[str] description: Description of the security group.
        :param pulumi.Input[int] from_port: (Optional) - Minimum port number.
        :param pulumi.Input[str] id: Id of the security group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels to assign to this security group.
        :param pulumi.Input[int] port: (Optional) - Port number (if applied to a single port).
        :param pulumi.Input[str] predefined_target: (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        :param pulumi.Input[str] security_group_id: (Optional) - Target security group ID for this rule.
        :param pulumi.Input[int] to_port: (Optional) - Maximum port number.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v4_cidr_blocks: (Optional) - The blocks of IPv4 addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v6_cidr_blocks: (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the security group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @predefined_target.setter
    def predefined_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "predefined_target", value)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @v4_cidr_blocks.setter
    def v4_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v4_cidr_blocks", value)

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")

    @v6_cidr_blocks.setter
    def v6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v6_cidr_blocks", value)


if not MYPY:
    class VpcGatewaySharedEgressGatewayArgsDict(TypedDict):
        pass
elif False:
    VpcGatewaySharedEgressGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcGatewaySharedEgressGatewayArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VpcPrivateEndpointDnsOptionsArgsDict(TypedDict):
        private_dns_records_enabled: NotRequired[pulumi.Input[bool]]
        """
        If enabled - additional service dns will be created.
        """
elif False:
    VpcPrivateEndpointDnsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcPrivateEndpointDnsOptionsArgs:
    def __init__(__self__, *,
                 private_dns_records_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] private_dns_records_enabled: If enabled - additional service dns will be created.
        """
        if private_dns_records_enabled is not None:
            pulumi.set(__self__, "private_dns_records_enabled", private_dns_records_enabled)

    @property
    @pulumi.getter(name="privateDnsRecordsEnabled")
    def private_dns_records_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled - additional service dns will be created.
        """
        return pulumi.get(self, "private_dns_records_enabled")

    @private_dns_records_enabled.setter
    def private_dns_records_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_dns_records_enabled", value)


if not MYPY:
    class VpcPrivateEndpointEndpointAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Specifies IP address within `subnet_id`.

        > Only one of `address_id` or `subnet_id` + `address` arguments can be specified.
        """
        address_id: NotRequired[pulumi.Input[str]]
        """
        ID of the address.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Subnet of the IP address.
        """
elif False:
    VpcPrivateEndpointEndpointAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcPrivateEndpointEndpointAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 address_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Specifies IP address within `subnet_id`.
               
               > Only one of `address_id` or `subnet_id` + `address` arguments can be specified.
        :param pulumi.Input[str] address_id: ID of the address.
        :param pulumi.Input[str] subnet_id: Subnet of the IP address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_id is not None:
            pulumi.set(__self__, "address_id", address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies IP address within `subnet_id`.

        > Only one of `address_id` or `subnet_id` + `address` arguments can be specified.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressId")
    def address_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the address.
        """
        return pulumi.get(self, "address_id")

    @address_id.setter
    def address_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet of the IP address.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class VpcPrivateEndpointObjectStorageArgsDict(TypedDict):
        pass
elif False:
    VpcPrivateEndpointObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcPrivateEndpointObjectStorageArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VpcRouteTableStaticRouteArgsDict(TypedDict):
        destination_prefix: NotRequired[pulumi.Input[str]]
        """
        Route prefix in CIDR notation.
        """
        gateway_id: NotRequired[pulumi.Input[str]]
        """
        ID of the gateway used ad next hop.

        > Only one of `next_hop_address` or `gateway_id` should be specified.
        """
        next_hop_address: NotRequired[pulumi.Input[str]]
        """
        Address of the next hop.
        """
elif False:
    VpcRouteTableStaticRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcRouteTableStaticRouteArgs:
    def __init__(__self__, *,
                 destination_prefix: Optional[pulumi.Input[str]] = None,
                 gateway_id: Optional[pulumi.Input[str]] = None,
                 next_hop_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination_prefix: Route prefix in CIDR notation.
        :param pulumi.Input[str] gateway_id: ID of the gateway used ad next hop.
               
               > Only one of `next_hop_address` or `gateway_id` should be specified.
        :param pulumi.Input[str] next_hop_address: Address of the next hop.
        """
        if destination_prefix is not None:
            pulumi.set(__self__, "destination_prefix", destination_prefix)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if next_hop_address is not None:
            pulumi.set(__self__, "next_hop_address", next_hop_address)

    @property
    @pulumi.getter(name="destinationPrefix")
    def destination_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Route prefix in CIDR notation.
        """
        return pulumi.get(self, "destination_prefix")

    @destination_prefix.setter
    def destination_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_prefix", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the gateway used ad next hop.

        > Only one of `next_hop_address` or `gateway_id` should be specified.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="nextHopAddress")
    def next_hop_address(self) -> Optional[pulumi.Input[str]]:
        """
        Address of the next hop.
        """
        return pulumi.get(self, "next_hop_address")

    @next_hop_address.setter
    def next_hop_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_hop_address", value)


if not MYPY:
    class VpcSecurityGroupEgressArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the security group.
        """
        from_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Minimum port number.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Id of the rule.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels to assign to this security group.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Port number (if applied to a single port).
        """
        predefined_target: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        security_group_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Target security group ID for this rule.
        """
        to_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Maximum port number.
        """
        v4_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        v6_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
elif False:
    VpcSecurityGroupEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcSecurityGroupEgressArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 from_port: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 predefined_target: Optional[pulumi.Input[str]] = None,
                 security_group_id: Optional[pulumi.Input[str]] = None,
                 to_port: Optional[pulumi.Input[int]] = None,
                 v4_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 v6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] protocol: (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param pulumi.Input[str] description: Description of the security group.
        :param pulumi.Input[int] from_port: (Optional) - Minimum port number.
        :param pulumi.Input[str] id: Id of the rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels to assign to this security group.
        :param pulumi.Input[int] port: (Optional) - Port number (if applied to a single port).
        :param pulumi.Input[str] predefined_target: (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        :param pulumi.Input[str] security_group_id: (Optional) - Target security group ID for this rule.
        :param pulumi.Input[int] to_port: (Optional) - Maximum port number.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v4_cidr_blocks: (Optional) - The blocks of IPv4 addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v6_cidr_blocks: (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @predefined_target.setter
    def predefined_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "predefined_target", value)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @v4_cidr_blocks.setter
    def v4_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v4_cidr_blocks", value)

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")

    @v6_cidr_blocks.setter
    def v6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v6_cidr_blocks", value)


if not MYPY:
    class VpcSecurityGroupIngressArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the security group.
        """
        from_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Minimum port number.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Id of the rule.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels to assign to this security group.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Port number (if applied to a single port).
        """
        predefined_target: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        security_group_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) - Target security group ID for this rule.
        """
        to_port: NotRequired[pulumi.Input[int]]
        """
        (Optional) - Maximum port number.
        """
        v4_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        v6_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
elif False:
    VpcSecurityGroupIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcSecurityGroupIngressArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 from_port: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 predefined_target: Optional[pulumi.Input[str]] = None,
                 security_group_id: Optional[pulumi.Input[str]] = None,
                 to_port: Optional[pulumi.Input[int]] = None,
                 v4_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 v6_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] protocol: (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param pulumi.Input[str] description: Description of the security group.
        :param pulumi.Input[int] from_port: (Optional) - Minimum port number.
        :param pulumi.Input[str] id: Id of the rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels to assign to this security group.
        :param pulumi.Input[int] port: (Optional) - Port number (if applied to a single port).
        :param pulumi.Input[str] predefined_target: (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        :param pulumi.Input[str] security_group_id: (Optional) - Target security group ID for this rule.
        :param pulumi.Input[int] to_port: (Optional) - Maximum port number.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v4_cidr_blocks: (Optional) - The blocks of IPv4 addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] v6_cidr_blocks: (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Required) - One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @predefined_target.setter
    def predefined_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "predefined_target", value)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) - Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Optional) - Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @v4_cidr_blocks.setter
    def v4_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v4_cidr_blocks", value)

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) - The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")

    @v6_cidr_blocks.setter
    def v6_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "v6_cidr_blocks", value)


if not MYPY:
    class VpcSubnetDhcpOptionsArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[str]]
        """
        Domain name.
        """
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Domain name server IP addresses.
        """
        ntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        NTP server IP addresses.
        """
elif False:
    VpcSubnetDhcpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcSubnetDhcpOptionsArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] domain_name: Domain name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domain_name_servers: Domain name server IP addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ntp_servers: NTP server IP addresses.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Domain name server IP addresses.
        """
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domain_name_servers", value)

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        NTP server IP addresses.
        """
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ntp_servers", value)


if not MYPY:
    class YdbDatabaseDedicatedLocationArgsDict(TypedDict):
        region: NotRequired[pulumi.Input['YdbDatabaseDedicatedLocationRegionArgsDict']]
        """
        Region for the Yandex Database cluster. The structure is documented below.
        """
elif False:
    YdbDatabaseDedicatedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbDatabaseDedicatedLocationArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input['YdbDatabaseDedicatedLocationRegionArgs']] = None):
        """
        :param pulumi.Input['YdbDatabaseDedicatedLocationRegionArgs'] region: Region for the Yandex Database cluster. The structure is documented below.
        """
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['YdbDatabaseDedicatedLocationRegionArgs']]:
        """
        Region for the Yandex Database cluster. The structure is documented below.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['YdbDatabaseDedicatedLocationRegionArgs']]):
        pulumi.set(self, "region", value)


if not MYPY:
    class YdbDatabaseDedicatedLocationRegionArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Region ID for the Yandex Database cluster.
        """
elif False:
    YdbDatabaseDedicatedLocationRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbDatabaseDedicatedLocationRegionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Region ID for the Yandex Database cluster.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Region ID for the Yandex Database cluster.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class YdbDatabaseDedicatedScalePolicyArgsDict(TypedDict):
        fixed_scale: pulumi.Input['YdbDatabaseDedicatedScalePolicyFixedScaleArgsDict']
        """
        Fixed scaling policy for the Yandex Database cluster. The structure is documented below.

        > Currently, only `fixed_scale` is supported.
        """
elif False:
    YdbDatabaseDedicatedScalePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbDatabaseDedicatedScalePolicyArgs:
    def __init__(__self__, *,
                 fixed_scale: pulumi.Input['YdbDatabaseDedicatedScalePolicyFixedScaleArgs']):
        """
        :param pulumi.Input['YdbDatabaseDedicatedScalePolicyFixedScaleArgs'] fixed_scale: Fixed scaling policy for the Yandex Database cluster. The structure is documented below.
               
               > Currently, only `fixed_scale` is supported.
        """
        pulumi.set(__self__, "fixed_scale", fixed_scale)

    @property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> pulumi.Input['YdbDatabaseDedicatedScalePolicyFixedScaleArgs']:
        """
        Fixed scaling policy for the Yandex Database cluster. The structure is documented below.

        > Currently, only `fixed_scale` is supported.
        """
        return pulumi.get(self, "fixed_scale")

    @fixed_scale.setter
    def fixed_scale(self, value: pulumi.Input['YdbDatabaseDedicatedScalePolicyFixedScaleArgs']):
        pulumi.set(self, "fixed_scale", value)


if not MYPY:
    class YdbDatabaseDedicatedScalePolicyFixedScaleArgsDict(TypedDict):
        size: pulumi.Input[int]
        """
        Number of instances for the Yandex Database cluster.
        """
elif False:
    YdbDatabaseDedicatedScalePolicyFixedScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbDatabaseDedicatedScalePolicyFixedScaleArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[int]):
        """
        :param pulumi.Input[int] size: Number of instances for the Yandex Database cluster.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        Number of instances for the Yandex Database cluster.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)


if not MYPY:
    class YdbDatabaseDedicatedStorageConfigArgsDict(TypedDict):
        group_count: pulumi.Input[int]
        """
        Amount of storage groups of selected type for the Yandex Database cluster.
        """
        storage_type_id: pulumi.Input[str]
        """
        Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
elif False:
    YdbDatabaseDedicatedStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbDatabaseDedicatedStorageConfigArgs:
    def __init__(__self__, *,
                 group_count: pulumi.Input[int],
                 storage_type_id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] group_count: Amount of storage groups of selected type for the Yandex Database cluster.
        :param pulumi.Input[str] storage_type_id: Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
        pulumi.set(__self__, "group_count", group_count)
        pulumi.set(__self__, "storage_type_id", storage_type_id)

    @property
    @pulumi.getter(name="groupCount")
    def group_count(self) -> pulumi.Input[int]:
        """
        Amount of storage groups of selected type for the Yandex Database cluster.
        """
        return pulumi.get(self, "group_count")

    @group_count.setter
    def group_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "group_count", value)

    @property
    @pulumi.getter(name="storageTypeId")
    def storage_type_id(self) -> pulumi.Input[str]:
        """
        Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
        return pulumi.get(self, "storage_type_id")

    @storage_type_id.setter
    def storage_type_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_type_id", value)


if not MYPY:
    class YdbDatabaseServerlessServerlessDatabaseArgsDict(TypedDict):
        enable_throttling_rcu_limit: NotRequired[pulumi.Input[bool]]
        provisioned_rcu_limit: NotRequired[pulumi.Input[int]]
        storage_size_limit: NotRequired[pulumi.Input[int]]
        throttling_rcu_limit: NotRequired[pulumi.Input[int]]
elif False:
    YdbDatabaseServerlessServerlessDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbDatabaseServerlessServerlessDatabaseArgs:
    def __init__(__self__, *,
                 enable_throttling_rcu_limit: Optional[pulumi.Input[bool]] = None,
                 provisioned_rcu_limit: Optional[pulumi.Input[int]] = None,
                 storage_size_limit: Optional[pulumi.Input[int]] = None,
                 throttling_rcu_limit: Optional[pulumi.Input[int]] = None):
        if enable_throttling_rcu_limit is not None:
            pulumi.set(__self__, "enable_throttling_rcu_limit", enable_throttling_rcu_limit)
        if provisioned_rcu_limit is not None:
            pulumi.set(__self__, "provisioned_rcu_limit", provisioned_rcu_limit)
        if storage_size_limit is not None:
            pulumi.set(__self__, "storage_size_limit", storage_size_limit)
        if throttling_rcu_limit is not None:
            pulumi.set(__self__, "throttling_rcu_limit", throttling_rcu_limit)

    @property
    @pulumi.getter(name="enableThrottlingRcuLimit")
    def enable_throttling_rcu_limit(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_throttling_rcu_limit")

    @enable_throttling_rcu_limit.setter
    def enable_throttling_rcu_limit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_throttling_rcu_limit", value)

    @property
    @pulumi.getter(name="provisionedRcuLimit")
    def provisioned_rcu_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "provisioned_rcu_limit")

    @provisioned_rcu_limit.setter
    def provisioned_rcu_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "provisioned_rcu_limit", value)

    @property
    @pulumi.getter(name="storageSizeLimit")
    def storage_size_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage_size_limit")

    @storage_size_limit.setter
    def storage_size_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage_size_limit", value)

    @property
    @pulumi.getter(name="throttlingRcuLimit")
    def throttling_rcu_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throttling_rcu_limit")

    @throttling_rcu_limit.setter
    def throttling_rcu_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throttling_rcu_limit", value)


if not MYPY:
    class YdbTableChangefeedConsumerArgsDict(TypedDict):
        name: pulumi.Input[str]
        important: NotRequired[pulumi.Input[bool]]
        starting_message_timestamp_ms: NotRequired[pulumi.Input[int]]
        supported_codecs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    YdbTableChangefeedConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTableChangefeedConsumerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 important: Optional[pulumi.Input[bool]] = None,
                 starting_message_timestamp_ms: Optional[pulumi.Input[int]] = None,
                 supported_codecs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "name", name)
        if important is not None:
            pulumi.set(__self__, "important", important)
        if starting_message_timestamp_ms is not None:
            pulumi.set(__self__, "starting_message_timestamp_ms", starting_message_timestamp_ms)
        if supported_codecs is not None:
            pulumi.set(__self__, "supported_codecs", supported_codecs)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def important(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "important")

    @important.setter
    def important(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "important", value)

    @property
    @pulumi.getter(name="startingMessageTimestampMs")
    def starting_message_timestamp_ms(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "starting_message_timestamp_ms")

    @starting_message_timestamp_ms.setter
    def starting_message_timestamp_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "starting_message_timestamp_ms", value)

    @property
    @pulumi.getter(name="supportedCodecs")
    def supported_codecs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "supported_codecs")

    @supported_codecs.setter
    def supported_codecs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_codecs", value)


if not MYPY:
    class YdbTableColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Column family name
        """
        type: pulumi.Input[str]
        """
        Column data type. YQL data types are used.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        Column group
        """
        not_null: NotRequired[pulumi.Input[bool]]
        """
        A column cannot have the NULL data type. ( Default: false )
        """
elif False:
    YdbTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 family: Optional[pulumi.Input[str]] = None,
                 not_null: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Column family name
        :param pulumi.Input[str] type: Column data type. YQL data types are used.
        :param pulumi.Input[str] family: Column group
        :param pulumi.Input[bool] not_null: A column cannot have the NULL data type. ( Default: false )
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if not_null is not None:
            pulumi.set(__self__, "not_null", not_null)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Column family name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Column data type. YQL data types are used.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        Column group
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter(name="notNull")
    def not_null(self) -> Optional[pulumi.Input[bool]]:
        """
        A column cannot have the NULL data type. ( Default: false )
        """
        return pulumi.get(self, "not_null")

    @not_null.setter
    def not_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "not_null", value)


if not MYPY:
    class YdbTableFamilyArgsDict(TypedDict):
        compression: pulumi.Input[str]
        """
        Data codec (acceptable values: off, lz4).
        """
        data: pulumi.Input[str]
        """
        Type of storage device for column data in this group (acceptable values: ssd, rot (from HDD spindle rotation)).
        """
        name: pulumi.Input[str]
        """
        Column family name
        """
elif False:
    YdbTableFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTableFamilyArgs:
    def __init__(__self__, *,
                 compression: pulumi.Input[str],
                 data: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] compression: Data codec (acceptable values: off, lz4).
        :param pulumi.Input[str] data: Type of storage device for column data in this group (acceptable values: ssd, rot (from HDD spindle rotation)).
        :param pulumi.Input[str] name: Column family name
        """
        pulumi.set(__self__, "compression", compression)
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def compression(self) -> pulumi.Input[str]:
        """
        Data codec (acceptable values: off, lz4).
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: pulumi.Input[str]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input[str]:
        """
        Type of storage device for column data in this group (acceptable values: ssd, rot (from HDD spindle rotation)).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[str]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Column family name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class YdbTablePartitioningSettingsArgsDict(TypedDict):
        auto_partitioning_by_load: NotRequired[pulumi.Input[bool]]
        auto_partitioning_by_size_enabled: NotRequired[pulumi.Input[bool]]
        auto_partitioning_max_partitions_count: NotRequired[pulumi.Input[int]]
        auto_partitioning_min_partitions_count: NotRequired[pulumi.Input[int]]
        auto_partitioning_partition_size_mb: NotRequired[pulumi.Input[int]]
        partition_at_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['YdbTablePartitioningSettingsPartitionAtKeyArgsDict']]]]
        uniform_partitions: NotRequired[pulumi.Input[int]]
elif False:
    YdbTablePartitioningSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTablePartitioningSettingsArgs:
    def __init__(__self__, *,
                 auto_partitioning_by_load: Optional[pulumi.Input[bool]] = None,
                 auto_partitioning_by_size_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_partitioning_max_partitions_count: Optional[pulumi.Input[int]] = None,
                 auto_partitioning_min_partitions_count: Optional[pulumi.Input[int]] = None,
                 auto_partitioning_partition_size_mb: Optional[pulumi.Input[int]] = None,
                 partition_at_keys: Optional[pulumi.Input[Sequence[pulumi.Input['YdbTablePartitioningSettingsPartitionAtKeyArgs']]]] = None,
                 uniform_partitions: Optional[pulumi.Input[int]] = None):
        if auto_partitioning_by_load is not None:
            pulumi.set(__self__, "auto_partitioning_by_load", auto_partitioning_by_load)
        if auto_partitioning_by_size_enabled is not None:
            pulumi.set(__self__, "auto_partitioning_by_size_enabled", auto_partitioning_by_size_enabled)
        if auto_partitioning_max_partitions_count is not None:
            pulumi.set(__self__, "auto_partitioning_max_partitions_count", auto_partitioning_max_partitions_count)
        if auto_partitioning_min_partitions_count is not None:
            pulumi.set(__self__, "auto_partitioning_min_partitions_count", auto_partitioning_min_partitions_count)
        if auto_partitioning_partition_size_mb is not None:
            pulumi.set(__self__, "auto_partitioning_partition_size_mb", auto_partitioning_partition_size_mb)
        if partition_at_keys is not None:
            pulumi.set(__self__, "partition_at_keys", partition_at_keys)
        if uniform_partitions is not None:
            pulumi.set(__self__, "uniform_partitions", uniform_partitions)

    @property
    @pulumi.getter(name="autoPartitioningByLoad")
    def auto_partitioning_by_load(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_partitioning_by_load")

    @auto_partitioning_by_load.setter
    def auto_partitioning_by_load(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_partitioning_by_load", value)

    @property
    @pulumi.getter(name="autoPartitioningBySizeEnabled")
    def auto_partitioning_by_size_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_partitioning_by_size_enabled")

    @auto_partitioning_by_size_enabled.setter
    def auto_partitioning_by_size_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_partitioning_by_size_enabled", value)

    @property
    @pulumi.getter(name="autoPartitioningMaxPartitionsCount")
    def auto_partitioning_max_partitions_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "auto_partitioning_max_partitions_count")

    @auto_partitioning_max_partitions_count.setter
    def auto_partitioning_max_partitions_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_partitioning_max_partitions_count", value)

    @property
    @pulumi.getter(name="autoPartitioningMinPartitionsCount")
    def auto_partitioning_min_partitions_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "auto_partitioning_min_partitions_count")

    @auto_partitioning_min_partitions_count.setter
    def auto_partitioning_min_partitions_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_partitioning_min_partitions_count", value)

    @property
    @pulumi.getter(name="autoPartitioningPartitionSizeMb")
    def auto_partitioning_partition_size_mb(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "auto_partitioning_partition_size_mb")

    @auto_partitioning_partition_size_mb.setter
    def auto_partitioning_partition_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_partitioning_partition_size_mb", value)

    @property
    @pulumi.getter(name="partitionAtKeys")
    def partition_at_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['YdbTablePartitioningSettingsPartitionAtKeyArgs']]]]:
        return pulumi.get(self, "partition_at_keys")

    @partition_at_keys.setter
    def partition_at_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['YdbTablePartitioningSettingsPartitionAtKeyArgs']]]]):
        pulumi.set(self, "partition_at_keys", value)

    @property
    @pulumi.getter(name="uniformPartitions")
    def uniform_partitions(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "uniform_partitions")

    @uniform_partitions.setter
    def uniform_partitions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uniform_partitions", value)


if not MYPY:
    class YdbTablePartitioningSettingsPartitionAtKeyArgsDict(TypedDict):
        keys: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    YdbTablePartitioningSettingsPartitionAtKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTablePartitioningSettingsPartitionAtKeyArgs:
    def __init__(__self__, *,
                 keys: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class YdbTableTtlArgsDict(TypedDict):
        column_name: pulumi.Input[str]
        """
        Column name for TTL
        """
        expire_interval: pulumi.Input[str]
        """
        Interval in the ISO 8601 format
        """
        unit: NotRequired[pulumi.Input[str]]
elif False:
    YdbTableTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTableTtlArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[str],
                 expire_interval: pulumi.Input[str],
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] column_name: Column name for TTL
        :param pulumi.Input[str] expire_interval: Interval in the ISO 8601 format
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "expire_interval", expire_interval)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[str]:
        """
        Column name for TTL
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="expireInterval")
    def expire_interval(self) -> pulumi.Input[str]:
        """
        Interval in the ISO 8601 format
        """
        return pulumi.get(self, "expire_interval")

    @expire_interval.setter
    def expire_interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "expire_interval", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class YdbTopicConsumerArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Topic name. Type: string, required. Default value: "".
        """
        important: NotRequired[pulumi.Input[bool]]
        starting_message_timestamp_ms: NotRequired[pulumi.Input[int]]
        supported_codecs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Supported data encodings. Types: array[string]. Default value: ["gzip", "raw", "zstd"].
        """
elif False:
    YdbTopicConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YdbTopicConsumerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 important: Optional[pulumi.Input[bool]] = None,
                 starting_message_timestamp_ms: Optional[pulumi.Input[int]] = None,
                 supported_codecs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: Topic name. Type: string, required. Default value: "".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_codecs: Supported data encodings. Types: array[string]. Default value: ["gzip", "raw", "zstd"].
        """
        pulumi.set(__self__, "name", name)
        if important is not None:
            pulumi.set(__self__, "important", important)
        if starting_message_timestamp_ms is not None:
            pulumi.set(__self__, "starting_message_timestamp_ms", starting_message_timestamp_ms)
        if supported_codecs is not None:
            pulumi.set(__self__, "supported_codecs", supported_codecs)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Topic name. Type: string, required. Default value: "".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def important(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "important")

    @important.setter
    def important(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "important", value)

    @property
    @pulumi.getter(name="startingMessageTimestampMs")
    def starting_message_timestamp_ms(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "starting_message_timestamp_ms")

    @starting_message_timestamp_ms.setter
    def starting_message_timestamp_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "starting_message_timestamp_ms", value)

    @property
    @pulumi.getter(name="supportedCodecs")
    def supported_codecs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported data encodings. Types: array[string]. Default value: ["gzip", "raw", "zstd"].
        """
        return pulumi.get(self, "supported_codecs")

    @supported_codecs.setter
    def supported_codecs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_codecs", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendArgsDict(TypedDict):
        healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckArgsDict'
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        load_balancing_config: 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict'
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        name: str
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        port: int
        """
        Port for incoming traffic.
        """
        target_group_ids: Sequence[str]
        """
        References target groups for the backend.
        """
        tls: 'GetAlbBackendGroupGrpcBackendTlsArgsDict'
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        weight: int
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
elif False:
    GetAlbBackendGroupGrpcBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendArgs:
    def __init__(__self__, *,
                 healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckArgs',
                 load_balancing_config: 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs',
                 name: str,
                 port: int,
                 target_group_ids: Sequence[str],
                 tls: 'GetAlbBackendGroupGrpcBackendTlsArgs',
                 weight: int):
        """
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param str name: Name of the Backend Group.
               
               > One of `backend_group_id` or `name` should be specified.
        :param int port: Port for incoming traffic.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupGrpcBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def healthcheck(self) -> 'GetAlbBackendGroupGrpcBackendHealthcheckArgs':
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: 'GetAlbBackendGroupGrpcBackendHealthcheckArgs'):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs':
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @load_balancing_config.setter
    def load_balancing_config(self, value: 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs'):
        pulumi.set(self, "load_balancing_config", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: int):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @target_group_ids.setter
    def target_group_ids(self, value: Sequence[str]):
        pulumi.set(self, "target_group_ids", value)

    @property
    @pulumi.getter
    def tls(self) -> 'GetAlbBackendGroupGrpcBackendTlsArgs':
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: 'GetAlbBackendGroupGrpcBackendTlsArgs'):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: int):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendHealthcheckArgsDict(TypedDict):
        grpc_healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict'
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        healthcheck_port: int
        """
        Optional alternative port for health checking.
        """
        healthy_threshold: int
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        http_healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict'
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        interval: str
        """
        Interval between health checks.
        """
        interval_jitter_percent: float
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        stream_healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict'
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        timeout: str
        """
        Time to wait for a health check response.
        """
        unhealthy_threshold: int
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
elif False:
    GetAlbBackendGroupGrpcBackendHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendHealthcheckArgs:
    def __init__(__self__, *,
                 grpc_healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs',
                 healthcheck_port: int,
                 healthy_threshold: int,
                 http_healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs',
                 interval: str,
                 interval_jitter_percent: float,
                 stream_healthcheck: 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs',
                 timeout: str,
                 unhealthy_threshold: int):
        """
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str interval: Interval between health checks.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str timeout: Time to wait for a health check response.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs':
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @grpc_healthcheck.setter
    def grpc_healthcheck(self, value: 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs'):
        pulumi.set(self, "grpc_healthcheck", value)

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @healthcheck_port.setter
    def healthcheck_port(self, value: int):
        pulumi.set(self, "healthcheck_port", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: int):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs':
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @http_healthcheck.setter
    def http_healthcheck(self, value: 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs'):
        pulumi.set(self, "http_healthcheck", value)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: str):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @interval_jitter_percent.setter
    def interval_jitter_percent(self, value: float):
        pulumi.set(self, "interval_jitter_percent", value)

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs':
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @stream_healthcheck.setter
    def stream_healthcheck(self, value: 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs'):
        pulumi.set(self, "stream_healthcheck", value)

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: str):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: int):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict(TypedDict):
        service_name: str
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
elif False:
    GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs:
    def __init__(__self__, *,
                 service_name: str):
        """
        :param str service_name: Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: str):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict(TypedDict):
        expected_statuses: Sequence[int]
        """
        (Optional) A list of HTTP response statuses considered healthy.
        """
        host: str
        """
        Optional "Host" HTTP header value.
        """
        http2: bool
        """
        If set, health checks will use HTTP2.
        """
        path: str
        """
        HTTP path.
        """
elif False:
    GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs:
    def __init__(__self__, *,
                 expected_statuses: Sequence[int],
                 host: str,
                 http2: bool,
                 path: str):
        """
        :param Sequence[int] expected_statuses: (Optional) A list of HTTP response statuses considered healthy.
        :param str host: Optional "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        :param str path: HTTP path.
        """
        pulumi.set(__self__, "expected_statuses", expected_statuses)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Sequence[int]:
        """
        (Optional) A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @expected_statuses.setter
    def expected_statuses(self, value: Sequence[int]):
        pulumi.set(self, "expected_statuses", value)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Optional "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: str):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: bool):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict(TypedDict):
        receive: str
        """
        Optional text that must be contained in the messages received from targets for a successful health check.
        """
        send: str
        """
        Optional message text sent to targets during TCP data transfer.
        """
elif False:
    GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs:
    def __init__(__self__, *,
                 receive: str,
                 send: str):
        """
        :param str receive: Optional text that must be contained in the messages received from targets for a successful health check.
        :param str send: Optional message text sent to targets during TCP data transfer.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> str:
        """
        Optional text that must be contained in the messages received from targets for a successful health check.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: str):
        pulumi.set(self, "receive", value)

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Optional message text sent to targets during TCP data transfer.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: str):
        pulumi.set(self, "send", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict(TypedDict):
        locality_aware_routing_percent: int
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        mode: str
        """
        Load balancing mode for the backend.
        """
        panic_threshold: int
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        strict_locality: bool
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
elif False:
    GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs:
    def __init__(__self__, *,
                 locality_aware_routing_percent: int,
                 mode: str,
                 panic_threshold: int,
                 strict_locality: bool):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param str mode: Load balancing mode for the backend.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @locality_aware_routing_percent.setter
    def locality_aware_routing_percent(self, value: int):
        pulumi.set(self, "locality_aware_routing_percent", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Load balancing mode for the backend.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: str):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @panic_threshold.setter
    def panic_threshold(self, value: int):
        pulumi.set(self, "panic_threshold", value)

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")

    @strict_locality.setter
    def strict_locality(self, value: bool):
        pulumi.set(self, "strict_locality", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendTlsArgsDict(TypedDict):
        sni: str
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        validation_context: 'GetAlbBackendGroupGrpcBackendTlsValidationContextArgsDict'
elif False:
    GetAlbBackendGroupGrpcBackendTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendTlsArgs:
    def __init__(__self__, *,
                 sni: str,
                 validation_context: 'GetAlbBackendGroupGrpcBackendTlsValidationContextArgs'):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: str):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'GetAlbBackendGroupGrpcBackendTlsValidationContextArgs':
        return pulumi.get(self, "validation_context")

    @validation_context.setter
    def validation_context(self, value: 'GetAlbBackendGroupGrpcBackendTlsValidationContextArgs'):
        pulumi.set(self, "validation_context", value)


if not MYPY:
    class GetAlbBackendGroupGrpcBackendTlsValidationContextArgsDict(TypedDict):
        trusted_ca_bytes: str
        """
        PEM-encoded trusted CA certificate chain.
        """
        trusted_ca_id: str
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
elif False:
    GetAlbBackendGroupGrpcBackendTlsValidationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupGrpcBackendTlsValidationContextArgs:
    def __init__(__self__, *,
                 trusted_ca_bytes: str,
                 trusted_ca_id: str):
        """
        :param str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> str:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @trusted_ca_bytes.setter
    def trusted_ca_bytes(self, value: str):
        pulumi.set(self, "trusted_ca_bytes", value)

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> str:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")

    @trusted_ca_id.setter
    def trusted_ca_id(self, value: str):
        pulumi.set(self, "trusted_ca_id", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendArgsDict(TypedDict):
        healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckArgsDict'
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        http2: bool
        """
        If set, health checks will use HTTP2.
        """
        load_balancing_config: 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgsDict'
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        name: str
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        port: int
        """
        Port for incoming traffic.
        """
        storage_bucket: str
        target_group_ids: Sequence[str]
        """
        References target groups for the backend.
        """
        tls: 'GetAlbBackendGroupHttpBackendTlsArgsDict'
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        weight: int
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
elif False:
    GetAlbBackendGroupHttpBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendArgs:
    def __init__(__self__, *,
                 healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckArgs',
                 http2: bool,
                 load_balancing_config: 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs',
                 name: str,
                 port: int,
                 storage_bucket: str,
                 target_group_ids: Sequence[str],
                 tls: 'GetAlbBackendGroupHttpBackendTlsArgs',
                 weight: int):
        """
        :param 'GetAlbBackendGroupHttpBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param bool http2: If set, health checks will use HTTP2.
        :param 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param str name: Name of the Backend Group.
               
               > One of `backend_group_id` or `name` should be specified.
        :param int port: Port for incoming traffic.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupHttpBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "storage_bucket", storage_bucket)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def healthcheck(self) -> 'GetAlbBackendGroupHttpBackendHealthcheckArgs':
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: 'GetAlbBackendGroupHttpBackendHealthcheckArgs'):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: bool):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs':
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @load_balancing_config.setter
    def load_balancing_config(self, value: 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs'):
        pulumi.set(self, "load_balancing_config", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: int):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="storageBucket")
    def storage_bucket(self) -> str:
        return pulumi.get(self, "storage_bucket")

    @storage_bucket.setter
    def storage_bucket(self, value: str):
        pulumi.set(self, "storage_bucket", value)

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @target_group_ids.setter
    def target_group_ids(self, value: Sequence[str]):
        pulumi.set(self, "target_group_ids", value)

    @property
    @pulumi.getter
    def tls(self) -> 'GetAlbBackendGroupHttpBackendTlsArgs':
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: 'GetAlbBackendGroupHttpBackendTlsArgs'):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: int):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendHealthcheckArgsDict(TypedDict):
        grpc_healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict'
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        healthcheck_port: int
        """
        Optional alternative port for health checking.
        """
        healthy_threshold: int
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        http_healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict'
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        interval: str
        """
        Interval between health checks.
        """
        interval_jitter_percent: float
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        stream_healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict'
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        timeout: str
        """
        Time to wait for a health check response.
        """
        unhealthy_threshold: int
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
elif False:
    GetAlbBackendGroupHttpBackendHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendHealthcheckArgs:
    def __init__(__self__, *,
                 grpc_healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs',
                 healthcheck_port: int,
                 healthy_threshold: int,
                 http_healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs',
                 interval: str,
                 interval_jitter_percent: float,
                 stream_healthcheck: 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs',
                 timeout: str,
                 unhealthy_threshold: int):
        """
        :param 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str interval: Interval between health checks.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str timeout: Time to wait for a health check response.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs':
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @grpc_healthcheck.setter
    def grpc_healthcheck(self, value: 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs'):
        pulumi.set(self, "grpc_healthcheck", value)

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @healthcheck_port.setter
    def healthcheck_port(self, value: int):
        pulumi.set(self, "healthcheck_port", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: int):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs':
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @http_healthcheck.setter
    def http_healthcheck(self, value: 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs'):
        pulumi.set(self, "http_healthcheck", value)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: str):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @interval_jitter_percent.setter
    def interval_jitter_percent(self, value: float):
        pulumi.set(self, "interval_jitter_percent", value)

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs':
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @stream_healthcheck.setter
    def stream_healthcheck(self, value: 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs'):
        pulumi.set(self, "stream_healthcheck", value)

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: str):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: int):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict(TypedDict):
        service_name: str
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
elif False:
    GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs:
    def __init__(__self__, *,
                 service_name: str):
        """
        :param str service_name: Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: str):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict(TypedDict):
        expected_statuses: Sequence[int]
        """
        (Optional) A list of HTTP response statuses considered healthy.
        """
        host: str
        """
        Optional "Host" HTTP header value.
        """
        http2: bool
        """
        If set, health checks will use HTTP2.
        """
        path: str
        """
        HTTP path.
        """
elif False:
    GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs:
    def __init__(__self__, *,
                 expected_statuses: Sequence[int],
                 host: str,
                 http2: bool,
                 path: str):
        """
        :param Sequence[int] expected_statuses: (Optional) A list of HTTP response statuses considered healthy.
        :param str host: Optional "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        :param str path: HTTP path.
        """
        pulumi.set(__self__, "expected_statuses", expected_statuses)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Sequence[int]:
        """
        (Optional) A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @expected_statuses.setter
    def expected_statuses(self, value: Sequence[int]):
        pulumi.set(self, "expected_statuses", value)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Optional "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: str):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: bool):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict(TypedDict):
        receive: str
        """
        Optional text that must be contained in the messages received from targets for a successful health check.
        """
        send: str
        """
        Optional message text sent to targets during TCP data transfer.
        """
elif False:
    GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs:
    def __init__(__self__, *,
                 receive: str,
                 send: str):
        """
        :param str receive: Optional text that must be contained in the messages received from targets for a successful health check.
        :param str send: Optional message text sent to targets during TCP data transfer.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> str:
        """
        Optional text that must be contained in the messages received from targets for a successful health check.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: str):
        pulumi.set(self, "receive", value)

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Optional message text sent to targets during TCP data transfer.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: str):
        pulumi.set(self, "send", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendLoadBalancingConfigArgsDict(TypedDict):
        locality_aware_routing_percent: int
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        mode: str
        """
        Load balancing mode for the backend.
        """
        panic_threshold: int
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        strict_locality: bool
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
elif False:
    GetAlbBackendGroupHttpBackendLoadBalancingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs:
    def __init__(__self__, *,
                 locality_aware_routing_percent: int,
                 mode: str,
                 panic_threshold: int,
                 strict_locality: bool):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param str mode: Load balancing mode for the backend.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @locality_aware_routing_percent.setter
    def locality_aware_routing_percent(self, value: int):
        pulumi.set(self, "locality_aware_routing_percent", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Load balancing mode for the backend.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: str):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @panic_threshold.setter
    def panic_threshold(self, value: int):
        pulumi.set(self, "panic_threshold", value)

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")

    @strict_locality.setter
    def strict_locality(self, value: bool):
        pulumi.set(self, "strict_locality", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendTlsArgsDict(TypedDict):
        sni: str
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        validation_context: 'GetAlbBackendGroupHttpBackendTlsValidationContextArgsDict'
elif False:
    GetAlbBackendGroupHttpBackendTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendTlsArgs:
    def __init__(__self__, *,
                 sni: str,
                 validation_context: 'GetAlbBackendGroupHttpBackendTlsValidationContextArgs'):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: str):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'GetAlbBackendGroupHttpBackendTlsValidationContextArgs':
        return pulumi.get(self, "validation_context")

    @validation_context.setter
    def validation_context(self, value: 'GetAlbBackendGroupHttpBackendTlsValidationContextArgs'):
        pulumi.set(self, "validation_context", value)


if not MYPY:
    class GetAlbBackendGroupHttpBackendTlsValidationContextArgsDict(TypedDict):
        trusted_ca_bytes: str
        """
        PEM-encoded trusted CA certificate chain.
        """
        trusted_ca_id: str
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
elif False:
    GetAlbBackendGroupHttpBackendTlsValidationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupHttpBackendTlsValidationContextArgs:
    def __init__(__self__, *,
                 trusted_ca_bytes: str,
                 trusted_ca_id: str):
        """
        :param str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> str:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @trusted_ca_bytes.setter
    def trusted_ca_bytes(self, value: str):
        pulumi.set(self, "trusted_ca_bytes", value)

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> str:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")

    @trusted_ca_id.setter
    def trusted_ca_id(self, value: str):
        pulumi.set(self, "trusted_ca_id", value)


if not MYPY:
    class GetAlbBackendGroupSessionAffinityArgsDict(TypedDict):
        connection: 'GetAlbBackendGroupSessionAffinityConnectionArgsDict'
        """
        Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
        """
        cookie: 'GetAlbBackendGroupSessionAffinityCookieArgsDict'
        """
        Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
        header: 'GetAlbBackendGroupSessionAffinityHeaderArgsDict'
        """
        Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
elif False:
    GetAlbBackendGroupSessionAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupSessionAffinityArgs:
    def __init__(__self__, *,
                 connection: 'GetAlbBackendGroupSessionAffinityConnectionArgs',
                 cookie: 'GetAlbBackendGroupSessionAffinityCookieArgs',
                 header: 'GetAlbBackendGroupSessionAffinityHeaderArgs'):
        """
        :param 'GetAlbBackendGroupSessionAffinityConnectionArgs' connection: Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
        :param 'GetAlbBackendGroupSessionAffinityCookieArgs' cookie: Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        :param 'GetAlbBackendGroupSessionAffinityHeaderArgs' header: Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "cookie", cookie)
        pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def connection(self) -> 'GetAlbBackendGroupSessionAffinityConnectionArgs':
        """
        Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address. Structure is documented below.
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: 'GetAlbBackendGroupSessionAffinityConnectionArgs'):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def cookie(self) -> 'GetAlbBackendGroupSessionAffinityCookieArgs':
        """
        Requests with the same cookie value and the specified file name are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: 'GetAlbBackendGroupSessionAffinityCookieArgs'):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> 'GetAlbBackendGroupSessionAffinityHeaderArgs':
        """
        Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for HTTP and gRPC backend groups. Structure is documented below.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: 'GetAlbBackendGroupSessionAffinityHeaderArgs'):
        pulumi.set(self, "header", value)


if not MYPY:
    class GetAlbBackendGroupSessionAffinityConnectionArgsDict(TypedDict):
        source_ip: bool
        """
        Source IP address to use with affinity.
        """
elif False:
    GetAlbBackendGroupSessionAffinityConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupSessionAffinityConnectionArgs:
    def __init__(__self__, *,
                 source_ip: bool):
        """
        :param bool source_ip: Source IP address to use with affinity.
        """
        pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> bool:
        """
        Source IP address to use with affinity.
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: bool):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class GetAlbBackendGroupSessionAffinityCookieArgsDict(TypedDict):
        name: str
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        ttl: str
        """
        TTL for the cookie (if not set, session cookie will be used)
        """
elif False:
    GetAlbBackendGroupSessionAffinityCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupSessionAffinityCookieArgs:
    def __init__(__self__, *,
                 name: str,
                 ttl: str):
        """
        :param str name: Name of the Backend Group.
               
               > One of `backend_group_id` or `name` should be specified.
        :param str ttl: TTL for the cookie (if not set, session cookie will be used)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ttl(self) -> str:
        """
        TTL for the cookie (if not set, session cookie will be used)
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: str):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class GetAlbBackendGroupSessionAffinityHeaderArgsDict(TypedDict):
        header_name: str
        """
        The name of the request header that will be used with affinity.
        """
elif False:
    GetAlbBackendGroupSessionAffinityHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupSessionAffinityHeaderArgs:
    def __init__(__self__, *,
                 header_name: str):
        """
        :param str header_name: The name of the request header that will be used with affinity.
        """
        pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the request header that will be used with affinity.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: str):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendArgsDict(TypedDict):
        enable_proxy_protocol: bool
        healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckArgsDict'
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        load_balancing_config: 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgsDict'
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        name: str
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        port: int
        """
        Port for incoming traffic.
        """
        target_group_ids: Sequence[str]
        """
        References target groups for the backend.
        """
        tls: 'GetAlbBackendGroupStreamBackendTlsArgsDict'
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        weight: int
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        keep_connections_on_host_health_failure: NotRequired[bool]
        """
        If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
elif False:
    GetAlbBackendGroupStreamBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendArgs:
    def __init__(__self__, *,
                 enable_proxy_protocol: bool,
                 healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckArgs',
                 load_balancing_config: 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs',
                 name: str,
                 port: int,
                 target_group_ids: Sequence[str],
                 tls: 'GetAlbBackendGroupStreamBackendTlsArgs',
                 weight: int,
                 keep_connections_on_host_health_failure: Optional[bool] = None):
        """
        :param 'GetAlbBackendGroupStreamBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param str name: Name of the Backend Group.
               
               > One of `backend_group_id` or `name` should be specified.
        :param int port: Port for incoming traffic.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupStreamBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        :param bool keep_connections_on_host_health_failure: If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        pulumi.set(__self__, "enable_proxy_protocol", enable_proxy_protocol)
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)
        if keep_connections_on_host_health_failure is not None:
            pulumi.set(__self__, "keep_connections_on_host_health_failure", keep_connections_on_host_health_failure)

    @property
    @pulumi.getter(name="enableProxyProtocol")
    def enable_proxy_protocol(self) -> bool:
        return pulumi.get(self, "enable_proxy_protocol")

    @enable_proxy_protocol.setter
    def enable_proxy_protocol(self, value: bool):
        pulumi.set(self, "enable_proxy_protocol", value)

    @property
    @pulumi.getter
    def healthcheck(self) -> 'GetAlbBackendGroupStreamBackendHealthcheckArgs':
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: 'GetAlbBackendGroupStreamBackendHealthcheckArgs'):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs':
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @load_balancing_config.setter
    def load_balancing_config(self, value: 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs'):
        pulumi.set(self, "load_balancing_config", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Backend Group.

        > One of `backend_group_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: int):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @target_group_ids.setter
    def target_group_ids(self, value: Sequence[str]):
        pulumi.set(self, "target_group_ids", value)

    @property
    @pulumi.getter
    def tls(self) -> 'GetAlbBackendGroupStreamBackendTlsArgs':
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: 'GetAlbBackendGroupStreamBackendTlsArgs'):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: int):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter(name="keepConnectionsOnHostHealthFailure")
    def keep_connections_on_host_health_failure(self) -> Optional[bool]:
        """
        If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        return pulumi.get(self, "keep_connections_on_host_health_failure")

    @keep_connections_on_host_health_failure.setter
    def keep_connections_on_host_health_failure(self, value: Optional[bool]):
        pulumi.set(self, "keep_connections_on_host_health_failure", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendHealthcheckArgsDict(TypedDict):
        grpc_healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict'
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        healthcheck_port: int
        """
        Optional alternative port for health checking.
        """
        healthy_threshold: int
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        http_healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict'
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        interval: str
        """
        Interval between health checks.
        """
        interval_jitter_percent: float
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        stream_healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict'
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        timeout: str
        """
        Time to wait for a health check response.
        """
        unhealthy_threshold: int
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
elif False:
    GetAlbBackendGroupStreamBackendHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendHealthcheckArgs:
    def __init__(__self__, *,
                 grpc_healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs',
                 healthcheck_port: int,
                 healthy_threshold: int,
                 http_healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs',
                 interval: str,
                 interval_jitter_percent: float,
                 stream_healthcheck: 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs',
                 timeout: str,
                 unhealthy_threshold: int):
        """
        :param 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str interval: Interval between health checks.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str timeout: Time to wait for a health check response.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs':
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @grpc_healthcheck.setter
    def grpc_healthcheck(self, value: 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs'):
        pulumi.set(self, "grpc_healthcheck", value)

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @healthcheck_port.setter
    def healthcheck_port(self, value: int):
        pulumi.set(self, "healthcheck_port", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: int):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs':
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @http_healthcheck.setter
    def http_healthcheck(self, value: 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs'):
        pulumi.set(self, "http_healthcheck", value)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: str):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @interval_jitter_percent.setter
    def interval_jitter_percent(self, value: float):
        pulumi.set(self, "interval_jitter_percent", value)

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs':
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @stream_healthcheck.setter
    def stream_healthcheck(self, value: 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs'):
        pulumi.set(self, "stream_healthcheck", value)

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: str):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: int):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict(TypedDict):
        service_name: str
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
elif False:
    GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs:
    def __init__(__self__, *,
                 service_name: str):
        """
        :param str service_name: Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: str):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict(TypedDict):
        expected_statuses: Sequence[int]
        """
        (Optional) A list of HTTP response statuses considered healthy.
        """
        host: str
        """
        Optional "Host" HTTP header value.
        """
        http2: bool
        """
        If set, health checks will use HTTP2.
        """
        path: str
        """
        HTTP path.
        """
elif False:
    GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs:
    def __init__(__self__, *,
                 expected_statuses: Sequence[int],
                 host: str,
                 http2: bool,
                 path: str):
        """
        :param Sequence[int] expected_statuses: (Optional) A list of HTTP response statuses considered healthy.
        :param str host: Optional "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        :param str path: HTTP path.
        """
        pulumi.set(__self__, "expected_statuses", expected_statuses)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Sequence[int]:
        """
        (Optional) A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @expected_statuses.setter
    def expected_statuses(self, value: Sequence[int]):
        pulumi.set(self, "expected_statuses", value)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Optional "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: str):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: bool):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict(TypedDict):
        receive: str
        """
        Optional text that must be contained in the messages received from targets for a successful health check.
        """
        send: str
        """
        Optional message text sent to targets during TCP data transfer.
        """
elif False:
    GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs:
    def __init__(__self__, *,
                 receive: str,
                 send: str):
        """
        :param str receive: Optional text that must be contained in the messages received from targets for a successful health check.
        :param str send: Optional message text sent to targets during TCP data transfer.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> str:
        """
        Optional text that must be contained in the messages received from targets for a successful health check.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: str):
        pulumi.set(self, "receive", value)

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Optional message text sent to targets during TCP data transfer.
        """
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: str):
        pulumi.set(self, "send", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendLoadBalancingConfigArgsDict(TypedDict):
        locality_aware_routing_percent: int
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        mode: str
        """
        Load balancing mode for the backend.
        """
        panic_threshold: int
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        strict_locality: bool
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
elif False:
    GetAlbBackendGroupStreamBackendLoadBalancingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs:
    def __init__(__self__, *,
                 locality_aware_routing_percent: int,
                 mode: str,
                 panic_threshold: int,
                 strict_locality: bool):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param str mode: Load balancing mode for the backend.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @locality_aware_routing_percent.setter
    def locality_aware_routing_percent(self, value: int):
        pulumi.set(self, "locality_aware_routing_percent", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Load balancing mode for the backend.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: str):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @panic_threshold.setter
    def panic_threshold(self, value: int):
        pulumi.set(self, "panic_threshold", value)

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")

    @strict_locality.setter
    def strict_locality(self, value: bool):
        pulumi.set(self, "strict_locality", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendTlsArgsDict(TypedDict):
        sni: str
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        validation_context: 'GetAlbBackendGroupStreamBackendTlsValidationContextArgsDict'
elif False:
    GetAlbBackendGroupStreamBackendTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendTlsArgs:
    def __init__(__self__, *,
                 sni: str,
                 validation_context: 'GetAlbBackendGroupStreamBackendTlsValidationContextArgs'):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: str):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'GetAlbBackendGroupStreamBackendTlsValidationContextArgs':
        return pulumi.get(self, "validation_context")

    @validation_context.setter
    def validation_context(self, value: 'GetAlbBackendGroupStreamBackendTlsValidationContextArgs'):
        pulumi.set(self, "validation_context", value)


if not MYPY:
    class GetAlbBackendGroupStreamBackendTlsValidationContextArgsDict(TypedDict):
        trusted_ca_bytes: str
        """
        PEM-encoded trusted CA certificate chain.
        """
        trusted_ca_id: str
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
elif False:
    GetAlbBackendGroupStreamBackendTlsValidationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlbBackendGroupStreamBackendTlsValidationContextArgs:
    def __init__(__self__, *,
                 trusted_ca_bytes: str,
                 trusted_ca_id: str):
        """
        :param str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> str:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @trusted_ca_bytes.setter
    def trusted_ca_bytes(self, value: str):
        pulumi.set(self, "trusted_ca_bytes", value)

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> str:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")

    @trusted_ca_id.setter
    def trusted_ca_id(self, value: str):
        pulumi.set(self, "trusted_ca_id", value)


if not MYPY:
    class GetApiGatewayCanaryArgsDict(TypedDict):
        variables: NotRequired[Mapping[str, str]]
        """
        A list of values for variables in gateway specification of canary release.
        """
        weight: NotRequired[int]
        """
        Percentage of requests, which will be processed by canary release.
        """
elif False:
    GetApiGatewayCanaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiGatewayCanaryArgs:
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, str]] = None,
                 weight: Optional[int] = None):
        """
        :param Mapping[str, str] variables: A list of values for variables in gateway specification of canary release.
        :param int weight: Percentage of requests, which will be processed by canary release.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        A list of values for variables in gateway specification of canary release.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "variables", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Percentage of requests, which will be processed by canary release.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GetApiGatewayConnectivityArgsDict(TypedDict):
        network_id: str
        """
        Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
elif False:
    GetApiGatewayConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiGatewayConnectivityArgs:
    def __init__(__self__, *,
                 network_id: str):
        """
        :param str network_id: Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: str):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class GetApiGatewayCustomDomainArgsDict(TypedDict):
        certificate_id: str
        domain_id: str
        fqdn: str
elif False:
    GetApiGatewayCustomDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiGatewayCustomDomainArgs:
    def __init__(__self__, *,
                 certificate_id: str,
                 domain_id: str,
                 fqdn: str):
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> str:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: str):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> str:
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: str):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: str):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class GetCdnResourceOptionsArgsDict(TypedDict):
        allowed_http_methods: Sequence[str]
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        browser_cache_settings: int
        """
        set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        cache_http_headers: Sequence[str]
        """
        list HTTP headers that must be included in responses to clients.
        """
        cors: Sequence[str]
        """
        parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        custom_host_header: str
        """
        custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        custom_server_name: str
        """
        wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        """
        disable_cache: bool
        """
        setup a cache status.
        """
        disable_proxy_force_ranges: bool
        """
        disabling proxy force ranges.
        """
        edge_cache_settings: int
        """
        content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        enable_ip_url_signing: bool
        """
        enable access limiting by IP addresses, option available only with setting secure_key.

        * `ip_address_acl.excepted_values` - the list of specified IP addresses to be allowed or denied depending on acl policy type.

        * `ip_address_acl.policy_type` - the policy type for ip_address_acl option, one of "allow" or "deny" values.
        """
        fetched_compressed: bool
        """
        option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        forward_host_header: bool
        """
        choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        gzip_on: bool
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        ignore_cookie: bool
        """
        set for ignoring cookie.
        """
        ignore_query_params: bool
        """
        files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        ip_address_acl: 'GetCdnResourceOptionsIpAddressAclArgsDict'
        proxy_cache_methods_set: bool
        """
        allows caching for GET, HEAD and POST requests.
        """
        query_params_blacklists: Sequence[str]
        """
        files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        query_params_whitelists: Sequence[str]
        """
        files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        redirect_http_to_https: bool
        """
        set up a redirect from HTTPS to HTTP.
        """
        redirect_https_to_http: bool
        """
        set up a redirect from HTTP to HTTPS.
        """
        secure_key: str
        """
        set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        """
        slice: bool
        """
        files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        static_request_headers: Mapping[str, str]
        """
        set up custom headers that CDN servers send in requests to origins.
        """
        static_response_headers: Mapping[str, str]
elif False:
    GetCdnResourceOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCdnResourceOptionsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Sequence[str],
                 browser_cache_settings: int,
                 cache_http_headers: Sequence[str],
                 cors: Sequence[str],
                 custom_host_header: str,
                 custom_server_name: str,
                 disable_cache: bool,
                 disable_proxy_force_ranges: bool,
                 edge_cache_settings: int,
                 enable_ip_url_signing: bool,
                 fetched_compressed: bool,
                 forward_host_header: bool,
                 gzip_on: bool,
                 ignore_cookie: bool,
                 ignore_query_params: bool,
                 ip_address_acl: 'GetCdnResourceOptionsIpAddressAclArgs',
                 proxy_cache_methods_set: bool,
                 query_params_blacklists: Sequence[str],
                 query_params_whitelists: Sequence[str],
                 redirect_http_to_https: bool,
                 redirect_https_to_http: bool,
                 secure_key: str,
                 slice: bool,
                 static_request_headers: Mapping[str, str],
                 static_response_headers: Mapping[str, str]):
        """
        :param Sequence[str] allowed_http_methods: HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        :param int browser_cache_settings: set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        :param Sequence[str] cache_http_headers: list HTTP headers that must be included in responses to clients.
        :param Sequence[str] cors: parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        :param str custom_host_header: custom value for the Host header. Your server must be able to process requests with the chosen header.
        :param str custom_server_name: wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        :param bool disable_cache: setup a cache status.
        :param bool disable_proxy_force_ranges: disabling proxy force ranges.
        :param int edge_cache_settings: content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        :param bool enable_ip_url_signing: enable access limiting by IP addresses, option available only with setting secure_key.
               
               * `ip_address_acl.excepted_values` - the list of specified IP addresses to be allowed or denied depending on acl policy type.
               
               * `ip_address_acl.policy_type` - the policy type for ip_address_acl option, one of "allow" or "deny" values.
        :param bool fetched_compressed: option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        :param bool forward_host_header: choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        :param bool gzip_on: GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        :param bool ignore_cookie: set for ignoring cookie.
        :param bool ignore_query_params: files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        :param bool proxy_cache_methods_set: allows caching for GET, HEAD and POST requests.
        :param Sequence[str] query_params_blacklists: files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        :param Sequence[str] query_params_whitelists: files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        :param bool redirect_http_to_https: set up a redirect from HTTPS to HTTP.
        :param bool redirect_https_to_http: set up a redirect from HTTP to HTTPS.
        :param str secure_key: set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        :param bool slice: files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        :param Mapping[str, str] static_request_headers: set up custom headers that CDN servers send in requests to origins.
        """
        pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        pulumi.set(__self__, "browser_cache_settings", browser_cache_settings)
        pulumi.set(__self__, "cache_http_headers", cache_http_headers)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "custom_host_header", custom_host_header)
        pulumi.set(__self__, "custom_server_name", custom_server_name)
        pulumi.set(__self__, "disable_cache", disable_cache)
        pulumi.set(__self__, "disable_proxy_force_ranges", disable_proxy_force_ranges)
        pulumi.set(__self__, "edge_cache_settings", edge_cache_settings)
        pulumi.set(__self__, "enable_ip_url_signing", enable_ip_url_signing)
        pulumi.set(__self__, "fetched_compressed", fetched_compressed)
        pulumi.set(__self__, "forward_host_header", forward_host_header)
        pulumi.set(__self__, "gzip_on", gzip_on)
        pulumi.set(__self__, "ignore_cookie", ignore_cookie)
        pulumi.set(__self__, "ignore_query_params", ignore_query_params)
        pulumi.set(__self__, "ip_address_acl", ip_address_acl)
        pulumi.set(__self__, "proxy_cache_methods_set", proxy_cache_methods_set)
        pulumi.set(__self__, "query_params_blacklists", query_params_blacklists)
        pulumi.set(__self__, "query_params_whitelists", query_params_whitelists)
        pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        pulumi.set(__self__, "redirect_https_to_http", redirect_https_to_http)
        pulumi.set(__self__, "secure_key", secure_key)
        pulumi.set(__self__, "slice", slice)
        pulumi.set(__self__, "static_request_headers", static_request_headers)
        pulumi.set(__self__, "static_response_headers", static_response_headers)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Sequence[str]:
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Sequence[str]):
        pulumi.set(self, "allowed_http_methods", value)

    @property
    @pulumi.getter(name="browserCacheSettings")
    def browser_cache_settings(self) -> int:
        """
        set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        return pulumi.get(self, "browser_cache_settings")

    @browser_cache_settings.setter
    def browser_cache_settings(self, value: int):
        pulumi.set(self, "browser_cache_settings", value)

    @property
    @pulumi.getter(name="cacheHttpHeaders")
    def cache_http_headers(self) -> Sequence[str]:
        """
        list HTTP headers that must be included in responses to clients.
        """
        return pulumi.get(self, "cache_http_headers")

    @cache_http_headers.setter
    def cache_http_headers(self, value: Sequence[str]):
        pulumi.set(self, "cache_http_headers", value)

    @property
    @pulumi.getter
    def cors(self) -> Sequence[str]:
        """
        parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Sequence[str]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="customHostHeader")
    def custom_host_header(self) -> str:
        """
        custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        return pulumi.get(self, "custom_host_header")

    @custom_host_header.setter
    def custom_host_header(self, value: str):
        pulumi.set(self, "custom_host_header", value)

    @property
    @pulumi.getter(name="customServerName")
    def custom_server_name(self) -> str:
        """
        wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        """
        return pulumi.get(self, "custom_server_name")

    @custom_server_name.setter
    def custom_server_name(self, value: str):
        pulumi.set(self, "custom_server_name", value)

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> bool:
        """
        setup a cache status.
        """
        return pulumi.get(self, "disable_cache")

    @disable_cache.setter
    def disable_cache(self, value: bool):
        pulumi.set(self, "disable_cache", value)

    @property
    @pulumi.getter(name="disableProxyForceRanges")
    def disable_proxy_force_ranges(self) -> bool:
        """
        disabling proxy force ranges.
        """
        return pulumi.get(self, "disable_proxy_force_ranges")

    @disable_proxy_force_ranges.setter
    def disable_proxy_force_ranges(self, value: bool):
        pulumi.set(self, "disable_proxy_force_ranges", value)

    @property
    @pulumi.getter(name="edgeCacheSettings")
    def edge_cache_settings(self) -> int:
        """
        content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        return pulumi.get(self, "edge_cache_settings")

    @edge_cache_settings.setter
    def edge_cache_settings(self, value: int):
        pulumi.set(self, "edge_cache_settings", value)

    @property
    @pulumi.getter(name="enableIpUrlSigning")
    def enable_ip_url_signing(self) -> bool:
        """
        enable access limiting by IP addresses, option available only with setting secure_key.

        * `ip_address_acl.excepted_values` - the list of specified IP addresses to be allowed or denied depending on acl policy type.

        * `ip_address_acl.policy_type` - the policy type for ip_address_acl option, one of "allow" or "deny" values.
        """
        return pulumi.get(self, "enable_ip_url_signing")

    @enable_ip_url_signing.setter
    def enable_ip_url_signing(self, value: bool):
        pulumi.set(self, "enable_ip_url_signing", value)

    @property
    @pulumi.getter(name="fetchedCompressed")
    def fetched_compressed(self) -> bool:
        """
        option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        return pulumi.get(self, "fetched_compressed")

    @fetched_compressed.setter
    def fetched_compressed(self, value: bool):
        pulumi.set(self, "fetched_compressed", value)

    @property
    @pulumi.getter(name="forwardHostHeader")
    def forward_host_header(self) -> bool:
        """
        choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        return pulumi.get(self, "forward_host_header")

    @forward_host_header.setter
    def forward_host_header(self, value: bool):
        pulumi.set(self, "forward_host_header", value)

    @property
    @pulumi.getter(name="gzipOn")
    def gzip_on(self) -> bool:
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        return pulumi.get(self, "gzip_on")

    @gzip_on.setter
    def gzip_on(self, value: bool):
        pulumi.set(self, "gzip_on", value)

    @property
    @pulumi.getter(name="ignoreCookie")
    def ignore_cookie(self) -> bool:
        """
        set for ignoring cookie.
        """
        return pulumi.get(self, "ignore_cookie")

    @ignore_cookie.setter
    def ignore_cookie(self, value: bool):
        pulumi.set(self, "ignore_cookie", value)

    @property
    @pulumi.getter(name="ignoreQueryParams")
    def ignore_query_params(self) -> bool:
        """
        files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        return pulumi.get(self, "ignore_query_params")

    @ignore_query_params.setter
    def ignore_query_params(self, value: bool):
        pulumi.set(self, "ignore_query_params", value)

    @property
    @pulumi.getter(name="ipAddressAcl")
    def ip_address_acl(self) -> 'GetCdnResourceOptionsIpAddressAclArgs':
        return pulumi.get(self, "ip_address_acl")

    @ip_address_acl.setter
    def ip_address_acl(self, value: 'GetCdnResourceOptionsIpAddressAclArgs'):
        pulumi.set(self, "ip_address_acl", value)

    @property
    @pulumi.getter(name="proxyCacheMethodsSet")
    def proxy_cache_methods_set(self) -> bool:
        """
        allows caching for GET, HEAD and POST requests.
        """
        return pulumi.get(self, "proxy_cache_methods_set")

    @proxy_cache_methods_set.setter
    def proxy_cache_methods_set(self, value: bool):
        pulumi.set(self, "proxy_cache_methods_set", value)

    @property
    @pulumi.getter(name="queryParamsBlacklists")
    def query_params_blacklists(self) -> Sequence[str]:
        """
        files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        return pulumi.get(self, "query_params_blacklists")

    @query_params_blacklists.setter
    def query_params_blacklists(self, value: Sequence[str]):
        pulumi.set(self, "query_params_blacklists", value)

    @property
    @pulumi.getter(name="queryParamsWhitelists")
    def query_params_whitelists(self) -> Sequence[str]:
        """
        files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        return pulumi.get(self, "query_params_whitelists")

    @query_params_whitelists.setter
    def query_params_whitelists(self, value: Sequence[str]):
        pulumi.set(self, "query_params_whitelists", value)

    @property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> bool:
        """
        set up a redirect from HTTPS to HTTP.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @redirect_http_to_https.setter
    def redirect_http_to_https(self, value: bool):
        pulumi.set(self, "redirect_http_to_https", value)

    @property
    @pulumi.getter(name="redirectHttpsToHttp")
    def redirect_https_to_http(self) -> bool:
        """
        set up a redirect from HTTP to HTTPS.
        """
        return pulumi.get(self, "redirect_https_to_http")

    @redirect_https_to_http.setter
    def redirect_https_to_http(self, value: bool):
        pulumi.set(self, "redirect_https_to_http", value)

    @property
    @pulumi.getter(name="secureKey")
    def secure_key(self) -> str:
        """
        set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        """
        return pulumi.get(self, "secure_key")

    @secure_key.setter
    def secure_key(self, value: str):
        pulumi.set(self, "secure_key", value)

    @property
    @pulumi.getter
    def slice(self) -> bool:
        """
        files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        return pulumi.get(self, "slice")

    @slice.setter
    def slice(self, value: bool):
        pulumi.set(self, "slice", value)

    @property
    @pulumi.getter(name="staticRequestHeaders")
    def static_request_headers(self) -> Mapping[str, str]:
        """
        set up custom headers that CDN servers send in requests to origins.
        """
        return pulumi.get(self, "static_request_headers")

    @static_request_headers.setter
    def static_request_headers(self, value: Mapping[str, str]):
        pulumi.set(self, "static_request_headers", value)

    @property
    @pulumi.getter(name="staticResponseHeaders")
    def static_response_headers(self) -> Mapping[str, str]:
        return pulumi.get(self, "static_response_headers")

    @static_response_headers.setter
    def static_response_headers(self, value: Mapping[str, str]):
        pulumi.set(self, "static_response_headers", value)


if not MYPY:
    class GetCdnResourceOptionsIpAddressAclArgsDict(TypedDict):
        excepted_values: Sequence[str]
        policy_type: str
elif False:
    GetCdnResourceOptionsIpAddressAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCdnResourceOptionsIpAddressAclArgs:
    def __init__(__self__, *,
                 excepted_values: Sequence[str],
                 policy_type: str):
        pulumi.set(__self__, "excepted_values", excepted_values)
        pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="exceptedValues")
    def excepted_values(self) -> Sequence[str]:
        return pulumi.get(self, "excepted_values")

    @excepted_values.setter
    def excepted_values(self, value: Sequence[str]):
        pulumi.set(self, "excepted_values", value)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: str):
        pulumi.set(self, "policy_type", value)


if not MYPY:
    class GetCdnResourceSslCertificateArgsDict(TypedDict):
        status: str
        type: str
        certificate_manager_id: NotRequired[str]
elif False:
    GetCdnResourceSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCdnResourceSslCertificateArgs:
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 certificate_manager_id: Optional[str] = None):
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if certificate_manager_id is not None:
            pulumi.set(__self__, "certificate_manager_id", certificate_manager_id)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="certificateManagerId")
    def certificate_manager_id(self) -> Optional[str]:
        return pulumi.get(self, "certificate_manager_id")

    @certificate_manager_id.setter
    def certificate_manager_id(self, value: Optional[str]):
        pulumi.set(self, "certificate_manager_id", value)


if not MYPY:
    class GetComputeDiskDiskPlacementPolicyArgsDict(TypedDict):
        disk_placement_group_id: str
elif False:
    GetComputeDiskDiskPlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeDiskDiskPlacementPolicyArgs:
    def __init__(__self__, *,
                 disk_placement_group_id: str):
        pulumi.set(__self__, "disk_placement_group_id", disk_placement_group_id)

    @property
    @pulumi.getter(name="diskPlacementGroupId")
    def disk_placement_group_id(self) -> str:
        return pulumi.get(self, "disk_placement_group_id")

    @disk_placement_group_id.setter
    def disk_placement_group_id(self, value: str):
        pulumi.set(self, "disk_placement_group_id", value)


if not MYPY:
    class GetComputeInstanceFilesystemArgsDict(TypedDict):
        device_name: str
        """
        Name of the device.
        """
        filesystem_id: str
        mode: str
        """
        Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
elif False:
    GetComputeInstanceFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeInstanceFilesystemArgs:
    def __init__(__self__, *,
                 device_name: str,
                 filesystem_id: str,
                 mode: str):
        """
        :param str device_name: Name of the device.
        :param str mode: Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the device.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: str):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> str:
        return pulumi.get(self, "filesystem_id")

    @filesystem_id.setter
    def filesystem_id(self, value: str):
        pulumi.set(self, "filesystem_id", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: str):
        pulumi.set(self, "mode", value)


if not MYPY:
    class GetComputeInstanceLocalDiskArgsDict(TypedDict):
        device_name: str
        """
        Name of the device.
        """
        size_bytes: int
        """
        Size of the disk, specified in bytes.
        """
elif False:
    GetComputeInstanceLocalDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeInstanceLocalDiskArgs:
    def __init__(__self__, *,
                 device_name: str,
                 size_bytes: int):
        """
        :param str device_name: Name of the device.
        :param int size_bytes: Size of the disk, specified in bytes.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "size_bytes", size_bytes)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Name of the device.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: str):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> int:
        """
        Size of the disk, specified in bytes.
        """
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: int):
        pulumi.set(self, "size_bytes", value)


if not MYPY:
    class GetComputeInstanceMetadataOptionsArgsDict(TypedDict):
        aws_v1_http_endpoint: int
        aws_v1_http_token: int
        gce_http_endpoint: int
        gce_http_token: int
elif False:
    GetComputeInstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 aws_v1_http_endpoint: int,
                 aws_v1_http_token: int,
                 gce_http_endpoint: int,
                 gce_http_token: int):
        pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        pulumi.set(__self__, "gce_http_token", gce_http_token)

    @property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> int:
        return pulumi.get(self, "aws_v1_http_endpoint")

    @aws_v1_http_endpoint.setter
    def aws_v1_http_endpoint(self, value: int):
        pulumi.set(self, "aws_v1_http_endpoint", value)

    @property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> int:
        return pulumi.get(self, "aws_v1_http_token")

    @aws_v1_http_token.setter
    def aws_v1_http_token(self, value: int):
        pulumi.set(self, "aws_v1_http_token", value)

    @property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> int:
        return pulumi.get(self, "gce_http_endpoint")

    @gce_http_endpoint.setter
    def gce_http_endpoint(self, value: int):
        pulumi.set(self, "gce_http_endpoint", value)

    @property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> int:
        return pulumi.get(self, "gce_http_token")

    @gce_http_token.setter
    def gce_http_token(self, value: int):
        pulumi.set(self, "gce_http_token", value)


if not MYPY:
    class GetComputeInstancePlacementPolicyArgsDict(TypedDict):
        host_affinity_rules: Sequence['GetComputeInstancePlacementPolicyHostAffinityRuleArgsDict']
        """
        List of host affinity rules. The structure is documented below.
        """
        placement_group_id: NotRequired[str]
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        placement_group_partition: NotRequired[int]
        """
        Specifies the number of partition in the Placement Group with the partition placement strategy.
        """
elif False:
    GetComputeInstancePlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeInstancePlacementPolicyArgs:
    def __init__(__self__, *,
                 host_affinity_rules: Sequence['GetComputeInstancePlacementPolicyHostAffinityRuleArgs'],
                 placement_group_id: Optional[str] = None,
                 placement_group_partition: Optional[int] = None):
        """
        :param Sequence['GetComputeInstancePlacementPolicyHostAffinityRuleArgs'] host_affinity_rules: List of host affinity rules. The structure is documented below.
        :param str placement_group_id: Specifies the id of the Placement Group to assign to the instance.
        :param int placement_group_partition: Specifies the number of partition in the Placement Group with the partition placement strategy.
        """
        pulumi.set(__self__, "host_affinity_rules", host_affinity_rules)
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="hostAffinityRules")
    def host_affinity_rules(self) -> Sequence['GetComputeInstancePlacementPolicyHostAffinityRuleArgs']:
        """
        List of host affinity rules. The structure is documented below.
        """
        return pulumi.get(self, "host_affinity_rules")

    @host_affinity_rules.setter
    def host_affinity_rules(self, value: Sequence['GetComputeInstancePlacementPolicyHostAffinityRuleArgs']):
        pulumi.set(self, "host_affinity_rules", value)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[str]:
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: Optional[str]):
        pulumi.set(self, "placement_group_id", value)

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[int]:
        """
        Specifies the number of partition in the Placement Group with the partition placement strategy.
        """
        return pulumi.get(self, "placement_group_partition")

    @placement_group_partition.setter
    def placement_group_partition(self, value: Optional[int]):
        pulumi.set(self, "placement_group_partition", value)


if not MYPY:
    class GetComputeInstancePlacementPolicyHostAffinityRuleArgsDict(TypedDict):
        key: str
        """
        Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        """
        op: str
        """
        Affinity action. The only value supported is `IN`.
        """
        values: Sequence[str]
        """
        List of values (host IDs or host group IDs).
        """
elif False:
    GetComputeInstancePlacementPolicyHostAffinityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeInstancePlacementPolicyHostAffinityRuleArgs:
    def __init__(__self__, *,
                 key: str,
                 op: str,
                 values: Sequence[str]):
        """
        :param str key: Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        :param str op: Affinity action. The only value supported is `IN`.
        :param Sequence[str] values: List of values (host IDs or host group IDs).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        Affinity action. The only value supported is `IN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of values (host IDs or host group IDs).
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetComputeSnapshotScheduleSchedulePolicyArgsDict(TypedDict):
        expression: str
        start_at: str
elif False:
    GetComputeSnapshotScheduleSchedulePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeSnapshotScheduleSchedulePolicyArgs:
    def __init__(__self__, *,
                 expression: str,
                 start_at: str):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "start_at", start_at)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: str):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="startAt")
    def start_at(self) -> str:
        return pulumi.get(self, "start_at")

    @start_at.setter
    def start_at(self, value: str):
        pulumi.set(self, "start_at", value)


if not MYPY:
    class GetComputeSnapshotScheduleSnapshotSpecArgsDict(TypedDict):
        description: str
        """
        An optional description of this snapshot schedule.
        """
        labels: Mapping[str, str]
        """
        A map of labels applied to this snapshot schedule.
        """
elif False:
    GetComputeSnapshotScheduleSnapshotSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetComputeSnapshotScheduleSnapshotSpecArgs:
    def __init__(__self__, *,
                 description: str,
                 labels: Mapping[str, str]):
        """
        :param str description: An optional description of this snapshot schedule.
        :param Mapping[str, str] labels: A map of labels applied to this snapshot schedule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        An optional description of this snapshot schedule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        A map of labels applied to this snapshot schedule.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Mapping[str, str]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class GetFunctionConnectivityArgsDict(TypedDict):
        network_id: str
        """
        Network the version will have access to. It's essential to specify network with subnets in all availability zones
        """
elif False:
    GetFunctionConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionConnectivityArgs:
    def __init__(__self__, *,
                 network_id: str):
        """
        :param str network_id: Network the version will have access to. It's essential to specify network with subnets in all availability zones
        """
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        Network the version will have access to. It's essential to specify network with subnets in all availability zones
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: str):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class GetFunctionMountArgsDict(TypedDict):
        mode: str
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`
        """
        name: str
        """
        Yandex Cloud Function name used to define function
        """
        ephemeral_disk: NotRequired['GetFunctionMountEphemeralDiskArgsDict']
        """
        One of the available mount types. Disk available during the function execution time
        """
        object_storage: NotRequired['GetFunctionMountObjectStorageArgsDict']
        """
        One of the available mount types. Object storage as a mount
        """
elif False:
    GetFunctionMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionMountArgs:
    def __init__(__self__, *,
                 mode: str,
                 name: str,
                 ephemeral_disk: Optional['GetFunctionMountEphemeralDiskArgs'] = None,
                 object_storage: Optional['GetFunctionMountObjectStorageArgs'] = None):
        """
        :param str mode: Mounts accessibility mode. Valid values are `ro` and `rw`
        :param str name: Yandex Cloud Function name used to define function
        :param 'GetFunctionMountEphemeralDiskArgs' ephemeral_disk: One of the available mount types. Disk available during the function execution time
        :param 'GetFunctionMountObjectStorageArgs' object_storage: One of the available mount types. Object storage as a mount
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: str):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Yandex Cloud Function name used to define function
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional['GetFunctionMountEphemeralDiskArgs']:
        """
        One of the available mount types. Disk available during the function execution time
        """
        return pulumi.get(self, "ephemeral_disk")

    @ephemeral_disk.setter
    def ephemeral_disk(self, value: Optional['GetFunctionMountEphemeralDiskArgs']):
        pulumi.set(self, "ephemeral_disk", value)

    @property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional['GetFunctionMountObjectStorageArgs']:
        """
        One of the available mount types. Object storage as a mount
        """
        return pulumi.get(self, "object_storage")

    @object_storage.setter
    def object_storage(self, value: Optional['GetFunctionMountObjectStorageArgs']):
        pulumi.set(self, "object_storage", value)


if not MYPY:
    class GetFunctionMountEphemeralDiskArgsDict(TypedDict):
        block_size_kb: int
        """
        Optional block size of the ephemeral disk in KB
        """
        size_gb: int
        """
        Size of the ephemeral disk in GB
        """
elif False:
    GetFunctionMountEphemeralDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionMountEphemeralDiskArgs:
    def __init__(__self__, *,
                 block_size_kb: int,
                 size_gb: int):
        """
        :param int block_size_kb: Optional block size of the ephemeral disk in KB
        :param int size_gb: Size of the ephemeral disk in GB
        """
        pulumi.set(__self__, "block_size_kb", block_size_kb)
        pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> int:
        """
        Optional block size of the ephemeral disk in KB
        """
        return pulumi.get(self, "block_size_kb")

    @block_size_kb.setter
    def block_size_kb(self, value: int):
        pulumi.set(self, "block_size_kb", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        Size of the ephemeral disk in GB
        """
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: int):
        pulumi.set(self, "size_gb", value)


if not MYPY:
    class GetFunctionMountObjectStorageArgsDict(TypedDict):
        bucket: str
        """
        Name of the mounting bucket
        """
        prefix: NotRequired[str]
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
elif False:
    GetFunctionMountObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionMountObjectStorageArgs:
    def __init__(__self__, *,
                 bucket: str,
                 prefix: Optional[str] = None):
        """
        :param str bucket: Name of the mounting bucket
        :param str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the mounting bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: str):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class GetFunctionScalingPolicyPolicyArgsDict(TypedDict):
        tag: str
        zone_instances_limit: NotRequired[int]
        zone_requests_limit: NotRequired[int]
elif False:
    GetFunctionScalingPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionScalingPolicyPolicyArgs:
    def __init__(__self__, *,
                 tag: str,
                 zone_instances_limit: Optional[int] = None,
                 zone_requests_limit: Optional[int] = None):
        pulumi.set(__self__, "tag", tag)
        if zone_instances_limit is not None:
            pulumi.set(__self__, "zone_instances_limit", zone_instances_limit)
        if zone_requests_limit is not None:
            pulumi.set(__self__, "zone_requests_limit", zone_requests_limit)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: str):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter(name="zoneInstancesLimit")
    def zone_instances_limit(self) -> Optional[int]:
        return pulumi.get(self, "zone_instances_limit")

    @zone_instances_limit.setter
    def zone_instances_limit(self, value: Optional[int]):
        pulumi.set(self, "zone_instances_limit", value)

    @property
    @pulumi.getter(name="zoneRequestsLimit")
    def zone_requests_limit(self) -> Optional[int]:
        return pulumi.get(self, "zone_requests_limit")

    @zone_requests_limit.setter
    def zone_requests_limit(self, value: Optional[int]):
        pulumi.set(self, "zone_requests_limit", value)


if not MYPY:
    class GetFunctionSecretArgsDict(TypedDict):
        environment_variable: str
        id: str
        key: str
        version_id: str
elif False:
    GetFunctionSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionSecretArgs:
    def __init__(__self__, *,
                 environment_variable: str,
                 id: str,
                 key: str,
                 version_id: str):
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> str:
        return pulumi.get(self, "environment_variable")

    @environment_variable.setter
    def environment_variable(self, value: str):
        pulumi.set(self, "environment_variable", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: str):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class GetFunctionStorageMountArgsDict(TypedDict):
        bucket: str
        """
        Name of the mounting bucket
        """
        mount_point_name: str
        """
        (Required) Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path
        """
        prefix: NotRequired[str]
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        read_only: NotRequired[bool]
        """
        Mount the bucket in read-only mode
        """
elif False:
    GetFunctionStorageMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionStorageMountArgs:
    def __init__(__self__, *,
                 bucket: str,
                 mount_point_name: str,
                 prefix: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str bucket: Name of the mounting bucket
        :param str mount_point_name: (Required) Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path
        :param str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        :param bool read_only: Mount the bucket in read-only mode
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_name", mount_point_name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the mounting bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: str):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="mountPointName")
    def mount_point_name(self) -> str:
        """
        (Required) Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path
        """
        return pulumi.get(self, "mount_point_name")

    @mount_point_name.setter
    def mount_point_name(self, value: str):
        pulumi.set(self, "mount_point_name", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mount the bucket in read-only mode
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[bool]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class GetIamPolicyBindingArgsDict(TypedDict):
        members: Sequence[str]
        """
        An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:
        * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.
        * **serviceAccount:{service_account_id}**: A unique service account ID.
        * **federatedUser:{federated_user_id}:**: A unique saml federation user account ID.
        * **group:{group_id}**: A unique group ID.
        * **system:group:federation:{federation_id}:users**: All users in federation.
        * **system:group:organization:{organization_id}:users**: All users in organization.
        * **system:allAuthenticatedUsers**: All authenticated users.
        * **system:allUsers**: All users, including unauthenticated ones.

        Note: for more information about system groups, see the [documentation](https://cloud.yandex.com/docs/iam/concepts/access-control/system-group).
        """
        role: str
        """
        The role/permission that will be granted to the members. See the [IAM Roles](https://cloud.yandex.com/docs/iam/concepts/access-control/roles) documentation for a complete list of roles.
        """
elif False:
    GetIamPolicyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamPolicyBindingArgs:
    def __init__(__self__, *,
                 members: Sequence[str],
                 role: str):
        """
        :param Sequence[str] members: An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:
               * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.
               * **serviceAccount:{service_account_id}**: A unique service account ID.
               * **federatedUser:{federated_user_id}:**: A unique saml federation user account ID.
               * **group:{group_id}**: A unique group ID.
               * **system:group:federation:{federation_id}:users**: All users in federation.
               * **system:group:organization:{organization_id}:users**: All users in organization.
               * **system:allAuthenticatedUsers**: All authenticated users.
               * **system:allUsers**: All users, including unauthenticated ones.
               
               Note: for more information about system groups, see the [documentation](https://cloud.yandex.com/docs/iam/concepts/access-control/system-group).
        :param str role: The role/permission that will be granted to the members. See the [IAM Roles](https://cloud.yandex.com/docs/iam/concepts/access-control/roles) documentation for a complete list of roles.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:
        * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.
        * **serviceAccount:{service_account_id}**: A unique service account ID.
        * **federatedUser:{federated_user_id}:**: A unique saml federation user account ID.
        * **group:{group_id}**: A unique group ID.
        * **system:group:federation:{federation_id}:users**: All users in federation.
        * **system:group:organization:{organization_id}:users**: All users in organization.
        * **system:allAuthenticatedUsers**: All authenticated users.
        * **system:allUsers**: All users, including unauthenticated ones.

        Note: for more information about system groups, see the [documentation](https://cloud.yandex.com/docs/iam/concepts/access-control/system-group).
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Sequence[str]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role/permission that will be granted to the members. See the [IAM Roles](https://cloud.yandex.com/docs/iam/concepts/access-control/roles) documentation for a complete list of roles.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: str):
        pulumi.set(self, "role", value)


if not MYPY:
    class GetLoadtestingAgentLogSettingsArgsDict(TypedDict):
        log_group_id: NotRequired[str]
        """
        The ID of cloud logging group to which the load testing agent sends logs.
        """
elif False:
    GetLoadtestingAgentLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadtestingAgentLogSettingsArgs:
    def __init__(__self__, *,
                 log_group_id: Optional[str] = None):
        """
        :param str log_group_id: The ID of cloud logging group to which the load testing agent sends logs.
        """
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[str]:
        """
        The ID of cloud logging group to which the load testing agent sends logs.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[str]):
        pulumi.set(self, "log_group_id", value)


if not MYPY:
    class GetMdbClickhouseClusterAccessArgsDict(TypedDict):
        data_lens: NotRequired[bool]
        """
        Allow access for Web SQL.
        """
        data_transfer: NotRequired[bool]
        """
        Allow access for DataTransfer
        """
        metrika: NotRequired[bool]
        """
        Allow access for Yandex.Metrika.
        """
        serverless: NotRequired[bool]
        """
        Allow access for Serverless.
        """
        web_sql: NotRequired[bool]
        """
        Allow access for DataLens.
        """
        yandex_query: NotRequired[bool]
        """
        Allow access for YandexQuery
        """
elif False:
    GetMdbClickhouseClusterAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[bool] = None,
                 data_transfer: Optional[bool] = None,
                 metrika: Optional[bool] = None,
                 serverless: Optional[bool] = None,
                 web_sql: Optional[bool] = None,
                 yandex_query: Optional[bool] = None):
        """
        :param bool data_lens: Allow access for Web SQL.
        :param bool data_transfer: Allow access for DataTransfer
        :param bool metrika: Allow access for Yandex.Metrika.
        :param bool serverless: Allow access for Serverless.
        :param bool web_sql: Allow access for DataLens.
        :param bool yandex_query: Allow access for YandexQuery
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if metrika is not None:
            pulumi.set(__self__, "metrika", metrika)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)
        if yandex_query is not None:
            pulumi.set(__self__, "yandex_query", yandex_query)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[bool]:
        """
        Allow access for Web SQL.
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[bool]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[bool]:
        """
        Allow access for DataTransfer
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[bool]):
        pulumi.set(self, "data_transfer", value)

    @property
    @pulumi.getter
    def metrika(self) -> Optional[bool]:
        """
        Allow access for Yandex.Metrika.
        """
        return pulumi.get(self, "metrika")

    @metrika.setter
    def metrika(self, value: Optional[bool]):
        pulumi.set(self, "metrika", value)

    @property
    @pulumi.getter
    def serverless(self) -> Optional[bool]:
        """
        Allow access for Serverless.
        """
        return pulumi.get(self, "serverless")

    @serverless.setter
    def serverless(self, value: Optional[bool]):
        pulumi.set(self, "serverless", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[bool]:
        """
        Allow access for DataLens.
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: Optional[bool]):
        pulumi.set(self, "web_sql", value)

    @property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> Optional[bool]:
        """
        Allow access for YandexQuery
        """
        return pulumi.get(self, "yandex_query")

    @yandex_query.setter
    def yandex_query(self, value: Optional[bool]):
        pulumi.set(self, "yandex_query", value)


if not MYPY:
    class GetMdbClickhouseClusterBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[int]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[int]
        """
        The minute at which backup will be started.
        """
elif False:
    GetMdbClickhouseClusterBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[int]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseArgsDict(TypedDict):
        config: 'GetMdbClickhouseClusterClickhouseConfigArgsDict'
        """
        Main ClickHouse cluster configuration. The structure is documented below.
        """
        resources: 'GetMdbClickhouseClusterClickhouseResourcesArgsDict'
        """
        Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
elif False:
    GetMdbClickhouseClusterClickhouseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseArgs:
    def __init__(__self__, *,
                 config: 'GetMdbClickhouseClusterClickhouseConfigArgs',
                 resources: 'GetMdbClickhouseClusterClickhouseResourcesArgs'):
        """
        :param 'GetMdbClickhouseClusterClickhouseConfigArgs' config: Main ClickHouse cluster configuration. The structure is documented below.
        :param 'GetMdbClickhouseClusterClickhouseResourcesArgs' resources: Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def config(self) -> 'GetMdbClickhouseClusterClickhouseConfigArgs':
        """
        Main ClickHouse cluster configuration. The structure is documented below.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: 'GetMdbClickhouseClusterClickhouseConfigArgs'):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def resources(self) -> 'GetMdbClickhouseClusterClickhouseResourcesArgs':
        """
        Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: 'GetMdbClickhouseClusterClickhouseResourcesArgs'):
        pulumi.set(self, "resources", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigArgsDict(TypedDict):
        asynchronous_insert_log_enabled: bool
        asynchronous_insert_log_retention_size: int
        asynchronous_insert_log_retention_time: int
        asynchronous_metric_log_enabled: bool
        asynchronous_metric_log_retention_size: int
        asynchronous_metric_log_retention_time: int
        background_buffer_flush_schedule_pool_size: int
        background_common_pool_size: int
        background_distributed_schedule_pool_size: int
        background_fetches_pool_size: int
        background_merges_mutations_concurrency_ratio: int
        background_message_broker_schedule_pool_size: int
        background_move_pool_size: int
        background_pool_size: int
        background_schedule_pool_size: int
        default_database: str
        dictionaries_lazy_load: bool
        geobase_enabled: bool
        geobase_uri: str
        kafka: 'GetMdbClickhouseClusterClickhouseConfigKafkaArgsDict'
        """
        Kafka connection configuration. The structure is documented below.
        """
        keep_alive_timeout: int
        log_level: str
        """
        , `max_connections`, `max_concurrent_queries`, `keep_alive_timeout`, `uncompressed_cache_size`, `mark_cache_size`, `max_table_size_to_drop`, `max_partition_size_to_drop`, `timezone`, `geobase_uri`, `query_log_retention_size`, `query_log_retention_time`, `query_thread_log_enabled`, `query_thread_log_retention_size`, `query_thread_log_retention_time`, `part_log_retention_size`, `part_log_retention_time`, `metric_log_enabled`, `metric_log_retention_size`, `metric_log_retention_time`, `trace_log_enabled`, `trace_log_retention_size`, `trace_log_retention_time`, `text_log_enabled`, `text_log_retention_size`, `text_log_retention_time`, `text_log_level`, `background_pool_size`, `background_schedule_pool_size`, `background_fetches_pool_size`, `background_message_broker_schedule_pool_size`, `background_buffer_flush_schedule_pool_size`, `background_move_pool_size`, `background_distributed_schedule_pool_size`, `background_common_pool_size`, `background_merges_mutations_concurrency_ratio`, `default_database`, `total_memory_profiler_step`, `dictionaries_lazy_load`, `opentelemetry_span_log_enabled`, `opentelemetry_span_log_retention_size`, `opentelemetry_span_log_retention_time`, `query_views_log_enabled`, `query_views_log_retention_size`, `query_views_log_retention_time`, `asynchronous_metric_log_enabled`, `asynchronous_metric_log_retention_size`, `asynchronous_metric_log_retention_time`, `session_log_enabled`, `session_log_retention_size`, `session_log_retention_time`, `zookeeper_log_enabled`, `zookeeper_log_retention_size`, `zookeeper_log_retention_time`, `asynchronous_insert_log_enabled`, `asynchronous_insert_log_retention_size`, `asynchronous_insert_log_retention_time` - ClickHouse server parameters. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/settings-list).
        """
        mark_cache_size: int
        max_concurrent_queries: int
        max_connections: int
        max_partition_size_to_drop: int
        max_table_size_to_drop: int
        merge_tree: 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgsDict'
        """
        MergeTree engine configuration. The structure is documented below.
        """
        metric_log_enabled: bool
        metric_log_retention_size: int
        metric_log_retention_time: int
        opentelemetry_span_log_enabled: bool
        opentelemetry_span_log_retention_size: int
        opentelemetry_span_log_retention_time: int
        part_log_retention_size: int
        part_log_retention_time: int
        query_cache: 'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgsDict'
        """
        Query cache configuration. The structure is documented below.
        """
        query_log_retention_size: int
        query_log_retention_time: int
        query_thread_log_enabled: bool
        query_thread_log_retention_size: int
        query_thread_log_retention_time: int
        query_views_log_enabled: bool
        query_views_log_retention_size: int
        query_views_log_retention_time: int
        rabbitmq: 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgsDict'
        """
        RabbitMQ connection configuration. The structure is documented below.
        """
        session_log_enabled: bool
        session_log_retention_size: int
        session_log_retention_time: int
        text_log_enabled: bool
        text_log_level: str
        text_log_retention_size: int
        text_log_retention_time: int
        timezone: str
        total_memory_profiler_step: int
        trace_log_enabled: bool
        trace_log_retention_size: int
        trace_log_retention_time: int
        uncompressed_cache_size: int
        zookeeper_log_enabled: bool
        zookeeper_log_retention_size: int
        zookeeper_log_retention_time: int
        compressions: NotRequired[Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgsDict']]
        """
        Data compression configuration. The structure is documented below.
        """
        graphite_rollups: NotRequired[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict']]
        """
        Graphite rollup configuration. The structure is documented below.
        """
        kafka_topics: NotRequired[Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict']]
        """
        Kafka topic connection configuration. The structure is documented below.
        """
        query_masking_rules: NotRequired[Sequence['GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict']]
        """
        Query masking rules configuration. The structure is documented below.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigArgs:
    def __init__(__self__, *,
                 asynchronous_insert_log_enabled: bool,
                 asynchronous_insert_log_retention_size: int,
                 asynchronous_insert_log_retention_time: int,
                 asynchronous_metric_log_enabled: bool,
                 asynchronous_metric_log_retention_size: int,
                 asynchronous_metric_log_retention_time: int,
                 background_buffer_flush_schedule_pool_size: int,
                 background_common_pool_size: int,
                 background_distributed_schedule_pool_size: int,
                 background_fetches_pool_size: int,
                 background_merges_mutations_concurrency_ratio: int,
                 background_message_broker_schedule_pool_size: int,
                 background_move_pool_size: int,
                 background_pool_size: int,
                 background_schedule_pool_size: int,
                 default_database: str,
                 dictionaries_lazy_load: bool,
                 geobase_enabled: bool,
                 geobase_uri: str,
                 kafka: 'GetMdbClickhouseClusterClickhouseConfigKafkaArgs',
                 keep_alive_timeout: int,
                 log_level: str,
                 mark_cache_size: int,
                 max_concurrent_queries: int,
                 max_connections: int,
                 max_partition_size_to_drop: int,
                 max_table_size_to_drop: int,
                 merge_tree: 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs',
                 metric_log_enabled: bool,
                 metric_log_retention_size: int,
                 metric_log_retention_time: int,
                 opentelemetry_span_log_enabled: bool,
                 opentelemetry_span_log_retention_size: int,
                 opentelemetry_span_log_retention_time: int,
                 part_log_retention_size: int,
                 part_log_retention_time: int,
                 query_cache: 'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs',
                 query_log_retention_size: int,
                 query_log_retention_time: int,
                 query_thread_log_enabled: bool,
                 query_thread_log_retention_size: int,
                 query_thread_log_retention_time: int,
                 query_views_log_enabled: bool,
                 query_views_log_retention_size: int,
                 query_views_log_retention_time: int,
                 rabbitmq: 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs',
                 session_log_enabled: bool,
                 session_log_retention_size: int,
                 session_log_retention_time: int,
                 text_log_enabled: bool,
                 text_log_level: str,
                 text_log_retention_size: int,
                 text_log_retention_time: int,
                 timezone: str,
                 total_memory_profiler_step: int,
                 trace_log_enabled: bool,
                 trace_log_retention_size: int,
                 trace_log_retention_time: int,
                 uncompressed_cache_size: int,
                 zookeeper_log_enabled: bool,
                 zookeeper_log_retention_size: int,
                 zookeeper_log_retention_time: int,
                 compressions: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgs']] = None,
                 graphite_rollups: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']] = None,
                 kafka_topics: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs']] = None,
                 query_masking_rules: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']] = None):
        """
        :param 'GetMdbClickhouseClusterClickhouseConfigKafkaArgs' kafka: Kafka connection configuration. The structure is documented below.
        :param str log_level: , `max_connections`, `max_concurrent_queries`, `keep_alive_timeout`, `uncompressed_cache_size`, `mark_cache_size`, `max_table_size_to_drop`, `max_partition_size_to_drop`, `timezone`, `geobase_uri`, `query_log_retention_size`, `query_log_retention_time`, `query_thread_log_enabled`, `query_thread_log_retention_size`, `query_thread_log_retention_time`, `part_log_retention_size`, `part_log_retention_time`, `metric_log_enabled`, `metric_log_retention_size`, `metric_log_retention_time`, `trace_log_enabled`, `trace_log_retention_size`, `trace_log_retention_time`, `text_log_enabled`, `text_log_retention_size`, `text_log_retention_time`, `text_log_level`, `background_pool_size`, `background_schedule_pool_size`, `background_fetches_pool_size`, `background_message_broker_schedule_pool_size`, `background_buffer_flush_schedule_pool_size`, `background_move_pool_size`, `background_distributed_schedule_pool_size`, `background_common_pool_size`, `background_merges_mutations_concurrency_ratio`, `default_database`, `total_memory_profiler_step`, `dictionaries_lazy_load`, `opentelemetry_span_log_enabled`, `opentelemetry_span_log_retention_size`, `opentelemetry_span_log_retention_time`, `query_views_log_enabled`, `query_views_log_retention_size`, `query_views_log_retention_time`, `asynchronous_metric_log_enabled`, `asynchronous_metric_log_retention_size`, `asynchronous_metric_log_retention_time`, `session_log_enabled`, `session_log_retention_size`, `session_log_retention_time`, `zookeeper_log_enabled`, `zookeeper_log_retention_size`, `zookeeper_log_retention_time`, `asynchronous_insert_log_enabled`, `asynchronous_insert_log_retention_size`, `asynchronous_insert_log_retention_time` - ClickHouse server parameters. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/settings-list).
        :param 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs' merge_tree: MergeTree engine configuration. The structure is documented below.
        :param 'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs' query_cache: Query cache configuration. The structure is documented below.
        :param 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs' rabbitmq: RabbitMQ connection configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgs'] compressions: Data compression configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs'] graphite_rollups: Graphite rollup configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs'] kafka_topics: Kafka topic connection configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs'] query_masking_rules: Query masking rules configuration. The structure is documented below.
        """
        pulumi.set(__self__, "asynchronous_insert_log_enabled", asynchronous_insert_log_enabled)
        pulumi.set(__self__, "asynchronous_insert_log_retention_size", asynchronous_insert_log_retention_size)
        pulumi.set(__self__, "asynchronous_insert_log_retention_time", asynchronous_insert_log_retention_time)
        pulumi.set(__self__, "asynchronous_metric_log_enabled", asynchronous_metric_log_enabled)
        pulumi.set(__self__, "asynchronous_metric_log_retention_size", asynchronous_metric_log_retention_size)
        pulumi.set(__self__, "asynchronous_metric_log_retention_time", asynchronous_metric_log_retention_time)
        pulumi.set(__self__, "background_buffer_flush_schedule_pool_size", background_buffer_flush_schedule_pool_size)
        pulumi.set(__self__, "background_common_pool_size", background_common_pool_size)
        pulumi.set(__self__, "background_distributed_schedule_pool_size", background_distributed_schedule_pool_size)
        pulumi.set(__self__, "background_fetches_pool_size", background_fetches_pool_size)
        pulumi.set(__self__, "background_merges_mutations_concurrency_ratio", background_merges_mutations_concurrency_ratio)
        pulumi.set(__self__, "background_message_broker_schedule_pool_size", background_message_broker_schedule_pool_size)
        pulumi.set(__self__, "background_move_pool_size", background_move_pool_size)
        pulumi.set(__self__, "background_pool_size", background_pool_size)
        pulumi.set(__self__, "background_schedule_pool_size", background_schedule_pool_size)
        pulumi.set(__self__, "default_database", default_database)
        pulumi.set(__self__, "dictionaries_lazy_load", dictionaries_lazy_load)
        pulumi.set(__self__, "geobase_enabled", geobase_enabled)
        pulumi.set(__self__, "geobase_uri", geobase_uri)
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "mark_cache_size", mark_cache_size)
        pulumi.set(__self__, "max_concurrent_queries", max_concurrent_queries)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_partition_size_to_drop", max_partition_size_to_drop)
        pulumi.set(__self__, "max_table_size_to_drop", max_table_size_to_drop)
        pulumi.set(__self__, "merge_tree", merge_tree)
        pulumi.set(__self__, "metric_log_enabled", metric_log_enabled)
        pulumi.set(__self__, "metric_log_retention_size", metric_log_retention_size)
        pulumi.set(__self__, "metric_log_retention_time", metric_log_retention_time)
        pulumi.set(__self__, "opentelemetry_span_log_enabled", opentelemetry_span_log_enabled)
        pulumi.set(__self__, "opentelemetry_span_log_retention_size", opentelemetry_span_log_retention_size)
        pulumi.set(__self__, "opentelemetry_span_log_retention_time", opentelemetry_span_log_retention_time)
        pulumi.set(__self__, "part_log_retention_size", part_log_retention_size)
        pulumi.set(__self__, "part_log_retention_time", part_log_retention_time)
        pulumi.set(__self__, "query_cache", query_cache)
        pulumi.set(__self__, "query_log_retention_size", query_log_retention_size)
        pulumi.set(__self__, "query_log_retention_time", query_log_retention_time)
        pulumi.set(__self__, "query_thread_log_enabled", query_thread_log_enabled)
        pulumi.set(__self__, "query_thread_log_retention_size", query_thread_log_retention_size)
        pulumi.set(__self__, "query_thread_log_retention_time", query_thread_log_retention_time)
        pulumi.set(__self__, "query_views_log_enabled", query_views_log_enabled)
        pulumi.set(__self__, "query_views_log_retention_size", query_views_log_retention_size)
        pulumi.set(__self__, "query_views_log_retention_time", query_views_log_retention_time)
        pulumi.set(__self__, "rabbitmq", rabbitmq)
        pulumi.set(__self__, "session_log_enabled", session_log_enabled)
        pulumi.set(__self__, "session_log_retention_size", session_log_retention_size)
        pulumi.set(__self__, "session_log_retention_time", session_log_retention_time)
        pulumi.set(__self__, "text_log_enabled", text_log_enabled)
        pulumi.set(__self__, "text_log_level", text_log_level)
        pulumi.set(__self__, "text_log_retention_size", text_log_retention_size)
        pulumi.set(__self__, "text_log_retention_time", text_log_retention_time)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "total_memory_profiler_step", total_memory_profiler_step)
        pulumi.set(__self__, "trace_log_enabled", trace_log_enabled)
        pulumi.set(__self__, "trace_log_retention_size", trace_log_retention_size)
        pulumi.set(__self__, "trace_log_retention_time", trace_log_retention_time)
        pulumi.set(__self__, "uncompressed_cache_size", uncompressed_cache_size)
        pulumi.set(__self__, "zookeeper_log_enabled", zookeeper_log_enabled)
        pulumi.set(__self__, "zookeeper_log_retention_size", zookeeper_log_retention_size)
        pulumi.set(__self__, "zookeeper_log_retention_time", zookeeper_log_retention_time)
        if compressions is not None:
            pulumi.set(__self__, "compressions", compressions)
        if graphite_rollups is not None:
            pulumi.set(__self__, "graphite_rollups", graphite_rollups)
        if kafka_topics is not None:
            pulumi.set(__self__, "kafka_topics", kafka_topics)
        if query_masking_rules is not None:
            pulumi.set(__self__, "query_masking_rules", query_masking_rules)

    @property
    @pulumi.getter(name="asynchronousInsertLogEnabled")
    def asynchronous_insert_log_enabled(self) -> bool:
        return pulumi.get(self, "asynchronous_insert_log_enabled")

    @asynchronous_insert_log_enabled.setter
    def asynchronous_insert_log_enabled(self, value: bool):
        pulumi.set(self, "asynchronous_insert_log_enabled", value)

    @property
    @pulumi.getter(name="asynchronousInsertLogRetentionSize")
    def asynchronous_insert_log_retention_size(self) -> int:
        return pulumi.get(self, "asynchronous_insert_log_retention_size")

    @asynchronous_insert_log_retention_size.setter
    def asynchronous_insert_log_retention_size(self, value: int):
        pulumi.set(self, "asynchronous_insert_log_retention_size", value)

    @property
    @pulumi.getter(name="asynchronousInsertLogRetentionTime")
    def asynchronous_insert_log_retention_time(self) -> int:
        return pulumi.get(self, "asynchronous_insert_log_retention_time")

    @asynchronous_insert_log_retention_time.setter
    def asynchronous_insert_log_retention_time(self, value: int):
        pulumi.set(self, "asynchronous_insert_log_retention_time", value)

    @property
    @pulumi.getter(name="asynchronousMetricLogEnabled")
    def asynchronous_metric_log_enabled(self) -> bool:
        return pulumi.get(self, "asynchronous_metric_log_enabled")

    @asynchronous_metric_log_enabled.setter
    def asynchronous_metric_log_enabled(self, value: bool):
        pulumi.set(self, "asynchronous_metric_log_enabled", value)

    @property
    @pulumi.getter(name="asynchronousMetricLogRetentionSize")
    def asynchronous_metric_log_retention_size(self) -> int:
        return pulumi.get(self, "asynchronous_metric_log_retention_size")

    @asynchronous_metric_log_retention_size.setter
    def asynchronous_metric_log_retention_size(self, value: int):
        pulumi.set(self, "asynchronous_metric_log_retention_size", value)

    @property
    @pulumi.getter(name="asynchronousMetricLogRetentionTime")
    def asynchronous_metric_log_retention_time(self) -> int:
        return pulumi.get(self, "asynchronous_metric_log_retention_time")

    @asynchronous_metric_log_retention_time.setter
    def asynchronous_metric_log_retention_time(self, value: int):
        pulumi.set(self, "asynchronous_metric_log_retention_time", value)

    @property
    @pulumi.getter(name="backgroundBufferFlushSchedulePoolSize")
    def background_buffer_flush_schedule_pool_size(self) -> int:
        return pulumi.get(self, "background_buffer_flush_schedule_pool_size")

    @background_buffer_flush_schedule_pool_size.setter
    def background_buffer_flush_schedule_pool_size(self, value: int):
        pulumi.set(self, "background_buffer_flush_schedule_pool_size", value)

    @property
    @pulumi.getter(name="backgroundCommonPoolSize")
    def background_common_pool_size(self) -> int:
        return pulumi.get(self, "background_common_pool_size")

    @background_common_pool_size.setter
    def background_common_pool_size(self, value: int):
        pulumi.set(self, "background_common_pool_size", value)

    @property
    @pulumi.getter(name="backgroundDistributedSchedulePoolSize")
    def background_distributed_schedule_pool_size(self) -> int:
        return pulumi.get(self, "background_distributed_schedule_pool_size")

    @background_distributed_schedule_pool_size.setter
    def background_distributed_schedule_pool_size(self, value: int):
        pulumi.set(self, "background_distributed_schedule_pool_size", value)

    @property
    @pulumi.getter(name="backgroundFetchesPoolSize")
    def background_fetches_pool_size(self) -> int:
        return pulumi.get(self, "background_fetches_pool_size")

    @background_fetches_pool_size.setter
    def background_fetches_pool_size(self, value: int):
        pulumi.set(self, "background_fetches_pool_size", value)

    @property
    @pulumi.getter(name="backgroundMergesMutationsConcurrencyRatio")
    def background_merges_mutations_concurrency_ratio(self) -> int:
        return pulumi.get(self, "background_merges_mutations_concurrency_ratio")

    @background_merges_mutations_concurrency_ratio.setter
    def background_merges_mutations_concurrency_ratio(self, value: int):
        pulumi.set(self, "background_merges_mutations_concurrency_ratio", value)

    @property
    @pulumi.getter(name="backgroundMessageBrokerSchedulePoolSize")
    def background_message_broker_schedule_pool_size(self) -> int:
        return pulumi.get(self, "background_message_broker_schedule_pool_size")

    @background_message_broker_schedule_pool_size.setter
    def background_message_broker_schedule_pool_size(self, value: int):
        pulumi.set(self, "background_message_broker_schedule_pool_size", value)

    @property
    @pulumi.getter(name="backgroundMovePoolSize")
    def background_move_pool_size(self) -> int:
        return pulumi.get(self, "background_move_pool_size")

    @background_move_pool_size.setter
    def background_move_pool_size(self, value: int):
        pulumi.set(self, "background_move_pool_size", value)

    @property
    @pulumi.getter(name="backgroundPoolSize")
    def background_pool_size(self) -> int:
        return pulumi.get(self, "background_pool_size")

    @background_pool_size.setter
    def background_pool_size(self, value: int):
        pulumi.set(self, "background_pool_size", value)

    @property
    @pulumi.getter(name="backgroundSchedulePoolSize")
    def background_schedule_pool_size(self) -> int:
        return pulumi.get(self, "background_schedule_pool_size")

    @background_schedule_pool_size.setter
    def background_schedule_pool_size(self, value: int):
        pulumi.set(self, "background_schedule_pool_size", value)

    @property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> str:
        return pulumi.get(self, "default_database")

    @default_database.setter
    def default_database(self, value: str):
        pulumi.set(self, "default_database", value)

    @property
    @pulumi.getter(name="dictionariesLazyLoad")
    def dictionaries_lazy_load(self) -> bool:
        return pulumi.get(self, "dictionaries_lazy_load")

    @dictionaries_lazy_load.setter
    def dictionaries_lazy_load(self, value: bool):
        pulumi.set(self, "dictionaries_lazy_load", value)

    @property
    @pulumi.getter(name="geobaseEnabled")
    def geobase_enabled(self) -> bool:
        return pulumi.get(self, "geobase_enabled")

    @geobase_enabled.setter
    def geobase_enabled(self, value: bool):
        pulumi.set(self, "geobase_enabled", value)

    @property
    @pulumi.getter(name="geobaseUri")
    def geobase_uri(self) -> str:
        return pulumi.get(self, "geobase_uri")

    @geobase_uri.setter
    def geobase_uri(self, value: str):
        pulumi.set(self, "geobase_uri", value)

    @property
    @pulumi.getter
    def kafka(self) -> 'GetMdbClickhouseClusterClickhouseConfigKafkaArgs':
        """
        Kafka connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: 'GetMdbClickhouseClusterClickhouseConfigKafkaArgs'):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> int:
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: int):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> str:
        """
        , `max_connections`, `max_concurrent_queries`, `keep_alive_timeout`, `uncompressed_cache_size`, `mark_cache_size`, `max_table_size_to_drop`, `max_partition_size_to_drop`, `timezone`, `geobase_uri`, `query_log_retention_size`, `query_log_retention_time`, `query_thread_log_enabled`, `query_thread_log_retention_size`, `query_thread_log_retention_time`, `part_log_retention_size`, `part_log_retention_time`, `metric_log_enabled`, `metric_log_retention_size`, `metric_log_retention_time`, `trace_log_enabled`, `trace_log_retention_size`, `trace_log_retention_time`, `text_log_enabled`, `text_log_retention_size`, `text_log_retention_time`, `text_log_level`, `background_pool_size`, `background_schedule_pool_size`, `background_fetches_pool_size`, `background_message_broker_schedule_pool_size`, `background_buffer_flush_schedule_pool_size`, `background_move_pool_size`, `background_distributed_schedule_pool_size`, `background_common_pool_size`, `background_merges_mutations_concurrency_ratio`, `default_database`, `total_memory_profiler_step`, `dictionaries_lazy_load`, `opentelemetry_span_log_enabled`, `opentelemetry_span_log_retention_size`, `opentelemetry_span_log_retention_time`, `query_views_log_enabled`, `query_views_log_retention_size`, `query_views_log_retention_time`, `asynchronous_metric_log_enabled`, `asynchronous_metric_log_retention_size`, `asynchronous_metric_log_retention_time`, `session_log_enabled`, `session_log_retention_size`, `session_log_retention_time`, `zookeeper_log_enabled`, `zookeeper_log_retention_size`, `zookeeper_log_retention_time`, `asynchronous_insert_log_enabled`, `asynchronous_insert_log_retention_size`, `asynchronous_insert_log_retention_time` - ClickHouse server parameters. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/settings-list).
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: str):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="markCacheSize")
    def mark_cache_size(self) -> int:
        return pulumi.get(self, "mark_cache_size")

    @mark_cache_size.setter
    def mark_cache_size(self, value: int):
        pulumi.set(self, "mark_cache_size", value)

    @property
    @pulumi.getter(name="maxConcurrentQueries")
    def max_concurrent_queries(self) -> int:
        return pulumi.get(self, "max_concurrent_queries")

    @max_concurrent_queries.setter
    def max_concurrent_queries(self, value: int):
        pulumi.set(self, "max_concurrent_queries", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: int):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxPartitionSizeToDrop")
    def max_partition_size_to_drop(self) -> int:
        return pulumi.get(self, "max_partition_size_to_drop")

    @max_partition_size_to_drop.setter
    def max_partition_size_to_drop(self, value: int):
        pulumi.set(self, "max_partition_size_to_drop", value)

    @property
    @pulumi.getter(name="maxTableSizeToDrop")
    def max_table_size_to_drop(self) -> int:
        return pulumi.get(self, "max_table_size_to_drop")

    @max_table_size_to_drop.setter
    def max_table_size_to_drop(self, value: int):
        pulumi.set(self, "max_table_size_to_drop", value)

    @property
    @pulumi.getter(name="mergeTree")
    def merge_tree(self) -> 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs':
        """
        MergeTree engine configuration. The structure is documented below.
        """
        return pulumi.get(self, "merge_tree")

    @merge_tree.setter
    def merge_tree(self, value: 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs'):
        pulumi.set(self, "merge_tree", value)

    @property
    @pulumi.getter(name="metricLogEnabled")
    def metric_log_enabled(self) -> bool:
        return pulumi.get(self, "metric_log_enabled")

    @metric_log_enabled.setter
    def metric_log_enabled(self, value: bool):
        pulumi.set(self, "metric_log_enabled", value)

    @property
    @pulumi.getter(name="metricLogRetentionSize")
    def metric_log_retention_size(self) -> int:
        return pulumi.get(self, "metric_log_retention_size")

    @metric_log_retention_size.setter
    def metric_log_retention_size(self, value: int):
        pulumi.set(self, "metric_log_retention_size", value)

    @property
    @pulumi.getter(name="metricLogRetentionTime")
    def metric_log_retention_time(self) -> int:
        return pulumi.get(self, "metric_log_retention_time")

    @metric_log_retention_time.setter
    def metric_log_retention_time(self, value: int):
        pulumi.set(self, "metric_log_retention_time", value)

    @property
    @pulumi.getter(name="opentelemetrySpanLogEnabled")
    def opentelemetry_span_log_enabled(self) -> bool:
        return pulumi.get(self, "opentelemetry_span_log_enabled")

    @opentelemetry_span_log_enabled.setter
    def opentelemetry_span_log_enabled(self, value: bool):
        pulumi.set(self, "opentelemetry_span_log_enabled", value)

    @property
    @pulumi.getter(name="opentelemetrySpanLogRetentionSize")
    def opentelemetry_span_log_retention_size(self) -> int:
        return pulumi.get(self, "opentelemetry_span_log_retention_size")

    @opentelemetry_span_log_retention_size.setter
    def opentelemetry_span_log_retention_size(self, value: int):
        pulumi.set(self, "opentelemetry_span_log_retention_size", value)

    @property
    @pulumi.getter(name="opentelemetrySpanLogRetentionTime")
    def opentelemetry_span_log_retention_time(self) -> int:
        return pulumi.get(self, "opentelemetry_span_log_retention_time")

    @opentelemetry_span_log_retention_time.setter
    def opentelemetry_span_log_retention_time(self, value: int):
        pulumi.set(self, "opentelemetry_span_log_retention_time", value)

    @property
    @pulumi.getter(name="partLogRetentionSize")
    def part_log_retention_size(self) -> int:
        return pulumi.get(self, "part_log_retention_size")

    @part_log_retention_size.setter
    def part_log_retention_size(self, value: int):
        pulumi.set(self, "part_log_retention_size", value)

    @property
    @pulumi.getter(name="partLogRetentionTime")
    def part_log_retention_time(self) -> int:
        return pulumi.get(self, "part_log_retention_time")

    @part_log_retention_time.setter
    def part_log_retention_time(self, value: int):
        pulumi.set(self, "part_log_retention_time", value)

    @property
    @pulumi.getter(name="queryCache")
    def query_cache(self) -> 'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs':
        """
        Query cache configuration. The structure is documented below.
        """
        return pulumi.get(self, "query_cache")

    @query_cache.setter
    def query_cache(self, value: 'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs'):
        pulumi.set(self, "query_cache", value)

    @property
    @pulumi.getter(name="queryLogRetentionSize")
    def query_log_retention_size(self) -> int:
        return pulumi.get(self, "query_log_retention_size")

    @query_log_retention_size.setter
    def query_log_retention_size(self, value: int):
        pulumi.set(self, "query_log_retention_size", value)

    @property
    @pulumi.getter(name="queryLogRetentionTime")
    def query_log_retention_time(self) -> int:
        return pulumi.get(self, "query_log_retention_time")

    @query_log_retention_time.setter
    def query_log_retention_time(self, value: int):
        pulumi.set(self, "query_log_retention_time", value)

    @property
    @pulumi.getter(name="queryThreadLogEnabled")
    def query_thread_log_enabled(self) -> bool:
        return pulumi.get(self, "query_thread_log_enabled")

    @query_thread_log_enabled.setter
    def query_thread_log_enabled(self, value: bool):
        pulumi.set(self, "query_thread_log_enabled", value)

    @property
    @pulumi.getter(name="queryThreadLogRetentionSize")
    def query_thread_log_retention_size(self) -> int:
        return pulumi.get(self, "query_thread_log_retention_size")

    @query_thread_log_retention_size.setter
    def query_thread_log_retention_size(self, value: int):
        pulumi.set(self, "query_thread_log_retention_size", value)

    @property
    @pulumi.getter(name="queryThreadLogRetentionTime")
    def query_thread_log_retention_time(self) -> int:
        return pulumi.get(self, "query_thread_log_retention_time")

    @query_thread_log_retention_time.setter
    def query_thread_log_retention_time(self, value: int):
        pulumi.set(self, "query_thread_log_retention_time", value)

    @property
    @pulumi.getter(name="queryViewsLogEnabled")
    def query_views_log_enabled(self) -> bool:
        return pulumi.get(self, "query_views_log_enabled")

    @query_views_log_enabled.setter
    def query_views_log_enabled(self, value: bool):
        pulumi.set(self, "query_views_log_enabled", value)

    @property
    @pulumi.getter(name="queryViewsLogRetentionSize")
    def query_views_log_retention_size(self) -> int:
        return pulumi.get(self, "query_views_log_retention_size")

    @query_views_log_retention_size.setter
    def query_views_log_retention_size(self, value: int):
        pulumi.set(self, "query_views_log_retention_size", value)

    @property
    @pulumi.getter(name="queryViewsLogRetentionTime")
    def query_views_log_retention_time(self) -> int:
        return pulumi.get(self, "query_views_log_retention_time")

    @query_views_log_retention_time.setter
    def query_views_log_retention_time(self, value: int):
        pulumi.set(self, "query_views_log_retention_time", value)

    @property
    @pulumi.getter
    def rabbitmq(self) -> 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs':
        """
        RabbitMQ connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "rabbitmq")

    @rabbitmq.setter
    def rabbitmq(self, value: 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs'):
        pulumi.set(self, "rabbitmq", value)

    @property
    @pulumi.getter(name="sessionLogEnabled")
    def session_log_enabled(self) -> bool:
        return pulumi.get(self, "session_log_enabled")

    @session_log_enabled.setter
    def session_log_enabled(self, value: bool):
        pulumi.set(self, "session_log_enabled", value)

    @property
    @pulumi.getter(name="sessionLogRetentionSize")
    def session_log_retention_size(self) -> int:
        return pulumi.get(self, "session_log_retention_size")

    @session_log_retention_size.setter
    def session_log_retention_size(self, value: int):
        pulumi.set(self, "session_log_retention_size", value)

    @property
    @pulumi.getter(name="sessionLogRetentionTime")
    def session_log_retention_time(self) -> int:
        return pulumi.get(self, "session_log_retention_time")

    @session_log_retention_time.setter
    def session_log_retention_time(self, value: int):
        pulumi.set(self, "session_log_retention_time", value)

    @property
    @pulumi.getter(name="textLogEnabled")
    def text_log_enabled(self) -> bool:
        return pulumi.get(self, "text_log_enabled")

    @text_log_enabled.setter
    def text_log_enabled(self, value: bool):
        pulumi.set(self, "text_log_enabled", value)

    @property
    @pulumi.getter(name="textLogLevel")
    def text_log_level(self) -> str:
        return pulumi.get(self, "text_log_level")

    @text_log_level.setter
    def text_log_level(self, value: str):
        pulumi.set(self, "text_log_level", value)

    @property
    @pulumi.getter(name="textLogRetentionSize")
    def text_log_retention_size(self) -> int:
        return pulumi.get(self, "text_log_retention_size")

    @text_log_retention_size.setter
    def text_log_retention_size(self, value: int):
        pulumi.set(self, "text_log_retention_size", value)

    @property
    @pulumi.getter(name="textLogRetentionTime")
    def text_log_retention_time(self) -> int:
        return pulumi.get(self, "text_log_retention_time")

    @text_log_retention_time.setter
    def text_log_retention_time(self, value: int):
        pulumi.set(self, "text_log_retention_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> str:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: str):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="totalMemoryProfilerStep")
    def total_memory_profiler_step(self) -> int:
        return pulumi.get(self, "total_memory_profiler_step")

    @total_memory_profiler_step.setter
    def total_memory_profiler_step(self, value: int):
        pulumi.set(self, "total_memory_profiler_step", value)

    @property
    @pulumi.getter(name="traceLogEnabled")
    def trace_log_enabled(self) -> bool:
        return pulumi.get(self, "trace_log_enabled")

    @trace_log_enabled.setter
    def trace_log_enabled(self, value: bool):
        pulumi.set(self, "trace_log_enabled", value)

    @property
    @pulumi.getter(name="traceLogRetentionSize")
    def trace_log_retention_size(self) -> int:
        return pulumi.get(self, "trace_log_retention_size")

    @trace_log_retention_size.setter
    def trace_log_retention_size(self, value: int):
        pulumi.set(self, "trace_log_retention_size", value)

    @property
    @pulumi.getter(name="traceLogRetentionTime")
    def trace_log_retention_time(self) -> int:
        return pulumi.get(self, "trace_log_retention_time")

    @trace_log_retention_time.setter
    def trace_log_retention_time(self, value: int):
        pulumi.set(self, "trace_log_retention_time", value)

    @property
    @pulumi.getter(name="uncompressedCacheSize")
    def uncompressed_cache_size(self) -> int:
        return pulumi.get(self, "uncompressed_cache_size")

    @uncompressed_cache_size.setter
    def uncompressed_cache_size(self, value: int):
        pulumi.set(self, "uncompressed_cache_size", value)

    @property
    @pulumi.getter(name="zookeeperLogEnabled")
    def zookeeper_log_enabled(self) -> bool:
        return pulumi.get(self, "zookeeper_log_enabled")

    @zookeeper_log_enabled.setter
    def zookeeper_log_enabled(self, value: bool):
        pulumi.set(self, "zookeeper_log_enabled", value)

    @property
    @pulumi.getter(name="zookeeperLogRetentionSize")
    def zookeeper_log_retention_size(self) -> int:
        return pulumi.get(self, "zookeeper_log_retention_size")

    @zookeeper_log_retention_size.setter
    def zookeeper_log_retention_size(self, value: int):
        pulumi.set(self, "zookeeper_log_retention_size", value)

    @property
    @pulumi.getter(name="zookeeperLogRetentionTime")
    def zookeeper_log_retention_time(self) -> int:
        return pulumi.get(self, "zookeeper_log_retention_time")

    @zookeeper_log_retention_time.setter
    def zookeeper_log_retention_time(self, value: int):
        pulumi.set(self, "zookeeper_log_retention_time", value)

    @property
    @pulumi.getter
    def compressions(self) -> Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgs']]:
        """
        Data compression configuration. The structure is documented below.
        """
        return pulumi.get(self, "compressions")

    @compressions.setter
    def compressions(self, value: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgs']]):
        pulumi.set(self, "compressions", value)

    @property
    @pulumi.getter(name="graphiteRollups")
    def graphite_rollups(self) -> Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']]:
        """
        Graphite rollup configuration. The structure is documented below.
        """
        return pulumi.get(self, "graphite_rollups")

    @graphite_rollups.setter
    def graphite_rollups(self, value: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs']]):
        pulumi.set(self, "graphite_rollups", value)

    @property
    @pulumi.getter(name="kafkaTopics")
    def kafka_topics(self) -> Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs']]:
        """
        Kafka topic connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka_topics")

    @kafka_topics.setter
    def kafka_topics(self, value: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs']]):
        pulumi.set(self, "kafka_topics", value)

    @property
    @pulumi.getter(name="queryMaskingRules")
    def query_masking_rules(self) -> Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']]:
        """
        Query masking rules configuration. The structure is documented below.
        """
        return pulumi.get(self, "query_masking_rules")

    @query_masking_rules.setter
    def query_masking_rules(self, value: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs']]):
        pulumi.set(self, "query_masking_rules", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigCompressionArgsDict(TypedDict):
        level: NotRequired[int]
        """
        (Optional) Compression level for `ZSTD` method.
        """
        method: NotRequired[str]
        """
        Method: Compression method. Two methods are available: LZ4 and zstd.
        """
        min_part_size: NotRequired[int]
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        min_part_size_ratio: NotRequired[float]
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigCompressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigCompressionArgs:
    def __init__(__self__, *,
                 level: Optional[int] = None,
                 method: Optional[str] = None,
                 min_part_size: Optional[int] = None,
                 min_part_size_ratio: Optional[float] = None):
        """
        :param int level: (Optional) Compression level for `ZSTD` method.
        :param str method: Method: Compression method. Two methods are available: LZ4 and zstd.
        :param int min_part_size: Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        :param float min_part_size_ratio: Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if min_part_size is not None:
            pulumi.set(__self__, "min_part_size", min_part_size)
        if min_part_size_ratio is not None:
            pulumi.set(__self__, "min_part_size_ratio", min_part_size_ratio)

    @property
    @pulumi.getter
    def level(self) -> Optional[int]:
        """
        (Optional) Compression level for `ZSTD` method.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[int]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Method: Compression method. Two methods are available: LZ4 and zstd.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="minPartSize")
    def min_part_size(self) -> Optional[int]:
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        return pulumi.get(self, "min_part_size")

    @min_part_size.setter
    def min_part_size(self, value: Optional[int]):
        pulumi.set(self, "min_part_size", value)

    @property
    @pulumi.getter(name="minPartSizeRatio")
    def min_part_size_ratio(self) -> Optional[float]:
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        return pulumi.get(self, "min_part_size_ratio")

    @min_part_size_ratio.setter
    def min_part_size_ratio(self, value: Optional[float]):
        pulumi.set(self, "min_part_size_ratio", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict(TypedDict):
        path_column_name: str
        """
        (Optional) The name of the column storing the metric name (Graphite sensor). Default value: Path.
        """
        time_column_name: str
        """
        (Optional) The name of the column storing the time of measuring the metric. Default value: Time.
        """
        value_column_name: str
        """
        (Optional) The name of the column storing the value of the metric at the time set in time_column_name. Default value: Value.
        """
        version_column_name: str
        """
        (Optional) The name of the column storing the version of the metric. Default value: Timestamp.
        """
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        patterns: NotRequired[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict']]
        """
        Set of thinning rules.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs:
    def __init__(__self__, *,
                 path_column_name: str,
                 time_column_name: str,
                 value_column_name: str,
                 version_column_name: str,
                 name: Optional[str] = None,
                 patterns: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']] = None):
        """
        :param str path_column_name: (Optional) The name of the column storing the metric name (Graphite sensor). Default value: Path.
        :param str time_column_name: (Optional) The name of the column storing the time of measuring the metric. Default value: Time.
        :param str value_column_name: (Optional) The name of the column storing the value of the metric at the time set in time_column_name. Default value: Value.
        :param str version_column_name: (Optional) The name of the column storing the version of the metric. Default value: Timestamp.
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs'] patterns: Set of thinning rules.
        """
        pulumi.set(__self__, "path_column_name", path_column_name)
        pulumi.set(__self__, "time_column_name", time_column_name)
        pulumi.set(__self__, "value_column_name", value_column_name)
        pulumi.set(__self__, "version_column_name", version_column_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter(name="pathColumnName")
    def path_column_name(self) -> str:
        """
        (Optional) The name of the column storing the metric name (Graphite sensor). Default value: Path.
        """
        return pulumi.get(self, "path_column_name")

    @path_column_name.setter
    def path_column_name(self, value: str):
        pulumi.set(self, "path_column_name", value)

    @property
    @pulumi.getter(name="timeColumnName")
    def time_column_name(self) -> str:
        """
        (Optional) The name of the column storing the time of measuring the metric. Default value: Time.
        """
        return pulumi.get(self, "time_column_name")

    @time_column_name.setter
    def time_column_name(self, value: str):
        pulumi.set(self, "time_column_name", value)

    @property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> str:
        """
        (Optional) The name of the column storing the value of the metric at the time set in time_column_name. Default value: Value.
        """
        return pulumi.get(self, "value_column_name")

    @value_column_name.setter
    def value_column_name(self, value: str):
        pulumi.set(self, "value_column_name", value)

    @property
    @pulumi.getter(name="versionColumnName")
    def version_column_name(self) -> str:
        """
        (Optional) The name of the column storing the version of the metric. Default value: Timestamp.
        """
        return pulumi.get(self, "version_column_name")

    @version_column_name.setter
    def version_column_name(self, value: str):
        pulumi.set(self, "version_column_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']]:
        """
        Set of thinning rules.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs']]):
        pulumi.set(self, "patterns", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict(TypedDict):
        regexp: str
        """
        (Required) RE2 compatible regular expression.
        """
        function: NotRequired[str]
        """
        Aggregation function name.
        """
        retentions: NotRequired[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict']]
        """
        Retain parameters.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs:
    def __init__(__self__, *,
                 regexp: str,
                 function: Optional[str] = None,
                 retentions: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']] = None):
        """
        :param str regexp: (Required) RE2 compatible regular expression.
        :param str function: Aggregation function name.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs'] retentions: Retain parameters.
        """
        pulumi.set(__self__, "regexp", regexp)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if retentions is not None:
            pulumi.set(__self__, "retentions", retentions)

    @property
    @pulumi.getter
    def regexp(self) -> str:
        """
        (Required) RE2 compatible regular expression.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: str):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        """
        Aggregation function name.
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[str]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def retentions(self) -> Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']]:
        """
        Retain parameters.
        """
        return pulumi.get(self, "retentions")

    @retentions.setter
    def retentions(self, value: Optional[Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs']]):
        pulumi.set(self, "retentions", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict(TypedDict):
        age: NotRequired[int]
        """
        Minimum data age in seconds.
        """
        precision: NotRequired[int]
        """
        Accuracy of determining the age of the data in seconds.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs:
    def __init__(__self__, *,
                 age: Optional[int] = None,
                 precision: Optional[int] = None):
        """
        :param int age: Minimum data age in seconds.
        :param int precision: Accuracy of determining the age of the data in seconds.
        """
        if age is not None:
            pulumi.set(__self__, "age", age)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter
    def age(self) -> Optional[int]:
        """
        Minimum data age in seconds.
        """
        return pulumi.get(self, "age")

    @age.setter
    def age(self, value: Optional[int]):
        pulumi.set(self, "age", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        Accuracy of determining the age of the data in seconds.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[int]):
        pulumi.set(self, "precision", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigKafkaArgsDict(TypedDict):
        auto_offset_reset: str
        """
        (Optional) Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        debug: str
        """
        (Optional) A comma-separated list of debug contexts to enable.
        """
        enable_ssl_certificate_verification: bool
        """
        (Optional) enable verification of SSL certificates.
        """
        max_poll_interval_ms: int
        """
        (Optional) Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        sasl_mechanism: str
        """
        SASL mechanism used in kafka authentication.
        """
        sasl_password: str
        """
        User password on kafka server.
        """
        sasl_username: str
        """
        Username on kafka server.
        """
        security_protocol: str
        """
        Security protocol used to connect to kafka server.
        """
        session_timeout_ms: int
        """
        (Optional) Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigKafkaArgs:
    def __init__(__self__, *,
                 auto_offset_reset: str,
                 debug: str,
                 enable_ssl_certificate_verification: bool,
                 max_poll_interval_ms: int,
                 sasl_mechanism: str,
                 sasl_password: str,
                 sasl_username: str,
                 security_protocol: str,
                 session_timeout_ms: int):
        """
        :param str auto_offset_reset: (Optional) Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param str debug: (Optional) A comma-separated list of debug contexts to enable.
        :param bool enable_ssl_certificate_verification: (Optional) enable verification of SSL certificates.
        :param int max_poll_interval_ms: (Optional) Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param str sasl_password: User password on kafka server.
        :param str sasl_username: Username on kafka server.
        :param str security_protocol: Security protocol used to connect to kafka server.
        :param int session_timeout_ms: (Optional) Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        pulumi.set(__self__, "sasl_password", sasl_password)
        pulumi.set(__self__, "sasl_username", sasl_username)
        pulumi.set(__self__, "security_protocol", security_protocol)
        pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> str:
        """
        (Optional) Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @auto_offset_reset.setter
    def auto_offset_reset(self, value: str):
        pulumi.set(self, "auto_offset_reset", value)

    @property
    @pulumi.getter
    def debug(self) -> str:
        """
        (Optional) A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: str):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> bool:
        """
        (Optional) enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @enable_ssl_certificate_verification.setter
    def enable_ssl_certificate_verification(self, value: bool):
        pulumi.set(self, "enable_ssl_certificate_verification", value)

    @property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> int:
        """
        (Optional) Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @max_poll_interval_ms.setter
    def max_poll_interval_ms(self, value: int):
        pulumi.set(self, "max_poll_interval_ms", value)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> str:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: str):
        pulumi.set(self, "sasl_mechanism", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> str:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: str):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> str:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: str):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> str:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: str):
        pulumi.set(self, "security_protocol", value)

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> int:
        """
        (Optional) Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")

    @session_timeout_ms.setter
    def session_timeout_ms(self, value: int):
        pulumi.set(self, "session_timeout_ms", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        settings: NotRequired['GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict']
        """
        Kafka connection settngs sanem as `kafka` block.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 settings: Optional['GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs'] = None):
        """
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param 'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs' settings: Kafka connection settngs sanem as `kafka` block.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional['GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs']:
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional['GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs']):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict(TypedDict):
        auto_offset_reset: str
        """
        (Optional) Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        debug: str
        """
        (Optional) A comma-separated list of debug contexts to enable.
        """
        enable_ssl_certificate_verification: bool
        """
        (Optional) enable verification of SSL certificates.
        """
        max_poll_interval_ms: int
        """
        (Optional) Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        session_timeout_ms: int
        """
        (Optional) Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        sasl_mechanism: NotRequired[str]
        """
        SASL mechanism used in kafka authentication.
        """
        sasl_password: NotRequired[str]
        """
        User password on kafka server.
        """
        sasl_username: NotRequired[str]
        """
        Username on kafka server.
        """
        security_protocol: NotRequired[str]
        """
        Security protocol used to connect to kafka server.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs:
    def __init__(__self__, *,
                 auto_offset_reset: str,
                 debug: str,
                 enable_ssl_certificate_verification: bool,
                 max_poll_interval_ms: int,
                 session_timeout_ms: int,
                 sasl_mechanism: Optional[str] = None,
                 sasl_password: Optional[str] = None,
                 sasl_username: Optional[str] = None,
                 security_protocol: Optional[str] = None):
        """
        :param str auto_offset_reset: (Optional) Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param str debug: (Optional) A comma-separated list of debug contexts to enable.
        :param bool enable_ssl_certificate_verification: (Optional) enable verification of SSL certificates.
        :param int max_poll_interval_ms: (Optional) Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param int session_timeout_ms: (Optional) Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        :param str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param str sasl_password: User password on kafka server.
        :param str sasl_username: Username on kafka server.
        :param str security_protocol: Security protocol used to connect to kafka server.
        """
        pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> str:
        """
        (Optional) Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @auto_offset_reset.setter
    def auto_offset_reset(self, value: str):
        pulumi.set(self, "auto_offset_reset", value)

    @property
    @pulumi.getter
    def debug(self) -> str:
        """
        (Optional) A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: str):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> bool:
        """
        (Optional) enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @enable_ssl_certificate_verification.setter
    def enable_ssl_certificate_verification(self, value: bool):
        pulumi.set(self, "enable_ssl_certificate_verification", value)

    @property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> int:
        """
        (Optional) Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @max_poll_interval_ms.setter
    def max_poll_interval_ms(self, value: int):
        pulumi.set(self, "max_poll_interval_ms", value)

    @property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> int:
        """
        (Optional) Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")

    @session_timeout_ms.setter
    def session_timeout_ms(self, value: int):
        pulumi.set(self, "session_timeout_ms", value)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: Optional[str]):
        pulumi.set(self, "sasl_mechanism", value)

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @sasl_password.setter
    def sasl_password(self, value: Optional[str]):
        pulumi.set(self, "sasl_password", value)

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @sasl_username.setter
    def sasl_username(self, value: Optional[str]):
        pulumi.set(self, "sasl_username", value)

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: Optional[str]):
        pulumi.set(self, "security_protocol", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigMergeTreeArgsDict(TypedDict):
        allow_remote_fs_zero_copy_replication: bool
        """
        (Optional) Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        check_sample_column_is_correct: bool
        """
        (Optional) Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        """
        cleanup_delay_period: int
        """
        (Optional) Minimum period to clean old queue logs, blocks hashes and parts.
        """
        inactive_parts_to_delay_insert: int
        """
        If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        """
        inactive_parts_to_throw_insert: int
        """
        If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the "Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts" exception.
        """
        max_avg_part_size_for_too_many_parts: int
        """
        (Optional) The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        """
        max_bytes_to_merge_at_max_space_in_pool: int
        """
        The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        """
        max_bytes_to_merge_at_min_space_in_pool: int
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        max_cleanup_delay_period: int
        """
        (Optional) Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        """
        max_merge_selecting_sleep_ms: int
        """
        (Optional) Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        """
        max_number_of_merges_with_ttl_in_pool: int
        """
        (Optional) When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        """
        max_parts_in_total: int
        """
        (Optional) Maximum number of parts in all partitions.
        """
        max_replicated_merges_in_queue: int
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        merge_max_block_size: int
        """
        (Optional) The number of rows that are read from the merged parts into memory. Default value: 8192.
        """
        merge_selecting_sleep_ms: int
        """
        (Optional) Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        """
        merge_with_recompression_ttl_timeout: int
        """
        (Optional) Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        """
        merge_with_ttl_timeout: int
        """
        (Optional) Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        """
        min_age_to_force_merge_on_partition_only: bool
        """
        (Optional) Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        """
        min_age_to_force_merge_seconds: int
        """
        (Optional) Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        """
        min_bytes_for_wide_part: int
        """
        (Optional) Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        min_rows_for_wide_part: int
        """
        (Optional) Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        number_of_free_entries_in_pool_to_execute_mutation: int
        """
        (Optional) When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid "Too many parts". Default value: 20.
        """
        number_of_free_entries_in_pool_to_lower_max_size_of_merge: int
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        parts_to_delay_insert: int
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        """
        parts_to_throw_insert: int
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        replicated_deduplication_window: int
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        replicated_deduplication_window_seconds: int
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        ttl_only_drop_parts: bool
        """
        (Optional) Enables or disables complete dropping of data parts where all rows are expired in MergeTree tables.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigMergeTreeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs:
    def __init__(__self__, *,
                 allow_remote_fs_zero_copy_replication: bool,
                 check_sample_column_is_correct: bool,
                 cleanup_delay_period: int,
                 inactive_parts_to_delay_insert: int,
                 inactive_parts_to_throw_insert: int,
                 max_avg_part_size_for_too_many_parts: int,
                 max_bytes_to_merge_at_max_space_in_pool: int,
                 max_bytes_to_merge_at_min_space_in_pool: int,
                 max_cleanup_delay_period: int,
                 max_merge_selecting_sleep_ms: int,
                 max_number_of_merges_with_ttl_in_pool: int,
                 max_parts_in_total: int,
                 max_replicated_merges_in_queue: int,
                 merge_max_block_size: int,
                 merge_selecting_sleep_ms: int,
                 merge_with_recompression_ttl_timeout: int,
                 merge_with_ttl_timeout: int,
                 min_age_to_force_merge_on_partition_only: bool,
                 min_age_to_force_merge_seconds: int,
                 min_bytes_for_wide_part: int,
                 min_rows_for_wide_part: int,
                 number_of_free_entries_in_pool_to_execute_mutation: int,
                 number_of_free_entries_in_pool_to_lower_max_size_of_merge: int,
                 parts_to_delay_insert: int,
                 parts_to_throw_insert: int,
                 replicated_deduplication_window: int,
                 replicated_deduplication_window_seconds: int,
                 ttl_only_drop_parts: bool):
        """
        :param bool allow_remote_fs_zero_copy_replication: (Optional) Enables zero-copy replication when a replica is located on a remote filesystem.
        :param bool check_sample_column_is_correct: (Optional) Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        :param int cleanup_delay_period: (Optional) Minimum period to clean old queue logs, blocks hashes and parts.
        :param int inactive_parts_to_delay_insert: If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        :param int inactive_parts_to_throw_insert: If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the "Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts" exception.
        :param int max_avg_part_size_for_too_many_parts: (Optional) The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        :param int max_bytes_to_merge_at_max_space_in_pool: The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        :param int max_bytes_to_merge_at_min_space_in_pool: Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        :param int max_cleanup_delay_period: (Optional) Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        :param int max_merge_selecting_sleep_ms: (Optional) Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        :param int max_number_of_merges_with_ttl_in_pool: (Optional) When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        :param int max_parts_in_total: (Optional) Maximum number of parts in all partitions.
        :param int max_replicated_merges_in_queue: Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        :param int merge_max_block_size: (Optional) The number of rows that are read from the merged parts into memory. Default value: 8192.
        :param int merge_selecting_sleep_ms: (Optional) Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        :param int merge_with_recompression_ttl_timeout: (Optional) Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        :param int merge_with_ttl_timeout: (Optional) Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        :param bool min_age_to_force_merge_on_partition_only: (Optional) Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        :param int min_age_to_force_merge_seconds: (Optional) Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        :param int min_bytes_for_wide_part: (Optional) Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param int min_rows_for_wide_part: (Optional) Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param int number_of_free_entries_in_pool_to_execute_mutation: (Optional) When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid "Too many parts". Default value: 20.
        :param int number_of_free_entries_in_pool_to_lower_max_size_of_merge: Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        :param int parts_to_delay_insert: Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        :param int parts_to_throw_insert: Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        :param int replicated_deduplication_window: Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        :param int replicated_deduplication_window_seconds: Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        :param bool ttl_only_drop_parts: (Optional) Enables or disables complete dropping of data parts where all rows are expired in MergeTree tables.
        """
        pulumi.set(__self__, "allow_remote_fs_zero_copy_replication", allow_remote_fs_zero_copy_replication)
        pulumi.set(__self__, "check_sample_column_is_correct", check_sample_column_is_correct)
        pulumi.set(__self__, "cleanup_delay_period", cleanup_delay_period)
        pulumi.set(__self__, "inactive_parts_to_delay_insert", inactive_parts_to_delay_insert)
        pulumi.set(__self__, "inactive_parts_to_throw_insert", inactive_parts_to_throw_insert)
        pulumi.set(__self__, "max_avg_part_size_for_too_many_parts", max_avg_part_size_for_too_many_parts)
        pulumi.set(__self__, "max_bytes_to_merge_at_max_space_in_pool", max_bytes_to_merge_at_max_space_in_pool)
        pulumi.set(__self__, "max_bytes_to_merge_at_min_space_in_pool", max_bytes_to_merge_at_min_space_in_pool)
        pulumi.set(__self__, "max_cleanup_delay_period", max_cleanup_delay_period)
        pulumi.set(__self__, "max_merge_selecting_sleep_ms", max_merge_selecting_sleep_ms)
        pulumi.set(__self__, "max_number_of_merges_with_ttl_in_pool", max_number_of_merges_with_ttl_in_pool)
        pulumi.set(__self__, "max_parts_in_total", max_parts_in_total)
        pulumi.set(__self__, "max_replicated_merges_in_queue", max_replicated_merges_in_queue)
        pulumi.set(__self__, "merge_max_block_size", merge_max_block_size)
        pulumi.set(__self__, "merge_selecting_sleep_ms", merge_selecting_sleep_ms)
        pulumi.set(__self__, "merge_with_recompression_ttl_timeout", merge_with_recompression_ttl_timeout)
        pulumi.set(__self__, "merge_with_ttl_timeout", merge_with_ttl_timeout)
        pulumi.set(__self__, "min_age_to_force_merge_on_partition_only", min_age_to_force_merge_on_partition_only)
        pulumi.set(__self__, "min_age_to_force_merge_seconds", min_age_to_force_merge_seconds)
        pulumi.set(__self__, "min_bytes_for_wide_part", min_bytes_for_wide_part)
        pulumi.set(__self__, "min_rows_for_wide_part", min_rows_for_wide_part)
        pulumi.set(__self__, "number_of_free_entries_in_pool_to_execute_mutation", number_of_free_entries_in_pool_to_execute_mutation)
        pulumi.set(__self__, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", number_of_free_entries_in_pool_to_lower_max_size_of_merge)
        pulumi.set(__self__, "parts_to_delay_insert", parts_to_delay_insert)
        pulumi.set(__self__, "parts_to_throw_insert", parts_to_throw_insert)
        pulumi.set(__self__, "replicated_deduplication_window", replicated_deduplication_window)
        pulumi.set(__self__, "replicated_deduplication_window_seconds", replicated_deduplication_window_seconds)
        pulumi.set(__self__, "ttl_only_drop_parts", ttl_only_drop_parts)

    @property
    @pulumi.getter(name="allowRemoteFsZeroCopyReplication")
    def allow_remote_fs_zero_copy_replication(self) -> bool:
        """
        (Optional) Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        return pulumi.get(self, "allow_remote_fs_zero_copy_replication")

    @allow_remote_fs_zero_copy_replication.setter
    def allow_remote_fs_zero_copy_replication(self, value: bool):
        pulumi.set(self, "allow_remote_fs_zero_copy_replication", value)

    @property
    @pulumi.getter(name="checkSampleColumnIsCorrect")
    def check_sample_column_is_correct(self) -> bool:
        """
        (Optional) Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        """
        return pulumi.get(self, "check_sample_column_is_correct")

    @check_sample_column_is_correct.setter
    def check_sample_column_is_correct(self, value: bool):
        pulumi.set(self, "check_sample_column_is_correct", value)

    @property
    @pulumi.getter(name="cleanupDelayPeriod")
    def cleanup_delay_period(self) -> int:
        """
        (Optional) Minimum period to clean old queue logs, blocks hashes and parts.
        """
        return pulumi.get(self, "cleanup_delay_period")

    @cleanup_delay_period.setter
    def cleanup_delay_period(self, value: int):
        pulumi.set(self, "cleanup_delay_period", value)

    @property
    @pulumi.getter(name="inactivePartsToDelayInsert")
    def inactive_parts_to_delay_insert(self) -> int:
        """
        If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        """
        return pulumi.get(self, "inactive_parts_to_delay_insert")

    @inactive_parts_to_delay_insert.setter
    def inactive_parts_to_delay_insert(self, value: int):
        pulumi.set(self, "inactive_parts_to_delay_insert", value)

    @property
    @pulumi.getter(name="inactivePartsToThrowInsert")
    def inactive_parts_to_throw_insert(self) -> int:
        """
        If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the "Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts" exception.
        """
        return pulumi.get(self, "inactive_parts_to_throw_insert")

    @inactive_parts_to_throw_insert.setter
    def inactive_parts_to_throw_insert(self, value: int):
        pulumi.set(self, "inactive_parts_to_throw_insert", value)

    @property
    @pulumi.getter(name="maxAvgPartSizeForTooManyParts")
    def max_avg_part_size_for_too_many_parts(self) -> int:
        """
        (Optional) The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        """
        return pulumi.get(self, "max_avg_part_size_for_too_many_parts")

    @max_avg_part_size_for_too_many_parts.setter
    def max_avg_part_size_for_too_many_parts(self, value: int):
        pulumi.set(self, "max_avg_part_size_for_too_many_parts", value)

    @property
    @pulumi.getter(name="maxBytesToMergeAtMaxSpaceInPool")
    def max_bytes_to_merge_at_max_space_in_pool(self) -> int:
        """
        The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_max_space_in_pool")

    @max_bytes_to_merge_at_max_space_in_pool.setter
    def max_bytes_to_merge_at_max_space_in_pool(self, value: int):
        pulumi.set(self, "max_bytes_to_merge_at_max_space_in_pool", value)

    @property
    @pulumi.getter(name="maxBytesToMergeAtMinSpaceInPool")
    def max_bytes_to_merge_at_min_space_in_pool(self) -> int:
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_min_space_in_pool")

    @max_bytes_to_merge_at_min_space_in_pool.setter
    def max_bytes_to_merge_at_min_space_in_pool(self, value: int):
        pulumi.set(self, "max_bytes_to_merge_at_min_space_in_pool", value)

    @property
    @pulumi.getter(name="maxCleanupDelayPeriod")
    def max_cleanup_delay_period(self) -> int:
        """
        (Optional) Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        """
        return pulumi.get(self, "max_cleanup_delay_period")

    @max_cleanup_delay_period.setter
    def max_cleanup_delay_period(self, value: int):
        pulumi.set(self, "max_cleanup_delay_period", value)

    @property
    @pulumi.getter(name="maxMergeSelectingSleepMs")
    def max_merge_selecting_sleep_ms(self) -> int:
        """
        (Optional) Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        """
        return pulumi.get(self, "max_merge_selecting_sleep_ms")

    @max_merge_selecting_sleep_ms.setter
    def max_merge_selecting_sleep_ms(self, value: int):
        pulumi.set(self, "max_merge_selecting_sleep_ms", value)

    @property
    @pulumi.getter(name="maxNumberOfMergesWithTtlInPool")
    def max_number_of_merges_with_ttl_in_pool(self) -> int:
        """
        (Optional) When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        """
        return pulumi.get(self, "max_number_of_merges_with_ttl_in_pool")

    @max_number_of_merges_with_ttl_in_pool.setter
    def max_number_of_merges_with_ttl_in_pool(self, value: int):
        pulumi.set(self, "max_number_of_merges_with_ttl_in_pool", value)

    @property
    @pulumi.getter(name="maxPartsInTotal")
    def max_parts_in_total(self) -> int:
        """
        (Optional) Maximum number of parts in all partitions.
        """
        return pulumi.get(self, "max_parts_in_total")

    @max_parts_in_total.setter
    def max_parts_in_total(self, value: int):
        pulumi.set(self, "max_parts_in_total", value)

    @property
    @pulumi.getter(name="maxReplicatedMergesInQueue")
    def max_replicated_merges_in_queue(self) -> int:
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        return pulumi.get(self, "max_replicated_merges_in_queue")

    @max_replicated_merges_in_queue.setter
    def max_replicated_merges_in_queue(self, value: int):
        pulumi.set(self, "max_replicated_merges_in_queue", value)

    @property
    @pulumi.getter(name="mergeMaxBlockSize")
    def merge_max_block_size(self) -> int:
        """
        (Optional) The number of rows that are read from the merged parts into memory. Default value: 8192.
        """
        return pulumi.get(self, "merge_max_block_size")

    @merge_max_block_size.setter
    def merge_max_block_size(self, value: int):
        pulumi.set(self, "merge_max_block_size", value)

    @property
    @pulumi.getter(name="mergeSelectingSleepMs")
    def merge_selecting_sleep_ms(self) -> int:
        """
        (Optional) Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        """
        return pulumi.get(self, "merge_selecting_sleep_ms")

    @merge_selecting_sleep_ms.setter
    def merge_selecting_sleep_ms(self, value: int):
        pulumi.set(self, "merge_selecting_sleep_ms", value)

    @property
    @pulumi.getter(name="mergeWithRecompressionTtlTimeout")
    def merge_with_recompression_ttl_timeout(self) -> int:
        """
        (Optional) Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_recompression_ttl_timeout")

    @merge_with_recompression_ttl_timeout.setter
    def merge_with_recompression_ttl_timeout(self, value: int):
        pulumi.set(self, "merge_with_recompression_ttl_timeout", value)

    @property
    @pulumi.getter(name="mergeWithTtlTimeout")
    def merge_with_ttl_timeout(self) -> int:
        """
        (Optional) Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_ttl_timeout")

    @merge_with_ttl_timeout.setter
    def merge_with_ttl_timeout(self, value: int):
        pulumi.set(self, "merge_with_ttl_timeout", value)

    @property
    @pulumi.getter(name="minAgeToForceMergeOnPartitionOnly")
    def min_age_to_force_merge_on_partition_only(self) -> bool:
        """
        (Optional) Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        """
        return pulumi.get(self, "min_age_to_force_merge_on_partition_only")

    @min_age_to_force_merge_on_partition_only.setter
    def min_age_to_force_merge_on_partition_only(self, value: bool):
        pulumi.set(self, "min_age_to_force_merge_on_partition_only", value)

    @property
    @pulumi.getter(name="minAgeToForceMergeSeconds")
    def min_age_to_force_merge_seconds(self) -> int:
        """
        (Optional) Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        """
        return pulumi.get(self, "min_age_to_force_merge_seconds")

    @min_age_to_force_merge_seconds.setter
    def min_age_to_force_merge_seconds(self, value: int):
        pulumi.set(self, "min_age_to_force_merge_seconds", value)

    @property
    @pulumi.getter(name="minBytesForWidePart")
    def min_bytes_for_wide_part(self) -> int:
        """
        (Optional) Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_bytes_for_wide_part")

    @min_bytes_for_wide_part.setter
    def min_bytes_for_wide_part(self, value: int):
        pulumi.set(self, "min_bytes_for_wide_part", value)

    @property
    @pulumi.getter(name="minRowsForWidePart")
    def min_rows_for_wide_part(self) -> int:
        """
        (Optional) Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_rows_for_wide_part")

    @min_rows_for_wide_part.setter
    def min_rows_for_wide_part(self, value: int):
        pulumi.set(self, "min_rows_for_wide_part", value)

    @property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToExecuteMutation")
    def number_of_free_entries_in_pool_to_execute_mutation(self) -> int:
        """
        (Optional) When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid "Too many parts". Default value: 20.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_execute_mutation")

    @number_of_free_entries_in_pool_to_execute_mutation.setter
    def number_of_free_entries_in_pool_to_execute_mutation(self, value: int):
        pulumi.set(self, "number_of_free_entries_in_pool_to_execute_mutation", value)

    @property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge")
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self) -> int:
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge")

    @number_of_free_entries_in_pool_to_lower_max_size_of_merge.setter
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self, value: int):
        pulumi.set(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", value)

    @property
    @pulumi.getter(name="partsToDelayInsert")
    def parts_to_delay_insert(self) -> int:
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        """
        return pulumi.get(self, "parts_to_delay_insert")

    @parts_to_delay_insert.setter
    def parts_to_delay_insert(self, value: int):
        pulumi.set(self, "parts_to_delay_insert", value)

    @property
    @pulumi.getter(name="partsToThrowInsert")
    def parts_to_throw_insert(self) -> int:
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        return pulumi.get(self, "parts_to_throw_insert")

    @parts_to_throw_insert.setter
    def parts_to_throw_insert(self, value: int):
        pulumi.set(self, "parts_to_throw_insert", value)

    @property
    @pulumi.getter(name="replicatedDeduplicationWindow")
    def replicated_deduplication_window(self) -> int:
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window")

    @replicated_deduplication_window.setter
    def replicated_deduplication_window(self, value: int):
        pulumi.set(self, "replicated_deduplication_window", value)

    @property
    @pulumi.getter(name="replicatedDeduplicationWindowSeconds")
    def replicated_deduplication_window_seconds(self) -> int:
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window_seconds")

    @replicated_deduplication_window_seconds.setter
    def replicated_deduplication_window_seconds(self, value: int):
        pulumi.set(self, "replicated_deduplication_window_seconds", value)

    @property
    @pulumi.getter(name="ttlOnlyDropParts")
    def ttl_only_drop_parts(self) -> bool:
        """
        (Optional) Enables or disables complete dropping of data parts where all rows are expired in MergeTree tables.
        """
        return pulumi.get(self, "ttl_only_drop_parts")

    @ttl_only_drop_parts.setter
    def ttl_only_drop_parts(self, value: bool):
        pulumi.set(self, "ttl_only_drop_parts", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigQueryCacheArgsDict(TypedDict):
        max_entries: int
        """
        (Optional) The maximum number of SELECT query results stored in the cache. Default value: 1024.
        """
        max_entry_size_in_bytes: int
        """
        (Optional) The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        """
        max_entry_size_in_rows: int
        """
        (Optional) The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        """
        max_size_in_bytes: int
        """
        (Optional) The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigQueryCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs:
    def __init__(__self__, *,
                 max_entries: int,
                 max_entry_size_in_bytes: int,
                 max_entry_size_in_rows: int,
                 max_size_in_bytes: int):
        """
        :param int max_entries: (Optional) The maximum number of SELECT query results stored in the cache. Default value: 1024.
        :param int max_entry_size_in_bytes: (Optional) The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        :param int max_entry_size_in_rows: (Optional) The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        :param int max_size_in_bytes: (Optional) The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        pulumi.set(__self__, "max_entries", max_entries)
        pulumi.set(__self__, "max_entry_size_in_bytes", max_entry_size_in_bytes)
        pulumi.set(__self__, "max_entry_size_in_rows", max_entry_size_in_rows)
        pulumi.set(__self__, "max_size_in_bytes", max_size_in_bytes)

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> int:
        """
        (Optional) The maximum number of SELECT query results stored in the cache. Default value: 1024.
        """
        return pulumi.get(self, "max_entries")

    @max_entries.setter
    def max_entries(self, value: int):
        pulumi.set(self, "max_entries", value)

    @property
    @pulumi.getter(name="maxEntrySizeInBytes")
    def max_entry_size_in_bytes(self) -> int:
        """
        (Optional) The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        """
        return pulumi.get(self, "max_entry_size_in_bytes")

    @max_entry_size_in_bytes.setter
    def max_entry_size_in_bytes(self, value: int):
        pulumi.set(self, "max_entry_size_in_bytes", value)

    @property
    @pulumi.getter(name="maxEntrySizeInRows")
    def max_entry_size_in_rows(self) -> int:
        """
        (Optional) The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        """
        return pulumi.get(self, "max_entry_size_in_rows")

    @max_entry_size_in_rows.setter
    def max_entry_size_in_rows(self, value: int):
        pulumi.set(self, "max_entry_size_in_rows", value)

    @property
    @pulumi.getter(name="maxSizeInBytes")
    def max_size_in_bytes(self) -> int:
        """
        (Optional) The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        return pulumi.get(self, "max_size_in_bytes")

    @max_size_in_bytes.setter
    def max_size_in_bytes(self, value: int):
        pulumi.set(self, "max_size_in_bytes", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict(TypedDict):
        name: str
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        replace: str
        """
        (Optional) Substitution string for sensitive data. Default value: six asterisks.
        """
        regexp: NotRequired[str]
        """
        (Required) RE2 compatible regular expression.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs:
    def __init__(__self__, *,
                 name: str,
                 replace: str,
                 regexp: Optional[str] = None):
        """
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param str replace: (Optional) Substitution string for sensitive data. Default value: six asterisks.
        :param str regexp: (Required) RE2 compatible regular expression.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replace", replace)
        if regexp is not None:
            pulumi.set(__self__, "regexp", regexp)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def replace(self) -> str:
        """
        (Optional) Substitution string for sensitive data. Default value: six asterisks.
        """
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: str):
        pulumi.set(self, "replace", value)

    @property
    @pulumi.getter
    def regexp(self) -> Optional[str]:
        """
        (Required) RE2 compatible regular expression.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: Optional[str]):
        pulumi.set(self, "regexp", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseConfigRabbitmqArgsDict(TypedDict):
        password: str
        """
        RabbitMQ user password.
        """
        username: str
        """
        RabbitMQ username.
        """
        vhost: str
        """
        (Optional) RabbitMQ vhost. Default: '\\'.
        """
elif False:
    GetMdbClickhouseClusterClickhouseConfigRabbitmqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str,
                 vhost: str):
        """
        :param str password: RabbitMQ user password.
        :param str username: RabbitMQ username.
        :param str vhost: (Optional) RabbitMQ vhost. Default: '\\'.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "vhost", vhost)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        RabbitMQ username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def vhost(self) -> str:
        """
        (Optional) RabbitMQ vhost. Default: '\\'.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: str):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class GetMdbClickhouseClusterClickhouseResourcesArgsDict(TypedDict):
        disk_size: int
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: str
        """
        Type of the storage of hosts.
        """
        resource_preset_id: str
elif False:
    GetMdbClickhouseClusterClickhouseResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterClickhouseResourcesArgs:
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: int):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: str):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: str):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbClickhouseClusterCloudStorageArgsDict(TypedDict):
        data_cache_enabled: bool
        """
        Enables temporary storage in the cluster repository of data requested from the object repository.
        """
        data_cache_max_size: int
        """
        Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        """
        move_factor: float
        """
        Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        """
        prefer_not_to_merge: bool
        """
        (Optional) Disables merging of data parts in `Yandex Object Storage`.
        """
        enabled: NotRequired[bool]
        """
        (Required) Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
elif False:
    GetMdbClickhouseClusterCloudStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterCloudStorageArgs:
    def __init__(__self__, *,
                 data_cache_enabled: bool,
                 data_cache_max_size: int,
                 move_factor: float,
                 prefer_not_to_merge: bool,
                 enabled: Optional[bool] = None):
        """
        :param bool data_cache_enabled: Enables temporary storage in the cluster repository of data requested from the object repository.
        :param int data_cache_max_size: Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        :param float move_factor: Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        :param bool prefer_not_to_merge: (Optional) Disables merging of data parts in `Yandex Object Storage`.
        :param bool enabled: (Required) Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        pulumi.set(__self__, "data_cache_enabled", data_cache_enabled)
        pulumi.set(__self__, "data_cache_max_size", data_cache_max_size)
        pulumi.set(__self__, "move_factor", move_factor)
        pulumi.set(__self__, "prefer_not_to_merge", prefer_not_to_merge)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dataCacheEnabled")
    def data_cache_enabled(self) -> bool:
        """
        Enables temporary storage in the cluster repository of data requested from the object repository.
        """
        return pulumi.get(self, "data_cache_enabled")

    @data_cache_enabled.setter
    def data_cache_enabled(self, value: bool):
        pulumi.set(self, "data_cache_enabled", value)

    @property
    @pulumi.getter(name="dataCacheMaxSize")
    def data_cache_max_size(self) -> int:
        """
        Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        """
        return pulumi.get(self, "data_cache_max_size")

    @data_cache_max_size.setter
    def data_cache_max_size(self, value: int):
        pulumi.set(self, "data_cache_max_size", value)

    @property
    @pulumi.getter(name="moveFactor")
    def move_factor(self) -> float:
        """
        Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        """
        return pulumi.get(self, "move_factor")

    @move_factor.setter
    def move_factor(self, value: float):
        pulumi.set(self, "move_factor", value)

    @property
    @pulumi.getter(name="preferNotToMerge")
    def prefer_not_to_merge(self) -> bool:
        """
        (Optional) Disables merging of data parts in `Yandex Object Storage`.
        """
        return pulumi.get(self, "prefer_not_to_merge")

    @prefer_not_to_merge.setter
    def prefer_not_to_merge(self, value: bool):
        pulumi.set(self, "prefer_not_to_merge", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        (Required) Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetMdbClickhouseClusterDatabaseArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
elif False:
    GetMdbClickhouseClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetMdbClickhouseClusterFormatSchemaArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        type: NotRequired[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        uri: NotRequired[str]
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
elif False:
    GetMdbClickhouseClusterFormatSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterFormatSchemaArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class GetMdbClickhouseClusterHostArgsDict(TypedDict):
        fqdn: str
        """
        The fully qualified domain name of the host.
        """
        shard_name: str
        """
        The name of the shard to which the host belongs.
        """
        subnet_id: str
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        assign_public_ip: NotRequired[bool]
        """
        Sets whether the host should get a public IP address on creation.
        """
        type: NotRequired[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        zone: NotRequired[str]
        """
        The availability zone where the ClickHouse host will be created.
        """
elif False:
    GetMdbClickhouseClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterHostArgs:
    def __init__(__self__, *,
                 fqdn: str,
                 shard_name: str,
                 subnet_id: str,
                 assign_public_ip: Optional[bool] = None,
                 type: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str fqdn: The fully qualified domain name of the host.
        :param str shard_name: The name of the shard to which the host belongs.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str zone: The availability zone where the ClickHouse host will be created.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "shard_name", shard_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: str):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @shard_name.setter
    def shard_name(self, value: str):
        pulumi.set(self, "shard_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: str):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the host should get a public IP address on creation.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[bool]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The availability zone where the ClickHouse host will be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[str]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class GetMdbClickhouseClusterMaintenanceWindowArgsDict(TypedDict):
        day: NotRequired[str]
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        hour: NotRequired[int]
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        type: NotRequired[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
elif False:
    GetMdbClickhouseClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: Optional[str] = None,
                 hour: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[int]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetMdbClickhouseClusterMlModelArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        type: NotRequired[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        uri: NotRequired[str]
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
elif False:
    GetMdbClickhouseClusterMlModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterMlModelArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class GetMdbClickhouseClusterShardArgsDict(TypedDict):
        resources: 'GetMdbClickhouseClusterShardResourcesArgsDict'
        """
        Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        weight: int
        """
        The weight of the shard.
        """
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
elif False:
    GetMdbClickhouseClusterShardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterShardArgs:
    def __init__(__self__, *,
                 resources: 'GetMdbClickhouseClusterShardResourcesArgs',
                 weight: int,
                 name: Optional[str] = None):
        """
        :param 'GetMdbClickhouseClusterShardResourcesArgs' resources: Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        :param int weight: The weight of the shard.
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        """
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "weight", weight)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def resources(self) -> 'GetMdbClickhouseClusterShardResourcesArgs':
        """
        Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: 'GetMdbClickhouseClusterShardResourcesArgs'):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of the shard.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: int):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetMdbClickhouseClusterShardGroupArgsDict(TypedDict):
        description: NotRequired[str]
        """
        Description of the shard group.
        """
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        shard_names: NotRequired[Sequence[str]]
        """
        List of shards names that belong to the shard group.
        """
elif False:
    GetMdbClickhouseClusterShardGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterShardGroupArgs:
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 shard_names: Optional[Sequence[str]] = None):
        """
        :param str description: Description of the shard group.
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param Sequence[str] shard_names: List of shards names that belong to the shard group.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shard_names is not None:
            pulumi.set(__self__, "shard_names", shard_names)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the shard group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shardNames")
    def shard_names(self) -> Optional[Sequence[str]]:
        """
        List of shards names that belong to the shard group.
        """
        return pulumi.get(self, "shard_names")

    @shard_names.setter
    def shard_names(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "shard_names", value)


if not MYPY:
    class GetMdbClickhouseClusterShardResourcesArgsDict(TypedDict):
        disk_size: int
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: str
        """
        Type of the storage of hosts.
        """
        resource_preset_id: str
elif False:
    GetMdbClickhouseClusterShardResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterShardResourcesArgs:
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: int):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: str):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: str):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbClickhouseClusterUserArgsDict(TypedDict):
        permissions: Sequence['GetMdbClickhouseClusterUserPermissionArgsDict']
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        quotas: Sequence['GetMdbClickhouseClusterUserQuotaArgsDict']
        """
        Set of user quotas. The structure is documented below.
        """
        settings: 'GetMdbClickhouseClusterUserSettingsArgsDict'
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        name: NotRequired[str]
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        password: NotRequired[str]
        """
        RabbitMQ user password.
        """
elif False:
    GetMdbClickhouseClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterUserArgs:
    def __init__(__self__, *,
                 permissions: Sequence['GetMdbClickhouseClusterUserPermissionArgs'],
                 quotas: Sequence['GetMdbClickhouseClusterUserQuotaArgs'],
                 settings: 'GetMdbClickhouseClusterUserSettingsArgs',
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param Sequence['GetMdbClickhouseClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterUserQuotaArgs'] quotas: Set of user quotas. The structure is documented below.
        :param 'GetMdbClickhouseClusterUserSettingsArgs' settings: Kafka connection settngs sanem as `kafka` block.
        :param str name: The name of the ClickHouse cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param str password: RabbitMQ user password.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "quotas", quotas)
        pulumi.set(__self__, "settings", settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['GetMdbClickhouseClusterUserPermissionArgs']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence['GetMdbClickhouseClusterUserPermissionArgs']):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def quotas(self) -> Sequence['GetMdbClickhouseClusterUserQuotaArgs']:
        """
        Set of user quotas. The structure is documented below.
        """
        return pulumi.get(self, "quotas")

    @quotas.setter
    def quotas(self, value: Sequence['GetMdbClickhouseClusterUserQuotaArgs']):
        pulumi.set(self, "quotas", value)

    @property
    @pulumi.getter
    def settings(self) -> 'GetMdbClickhouseClusterUserSettingsArgs':
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: 'GetMdbClickhouseClusterUserSettingsArgs'):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ClickHouse cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class GetMdbClickhouseClusterUserPermissionArgsDict(TypedDict):
        database_name: NotRequired[str]
        """
        The name of the database that the permission grants access to.
        """
elif False:
    GetMdbClickhouseClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: Optional[str] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[str]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class GetMdbClickhouseClusterUserQuotaArgsDict(TypedDict):
        errors: int
        """
        The number of queries that threw exception.
        """
        execution_time: int
        """
        The total query execution time, in milliseconds (wall time).
        """
        queries: int
        """
        The total number of queries.
        """
        read_rows: int
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        result_rows: int
        """
        The total number of rows given as the result.
        """
        interval_duration: NotRequired[int]
        """
        Duration of interval for quota in milliseconds.
        """
elif False:
    GetMdbClickhouseClusterUserQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterUserQuotaArgs:
    def __init__(__self__, *,
                 errors: int,
                 execution_time: int,
                 queries: int,
                 read_rows: int,
                 result_rows: int,
                 interval_duration: Optional[int] = None):
        """
        :param int errors: The number of queries that threw exception.
        :param int execution_time: The total query execution time, in milliseconds (wall time).
        :param int queries: The total number of queries.
        :param int read_rows: The total number of source rows read from tables for running the query, on all remote servers.
        :param int result_rows: The total number of rows given as the result.
        :param int interval_duration: Duration of interval for quota in milliseconds.
        """
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "execution_time", execution_time)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "read_rows", read_rows)
        pulumi.set(__self__, "result_rows", result_rows)
        if interval_duration is not None:
            pulumi.set(__self__, "interval_duration", interval_duration)

    @property
    @pulumi.getter
    def errors(self) -> int:
        """
        The number of queries that threw exception.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: int):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> int:
        """
        The total query execution time, in milliseconds (wall time).
        """
        return pulumi.get(self, "execution_time")

    @execution_time.setter
    def execution_time(self, value: int):
        pulumi.set(self, "execution_time", value)

    @property
    @pulumi.getter
    def queries(self) -> int:
        """
        The total number of queries.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: int):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="readRows")
    def read_rows(self) -> int:
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        return pulumi.get(self, "read_rows")

    @read_rows.setter
    def read_rows(self, value: int):
        pulumi.set(self, "read_rows", value)

    @property
    @pulumi.getter(name="resultRows")
    def result_rows(self) -> int:
        """
        The total number of rows given as the result.
        """
        return pulumi.get(self, "result_rows")

    @result_rows.setter
    def result_rows(self, value: int):
        pulumi.set(self, "result_rows", value)

    @property
    @pulumi.getter(name="intervalDuration")
    def interval_duration(self) -> Optional[int]:
        """
        Duration of interval for quota in milliseconds.
        """
        return pulumi.get(self, "interval_duration")

    @interval_duration.setter
    def interval_duration(self, value: Optional[int]):
        pulumi.set(self, "interval_duration", value)


if not MYPY:
    class GetMdbClickhouseClusterUserSettingsArgsDict(TypedDict):
        add_http_cors_header: bool
        """
        Include CORS headers in HTTP responces.
        """
        allow_ddl: bool
        """
        Allows or denies DDL queries.
        """
        allow_introspection_functions: bool
        """
        (Optional) Enables introspections functions for query profiling.
        """
        allow_suspicious_low_cardinality_types: bool
        """
        (Optional) Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        """
        any_join_distinct_right_table_keys: bool
        """
        enables legacy ClickHouse server behaviour in ANY INNER|LEFT JOIN operations.
        """
        async_insert: bool
        """
        (Optional) Enables asynchronous inserts. Disabled by default.
        """
        async_insert_busy_timeout: int
        """
        (Optional) The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        """
        async_insert_max_data_size: int
        """
        (Optional) The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        """
        async_insert_stale_timeout: int
        """
        (Optional) The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        """
        async_insert_threads: int
        """
        (Optional) The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        """
        cancel_http_readonly_queries_on_client_close: bool
        """
        (Optional) Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        """
        compile: bool
        """
        Enable compilation of queries.
        """
        compile_expressions: bool
        """
        Turn on expression compilation.
        """
        connect_timeout: int
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        connect_timeout_with_failover: int
        """
        (Optional) The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        """
        count_distinct_implementation: str
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        """
        date_time_input_format: str
        """
        (Optional) Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        """
        date_time_output_format: str
        """
        (Optional) Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        """
        deduplicate_blocks_in_dependent_materialized_views: bool
        """
        Enables or disables the deduplication check for materialized views that receive data from Replicated* tables.
        """
        distinct_overflow_mode: str
        """
        Sets behaviour on overflow when using DISTINCT. Possible values:
        """
        distributed_aggregation_memory_efficient: bool
        """
        Determine the behavior of distributed subqueries.
        """
        distributed_ddl_task_timeout: int
        """
        Timeout for DDL queries, in milliseconds.
        """
        distributed_product_mode: str
        """
        Changes the behaviour of distributed subqueries.
        """
        empty_result_for_aggregation_by_empty_set: bool
        """
        Allows to retunr empty result.
        """
        enable_http_compression: bool
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        fallback_to_stale_replicas_for_distributed_queries: bool
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        flatten_nested: bool
        """
        (Optional) Sets the data format of a nested columns.
        """
        force_index_by_date: bool
        """
        Disables query execution if the index cant be used by date.
        """
        force_primary_key: bool
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        format_regexp: str
        """
        (Optional) Regular expression (for Regexp format).
        """
        format_regexp_skip_unmatched: bool
        """
        (Optional) Skip lines unmatched by regular expression.
        """
        group_by_overflow_mode: str
        """
        Sets behaviour on overflow while GROUP BY operation. Possible values:
        """
        group_by_two_level_threshold: int
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        group_by_two_level_threshold_bytes: int
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        hedged_connection_timeout_ms: int
        """
        (Optional) Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        """
        http_connection_timeout: int
        """
        Timeout for HTTP connection in milliseconds.
        """
        http_headers_progress_interval: int
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        http_receive_timeout: int
        """
        Timeout for HTTP connection in milliseconds.
        """
        http_send_timeout: int
        """
        Timeout for HTTP connection in milliseconds.
        """
        idle_connection_timeout: int
        """
        (Optional) Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        """
        input_format_defaults_for_omitted_fields: bool
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        input_format_import_nested_json: bool
        """
        (Optional) Enables or disables the insertion of JSON data with nested objects.
        """
        input_format_null_as_default: bool
        """
        Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        """
        input_format_parallel_parsing: bool
        """
        (Optional) Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        """
        input_format_values_interpret_expressions: bool
        """
        Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        """
        input_format_with_names_use_header: bool
        """
        Enables or disables checking the column order when inserting data.
        """
        insert_keeper_max_retries: int
        """
        (Optional) The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        """
        insert_null_as_default: bool
        """
        (Optional) Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        """
        insert_quorum: int
        """
        Enables the quorum writes.
        """
        insert_quorum_parallel: bool
        """
        Enables or disables parallelism for quorum INSERT queries.
        """
        insert_quorum_timeout: int
        """
        Write to a quorum timeout in milliseconds.
        """
        join_algorithms: Sequence[str]
        """
        Specifies which JOIN algorithm is used. Possible values:
        """
        join_overflow_mode: str
        """
        Sets behaviour on overflow in JOIN. Possible values:
        """
        join_use_nulls: bool
        """
        Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        joined_subquery_requires_alias: bool
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        load_balancing: str
        """
        (Optional) Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        """
        local_filesystem_read_method: str
        """
        (Optional) Method of reading data from local filesystem. Possible values:
        """
        log_query_threads: bool
        """
        (Optional) Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: true.
        """
        low_cardinality_allow_in_native_format: bool
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        max_ast_depth: int
        """
        Maximum abstract syntax tree depth.
        """
        max_ast_elements: int
        """
        Maximum abstract syntax tree elements.
        """
        max_block_size: int
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        max_bytes_before_external_group_by: int
        """
        Limit in bytes for using memoru for GROUP BY before using swap on disk.
        """
        max_bytes_before_external_sort: int
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        max_bytes_in_distinct: int
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        max_bytes_in_join: int
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        max_bytes_in_set: int
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        max_bytes_to_read: int
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        max_bytes_to_sort: int
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        max_bytes_to_transfer: int
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        max_columns_to_read: int
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        max_concurrent_queries_for_user: int
        """
        (Optional) The maximum number of concurrent requests per user. Default value: 0 (no limit).
        """
        max_execution_time: int
        """
        Limits the maximum query execution time in milliseconds.
        """
        max_expanded_ast_elements: int
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        max_final_threads: int
        """
        (Optional) Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        """
        max_http_get_redirects: int
        """
        (Optional) Limits the maximum number of HTTP GET redirect hops for URL-engine tables. If the parameter is set to 0 (default), no hops is allowed.
        """
        max_insert_block_size: int
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        max_insert_threads: int
        """
        (Optional) The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        """
        max_memory_usage: int
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        max_memory_usage_for_user: int
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        max_network_bandwidth: int
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        max_network_bandwidth_for_user: int
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        max_parser_depth: int
        """
        (Optional) Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        """
        max_query_size: int
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        max_read_buffer_size: int
        """
        (Optional) The maximum size of the buffer to read from the filesystem.
        """
        max_replica_delay_for_distributed_queries: int
        """
        Disables lagging replicas for distributed queries.
        """
        max_result_bytes: int
        """
        Limits the number of bytes in the result.
        """
        max_result_rows: int
        """
        Limits the number of rows in the result.
        """
        max_rows_in_distinct: int
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        max_rows_in_join: int
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        max_rows_in_set: int
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        max_rows_to_group_by: int
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        max_rows_to_read: int
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        max_rows_to_sort: int
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        max_rows_to_transfer: int
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        max_temporary_columns: int
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        max_temporary_data_on_disk_size_for_query: int
        """
        (Optional) The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        """
        max_temporary_data_on_disk_size_for_user: int
        """
        (Optional) The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        """
        max_temporary_non_const_columns: int
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        max_threads: int
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        memory_overcommit_ratio_denominator: int
        """
        (Optional) It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        memory_overcommit_ratio_denominator_for_user: int
        """
        (Optional) It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        memory_profiler_sample_probability: float
        """
        (Optional) Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        """
        memory_profiler_step: int
        """
        (Optional) Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        """
        memory_usage_overcommit_max_wait_microseconds: int
        """
        (Optional) Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        """
        merge_tree_max_bytes_to_use_cache: int
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        """
        merge_tree_max_rows_to_use_cache: int
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        """
        merge_tree_min_bytes_for_concurrent_read: int
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        merge_tree_min_rows_for_concurrent_read: int
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        min_bytes_to_use_direct_io: int
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        min_count_to_compile: int
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        min_count_to_compile_expression: int
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        min_execution_speed: int
        """
        Minimal execution speed in rows per second.
        """
        min_execution_speed_bytes: int
        """
        Minimal execution speed in bytes per second.
        """
        min_insert_block_size_bytes: int
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        min_insert_block_size_rows: int
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        output_format_json_quote64bit_integers: bool
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        output_format_json_quote_denormals: bool
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        prefer_localhost_replica: bool
        """
        (Optional) Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        """
        priority: int
        """
        Query priority.
        """
        quota_mode: str
        """
        Quota accounting mode.
        """
        read_overflow_mode: str
        """
        Sets behaviour on overflow while read. Possible values:
        """
        readonly: int
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        receive_timeout: int
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        remote_filesystem_read_method: str
        """
        (Optional) Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        """
        replication_alter_partitions_sync: int
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        result_overflow_mode: str
        """
        Sets behaviour on overflow in result. Possible values:
        """
        select_sequential_consistency: bool
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        send_progress_in_http_headers: bool
        """
        Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        """
        send_timeout: int
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        set_overflow_mode: str
        """
        Sets behaviour on overflow in the set resulting. Possible values:
        """
        skip_unavailable_shards: bool
        """
        Enables or disables silently skipping of unavailable shards.
        """
        sort_overflow_mode: str
        """
        Sets behaviour on overflow while sort. Possible values:
        """
        timeout_before_checking_execution_speed: int
        """
        (Optional) Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        """
        timeout_overflow_mode: str
        """
        Sets behaviour on overflow. Possible values:
        """
        transfer_overflow_mode: str
        """
        Sets behaviour on overflow. Possible values:
        """
        transform_null_in: bool
        """
        Enables equality of NULL values for IN operator.
        """
        use_hedged_requests: bool
        """
        (Optional) Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        """
        use_uncompressed_cache: bool
        """
        Whether to use a cache of uncompressed blocks.
        """
        wait_for_async_insert: bool
        """
        (Optional) Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        """
        wait_for_async_insert_timeout: int
        """
        (Optional) The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
elif False:
    GetMdbClickhouseClusterUserSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterUserSettingsArgs:
    def __init__(__self__, *,
                 add_http_cors_header: bool,
                 allow_ddl: bool,
                 allow_introspection_functions: bool,
                 allow_suspicious_low_cardinality_types: bool,
                 any_join_distinct_right_table_keys: bool,
                 async_insert: bool,
                 async_insert_busy_timeout: int,
                 async_insert_max_data_size: int,
                 async_insert_stale_timeout: int,
                 async_insert_threads: int,
                 cancel_http_readonly_queries_on_client_close: bool,
                 compile: bool,
                 compile_expressions: bool,
                 connect_timeout: int,
                 connect_timeout_with_failover: int,
                 count_distinct_implementation: str,
                 date_time_input_format: str,
                 date_time_output_format: str,
                 deduplicate_blocks_in_dependent_materialized_views: bool,
                 distinct_overflow_mode: str,
                 distributed_aggregation_memory_efficient: bool,
                 distributed_ddl_task_timeout: int,
                 distributed_product_mode: str,
                 empty_result_for_aggregation_by_empty_set: bool,
                 enable_http_compression: bool,
                 fallback_to_stale_replicas_for_distributed_queries: bool,
                 flatten_nested: bool,
                 force_index_by_date: bool,
                 force_primary_key: bool,
                 format_regexp: str,
                 format_regexp_skip_unmatched: bool,
                 group_by_overflow_mode: str,
                 group_by_two_level_threshold: int,
                 group_by_two_level_threshold_bytes: int,
                 hedged_connection_timeout_ms: int,
                 http_connection_timeout: int,
                 http_headers_progress_interval: int,
                 http_receive_timeout: int,
                 http_send_timeout: int,
                 idle_connection_timeout: int,
                 input_format_defaults_for_omitted_fields: bool,
                 input_format_import_nested_json: bool,
                 input_format_null_as_default: bool,
                 input_format_parallel_parsing: bool,
                 input_format_values_interpret_expressions: bool,
                 input_format_with_names_use_header: bool,
                 insert_keeper_max_retries: int,
                 insert_null_as_default: bool,
                 insert_quorum: int,
                 insert_quorum_parallel: bool,
                 insert_quorum_timeout: int,
                 join_algorithms: Sequence[str],
                 join_overflow_mode: str,
                 join_use_nulls: bool,
                 joined_subquery_requires_alias: bool,
                 load_balancing: str,
                 local_filesystem_read_method: str,
                 log_query_threads: bool,
                 low_cardinality_allow_in_native_format: bool,
                 max_ast_depth: int,
                 max_ast_elements: int,
                 max_block_size: int,
                 max_bytes_before_external_group_by: int,
                 max_bytes_before_external_sort: int,
                 max_bytes_in_distinct: int,
                 max_bytes_in_join: int,
                 max_bytes_in_set: int,
                 max_bytes_to_read: int,
                 max_bytes_to_sort: int,
                 max_bytes_to_transfer: int,
                 max_columns_to_read: int,
                 max_concurrent_queries_for_user: int,
                 max_execution_time: int,
                 max_expanded_ast_elements: int,
                 max_final_threads: int,
                 max_http_get_redirects: int,
                 max_insert_block_size: int,
                 max_insert_threads: int,
                 max_memory_usage: int,
                 max_memory_usage_for_user: int,
                 max_network_bandwidth: int,
                 max_network_bandwidth_for_user: int,
                 max_parser_depth: int,
                 max_query_size: int,
                 max_read_buffer_size: int,
                 max_replica_delay_for_distributed_queries: int,
                 max_result_bytes: int,
                 max_result_rows: int,
                 max_rows_in_distinct: int,
                 max_rows_in_join: int,
                 max_rows_in_set: int,
                 max_rows_to_group_by: int,
                 max_rows_to_read: int,
                 max_rows_to_sort: int,
                 max_rows_to_transfer: int,
                 max_temporary_columns: int,
                 max_temporary_data_on_disk_size_for_query: int,
                 max_temporary_data_on_disk_size_for_user: int,
                 max_temporary_non_const_columns: int,
                 max_threads: int,
                 memory_overcommit_ratio_denominator: int,
                 memory_overcommit_ratio_denominator_for_user: int,
                 memory_profiler_sample_probability: float,
                 memory_profiler_step: int,
                 memory_usage_overcommit_max_wait_microseconds: int,
                 merge_tree_max_bytes_to_use_cache: int,
                 merge_tree_max_rows_to_use_cache: int,
                 merge_tree_min_bytes_for_concurrent_read: int,
                 merge_tree_min_rows_for_concurrent_read: int,
                 min_bytes_to_use_direct_io: int,
                 min_count_to_compile: int,
                 min_count_to_compile_expression: int,
                 min_execution_speed: int,
                 min_execution_speed_bytes: int,
                 min_insert_block_size_bytes: int,
                 min_insert_block_size_rows: int,
                 output_format_json_quote64bit_integers: bool,
                 output_format_json_quote_denormals: bool,
                 prefer_localhost_replica: bool,
                 priority: int,
                 quota_mode: str,
                 read_overflow_mode: str,
                 readonly: int,
                 receive_timeout: int,
                 remote_filesystem_read_method: str,
                 replication_alter_partitions_sync: int,
                 result_overflow_mode: str,
                 select_sequential_consistency: bool,
                 send_progress_in_http_headers: bool,
                 send_timeout: int,
                 set_overflow_mode: str,
                 skip_unavailable_shards: bool,
                 sort_overflow_mode: str,
                 timeout_before_checking_execution_speed: int,
                 timeout_overflow_mode: str,
                 transfer_overflow_mode: str,
                 transform_null_in: bool,
                 use_hedged_requests: bool,
                 use_uncompressed_cache: bool,
                 wait_for_async_insert: bool,
                 wait_for_async_insert_timeout: int):
        """
        :param bool add_http_cors_header: Include CORS headers in HTTP responces.
        :param bool allow_ddl: Allows or denies DDL queries.
        :param bool allow_introspection_functions: (Optional) Enables introspections functions for query profiling.
        :param bool allow_suspicious_low_cardinality_types: (Optional) Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        :param bool any_join_distinct_right_table_keys: enables legacy ClickHouse server behaviour in ANY INNER|LEFT JOIN operations.
        :param bool async_insert: (Optional) Enables asynchronous inserts. Disabled by default.
        :param int async_insert_busy_timeout: (Optional) The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        :param int async_insert_max_data_size: (Optional) The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        :param int async_insert_stale_timeout: (Optional) The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        :param int async_insert_threads: (Optional) The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        :param bool cancel_http_readonly_queries_on_client_close: (Optional) Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        :param bool compile: Enable compilation of queries.
        :param bool compile_expressions: Turn on expression compilation.
        :param int connect_timeout: Connect timeout in milliseconds on the socket used for communicating with the client.
        :param int connect_timeout_with_failover: (Optional) The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        :param str count_distinct_implementation: Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        :param str date_time_input_format: (Optional) Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        :param str date_time_output_format: (Optional) Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        :param bool deduplicate_blocks_in_dependent_materialized_views: Enables or disables the deduplication check for materialized views that receive data from Replicated* tables.
        :param str distinct_overflow_mode: Sets behaviour on overflow when using DISTINCT. Possible values:
        :param bool distributed_aggregation_memory_efficient: Determine the behavior of distributed subqueries.
        :param int distributed_ddl_task_timeout: Timeout for DDL queries, in milliseconds.
        :param str distributed_product_mode: Changes the behaviour of distributed subqueries.
        :param bool empty_result_for_aggregation_by_empty_set: Allows to retunr empty result.
        :param bool enable_http_compression: Enables or disables data compression in the response to an HTTP request.
        :param bool fallback_to_stale_replicas_for_distributed_queries: Forces a query to an out-of-date replica if updated data is not available.
        :param bool flatten_nested: (Optional) Sets the data format of a nested columns.
        :param bool force_index_by_date: Disables query execution if the index cant be used by date.
        :param bool force_primary_key: Disables query execution if indexing by the primary key is not possible.
        :param str format_regexp: (Optional) Regular expression (for Regexp format).
        :param bool format_regexp_skip_unmatched: (Optional) Skip lines unmatched by regular expression.
        :param str group_by_overflow_mode: Sets behaviour on overflow while GROUP BY operation. Possible values:
        :param int group_by_two_level_threshold: Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        :param int group_by_two_level_threshold_bytes: Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        :param int hedged_connection_timeout_ms: (Optional) Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        :param int http_connection_timeout: Timeout for HTTP connection in milliseconds.
        :param int http_headers_progress_interval: Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        :param int http_receive_timeout: Timeout for HTTP connection in milliseconds.
        :param int http_send_timeout: Timeout for HTTP connection in milliseconds.
        :param int idle_connection_timeout: (Optional) Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        :param bool input_format_defaults_for_omitted_fields: When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        :param bool input_format_import_nested_json: (Optional) Enables or disables the insertion of JSON data with nested objects.
        :param bool input_format_null_as_default: Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        :param bool input_format_parallel_parsing: (Optional) Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        :param bool input_format_values_interpret_expressions: Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        :param bool input_format_with_names_use_header: Enables or disables checking the column order when inserting data.
        :param int insert_keeper_max_retries: (Optional) The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        :param bool insert_null_as_default: (Optional) Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        :param int insert_quorum: Enables the quorum writes.
        :param bool insert_quorum_parallel: Enables or disables parallelism for quorum INSERT queries.
        :param int insert_quorum_timeout: Write to a quorum timeout in milliseconds.
        :param Sequence[str] join_algorithms: Specifies which JOIN algorithm is used. Possible values:
        :param str join_overflow_mode: Sets behaviour on overflow in JOIN. Possible values:
        :param bool join_use_nulls: Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        :param bool joined_subquery_requires_alias: Require aliases for subselects and table functions in FROM that more than one table is present.
        :param str load_balancing: (Optional) Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        :param str local_filesystem_read_method: (Optional) Method of reading data from local filesystem. Possible values:
        :param bool log_query_threads: (Optional) Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: true.
        :param bool low_cardinality_allow_in_native_format: Allows or restricts using the LowCardinality data type with the Native format.
        :param int max_ast_depth: Maximum abstract syntax tree depth.
        :param int max_ast_elements: Maximum abstract syntax tree elements.
        :param int max_block_size: A recommendation for what size of the block (in a count of rows) to load from tables.
        :param int max_bytes_before_external_group_by: Limit in bytes for using memoru for GROUP BY before using swap on disk.
        :param int max_bytes_before_external_sort: This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        :param int max_bytes_in_distinct: Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        :param int max_bytes_in_join: Limit on maximum size of the hash table for JOIN, in bytes.
        :param int max_bytes_in_set: Limit on the number of bytes in the set resulting from the execution of the IN section.
        :param int max_bytes_to_read: Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        :param int max_bytes_to_sort: Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        :param int max_bytes_to_transfer: Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param int max_columns_to_read: Limits the maximum number of columns that can be read from a table in a single query.
        :param int max_concurrent_queries_for_user: (Optional) The maximum number of concurrent requests per user. Default value: 0 (no limit).
        :param int max_execution_time: Limits the maximum query execution time in milliseconds.
        :param int max_expanded_ast_elements: Maximum abstract syntax tree depth after after expansion of aliases.
        :param int max_final_threads: (Optional) Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        :param int max_http_get_redirects: (Optional) Limits the maximum number of HTTP GET redirect hops for URL-engine tables. If the parameter is set to 0 (default), no hops is allowed.
        :param int max_insert_block_size: The size of blocks (in a count of rows) to form for insertion into a table.
        :param int max_insert_threads: (Optional) The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        :param int max_memory_usage: Limits the maximum memory usage (in bytes) for processing queries on a single server.
        :param int max_memory_usage_for_user: Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        :param int max_network_bandwidth: Limits the speed of the data exchange over the network in bytes per second.
        :param int max_network_bandwidth_for_user: Limits the speed of the data exchange over the network in bytes per second.
        :param int max_parser_depth: (Optional) Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        :param int max_query_size: The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        :param int max_read_buffer_size: (Optional) The maximum size of the buffer to read from the filesystem.
        :param int max_replica_delay_for_distributed_queries: Disables lagging replicas for distributed queries.
        :param int max_result_bytes: Limits the number of bytes in the result.
        :param int max_result_rows: Limits the number of rows in the result.
        :param int max_rows_in_distinct: Limits the maximum number of different rows when using DISTINCT.
        :param int max_rows_in_join: Limit on maximum size of the hash table for JOIN, in rows.
        :param int max_rows_in_set: Limit on the number of rows in the set resulting from the execution of the IN section.
        :param int max_rows_to_group_by: Limits the maximum number of unique keys received from aggregation function.
        :param int max_rows_to_read: Limits the maximum number of rows that can be read from a table when running a query.
        :param int max_rows_to_sort: Limits the maximum number of rows that can be read from a table for sorting.
        :param int max_rows_to_transfer: Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param int max_temporary_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        :param int max_temporary_data_on_disk_size_for_query: (Optional) The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        :param int max_temporary_data_on_disk_size_for_user: (Optional) The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        :param int max_temporary_non_const_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        :param int max_threads: The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        :param int memory_overcommit_ratio_denominator: (Optional) It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param int memory_overcommit_ratio_denominator_for_user: (Optional) It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param float memory_profiler_sample_probability: (Optional) Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        :param int memory_profiler_step: (Optional) Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        :param int memory_usage_overcommit_max_wait_microseconds: (Optional) Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        :param int merge_tree_max_bytes_to_use_cache: If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        :param int merge_tree_max_rows_to_use_cache: If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        :param int merge_tree_min_bytes_for_concurrent_read: If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        :param int merge_tree_min_rows_for_concurrent_read: If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        :param int min_bytes_to_use_direct_io: The minimum data volume required for using direct I/O access to the storage disk.
        :param int min_count_to_compile: How many times to potentially use a compiled chunk of code before running compilation.
        :param int min_count_to_compile_expression: A query waits for expression compilation process to complete prior to continuing execution.
        :param int min_execution_speed: Minimal execution speed in rows per second.
        :param int min_execution_speed_bytes: Minimal execution speed in bytes per second.
        :param int min_insert_block_size_bytes: Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        :param int min_insert_block_size_rows: Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        :param bool output_format_json_quote64bit_integers: If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        :param bool output_format_json_quote_denormals: Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        :param bool prefer_localhost_replica: (Optional) Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        :param int priority: Query priority.
        :param str quota_mode: Quota accounting mode.
        :param str read_overflow_mode: Sets behaviour on overflow while read. Possible values:
        :param int readonly: Restricts permissions for reading data, write data and change settings queries.
        :param int receive_timeout: Receive timeout in milliseconds on the socket used for communicating with the client.
        :param str remote_filesystem_read_method: (Optional) Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        :param int replication_alter_partitions_sync: For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        :param str result_overflow_mode: Sets behaviour on overflow in result. Possible values:
        :param bool select_sequential_consistency: Enables or disables sequential consistency for SELECT queries.
        :param bool send_progress_in_http_headers: Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        :param int send_timeout: Send timeout in milliseconds on the socket used for communicating with the client.
        :param str set_overflow_mode: Sets behaviour on overflow in the set resulting. Possible values:
        :param bool skip_unavailable_shards: Enables or disables silently skipping of unavailable shards.
        :param str sort_overflow_mode: Sets behaviour on overflow while sort. Possible values:
        :param int timeout_before_checking_execution_speed: (Optional) Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        :param str timeout_overflow_mode: Sets behaviour on overflow. Possible values:
        :param str transfer_overflow_mode: Sets behaviour on overflow. Possible values:
        :param bool transform_null_in: Enables equality of NULL values for IN operator.
        :param bool use_hedged_requests: (Optional) Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        :param bool use_uncompressed_cache: Whether to use a cache of uncompressed blocks.
        :param bool wait_for_async_insert: (Optional) Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        :param int wait_for_async_insert_timeout: (Optional) The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        pulumi.set(__self__, "add_http_cors_header", add_http_cors_header)
        pulumi.set(__self__, "allow_ddl", allow_ddl)
        pulumi.set(__self__, "allow_introspection_functions", allow_introspection_functions)
        pulumi.set(__self__, "allow_suspicious_low_cardinality_types", allow_suspicious_low_cardinality_types)
        pulumi.set(__self__, "any_join_distinct_right_table_keys", any_join_distinct_right_table_keys)
        pulumi.set(__self__, "async_insert", async_insert)
        pulumi.set(__self__, "async_insert_busy_timeout", async_insert_busy_timeout)
        pulumi.set(__self__, "async_insert_max_data_size", async_insert_max_data_size)
        pulumi.set(__self__, "async_insert_stale_timeout", async_insert_stale_timeout)
        pulumi.set(__self__, "async_insert_threads", async_insert_threads)
        pulumi.set(__self__, "cancel_http_readonly_queries_on_client_close", cancel_http_readonly_queries_on_client_close)
        pulumi.set(__self__, "compile", compile)
        pulumi.set(__self__, "compile_expressions", compile_expressions)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "connect_timeout_with_failover", connect_timeout_with_failover)
        pulumi.set(__self__, "count_distinct_implementation", count_distinct_implementation)
        pulumi.set(__self__, "date_time_input_format", date_time_input_format)
        pulumi.set(__self__, "date_time_output_format", date_time_output_format)
        pulumi.set(__self__, "deduplicate_blocks_in_dependent_materialized_views", deduplicate_blocks_in_dependent_materialized_views)
        pulumi.set(__self__, "distinct_overflow_mode", distinct_overflow_mode)
        pulumi.set(__self__, "distributed_aggregation_memory_efficient", distributed_aggregation_memory_efficient)
        pulumi.set(__self__, "distributed_ddl_task_timeout", distributed_ddl_task_timeout)
        pulumi.set(__self__, "distributed_product_mode", distributed_product_mode)
        pulumi.set(__self__, "empty_result_for_aggregation_by_empty_set", empty_result_for_aggregation_by_empty_set)
        pulumi.set(__self__, "enable_http_compression", enable_http_compression)
        pulumi.set(__self__, "fallback_to_stale_replicas_for_distributed_queries", fallback_to_stale_replicas_for_distributed_queries)
        pulumi.set(__self__, "flatten_nested", flatten_nested)
        pulumi.set(__self__, "force_index_by_date", force_index_by_date)
        pulumi.set(__self__, "force_primary_key", force_primary_key)
        pulumi.set(__self__, "format_regexp", format_regexp)
        pulumi.set(__self__, "format_regexp_skip_unmatched", format_regexp_skip_unmatched)
        pulumi.set(__self__, "group_by_overflow_mode", group_by_overflow_mode)
        pulumi.set(__self__, "group_by_two_level_threshold", group_by_two_level_threshold)
        pulumi.set(__self__, "group_by_two_level_threshold_bytes", group_by_two_level_threshold_bytes)
        pulumi.set(__self__, "hedged_connection_timeout_ms", hedged_connection_timeout_ms)
        pulumi.set(__self__, "http_connection_timeout", http_connection_timeout)
        pulumi.set(__self__, "http_headers_progress_interval", http_headers_progress_interval)
        pulumi.set(__self__, "http_receive_timeout", http_receive_timeout)
        pulumi.set(__self__, "http_send_timeout", http_send_timeout)
        pulumi.set(__self__, "idle_connection_timeout", idle_connection_timeout)
        pulumi.set(__self__, "input_format_defaults_for_omitted_fields", input_format_defaults_for_omitted_fields)
        pulumi.set(__self__, "input_format_import_nested_json", input_format_import_nested_json)
        pulumi.set(__self__, "input_format_null_as_default", input_format_null_as_default)
        pulumi.set(__self__, "input_format_parallel_parsing", input_format_parallel_parsing)
        pulumi.set(__self__, "input_format_values_interpret_expressions", input_format_values_interpret_expressions)
        pulumi.set(__self__, "input_format_with_names_use_header", input_format_with_names_use_header)
        pulumi.set(__self__, "insert_keeper_max_retries", insert_keeper_max_retries)
        pulumi.set(__self__, "insert_null_as_default", insert_null_as_default)
        pulumi.set(__self__, "insert_quorum", insert_quorum)
        pulumi.set(__self__, "insert_quorum_parallel", insert_quorum_parallel)
        pulumi.set(__self__, "insert_quorum_timeout", insert_quorum_timeout)
        pulumi.set(__self__, "join_algorithms", join_algorithms)
        pulumi.set(__self__, "join_overflow_mode", join_overflow_mode)
        pulumi.set(__self__, "join_use_nulls", join_use_nulls)
        pulumi.set(__self__, "joined_subquery_requires_alias", joined_subquery_requires_alias)
        pulumi.set(__self__, "load_balancing", load_balancing)
        pulumi.set(__self__, "local_filesystem_read_method", local_filesystem_read_method)
        pulumi.set(__self__, "log_query_threads", log_query_threads)
        pulumi.set(__self__, "low_cardinality_allow_in_native_format", low_cardinality_allow_in_native_format)
        pulumi.set(__self__, "max_ast_depth", max_ast_depth)
        pulumi.set(__self__, "max_ast_elements", max_ast_elements)
        pulumi.set(__self__, "max_block_size", max_block_size)
        pulumi.set(__self__, "max_bytes_before_external_group_by", max_bytes_before_external_group_by)
        pulumi.set(__self__, "max_bytes_before_external_sort", max_bytes_before_external_sort)
        pulumi.set(__self__, "max_bytes_in_distinct", max_bytes_in_distinct)
        pulumi.set(__self__, "max_bytes_in_join", max_bytes_in_join)
        pulumi.set(__self__, "max_bytes_in_set", max_bytes_in_set)
        pulumi.set(__self__, "max_bytes_to_read", max_bytes_to_read)
        pulumi.set(__self__, "max_bytes_to_sort", max_bytes_to_sort)
        pulumi.set(__self__, "max_bytes_to_transfer", max_bytes_to_transfer)
        pulumi.set(__self__, "max_columns_to_read", max_columns_to_read)
        pulumi.set(__self__, "max_concurrent_queries_for_user", max_concurrent_queries_for_user)
        pulumi.set(__self__, "max_execution_time", max_execution_time)
        pulumi.set(__self__, "max_expanded_ast_elements", max_expanded_ast_elements)
        pulumi.set(__self__, "max_final_threads", max_final_threads)
        pulumi.set(__self__, "max_http_get_redirects", max_http_get_redirects)
        pulumi.set(__self__, "max_insert_block_size", max_insert_block_size)
        pulumi.set(__self__, "max_insert_threads", max_insert_threads)
        pulumi.set(__self__, "max_memory_usage", max_memory_usage)
        pulumi.set(__self__, "max_memory_usage_for_user", max_memory_usage_for_user)
        pulumi.set(__self__, "max_network_bandwidth", max_network_bandwidth)
        pulumi.set(__self__, "max_network_bandwidth_for_user", max_network_bandwidth_for_user)
        pulumi.set(__self__, "max_parser_depth", max_parser_depth)
        pulumi.set(__self__, "max_query_size", max_query_size)
        pulumi.set(__self__, "max_read_buffer_size", max_read_buffer_size)
        pulumi.set(__self__, "max_replica_delay_for_distributed_queries", max_replica_delay_for_distributed_queries)
        pulumi.set(__self__, "max_result_bytes", max_result_bytes)
        pulumi.set(__self__, "max_result_rows", max_result_rows)
        pulumi.set(__self__, "max_rows_in_distinct", max_rows_in_distinct)
        pulumi.set(__self__, "max_rows_in_join", max_rows_in_join)
        pulumi.set(__self__, "max_rows_in_set", max_rows_in_set)
        pulumi.set(__self__, "max_rows_to_group_by", max_rows_to_group_by)
        pulumi.set(__self__, "max_rows_to_read", max_rows_to_read)
        pulumi.set(__self__, "max_rows_to_sort", max_rows_to_sort)
        pulumi.set(__self__, "max_rows_to_transfer", max_rows_to_transfer)
        pulumi.set(__self__, "max_temporary_columns", max_temporary_columns)
        pulumi.set(__self__, "max_temporary_data_on_disk_size_for_query", max_temporary_data_on_disk_size_for_query)
        pulumi.set(__self__, "max_temporary_data_on_disk_size_for_user", max_temporary_data_on_disk_size_for_user)
        pulumi.set(__self__, "max_temporary_non_const_columns", max_temporary_non_const_columns)
        pulumi.set(__self__, "max_threads", max_threads)
        pulumi.set(__self__, "memory_overcommit_ratio_denominator", memory_overcommit_ratio_denominator)
        pulumi.set(__self__, "memory_overcommit_ratio_denominator_for_user", memory_overcommit_ratio_denominator_for_user)
        pulumi.set(__self__, "memory_profiler_sample_probability", memory_profiler_sample_probability)
        pulumi.set(__self__, "memory_profiler_step", memory_profiler_step)
        pulumi.set(__self__, "memory_usage_overcommit_max_wait_microseconds", memory_usage_overcommit_max_wait_microseconds)
        pulumi.set(__self__, "merge_tree_max_bytes_to_use_cache", merge_tree_max_bytes_to_use_cache)
        pulumi.set(__self__, "merge_tree_max_rows_to_use_cache", merge_tree_max_rows_to_use_cache)
        pulumi.set(__self__, "merge_tree_min_bytes_for_concurrent_read", merge_tree_min_bytes_for_concurrent_read)
        pulumi.set(__self__, "merge_tree_min_rows_for_concurrent_read", merge_tree_min_rows_for_concurrent_read)
        pulumi.set(__self__, "min_bytes_to_use_direct_io", min_bytes_to_use_direct_io)
        pulumi.set(__self__, "min_count_to_compile", min_count_to_compile)
        pulumi.set(__self__, "min_count_to_compile_expression", min_count_to_compile_expression)
        pulumi.set(__self__, "min_execution_speed", min_execution_speed)
        pulumi.set(__self__, "min_execution_speed_bytes", min_execution_speed_bytes)
        pulumi.set(__self__, "min_insert_block_size_bytes", min_insert_block_size_bytes)
        pulumi.set(__self__, "min_insert_block_size_rows", min_insert_block_size_rows)
        pulumi.set(__self__, "output_format_json_quote64bit_integers", output_format_json_quote64bit_integers)
        pulumi.set(__self__, "output_format_json_quote_denormals", output_format_json_quote_denormals)
        pulumi.set(__self__, "prefer_localhost_replica", prefer_localhost_replica)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "quota_mode", quota_mode)
        pulumi.set(__self__, "read_overflow_mode", read_overflow_mode)
        pulumi.set(__self__, "readonly", readonly)
        pulumi.set(__self__, "receive_timeout", receive_timeout)
        pulumi.set(__self__, "remote_filesystem_read_method", remote_filesystem_read_method)
        pulumi.set(__self__, "replication_alter_partitions_sync", replication_alter_partitions_sync)
        pulumi.set(__self__, "result_overflow_mode", result_overflow_mode)
        pulumi.set(__self__, "select_sequential_consistency", select_sequential_consistency)
        pulumi.set(__self__, "send_progress_in_http_headers", send_progress_in_http_headers)
        pulumi.set(__self__, "send_timeout", send_timeout)
        pulumi.set(__self__, "set_overflow_mode", set_overflow_mode)
        pulumi.set(__self__, "skip_unavailable_shards", skip_unavailable_shards)
        pulumi.set(__self__, "sort_overflow_mode", sort_overflow_mode)
        pulumi.set(__self__, "timeout_before_checking_execution_speed", timeout_before_checking_execution_speed)
        pulumi.set(__self__, "timeout_overflow_mode", timeout_overflow_mode)
        pulumi.set(__self__, "transfer_overflow_mode", transfer_overflow_mode)
        pulumi.set(__self__, "transform_null_in", transform_null_in)
        pulumi.set(__self__, "use_hedged_requests", use_hedged_requests)
        pulumi.set(__self__, "use_uncompressed_cache", use_uncompressed_cache)
        pulumi.set(__self__, "wait_for_async_insert", wait_for_async_insert)
        pulumi.set(__self__, "wait_for_async_insert_timeout", wait_for_async_insert_timeout)

    @property
    @pulumi.getter(name="addHttpCorsHeader")
    def add_http_cors_header(self) -> bool:
        """
        Include CORS headers in HTTP responces.
        """
        return pulumi.get(self, "add_http_cors_header")

    @add_http_cors_header.setter
    def add_http_cors_header(self, value: bool):
        pulumi.set(self, "add_http_cors_header", value)

    @property
    @pulumi.getter(name="allowDdl")
    def allow_ddl(self) -> bool:
        """
        Allows or denies DDL queries.
        """
        return pulumi.get(self, "allow_ddl")

    @allow_ddl.setter
    def allow_ddl(self, value: bool):
        pulumi.set(self, "allow_ddl", value)

    @property
    @pulumi.getter(name="allowIntrospectionFunctions")
    def allow_introspection_functions(self) -> bool:
        """
        (Optional) Enables introspections functions for query profiling.
        """
        return pulumi.get(self, "allow_introspection_functions")

    @allow_introspection_functions.setter
    def allow_introspection_functions(self, value: bool):
        pulumi.set(self, "allow_introspection_functions", value)

    @property
    @pulumi.getter(name="allowSuspiciousLowCardinalityTypes")
    def allow_suspicious_low_cardinality_types(self) -> bool:
        """
        (Optional) Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        """
        return pulumi.get(self, "allow_suspicious_low_cardinality_types")

    @allow_suspicious_low_cardinality_types.setter
    def allow_suspicious_low_cardinality_types(self, value: bool):
        pulumi.set(self, "allow_suspicious_low_cardinality_types", value)

    @property
    @pulumi.getter(name="anyJoinDistinctRightTableKeys")
    def any_join_distinct_right_table_keys(self) -> bool:
        """
        enables legacy ClickHouse server behaviour in ANY INNER|LEFT JOIN operations.
        """
        return pulumi.get(self, "any_join_distinct_right_table_keys")

    @any_join_distinct_right_table_keys.setter
    def any_join_distinct_right_table_keys(self, value: bool):
        pulumi.set(self, "any_join_distinct_right_table_keys", value)

    @property
    @pulumi.getter(name="asyncInsert")
    def async_insert(self) -> bool:
        """
        (Optional) Enables asynchronous inserts. Disabled by default.
        """
        return pulumi.get(self, "async_insert")

    @async_insert.setter
    def async_insert(self, value: bool):
        pulumi.set(self, "async_insert", value)

    @property
    @pulumi.getter(name="asyncInsertBusyTimeout")
    def async_insert_busy_timeout(self) -> int:
        """
        (Optional) The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        """
        return pulumi.get(self, "async_insert_busy_timeout")

    @async_insert_busy_timeout.setter
    def async_insert_busy_timeout(self, value: int):
        pulumi.set(self, "async_insert_busy_timeout", value)

    @property
    @pulumi.getter(name="asyncInsertMaxDataSize")
    def async_insert_max_data_size(self) -> int:
        """
        (Optional) The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        """
        return pulumi.get(self, "async_insert_max_data_size")

    @async_insert_max_data_size.setter
    def async_insert_max_data_size(self, value: int):
        pulumi.set(self, "async_insert_max_data_size", value)

    @property
    @pulumi.getter(name="asyncInsertStaleTimeout")
    def async_insert_stale_timeout(self) -> int:
        """
        (Optional) The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        """
        return pulumi.get(self, "async_insert_stale_timeout")

    @async_insert_stale_timeout.setter
    def async_insert_stale_timeout(self, value: int):
        pulumi.set(self, "async_insert_stale_timeout", value)

    @property
    @pulumi.getter(name="asyncInsertThreads")
    def async_insert_threads(self) -> int:
        """
        (Optional) The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        """
        return pulumi.get(self, "async_insert_threads")

    @async_insert_threads.setter
    def async_insert_threads(self, value: int):
        pulumi.set(self, "async_insert_threads", value)

    @property
    @pulumi.getter(name="cancelHttpReadonlyQueriesOnClientClose")
    def cancel_http_readonly_queries_on_client_close(self) -> bool:
        """
        (Optional) Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        """
        return pulumi.get(self, "cancel_http_readonly_queries_on_client_close")

    @cancel_http_readonly_queries_on_client_close.setter
    def cancel_http_readonly_queries_on_client_close(self, value: bool):
        pulumi.set(self, "cancel_http_readonly_queries_on_client_close", value)

    @property
    @pulumi.getter
    def compile(self) -> bool:
        """
        Enable compilation of queries.
        """
        return pulumi.get(self, "compile")

    @compile.setter
    def compile(self, value: bool):
        pulumi.set(self, "compile", value)

    @property
    @pulumi.getter(name="compileExpressions")
    def compile_expressions(self) -> bool:
        """
        Turn on expression compilation.
        """
        return pulumi.get(self, "compile_expressions")

    @compile_expressions.setter
    def compile_expressions(self, value: bool):
        pulumi.set(self, "compile_expressions", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: int):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="connectTimeoutWithFailover")
    def connect_timeout_with_failover(self) -> int:
        """
        (Optional) The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        """
        return pulumi.get(self, "connect_timeout_with_failover")

    @connect_timeout_with_failover.setter
    def connect_timeout_with_failover(self, value: int):
        pulumi.set(self, "connect_timeout_with_failover", value)

    @property
    @pulumi.getter(name="countDistinctImplementation")
    def count_distinct_implementation(self) -> str:
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        """
        return pulumi.get(self, "count_distinct_implementation")

    @count_distinct_implementation.setter
    def count_distinct_implementation(self, value: str):
        pulumi.set(self, "count_distinct_implementation", value)

    @property
    @pulumi.getter(name="dateTimeInputFormat")
    def date_time_input_format(self) -> str:
        """
        (Optional) Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        """
        return pulumi.get(self, "date_time_input_format")

    @date_time_input_format.setter
    def date_time_input_format(self, value: str):
        pulumi.set(self, "date_time_input_format", value)

    @property
    @pulumi.getter(name="dateTimeOutputFormat")
    def date_time_output_format(self) -> str:
        """
        (Optional) Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        """
        return pulumi.get(self, "date_time_output_format")

    @date_time_output_format.setter
    def date_time_output_format(self, value: str):
        pulumi.set(self, "date_time_output_format", value)

    @property
    @pulumi.getter(name="deduplicateBlocksInDependentMaterializedViews")
    def deduplicate_blocks_in_dependent_materialized_views(self) -> bool:
        """
        Enables or disables the deduplication check for materialized views that receive data from Replicated* tables.
        """
        return pulumi.get(self, "deduplicate_blocks_in_dependent_materialized_views")

    @deduplicate_blocks_in_dependent_materialized_views.setter
    def deduplicate_blocks_in_dependent_materialized_views(self, value: bool):
        pulumi.set(self, "deduplicate_blocks_in_dependent_materialized_views", value)

    @property
    @pulumi.getter(name="distinctOverflowMode")
    def distinct_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow when using DISTINCT. Possible values:
        """
        return pulumi.get(self, "distinct_overflow_mode")

    @distinct_overflow_mode.setter
    def distinct_overflow_mode(self, value: str):
        pulumi.set(self, "distinct_overflow_mode", value)

    @property
    @pulumi.getter(name="distributedAggregationMemoryEfficient")
    def distributed_aggregation_memory_efficient(self) -> bool:
        """
        Determine the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_aggregation_memory_efficient")

    @distributed_aggregation_memory_efficient.setter
    def distributed_aggregation_memory_efficient(self, value: bool):
        pulumi.set(self, "distributed_aggregation_memory_efficient", value)

    @property
    @pulumi.getter(name="distributedDdlTaskTimeout")
    def distributed_ddl_task_timeout(self) -> int:
        """
        Timeout for DDL queries, in milliseconds.
        """
        return pulumi.get(self, "distributed_ddl_task_timeout")

    @distributed_ddl_task_timeout.setter
    def distributed_ddl_task_timeout(self, value: int):
        pulumi.set(self, "distributed_ddl_task_timeout", value)

    @property
    @pulumi.getter(name="distributedProductMode")
    def distributed_product_mode(self) -> str:
        """
        Changes the behaviour of distributed subqueries.
        """
        return pulumi.get(self, "distributed_product_mode")

    @distributed_product_mode.setter
    def distributed_product_mode(self, value: str):
        pulumi.set(self, "distributed_product_mode", value)

    @property
    @pulumi.getter(name="emptyResultForAggregationByEmptySet")
    def empty_result_for_aggregation_by_empty_set(self) -> bool:
        """
        Allows to retunr empty result.
        """
        return pulumi.get(self, "empty_result_for_aggregation_by_empty_set")

    @empty_result_for_aggregation_by_empty_set.setter
    def empty_result_for_aggregation_by_empty_set(self, value: bool):
        pulumi.set(self, "empty_result_for_aggregation_by_empty_set", value)

    @property
    @pulumi.getter(name="enableHttpCompression")
    def enable_http_compression(self) -> bool:
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        return pulumi.get(self, "enable_http_compression")

    @enable_http_compression.setter
    def enable_http_compression(self, value: bool):
        pulumi.set(self, "enable_http_compression", value)

    @property
    @pulumi.getter(name="fallbackToStaleReplicasForDistributedQueries")
    def fallback_to_stale_replicas_for_distributed_queries(self) -> bool:
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        return pulumi.get(self, "fallback_to_stale_replicas_for_distributed_queries")

    @fallback_to_stale_replicas_for_distributed_queries.setter
    def fallback_to_stale_replicas_for_distributed_queries(self, value: bool):
        pulumi.set(self, "fallback_to_stale_replicas_for_distributed_queries", value)

    @property
    @pulumi.getter(name="flattenNested")
    def flatten_nested(self) -> bool:
        """
        (Optional) Sets the data format of a nested columns.
        """
        return pulumi.get(self, "flatten_nested")

    @flatten_nested.setter
    def flatten_nested(self, value: bool):
        pulumi.set(self, "flatten_nested", value)

    @property
    @pulumi.getter(name="forceIndexByDate")
    def force_index_by_date(self) -> bool:
        """
        Disables query execution if the index cant be used by date.
        """
        return pulumi.get(self, "force_index_by_date")

    @force_index_by_date.setter
    def force_index_by_date(self, value: bool):
        pulumi.set(self, "force_index_by_date", value)

    @property
    @pulumi.getter(name="forcePrimaryKey")
    def force_primary_key(self) -> bool:
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        return pulumi.get(self, "force_primary_key")

    @force_primary_key.setter
    def force_primary_key(self, value: bool):
        pulumi.set(self, "force_primary_key", value)

    @property
    @pulumi.getter(name="formatRegexp")
    def format_regexp(self) -> str:
        """
        (Optional) Regular expression (for Regexp format).
        """
        return pulumi.get(self, "format_regexp")

    @format_regexp.setter
    def format_regexp(self, value: str):
        pulumi.set(self, "format_regexp", value)

    @property
    @pulumi.getter(name="formatRegexpSkipUnmatched")
    def format_regexp_skip_unmatched(self) -> bool:
        """
        (Optional) Skip lines unmatched by regular expression.
        """
        return pulumi.get(self, "format_regexp_skip_unmatched")

    @format_regexp_skip_unmatched.setter
    def format_regexp_skip_unmatched(self, value: bool):
        pulumi.set(self, "format_regexp_skip_unmatched", value)

    @property
    @pulumi.getter(name="groupByOverflowMode")
    def group_by_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow while GROUP BY operation. Possible values:
        """
        return pulumi.get(self, "group_by_overflow_mode")

    @group_by_overflow_mode.setter
    def group_by_overflow_mode(self, value: str):
        pulumi.set(self, "group_by_overflow_mode", value)

    @property
    @pulumi.getter(name="groupByTwoLevelThreshold")
    def group_by_two_level_threshold(self) -> int:
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold")

    @group_by_two_level_threshold.setter
    def group_by_two_level_threshold(self, value: int):
        pulumi.set(self, "group_by_two_level_threshold", value)

    @property
    @pulumi.getter(name="groupByTwoLevelThresholdBytes")
    def group_by_two_level_threshold_bytes(self) -> int:
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold_bytes")

    @group_by_two_level_threshold_bytes.setter
    def group_by_two_level_threshold_bytes(self, value: int):
        pulumi.set(self, "group_by_two_level_threshold_bytes", value)

    @property
    @pulumi.getter(name="hedgedConnectionTimeoutMs")
    def hedged_connection_timeout_ms(self) -> int:
        """
        (Optional) Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        """
        return pulumi.get(self, "hedged_connection_timeout_ms")

    @hedged_connection_timeout_ms.setter
    def hedged_connection_timeout_ms(self, value: int):
        pulumi.set(self, "hedged_connection_timeout_ms", value)

    @property
    @pulumi.getter(name="httpConnectionTimeout")
    def http_connection_timeout(self) -> int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_connection_timeout")

    @http_connection_timeout.setter
    def http_connection_timeout(self, value: int):
        pulumi.set(self, "http_connection_timeout", value)

    @property
    @pulumi.getter(name="httpHeadersProgressInterval")
    def http_headers_progress_interval(self) -> int:
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        return pulumi.get(self, "http_headers_progress_interval")

    @http_headers_progress_interval.setter
    def http_headers_progress_interval(self, value: int):
        pulumi.set(self, "http_headers_progress_interval", value)

    @property
    @pulumi.getter(name="httpReceiveTimeout")
    def http_receive_timeout(self) -> int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_receive_timeout")

    @http_receive_timeout.setter
    def http_receive_timeout(self, value: int):
        pulumi.set(self, "http_receive_timeout", value)

    @property
    @pulumi.getter(name="httpSendTimeout")
    def http_send_timeout(self) -> int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_send_timeout")

    @http_send_timeout.setter
    def http_send_timeout(self, value: int):
        pulumi.set(self, "http_send_timeout", value)

    @property
    @pulumi.getter(name="idleConnectionTimeout")
    def idle_connection_timeout(self) -> int:
        """
        (Optional) Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        """
        return pulumi.get(self, "idle_connection_timeout")

    @idle_connection_timeout.setter
    def idle_connection_timeout(self, value: int):
        pulumi.set(self, "idle_connection_timeout", value)

    @property
    @pulumi.getter(name="inputFormatDefaultsForOmittedFields")
    def input_format_defaults_for_omitted_fields(self) -> bool:
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        return pulumi.get(self, "input_format_defaults_for_omitted_fields")

    @input_format_defaults_for_omitted_fields.setter
    def input_format_defaults_for_omitted_fields(self, value: bool):
        pulumi.set(self, "input_format_defaults_for_omitted_fields", value)

    @property
    @pulumi.getter(name="inputFormatImportNestedJson")
    def input_format_import_nested_json(self) -> bool:
        """
        (Optional) Enables or disables the insertion of JSON data with nested objects.
        """
        return pulumi.get(self, "input_format_import_nested_json")

    @input_format_import_nested_json.setter
    def input_format_import_nested_json(self, value: bool):
        pulumi.set(self, "input_format_import_nested_json", value)

    @property
    @pulumi.getter(name="inputFormatNullAsDefault")
    def input_format_null_as_default(self) -> bool:
        """
        Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        """
        return pulumi.get(self, "input_format_null_as_default")

    @input_format_null_as_default.setter
    def input_format_null_as_default(self, value: bool):
        pulumi.set(self, "input_format_null_as_default", value)

    @property
    @pulumi.getter(name="inputFormatParallelParsing")
    def input_format_parallel_parsing(self) -> bool:
        """
        (Optional) Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        """
        return pulumi.get(self, "input_format_parallel_parsing")

    @input_format_parallel_parsing.setter
    def input_format_parallel_parsing(self, value: bool):
        pulumi.set(self, "input_format_parallel_parsing", value)

    @property
    @pulumi.getter(name="inputFormatValuesInterpretExpressions")
    def input_format_values_interpret_expressions(self) -> bool:
        """
        Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        """
        return pulumi.get(self, "input_format_values_interpret_expressions")

    @input_format_values_interpret_expressions.setter
    def input_format_values_interpret_expressions(self, value: bool):
        pulumi.set(self, "input_format_values_interpret_expressions", value)

    @property
    @pulumi.getter(name="inputFormatWithNamesUseHeader")
    def input_format_with_names_use_header(self) -> bool:
        """
        Enables or disables checking the column order when inserting data.
        """
        return pulumi.get(self, "input_format_with_names_use_header")

    @input_format_with_names_use_header.setter
    def input_format_with_names_use_header(self, value: bool):
        pulumi.set(self, "input_format_with_names_use_header", value)

    @property
    @pulumi.getter(name="insertKeeperMaxRetries")
    def insert_keeper_max_retries(self) -> int:
        """
        (Optional) The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        """
        return pulumi.get(self, "insert_keeper_max_retries")

    @insert_keeper_max_retries.setter
    def insert_keeper_max_retries(self, value: int):
        pulumi.set(self, "insert_keeper_max_retries", value)

    @property
    @pulumi.getter(name="insertNullAsDefault")
    def insert_null_as_default(self) -> bool:
        """
        (Optional) Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        """
        return pulumi.get(self, "insert_null_as_default")

    @insert_null_as_default.setter
    def insert_null_as_default(self, value: bool):
        pulumi.set(self, "insert_null_as_default", value)

    @property
    @pulumi.getter(name="insertQuorum")
    def insert_quorum(self) -> int:
        """
        Enables the quorum writes.
        """
        return pulumi.get(self, "insert_quorum")

    @insert_quorum.setter
    def insert_quorum(self, value: int):
        pulumi.set(self, "insert_quorum", value)

    @property
    @pulumi.getter(name="insertQuorumParallel")
    def insert_quorum_parallel(self) -> bool:
        """
        Enables or disables parallelism for quorum INSERT queries.
        """
        return pulumi.get(self, "insert_quorum_parallel")

    @insert_quorum_parallel.setter
    def insert_quorum_parallel(self, value: bool):
        pulumi.set(self, "insert_quorum_parallel", value)

    @property
    @pulumi.getter(name="insertQuorumTimeout")
    def insert_quorum_timeout(self) -> int:
        """
        Write to a quorum timeout in milliseconds.
        """
        return pulumi.get(self, "insert_quorum_timeout")

    @insert_quorum_timeout.setter
    def insert_quorum_timeout(self, value: int):
        pulumi.set(self, "insert_quorum_timeout", value)

    @property
    @pulumi.getter(name="joinAlgorithms")
    def join_algorithms(self) -> Sequence[str]:
        """
        Specifies which JOIN algorithm is used. Possible values:
        """
        return pulumi.get(self, "join_algorithms")

    @join_algorithms.setter
    def join_algorithms(self, value: Sequence[str]):
        pulumi.set(self, "join_algorithms", value)

    @property
    @pulumi.getter(name="joinOverflowMode")
    def join_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow in JOIN. Possible values:
        """
        return pulumi.get(self, "join_overflow_mode")

    @join_overflow_mode.setter
    def join_overflow_mode(self, value: str):
        pulumi.set(self, "join_overflow_mode", value)

    @property
    @pulumi.getter(name="joinUseNulls")
    def join_use_nulls(self) -> bool:
        """
        Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        return pulumi.get(self, "join_use_nulls")

    @join_use_nulls.setter
    def join_use_nulls(self, value: bool):
        pulumi.set(self, "join_use_nulls", value)

    @property
    @pulumi.getter(name="joinedSubqueryRequiresAlias")
    def joined_subquery_requires_alias(self) -> bool:
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        return pulumi.get(self, "joined_subquery_requires_alias")

    @joined_subquery_requires_alias.setter
    def joined_subquery_requires_alias(self, value: bool):
        pulumi.set(self, "joined_subquery_requires_alias", value)

    @property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> str:
        """
        (Optional) Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        """
        return pulumi.get(self, "load_balancing")

    @load_balancing.setter
    def load_balancing(self, value: str):
        pulumi.set(self, "load_balancing", value)

    @property
    @pulumi.getter(name="localFilesystemReadMethod")
    def local_filesystem_read_method(self) -> str:
        """
        (Optional) Method of reading data from local filesystem. Possible values:
        """
        return pulumi.get(self, "local_filesystem_read_method")

    @local_filesystem_read_method.setter
    def local_filesystem_read_method(self, value: str):
        pulumi.set(self, "local_filesystem_read_method", value)

    @property
    @pulumi.getter(name="logQueryThreads")
    def log_query_threads(self) -> bool:
        """
        (Optional) Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: true.
        """
        return pulumi.get(self, "log_query_threads")

    @log_query_threads.setter
    def log_query_threads(self, value: bool):
        pulumi.set(self, "log_query_threads", value)

    @property
    @pulumi.getter(name="lowCardinalityAllowInNativeFormat")
    def low_cardinality_allow_in_native_format(self) -> bool:
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        return pulumi.get(self, "low_cardinality_allow_in_native_format")

    @low_cardinality_allow_in_native_format.setter
    def low_cardinality_allow_in_native_format(self, value: bool):
        pulumi.set(self, "low_cardinality_allow_in_native_format", value)

    @property
    @pulumi.getter(name="maxAstDepth")
    def max_ast_depth(self) -> int:
        """
        Maximum abstract syntax tree depth.
        """
        return pulumi.get(self, "max_ast_depth")

    @max_ast_depth.setter
    def max_ast_depth(self, value: int):
        pulumi.set(self, "max_ast_depth", value)

    @property
    @pulumi.getter(name="maxAstElements")
    def max_ast_elements(self) -> int:
        """
        Maximum abstract syntax tree elements.
        """
        return pulumi.get(self, "max_ast_elements")

    @max_ast_elements.setter
    def max_ast_elements(self, value: int):
        pulumi.set(self, "max_ast_elements", value)

    @property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> int:
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        return pulumi.get(self, "max_block_size")

    @max_block_size.setter
    def max_block_size(self, value: int):
        pulumi.set(self, "max_block_size", value)

    @property
    @pulumi.getter(name="maxBytesBeforeExternalGroupBy")
    def max_bytes_before_external_group_by(self) -> int:
        """
        Limit in bytes for using memoru for GROUP BY before using swap on disk.
        """
        return pulumi.get(self, "max_bytes_before_external_group_by")

    @max_bytes_before_external_group_by.setter
    def max_bytes_before_external_group_by(self, value: int):
        pulumi.set(self, "max_bytes_before_external_group_by", value)

    @property
    @pulumi.getter(name="maxBytesBeforeExternalSort")
    def max_bytes_before_external_sort(self) -> int:
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        return pulumi.get(self, "max_bytes_before_external_sort")

    @max_bytes_before_external_sort.setter
    def max_bytes_before_external_sort(self, value: int):
        pulumi.set(self, "max_bytes_before_external_sort", value)

    @property
    @pulumi.getter(name="maxBytesInDistinct")
    def max_bytes_in_distinct(self) -> int:
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        return pulumi.get(self, "max_bytes_in_distinct")

    @max_bytes_in_distinct.setter
    def max_bytes_in_distinct(self, value: int):
        pulumi.set(self, "max_bytes_in_distinct", value)

    @property
    @pulumi.getter(name="maxBytesInJoin")
    def max_bytes_in_join(self) -> int:
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        return pulumi.get(self, "max_bytes_in_join")

    @max_bytes_in_join.setter
    def max_bytes_in_join(self, value: int):
        pulumi.set(self, "max_bytes_in_join", value)

    @property
    @pulumi.getter(name="maxBytesInSet")
    def max_bytes_in_set(self) -> int:
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_bytes_in_set")

    @max_bytes_in_set.setter
    def max_bytes_in_set(self, value: int):
        pulumi.set(self, "max_bytes_in_set", value)

    @property
    @pulumi.getter(name="maxBytesToRead")
    def max_bytes_to_read(self) -> int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_bytes_to_read")

    @max_bytes_to_read.setter
    def max_bytes_to_read(self, value: int):
        pulumi.set(self, "max_bytes_to_read", value)

    @property
    @pulumi.getter(name="maxBytesToSort")
    def max_bytes_to_sort(self) -> int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_bytes_to_sort")

    @max_bytes_to_sort.setter
    def max_bytes_to_sort(self, value: int):
        pulumi.set(self, "max_bytes_to_sort", value)

    @property
    @pulumi.getter(name="maxBytesToTransfer")
    def max_bytes_to_transfer(self) -> int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_bytes_to_transfer")

    @max_bytes_to_transfer.setter
    def max_bytes_to_transfer(self, value: int):
        pulumi.set(self, "max_bytes_to_transfer", value)

    @property
    @pulumi.getter(name="maxColumnsToRead")
    def max_columns_to_read(self) -> int:
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        return pulumi.get(self, "max_columns_to_read")

    @max_columns_to_read.setter
    def max_columns_to_read(self, value: int):
        pulumi.set(self, "max_columns_to_read", value)

    @property
    @pulumi.getter(name="maxConcurrentQueriesForUser")
    def max_concurrent_queries_for_user(self) -> int:
        """
        (Optional) The maximum number of concurrent requests per user. Default value: 0 (no limit).
        """
        return pulumi.get(self, "max_concurrent_queries_for_user")

    @max_concurrent_queries_for_user.setter
    def max_concurrent_queries_for_user(self, value: int):
        pulumi.set(self, "max_concurrent_queries_for_user", value)

    @property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> int:
        """
        Limits the maximum query execution time in milliseconds.
        """
        return pulumi.get(self, "max_execution_time")

    @max_execution_time.setter
    def max_execution_time(self, value: int):
        pulumi.set(self, "max_execution_time", value)

    @property
    @pulumi.getter(name="maxExpandedAstElements")
    def max_expanded_ast_elements(self) -> int:
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        return pulumi.get(self, "max_expanded_ast_elements")

    @max_expanded_ast_elements.setter
    def max_expanded_ast_elements(self, value: int):
        pulumi.set(self, "max_expanded_ast_elements", value)

    @property
    @pulumi.getter(name="maxFinalThreads")
    def max_final_threads(self) -> int:
        """
        (Optional) Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        """
        return pulumi.get(self, "max_final_threads")

    @max_final_threads.setter
    def max_final_threads(self, value: int):
        pulumi.set(self, "max_final_threads", value)

    @property
    @pulumi.getter(name="maxHttpGetRedirects")
    def max_http_get_redirects(self) -> int:
        """
        (Optional) Limits the maximum number of HTTP GET redirect hops for URL-engine tables. If the parameter is set to 0 (default), no hops is allowed.
        """
        return pulumi.get(self, "max_http_get_redirects")

    @max_http_get_redirects.setter
    def max_http_get_redirects(self, value: int):
        pulumi.set(self, "max_http_get_redirects", value)

    @property
    @pulumi.getter(name="maxInsertBlockSize")
    def max_insert_block_size(self) -> int:
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        return pulumi.get(self, "max_insert_block_size")

    @max_insert_block_size.setter
    def max_insert_block_size(self, value: int):
        pulumi.set(self, "max_insert_block_size", value)

    @property
    @pulumi.getter(name="maxInsertThreads")
    def max_insert_threads(self) -> int:
        """
        (Optional) The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        """
        return pulumi.get(self, "max_insert_threads")

    @max_insert_threads.setter
    def max_insert_threads(self, value: int):
        pulumi.set(self, "max_insert_threads", value)

    @property
    @pulumi.getter(name="maxMemoryUsage")
    def max_memory_usage(self) -> int:
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage")

    @max_memory_usage.setter
    def max_memory_usage(self, value: int):
        pulumi.set(self, "max_memory_usage", value)

    @property
    @pulumi.getter(name="maxMemoryUsageForUser")
    def max_memory_usage_for_user(self) -> int:
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage_for_user")

    @max_memory_usage_for_user.setter
    def max_memory_usage_for_user(self, value: int):
        pulumi.set(self, "max_memory_usage_for_user", value)

    @property
    @pulumi.getter(name="maxNetworkBandwidth")
    def max_network_bandwidth(self) -> int:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth")

    @max_network_bandwidth.setter
    def max_network_bandwidth(self, value: int):
        pulumi.set(self, "max_network_bandwidth", value)

    @property
    @pulumi.getter(name="maxNetworkBandwidthForUser")
    def max_network_bandwidth_for_user(self) -> int:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth_for_user")

    @max_network_bandwidth_for_user.setter
    def max_network_bandwidth_for_user(self, value: int):
        pulumi.set(self, "max_network_bandwidth_for_user", value)

    @property
    @pulumi.getter(name="maxParserDepth")
    def max_parser_depth(self) -> int:
        """
        (Optional) Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        """
        return pulumi.get(self, "max_parser_depth")

    @max_parser_depth.setter
    def max_parser_depth(self, value: int):
        pulumi.set(self, "max_parser_depth", value)

    @property
    @pulumi.getter(name="maxQuerySize")
    def max_query_size(self) -> int:
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        return pulumi.get(self, "max_query_size")

    @max_query_size.setter
    def max_query_size(self, value: int):
        pulumi.set(self, "max_query_size", value)

    @property
    @pulumi.getter(name="maxReadBufferSize")
    def max_read_buffer_size(self) -> int:
        """
        (Optional) The maximum size of the buffer to read from the filesystem.
        """
        return pulumi.get(self, "max_read_buffer_size")

    @max_read_buffer_size.setter
    def max_read_buffer_size(self, value: int):
        pulumi.set(self, "max_read_buffer_size", value)

    @property
    @pulumi.getter(name="maxReplicaDelayForDistributedQueries")
    def max_replica_delay_for_distributed_queries(self) -> int:
        """
        Disables lagging replicas for distributed queries.
        """
        return pulumi.get(self, "max_replica_delay_for_distributed_queries")

    @max_replica_delay_for_distributed_queries.setter
    def max_replica_delay_for_distributed_queries(self, value: int):
        pulumi.set(self, "max_replica_delay_for_distributed_queries", value)

    @property
    @pulumi.getter(name="maxResultBytes")
    def max_result_bytes(self) -> int:
        """
        Limits the number of bytes in the result.
        """
        return pulumi.get(self, "max_result_bytes")

    @max_result_bytes.setter
    def max_result_bytes(self, value: int):
        pulumi.set(self, "max_result_bytes", value)

    @property
    @pulumi.getter(name="maxResultRows")
    def max_result_rows(self) -> int:
        """
        Limits the number of rows in the result.
        """
        return pulumi.get(self, "max_result_rows")

    @max_result_rows.setter
    def max_result_rows(self, value: int):
        pulumi.set(self, "max_result_rows", value)

    @property
    @pulumi.getter(name="maxRowsInDistinct")
    def max_rows_in_distinct(self) -> int:
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        return pulumi.get(self, "max_rows_in_distinct")

    @max_rows_in_distinct.setter
    def max_rows_in_distinct(self, value: int):
        pulumi.set(self, "max_rows_in_distinct", value)

    @property
    @pulumi.getter(name="maxRowsInJoin")
    def max_rows_in_join(self) -> int:
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        return pulumi.get(self, "max_rows_in_join")

    @max_rows_in_join.setter
    def max_rows_in_join(self, value: int):
        pulumi.set(self, "max_rows_in_join", value)

    @property
    @pulumi.getter(name="maxRowsInSet")
    def max_rows_in_set(self) -> int:
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_rows_in_set")

    @max_rows_in_set.setter
    def max_rows_in_set(self, value: int):
        pulumi.set(self, "max_rows_in_set", value)

    @property
    @pulumi.getter(name="maxRowsToGroupBy")
    def max_rows_to_group_by(self) -> int:
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        return pulumi.get(self, "max_rows_to_group_by")

    @max_rows_to_group_by.setter
    def max_rows_to_group_by(self, value: int):
        pulumi.set(self, "max_rows_to_group_by", value)

    @property
    @pulumi.getter(name="maxRowsToRead")
    def max_rows_to_read(self) -> int:
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_rows_to_read")

    @max_rows_to_read.setter
    def max_rows_to_read(self, value: int):
        pulumi.set(self, "max_rows_to_read", value)

    @property
    @pulumi.getter(name="maxRowsToSort")
    def max_rows_to_sort(self) -> int:
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_rows_to_sort")

    @max_rows_to_sort.setter
    def max_rows_to_sort(self, value: int):
        pulumi.set(self, "max_rows_to_sort", value)

    @property
    @pulumi.getter(name="maxRowsToTransfer")
    def max_rows_to_transfer(self) -> int:
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_rows_to_transfer")

    @max_rows_to_transfer.setter
    def max_rows_to_transfer(self, value: int):
        pulumi.set(self, "max_rows_to_transfer", value)

    @property
    @pulumi.getter(name="maxTemporaryColumns")
    def max_temporary_columns(self) -> int:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        return pulumi.get(self, "max_temporary_columns")

    @max_temporary_columns.setter
    def max_temporary_columns(self, value: int):
        pulumi.set(self, "max_temporary_columns", value)

    @property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForQuery")
    def max_temporary_data_on_disk_size_for_query(self) -> int:
        """
        (Optional) The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_query")

    @max_temporary_data_on_disk_size_for_query.setter
    def max_temporary_data_on_disk_size_for_query(self, value: int):
        pulumi.set(self, "max_temporary_data_on_disk_size_for_query", value)

    @property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForUser")
    def max_temporary_data_on_disk_size_for_user(self) -> int:
        """
        (Optional) The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_user")

    @max_temporary_data_on_disk_size_for_user.setter
    def max_temporary_data_on_disk_size_for_user(self, value: int):
        pulumi.set(self, "max_temporary_data_on_disk_size_for_user", value)

    @property
    @pulumi.getter(name="maxTemporaryNonConstColumns")
    def max_temporary_non_const_columns(self) -> int:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        return pulumi.get(self, "max_temporary_non_const_columns")

    @max_temporary_non_const_columns.setter
    def max_temporary_non_const_columns(self, value: int):
        pulumi.set(self, "max_temporary_non_const_columns", value)

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> int:
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        return pulumi.get(self, "max_threads")

    @max_threads.setter
    def max_threads(self, value: int):
        pulumi.set(self, "max_threads", value)

    @property
    @pulumi.getter(name="memoryOvercommitRatioDenominator")
    def memory_overcommit_ratio_denominator(self) -> int:
        """
        (Optional) It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator")

    @memory_overcommit_ratio_denominator.setter
    def memory_overcommit_ratio_denominator(self, value: int):
        pulumi.set(self, "memory_overcommit_ratio_denominator", value)

    @property
    @pulumi.getter(name="memoryOvercommitRatioDenominatorForUser")
    def memory_overcommit_ratio_denominator_for_user(self) -> int:
        """
        (Optional) It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator_for_user")

    @memory_overcommit_ratio_denominator_for_user.setter
    def memory_overcommit_ratio_denominator_for_user(self, value: int):
        pulumi.set(self, "memory_overcommit_ratio_denominator_for_user", value)

    @property
    @pulumi.getter(name="memoryProfilerSampleProbability")
    def memory_profiler_sample_probability(self) -> float:
        """
        (Optional) Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        """
        return pulumi.get(self, "memory_profiler_sample_probability")

    @memory_profiler_sample_probability.setter
    def memory_profiler_sample_probability(self, value: float):
        pulumi.set(self, "memory_profiler_sample_probability", value)

    @property
    @pulumi.getter(name="memoryProfilerStep")
    def memory_profiler_step(self) -> int:
        """
        (Optional) Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        """
        return pulumi.get(self, "memory_profiler_step")

    @memory_profiler_step.setter
    def memory_profiler_step(self, value: int):
        pulumi.set(self, "memory_profiler_step", value)

    @property
    @pulumi.getter(name="memoryUsageOvercommitMaxWaitMicroseconds")
    def memory_usage_overcommit_max_wait_microseconds(self) -> int:
        """
        (Optional) Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        """
        return pulumi.get(self, "memory_usage_overcommit_max_wait_microseconds")

    @memory_usage_overcommit_max_wait_microseconds.setter
    def memory_usage_overcommit_max_wait_microseconds(self, value: int):
        pulumi.set(self, "memory_usage_overcommit_max_wait_microseconds", value)

    @property
    @pulumi.getter(name="mergeTreeMaxBytesToUseCache")
    def merge_tree_max_bytes_to_use_cache(self) -> int:
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_bytes_to_use_cache")

    @merge_tree_max_bytes_to_use_cache.setter
    def merge_tree_max_bytes_to_use_cache(self, value: int):
        pulumi.set(self, "merge_tree_max_bytes_to_use_cache", value)

    @property
    @pulumi.getter(name="mergeTreeMaxRowsToUseCache")
    def merge_tree_max_rows_to_use_cache(self) -> int:
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_rows_to_use_cache")

    @merge_tree_max_rows_to_use_cache.setter
    def merge_tree_max_rows_to_use_cache(self, value: int):
        pulumi.set(self, "merge_tree_max_rows_to_use_cache", value)

    @property
    @pulumi.getter(name="mergeTreeMinBytesForConcurrentRead")
    def merge_tree_min_bytes_for_concurrent_read(self) -> int:
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        return pulumi.get(self, "merge_tree_min_bytes_for_concurrent_read")

    @merge_tree_min_bytes_for_concurrent_read.setter
    def merge_tree_min_bytes_for_concurrent_read(self, value: int):
        pulumi.set(self, "merge_tree_min_bytes_for_concurrent_read", value)

    @property
    @pulumi.getter(name="mergeTreeMinRowsForConcurrentRead")
    def merge_tree_min_rows_for_concurrent_read(self) -> int:
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        return pulumi.get(self, "merge_tree_min_rows_for_concurrent_read")

    @merge_tree_min_rows_for_concurrent_read.setter
    def merge_tree_min_rows_for_concurrent_read(self, value: int):
        pulumi.set(self, "merge_tree_min_rows_for_concurrent_read", value)

    @property
    @pulumi.getter(name="minBytesToUseDirectIo")
    def min_bytes_to_use_direct_io(self) -> int:
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        return pulumi.get(self, "min_bytes_to_use_direct_io")

    @min_bytes_to_use_direct_io.setter
    def min_bytes_to_use_direct_io(self, value: int):
        pulumi.set(self, "min_bytes_to_use_direct_io", value)

    @property
    @pulumi.getter(name="minCountToCompile")
    def min_count_to_compile(self) -> int:
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        return pulumi.get(self, "min_count_to_compile")

    @min_count_to_compile.setter
    def min_count_to_compile(self, value: int):
        pulumi.set(self, "min_count_to_compile", value)

    @property
    @pulumi.getter(name="minCountToCompileExpression")
    def min_count_to_compile_expression(self) -> int:
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        return pulumi.get(self, "min_count_to_compile_expression")

    @min_count_to_compile_expression.setter
    def min_count_to_compile_expression(self, value: int):
        pulumi.set(self, "min_count_to_compile_expression", value)

    @property
    @pulumi.getter(name="minExecutionSpeed")
    def min_execution_speed(self) -> int:
        """
        Minimal execution speed in rows per second.
        """
        return pulumi.get(self, "min_execution_speed")

    @min_execution_speed.setter
    def min_execution_speed(self, value: int):
        pulumi.set(self, "min_execution_speed", value)

    @property
    @pulumi.getter(name="minExecutionSpeedBytes")
    def min_execution_speed_bytes(self) -> int:
        """
        Minimal execution speed in bytes per second.
        """
        return pulumi.get(self, "min_execution_speed_bytes")

    @min_execution_speed_bytes.setter
    def min_execution_speed_bytes(self, value: int):
        pulumi.set(self, "min_execution_speed_bytes", value)

    @property
    @pulumi.getter(name="minInsertBlockSizeBytes")
    def min_insert_block_size_bytes(self) -> int:
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_bytes")

    @min_insert_block_size_bytes.setter
    def min_insert_block_size_bytes(self, value: int):
        pulumi.set(self, "min_insert_block_size_bytes", value)

    @property
    @pulumi.getter(name="minInsertBlockSizeRows")
    def min_insert_block_size_rows(self) -> int:
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_rows")

    @min_insert_block_size_rows.setter
    def min_insert_block_size_rows(self, value: int):
        pulumi.set(self, "min_insert_block_size_rows", value)

    @property
    @pulumi.getter(name="outputFormatJsonQuote64bitIntegers")
    def output_format_json_quote64bit_integers(self) -> bool:
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        return pulumi.get(self, "output_format_json_quote64bit_integers")

    @output_format_json_quote64bit_integers.setter
    def output_format_json_quote64bit_integers(self, value: bool):
        pulumi.set(self, "output_format_json_quote64bit_integers", value)

    @property
    @pulumi.getter(name="outputFormatJsonQuoteDenormals")
    def output_format_json_quote_denormals(self) -> bool:
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        return pulumi.get(self, "output_format_json_quote_denormals")

    @output_format_json_quote_denormals.setter
    def output_format_json_quote_denormals(self, value: bool):
        pulumi.set(self, "output_format_json_quote_denormals", value)

    @property
    @pulumi.getter(name="preferLocalhostReplica")
    def prefer_localhost_replica(self) -> bool:
        """
        (Optional) Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        """
        return pulumi.get(self, "prefer_localhost_replica")

    @prefer_localhost_replica.setter
    def prefer_localhost_replica(self, value: bool):
        pulumi.set(self, "prefer_localhost_replica", value)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Query priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: int):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="quotaMode")
    def quota_mode(self) -> str:
        """
        Quota accounting mode.
        """
        return pulumi.get(self, "quota_mode")

    @quota_mode.setter
    def quota_mode(self, value: str):
        pulumi.set(self, "quota_mode", value)

    @property
    @pulumi.getter(name="readOverflowMode")
    def read_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow while read. Possible values:
        """
        return pulumi.get(self, "read_overflow_mode")

    @read_overflow_mode.setter
    def read_overflow_mode(self, value: str):
        pulumi.set(self, "read_overflow_mode", value)

    @property
    @pulumi.getter
    def readonly(self) -> int:
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: int):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> int:
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "receive_timeout")

    @receive_timeout.setter
    def receive_timeout(self, value: int):
        pulumi.set(self, "receive_timeout", value)

    @property
    @pulumi.getter(name="remoteFilesystemReadMethod")
    def remote_filesystem_read_method(self) -> str:
        """
        (Optional) Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        """
        return pulumi.get(self, "remote_filesystem_read_method")

    @remote_filesystem_read_method.setter
    def remote_filesystem_read_method(self, value: str):
        pulumi.set(self, "remote_filesystem_read_method", value)

    @property
    @pulumi.getter(name="replicationAlterPartitionsSync")
    def replication_alter_partitions_sync(self) -> int:
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        return pulumi.get(self, "replication_alter_partitions_sync")

    @replication_alter_partitions_sync.setter
    def replication_alter_partitions_sync(self, value: int):
        pulumi.set(self, "replication_alter_partitions_sync", value)

    @property
    @pulumi.getter(name="resultOverflowMode")
    def result_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow in result. Possible values:
        """
        return pulumi.get(self, "result_overflow_mode")

    @result_overflow_mode.setter
    def result_overflow_mode(self, value: str):
        pulumi.set(self, "result_overflow_mode", value)

    @property
    @pulumi.getter(name="selectSequentialConsistency")
    def select_sequential_consistency(self) -> bool:
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        return pulumi.get(self, "select_sequential_consistency")

    @select_sequential_consistency.setter
    def select_sequential_consistency(self, value: bool):
        pulumi.set(self, "select_sequential_consistency", value)

    @property
    @pulumi.getter(name="sendProgressInHttpHeaders")
    def send_progress_in_http_headers(self) -> bool:
        """
        Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        """
        return pulumi.get(self, "send_progress_in_http_headers")

    @send_progress_in_http_headers.setter
    def send_progress_in_http_headers(self, value: bool):
        pulumi.set(self, "send_progress_in_http_headers", value)

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> int:
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "send_timeout")

    @send_timeout.setter
    def send_timeout(self, value: int):
        pulumi.set(self, "send_timeout", value)

    @property
    @pulumi.getter(name="setOverflowMode")
    def set_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow in the set resulting. Possible values:
        """
        return pulumi.get(self, "set_overflow_mode")

    @set_overflow_mode.setter
    def set_overflow_mode(self, value: str):
        pulumi.set(self, "set_overflow_mode", value)

    @property
    @pulumi.getter(name="skipUnavailableShards")
    def skip_unavailable_shards(self) -> bool:
        """
        Enables or disables silently skipping of unavailable shards.
        """
        return pulumi.get(self, "skip_unavailable_shards")

    @skip_unavailable_shards.setter
    def skip_unavailable_shards(self, value: bool):
        pulumi.set(self, "skip_unavailable_shards", value)

    @property
    @pulumi.getter(name="sortOverflowMode")
    def sort_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow while sort. Possible values:
        """
        return pulumi.get(self, "sort_overflow_mode")

    @sort_overflow_mode.setter
    def sort_overflow_mode(self, value: str):
        pulumi.set(self, "sort_overflow_mode", value)

    @property
    @pulumi.getter(name="timeoutBeforeCheckingExecutionSpeed")
    def timeout_before_checking_execution_speed(self) -> int:
        """
        (Optional) Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        """
        return pulumi.get(self, "timeout_before_checking_execution_speed")

    @timeout_before_checking_execution_speed.setter
    def timeout_before_checking_execution_speed(self, value: int):
        pulumi.set(self, "timeout_before_checking_execution_speed", value)

    @property
    @pulumi.getter(name="timeoutOverflowMode")
    def timeout_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "timeout_overflow_mode")

    @timeout_overflow_mode.setter
    def timeout_overflow_mode(self, value: str):
        pulumi.set(self, "timeout_overflow_mode", value)

    @property
    @pulumi.getter(name="transferOverflowMode")
    def transfer_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "transfer_overflow_mode")

    @transfer_overflow_mode.setter
    def transfer_overflow_mode(self, value: str):
        pulumi.set(self, "transfer_overflow_mode", value)

    @property
    @pulumi.getter(name="transformNullIn")
    def transform_null_in(self) -> bool:
        """
        Enables equality of NULL values for IN operator.
        """
        return pulumi.get(self, "transform_null_in")

    @transform_null_in.setter
    def transform_null_in(self, value: bool):
        pulumi.set(self, "transform_null_in", value)

    @property
    @pulumi.getter(name="useHedgedRequests")
    def use_hedged_requests(self) -> bool:
        """
        (Optional) Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        """
        return pulumi.get(self, "use_hedged_requests")

    @use_hedged_requests.setter
    def use_hedged_requests(self, value: bool):
        pulumi.set(self, "use_hedged_requests", value)

    @property
    @pulumi.getter(name="useUncompressedCache")
    def use_uncompressed_cache(self) -> bool:
        """
        Whether to use a cache of uncompressed blocks.
        """
        return pulumi.get(self, "use_uncompressed_cache")

    @use_uncompressed_cache.setter
    def use_uncompressed_cache(self, value: bool):
        pulumi.set(self, "use_uncompressed_cache", value)

    @property
    @pulumi.getter(name="waitForAsyncInsert")
    def wait_for_async_insert(self) -> bool:
        """
        (Optional) Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        """
        return pulumi.get(self, "wait_for_async_insert")

    @wait_for_async_insert.setter
    def wait_for_async_insert(self, value: bool):
        pulumi.set(self, "wait_for_async_insert", value)

    @property
    @pulumi.getter(name="waitForAsyncInsertTimeout")
    def wait_for_async_insert_timeout(self) -> int:
        """
        (Optional) The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        return pulumi.get(self, "wait_for_async_insert_timeout")

    @wait_for_async_insert_timeout.setter
    def wait_for_async_insert_timeout(self, value: int):
        pulumi.set(self, "wait_for_async_insert_timeout", value)


if not MYPY:
    class GetMdbClickhouseClusterZookeeperArgsDict(TypedDict):
        resources: 'GetMdbClickhouseClusterZookeeperResourcesArgsDict'
        """
        Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
elif False:
    GetMdbClickhouseClusterZookeeperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterZookeeperArgs:
    def __init__(__self__, *,
                 resources: 'GetMdbClickhouseClusterZookeeperResourcesArgs'):
        """
        :param 'GetMdbClickhouseClusterZookeeperResourcesArgs' resources: Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'GetMdbClickhouseClusterZookeeperResourcesArgs':
        """
        Resources allocated to hosts of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: 'GetMdbClickhouseClusterZookeeperResourcesArgs'):
        pulumi.set(self, "resources", value)


if not MYPY:
    class GetMdbClickhouseClusterZookeeperResourcesArgsDict(TypedDict):
        disk_size: int
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: str
        """
        Type of the storage of hosts.
        """
        resource_preset_id: str
elif False:
    GetMdbClickhouseClusterZookeeperResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbClickhouseClusterZookeeperResourcesArgs:
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: int):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: str):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: str):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbGreenplumClusterBackgroundActivityArgsDict(TypedDict):
        analyze_and_vacuums: Sequence['GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict']
        """
        (Optional) Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        """
        query_killer_idle_in_transactions: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict']
        """
        (Optional) block to configure script that kills long running queries that are in `idle in transaction` state.
        """
        query_killer_idles: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict']
        """
        (Optional) Block to configure script that kills long running queries that are in `idle` state.
        """
        query_killer_long_runnings: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict']
        """
        (Optional) block to configure script that kills long running queries (in any state).
        """
elif False:
    GetMdbGreenplumClusterBackgroundActivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterBackgroundActivityArgs:
    def __init__(__self__, *,
                 analyze_and_vacuums: Sequence['GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs'],
                 query_killer_idle_in_transactions: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs'],
                 query_killer_idles: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs'],
                 query_killer_long_runnings: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']):
        """
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs'] analyze_and_vacuums: (Optional) Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs'] query_killer_idle_in_transactions: (Optional) block to configure script that kills long running queries that are in `idle in transaction` state.
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs'] query_killer_idles: (Optional) Block to configure script that kills long running queries that are in `idle` state.
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs'] query_killer_long_runnings: (Optional) block to configure script that kills long running queries (in any state).
        """
        pulumi.set(__self__, "analyze_and_vacuums", analyze_and_vacuums)
        pulumi.set(__self__, "query_killer_idle_in_transactions", query_killer_idle_in_transactions)
        pulumi.set(__self__, "query_killer_idles", query_killer_idles)
        pulumi.set(__self__, "query_killer_long_runnings", query_killer_long_runnings)

    @property
    @pulumi.getter(name="analyzeAndVacuums")
    def analyze_and_vacuums(self) -> Sequence['GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs']:
        """
        (Optional) Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        """
        return pulumi.get(self, "analyze_and_vacuums")

    @analyze_and_vacuums.setter
    def analyze_and_vacuums(self, value: Sequence['GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs']):
        pulumi.set(self, "analyze_and_vacuums", value)

    @property
    @pulumi.getter(name="queryKillerIdleInTransactions")
    def query_killer_idle_in_transactions(self) -> Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs']:
        """
        (Optional) block to configure script that kills long running queries that are in `idle in transaction` state.
        """
        return pulumi.get(self, "query_killer_idle_in_transactions")

    @query_killer_idle_in_transactions.setter
    def query_killer_idle_in_transactions(self, value: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs']):
        pulumi.set(self, "query_killer_idle_in_transactions", value)

    @property
    @pulumi.getter(name="queryKillerIdles")
    def query_killer_idles(self) -> Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs']:
        """
        (Optional) Block to configure script that kills long running queries that are in `idle` state.
        """
        return pulumi.get(self, "query_killer_idles")

    @query_killer_idles.setter
    def query_killer_idles(self, value: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs']):
        pulumi.set(self, "query_killer_idles", value)

    @property
    @pulumi.getter(name="queryKillerLongRunnings")
    def query_killer_long_runnings(self) -> Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']:
        """
        (Optional) block to configure script that kills long running queries (in any state).
        """
        return pulumi.get(self, "query_killer_long_runnings")

    @query_killer_long_runnings.setter
    def query_killer_long_runnings(self, value: Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs']):
        pulumi.set(self, "query_killer_long_runnings", value)


if not MYPY:
    class GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict(TypedDict):
        analyze_timeout: int
        """
        Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        """
        start_time: str
        """
        Time of day in 'HH:MM' format when scripts should run.
        """
        vacuum_timeout: int
        """
        Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
elif False:
    GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs:
    def __init__(__self__, *,
                 analyze_timeout: int,
                 start_time: str,
                 vacuum_timeout: int):
        """
        :param int analyze_timeout: Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        :param str start_time: Time of day in 'HH:MM' format when scripts should run.
        :param int vacuum_timeout: Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        pulumi.set(__self__, "analyze_timeout", analyze_timeout)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "vacuum_timeout", vacuum_timeout)

    @property
    @pulumi.getter(name="analyzeTimeout")
    def analyze_timeout(self) -> int:
        """
        Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        """
        return pulumi.get(self, "analyze_timeout")

    @analyze_timeout.setter
    def analyze_timeout(self, value: int):
        pulumi.set(self, "analyze_timeout", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Time of day in 'HH:MM' format when scripts should run.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: str):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="vacuumTimeout")
    def vacuum_timeout(self) -> int:
        """
        Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        return pulumi.get(self, "vacuum_timeout")

    @vacuum_timeout.setter
    def vacuum_timeout(self, value: int):
        pulumi.set(self, "vacuum_timeout", value)


if not MYPY:
    class GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict(TypedDict):
        enable: bool
        """
        Flag that indicates whether script is enabled.
        """
        ignore_users: Sequence[str]
        """
        List of users to ignore when considering queries to terminate.
        """
        max_age: int
        """
        Maximum duration for this type of queries (in seconds).
        """
elif False:
    GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs:
    def __init__(__self__, *,
                 enable: bool,
                 ignore_users: Sequence[str],
                 max_age: int):
        """
        :param bool enable: Flag that indicates whether script is enabled.
        :param Sequence[str] ignore_users: List of users to ignore when considering queries to terminate.
        :param int max_age: Maximum duration for this type of queries (in seconds).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "ignore_users", ignore_users)
        pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: bool):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Sequence[str]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @ignore_users.setter
    def ignore_users(self, value: Sequence[str]):
        pulumi.set(self, "ignore_users", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: int):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict(TypedDict):
        enable: bool
        """
        Flag that indicates whether script is enabled.
        """
        ignore_users: Sequence[str]
        """
        List of users to ignore when considering queries to terminate.
        """
        max_age: int
        """
        Maximum duration for this type of queries (in seconds).
        """
elif False:
    GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs:
    def __init__(__self__, *,
                 enable: bool,
                 ignore_users: Sequence[str],
                 max_age: int):
        """
        :param bool enable: Flag that indicates whether script is enabled.
        :param Sequence[str] ignore_users: List of users to ignore when considering queries to terminate.
        :param int max_age: Maximum duration for this type of queries (in seconds).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "ignore_users", ignore_users)
        pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: bool):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Sequence[str]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @ignore_users.setter
    def ignore_users(self, value: Sequence[str]):
        pulumi.set(self, "ignore_users", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: int):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict(TypedDict):
        enable: bool
        """
        Flag that indicates whether script is enabled.
        """
        ignore_users: Sequence[str]
        """
        List of users to ignore when considering queries to terminate.
        """
        max_age: int
        """
        Maximum duration for this type of queries (in seconds).
        """
elif False:
    GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs:
    def __init__(__self__, *,
                 enable: bool,
                 ignore_users: Sequence[str],
                 max_age: int):
        """
        :param bool enable: Flag that indicates whether script is enabled.
        :param Sequence[str] ignore_users: List of users to ignore when considering queries to terminate.
        :param int max_age: Maximum duration for this type of queries (in seconds).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "ignore_users", ignore_users)
        pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: bool):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Sequence[str]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @ignore_users.setter
    def ignore_users(self, value: Sequence[str]):
        pulumi.set(self, "ignore_users", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> int:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: int):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class GetMdbGreenplumClusterPoolerConfigArgsDict(TypedDict):
        pool_client_idle_timeout: NotRequired[int]
        """
        Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        """
        pool_size: NotRequired[int]
        """
        Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        """
        pooling_mode: NotRequired[str]
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
elif False:
    GetMdbGreenplumClusterPoolerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterPoolerConfigArgs:
    def __init__(__self__, *,
                 pool_client_idle_timeout: Optional[int] = None,
                 pool_size: Optional[int] = None,
                 pooling_mode: Optional[str] = None):
        """
        :param int pool_client_idle_timeout: Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        :param int pool_size: Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        :param str pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        if pool_client_idle_timeout is not None:
            pulumi.set(__self__, "pool_client_idle_timeout", pool_client_idle_timeout)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="poolClientIdleTimeout")
    def pool_client_idle_timeout(self) -> Optional[int]:
        """
        Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        """
        return pulumi.get(self, "pool_client_idle_timeout")

    @pool_client_idle_timeout.setter
    def pool_client_idle_timeout(self, value: Optional[int]):
        pulumi.set(self, "pool_client_idle_timeout", value)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[int]:
        """
        Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        """
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[int]):
        pulumi.set(self, "pool_size", value)

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[str]:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")

    @pooling_mode.setter
    def pooling_mode(self, value: Optional[str]):
        pulumi.set(self, "pooling_mode", value)


if not MYPY:
    class GetMdbGreenplumClusterPxfConfigArgsDict(TypedDict):
        connection_timeout: NotRequired[int]
        """
        The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        """
        max_threads: NotRequired[int]
        """
        The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        """
        pool_allow_core_thread_timeout: NotRequired[bool]
        """
        Identifies whether or not core streaming threads are allowed to time out.
        """
        pool_core_size: NotRequired[int]
        """
        The number of core streaming threads. Value is between 1 and 1024.
        """
        pool_max_size: NotRequired[int]
        """
        The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        """
        pool_queue_capacity: NotRequired[int]
        """
        The capacity of the core streaming thread pool queue. Value is positive.
        """
        upload_timeout: NotRequired[int]
        """
        The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        """
        xms: NotRequired[int]
        """
        Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        xmx: NotRequired[int]
        """
        Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
elif False:
    GetMdbGreenplumClusterPxfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbGreenplumClusterPxfConfigArgs:
    def __init__(__self__, *,
                 connection_timeout: Optional[int] = None,
                 max_threads: Optional[int] = None,
                 pool_allow_core_thread_timeout: Optional[bool] = None,
                 pool_core_size: Optional[int] = None,
                 pool_max_size: Optional[int] = None,
                 pool_queue_capacity: Optional[int] = None,
                 upload_timeout: Optional[int] = None,
                 xms: Optional[int] = None,
                 xmx: Optional[int] = None):
        """
        :param int connection_timeout: The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        :param int max_threads: The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        :param bool pool_allow_core_thread_timeout: Identifies whether or not core streaming threads are allowed to time out.
        :param int pool_core_size: The number of core streaming threads. Value is between 1 and 1024.
        :param int pool_max_size: The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        :param int pool_queue_capacity: The capacity of the core streaming thread pool queue. Value is positive.
        :param int upload_timeout: The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        :param int xms: Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        :param int xmx: Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if pool_allow_core_thread_timeout is not None:
            pulumi.set(__self__, "pool_allow_core_thread_timeout", pool_allow_core_thread_timeout)
        if pool_core_size is not None:
            pulumi.set(__self__, "pool_core_size", pool_core_size)
        if pool_max_size is not None:
            pulumi.set(__self__, "pool_max_size", pool_max_size)
        if pool_queue_capacity is not None:
            pulumi.set(__self__, "pool_queue_capacity", pool_queue_capacity)
        if upload_timeout is not None:
            pulumi.set(__self__, "upload_timeout", upload_timeout)
        if xms is not None:
            pulumi.set(__self__, "xms", xms)
        if xmx is not None:
            pulumi.set(__self__, "xmx", xmx)

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[int]:
        """
        The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[int]):
        pulumi.set(self, "connection_timeout", value)

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[int]:
        """
        The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "max_threads")

    @max_threads.setter
    def max_threads(self, value: Optional[int]):
        pulumi.set(self, "max_threads", value)

    @property
    @pulumi.getter(name="poolAllowCoreThreadTimeout")
    def pool_allow_core_thread_timeout(self) -> Optional[bool]:
        """
        Identifies whether or not core streaming threads are allowed to time out.
        """
        return pulumi.get(self, "pool_allow_core_thread_timeout")

    @pool_allow_core_thread_timeout.setter
    def pool_allow_core_thread_timeout(self, value: Optional[bool]):
        pulumi.set(self, "pool_allow_core_thread_timeout", value)

    @property
    @pulumi.getter(name="poolCoreSize")
    def pool_core_size(self) -> Optional[int]:
        """
        The number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_core_size")

    @pool_core_size.setter
    def pool_core_size(self, value: Optional[int]):
        pulumi.set(self, "pool_core_size", value)

    @property
    @pulumi.getter(name="poolMaxSize")
    def pool_max_size(self) -> Optional[int]:
        """
        The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_max_size")

    @pool_max_size.setter
    def pool_max_size(self, value: Optional[int]):
        pulumi.set(self, "pool_max_size", value)

    @property
    @pulumi.getter(name="poolQueueCapacity")
    def pool_queue_capacity(self) -> Optional[int]:
        """
        The capacity of the core streaming thread pool queue. Value is positive.
        """
        return pulumi.get(self, "pool_queue_capacity")

    @pool_queue_capacity.setter
    def pool_queue_capacity(self, value: Optional[int]):
        pulumi.set(self, "pool_queue_capacity", value)

    @property
    @pulumi.getter(name="uploadTimeout")
    def upload_timeout(self) -> Optional[int]:
        """
        The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "upload_timeout")

    @upload_timeout.setter
    def upload_timeout(self, value: Optional[int]):
        pulumi.set(self, "upload_timeout", value)

    @property
    @pulumi.getter
    def xms(self) -> Optional[int]:
        """
        Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xms")

    @xms.setter
    def xms(self, value: Optional[int]):
        pulumi.set(self, "xms", value)

    @property
    @pulumi.getter
    def xmx(self) -> Optional[int]:
        """
        Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xmx")

    @xmx.setter
    def xmx(self, value: Optional[int]):
        pulumi.set(self, "xmx", value)


if not MYPY:
    class GetMdbKafkaClusterConfigArgsDict(TypedDict):
        access: 'GetMdbKafkaClusterConfigAccessArgsDict'
        """
        (Optional) Access policy to the Kafka cluster. The structure is documented below.
        """
        disk_size_autoscaling: 'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgsDict'
        """
        Disk autoscaling settings of the Kafka cluster. The structure is documented below.
        """
        kafka: 'GetMdbKafkaClusterConfigKafkaArgsDict'
        """
        (Optional) Configuration of the Kafka subcluster. The structure is documented below.
        """
        kraft: 'GetMdbKafkaClusterConfigKraftArgsDict'
        """
        (Optional) Configuration of the KRaft-controller subcluster. The structure is documented below.
        """
        version: str
        """
        (Required) Version of the Kafka server software.
        """
        zones: Sequence[str]
        """
        (Optional) List of availability zones.
        """
        zookeeper: 'GetMdbKafkaClusterConfigZookeeperArgsDict'
        """
        (Optional) Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        assign_public_ip: NotRequired[bool]
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        brokers_count: NotRequired[int]
        """
        (Optional) Count of brokers per availability zone.
        """
        schema_registry: NotRequired[bool]
        """
        (Optional) Enables managed schema registry on cluster. Can be either `true` or `false`.
        """
        unmanaged_topics: NotRequired[bool]
elif False:
    GetMdbKafkaClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigArgs:
    def __init__(__self__, *,
                 access: 'GetMdbKafkaClusterConfigAccessArgs',
                 disk_size_autoscaling: 'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs',
                 kafka: 'GetMdbKafkaClusterConfigKafkaArgs',
                 kraft: 'GetMdbKafkaClusterConfigKraftArgs',
                 version: str,
                 zones: Sequence[str],
                 zookeeper: 'GetMdbKafkaClusterConfigZookeeperArgs',
                 assign_public_ip: Optional[bool] = None,
                 brokers_count: Optional[int] = None,
                 schema_registry: Optional[bool] = None,
                 unmanaged_topics: Optional[bool] = None):
        """
        :param 'GetMdbKafkaClusterConfigAccessArgs' access: (Optional) Access policy to the Kafka cluster. The structure is documented below.
        :param 'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs' disk_size_autoscaling: Disk autoscaling settings of the Kafka cluster. The structure is documented below.
        :param 'GetMdbKafkaClusterConfigKafkaArgs' kafka: (Optional) Configuration of the Kafka subcluster. The structure is documented below.
        :param 'GetMdbKafkaClusterConfigKraftArgs' kraft: (Optional) Configuration of the KRaft-controller subcluster. The structure is documented below.
        :param str version: (Required) Version of the Kafka server software.
        :param Sequence[str] zones: (Optional) List of availability zones.
        :param 'GetMdbKafkaClusterConfigZookeeperArgs' zookeeper: (Optional) Configuration of the ZooKeeper subcluster. The structure is documented below.
        :param bool assign_public_ip: The flag that defines whether a public IP address is assigned to the node.
        :param int brokers_count: (Optional) Count of brokers per availability zone.
        :param bool schema_registry: (Optional) Enables managed schema registry on cluster. Can be either `true` or `false`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "disk_size_autoscaling", disk_size_autoscaling)
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "kraft", kraft)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zones", zones)
        pulumi.set(__self__, "zookeeper", zookeeper)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if brokers_count is not None:
            pulumi.set(__self__, "brokers_count", brokers_count)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if unmanaged_topics is not None:
            warnings.warn("""The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""", DeprecationWarning)
            pulumi.log.warn("""unmanaged_topics is deprecated: The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""")
        if unmanaged_topics is not None:
            pulumi.set(__self__, "unmanaged_topics", unmanaged_topics)

    @property
    @pulumi.getter
    def access(self) -> 'GetMdbKafkaClusterConfigAccessArgs':
        """
        (Optional) Access policy to the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: 'GetMdbKafkaClusterConfigAccessArgs'):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="diskSizeAutoscaling")
    def disk_size_autoscaling(self) -> 'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs':
        """
        Disk autoscaling settings of the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "disk_size_autoscaling")

    @disk_size_autoscaling.setter
    def disk_size_autoscaling(self, value: 'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs'):
        pulumi.set(self, "disk_size_autoscaling", value)

    @property
    @pulumi.getter
    def kafka(self) -> 'GetMdbKafkaClusterConfigKafkaArgs':
        """
        (Optional) Configuration of the Kafka subcluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: 'GetMdbKafkaClusterConfigKafkaArgs'):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter
    def kraft(self) -> 'GetMdbKafkaClusterConfigKraftArgs':
        """
        (Optional) Configuration of the KRaft-controller subcluster. The structure is documented below.
        """
        return pulumi.get(self, "kraft")

    @kraft.setter
    def kraft(self, value: 'GetMdbKafkaClusterConfigKraftArgs'):
        pulumi.set(self, "kraft", value)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        (Required) Version of the Kafka server software.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: str):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        (Optional) List of availability zones.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Sequence[str]):
        pulumi.set(self, "zones", value)

    @property
    @pulumi.getter
    def zookeeper(self) -> 'GetMdbKafkaClusterConfigZookeeperArgs':
        """
        (Optional) Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "zookeeper")

    @zookeeper.setter
    def zookeeper(self, value: 'GetMdbKafkaClusterConfigZookeeperArgs'):
        pulumi.set(self, "zookeeper", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[bool]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="brokersCount")
    def brokers_count(self) -> Optional[int]:
        """
        (Optional) Count of brokers per availability zone.
        """
        return pulumi.get(self, "brokers_count")

    @brokers_count.setter
    def brokers_count(self, value: Optional[int]):
        pulumi.set(self, "brokers_count", value)

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[bool]:
        """
        (Optional) Enables managed schema registry on cluster. Can be either `true` or `false`.
        """
        return pulumi.get(self, "schema_registry")

    @schema_registry.setter
    def schema_registry(self, value: Optional[bool]):
        pulumi.set(self, "schema_registry", value)

    @property
    @pulumi.getter(name="unmanagedTopics")
    @_utilities.deprecated("""The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""")
    def unmanaged_topics(self) -> Optional[bool]:
        return pulumi.get(self, "unmanaged_topics")

    @unmanaged_topics.setter
    def unmanaged_topics(self, value: Optional[bool]):
        pulumi.set(self, "unmanaged_topics", value)


if not MYPY:
    class GetMdbKafkaClusterConfigAccessArgsDict(TypedDict):
        data_transfer: NotRequired[bool]
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
elif False:
    GetMdbKafkaClusterConfigAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigAccessArgs:
    def __init__(__self__, *,
                 data_transfer: Optional[bool] = None):
        """
        :param bool data_transfer: Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[bool]:
        """
        Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[bool]):
        pulumi.set(self, "data_transfer", value)


if not MYPY:
    class GetMdbKafkaClusterConfigDiskSizeAutoscalingArgsDict(TypedDict):
        disk_size_limit: int
        """
        Maximum possible size of disk in bytes.
        """
        emergency_usage_threshold: NotRequired[int]
        """
        Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned_usage_threshold' value.
        """
        planned_usage_threshold: NotRequired[int]
        """
        Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled)
        """
elif False:
    GetMdbKafkaClusterConfigDiskSizeAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs:
    def __init__(__self__, *,
                 disk_size_limit: int,
                 emergency_usage_threshold: Optional[int] = None,
                 planned_usage_threshold: Optional[int] = None):
        """
        :param int disk_size_limit: Maximum possible size of disk in bytes.
        :param int emergency_usage_threshold: Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned_usage_threshold' value.
        :param int planned_usage_threshold: Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled)
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> int:
        """
        Maximum possible size of disk in bytes.
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: int):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[int]:
        """
        Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned_usage_threshold' value.
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[int]:
        """
        Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled)
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class GetMdbKafkaClusterConfigKafkaArgsDict(TypedDict):
        resources: 'GetMdbKafkaClusterConfigKafkaResourcesArgsDict'
        """
        (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        kafka_config: NotRequired['GetMdbKafkaClusterConfigKafkaKafkaConfigArgsDict']
        """
        (Optional) User-defined settings for the Kafka cluster. The structure is documented below.
        """
elif False:
    GetMdbKafkaClusterConfigKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigKafkaArgs:
    def __init__(__self__, *,
                 resources: 'GetMdbKafkaClusterConfigKafkaResourcesArgs',
                 kafka_config: Optional['GetMdbKafkaClusterConfigKafkaKafkaConfigArgs'] = None):
        """
        :param 'GetMdbKafkaClusterConfigKafkaResourcesArgs' resources: (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        :param 'GetMdbKafkaClusterConfigKafkaKafkaConfigArgs' kafka_config: (Optional) User-defined settings for the Kafka cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)
        if kafka_config is not None:
            pulumi.set(__self__, "kafka_config", kafka_config)

    @property
    @pulumi.getter
    def resources(self) -> 'GetMdbKafkaClusterConfigKafkaResourcesArgs':
        """
        (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: 'GetMdbKafkaClusterConfigKafkaResourcesArgs'):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="kafkaConfig")
    def kafka_config(self) -> Optional['GetMdbKafkaClusterConfigKafkaKafkaConfigArgs']:
        """
        (Optional) User-defined settings for the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka_config")

    @kafka_config.setter
    def kafka_config(self, value: Optional['GetMdbKafkaClusterConfigKafkaKafkaConfigArgs']):
        pulumi.set(self, "kafka_config", value)


if not MYPY:
    class GetMdbKafkaClusterConfigKafkaKafkaConfigArgsDict(TypedDict):
        auto_create_topics_enable: NotRequired[bool]
        compression_type: NotRequired[str]
        """
        , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        default_replication_factor: NotRequired[str]
        log_flush_interval_messages: NotRequired[str]
        log_flush_interval_ms: NotRequired[str]
        log_flush_scheduler_interval_ms: NotRequired[str]
        log_preallocate: NotRequired[bool]
        log_retention_bytes: NotRequired[str]
        log_retention_hours: NotRequired[str]
        log_retention_minutes: NotRequired[str]
        log_retention_ms: NotRequired[str]
        log_segment_bytes: NotRequired[str]
        message_max_bytes: NotRequired[str]
        num_partitions: NotRequired[str]
        offsets_retention_minutes: NotRequired[str]
        replica_fetch_max_bytes: NotRequired[str]
        sasl_enabled_mechanisms: NotRequired[Sequence[str]]
        socket_receive_buffer_bytes: NotRequired[str]
        socket_send_buffer_bytes: NotRequired[str]
        ssl_cipher_suites: NotRequired[Sequence[str]]
elif False:
    GetMdbKafkaClusterConfigKafkaKafkaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigKafkaKafkaConfigArgs:
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[bool] = None,
                 compression_type: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_flush_scheduler_interval_ms: Optional[str] = None,
                 log_preallocate: Optional[bool] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_minutes: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 message_max_bytes: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 offsets_retention_minutes: Optional[str] = None,
                 replica_fetch_max_bytes: Optional[str] = None,
                 sasl_enabled_mechanisms: Optional[Sequence[str]] = None,
                 socket_receive_buffer_bytes: Optional[str] = None,
                 socket_send_buffer_bytes: Optional[str] = None,
                 ssl_cipher_suites: Optional[Sequence[str]] = None):
        """
        :param str compression_type: , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_flush_scheduler_interval_ms is not None:
            pulumi.set(__self__, "log_flush_scheduler_interval_ms", log_flush_scheduler_interval_ms)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_minutes is not None:
            pulumi.set(__self__, "log_retention_minutes", log_retention_minutes)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if sasl_enabled_mechanisms is not None:
            pulumi.set(__self__, "sasl_enabled_mechanisms", sasl_enabled_mechanisms)
        if socket_receive_buffer_bytes is not None:
            pulumi.set(__self__, "socket_receive_buffer_bytes", socket_receive_buffer_bytes)
        if socket_send_buffer_bytes is not None:
            pulumi.set(__self__, "socket_send_buffer_bytes", socket_send_buffer_bytes)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[bool]:
        return pulumi.get(self, "auto_create_topics_enable")

    @auto_create_topics_enable.setter
    def auto_create_topics_enable(self, value: Optional[bool]):
        pulumi.set(self, "auto_create_topics_enable", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[str]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @default_replication_factor.setter
    def default_replication_factor(self, value: Optional[str]):
        pulumi.set(self, "default_replication_factor", value)

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @log_flush_interval_messages.setter
    def log_flush_interval_messages(self, value: Optional[str]):
        pulumi.set(self, "log_flush_interval_messages", value)

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @log_flush_interval_ms.setter
    def log_flush_interval_ms(self, value: Optional[str]):
        pulumi.set(self, "log_flush_interval_ms", value)

    @property
    @pulumi.getter(name="logFlushSchedulerIntervalMs")
    def log_flush_scheduler_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_scheduler_interval_ms")

    @log_flush_scheduler_interval_ms.setter
    def log_flush_scheduler_interval_ms(self, value: Optional[str]):
        pulumi.set(self, "log_flush_scheduler_interval_ms", value)

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "log_preallocate")

    @log_preallocate.setter
    def log_preallocate(self, value: Optional[bool]):
        pulumi.set(self, "log_preallocate", value)

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @log_retention_bytes.setter
    def log_retention_bytes(self, value: Optional[str]):
        pulumi.set(self, "log_retention_bytes", value)

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @log_retention_hours.setter
    def log_retention_hours(self, value: Optional[str]):
        pulumi.set(self, "log_retention_hours", value)

    @property
    @pulumi.getter(name="logRetentionMinutes")
    def log_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_minutes")

    @log_retention_minutes.setter
    def log_retention_minutes(self, value: Optional[str]):
        pulumi.set(self, "log_retention_minutes", value)

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @log_retention_ms.setter
    def log_retention_ms(self, value: Optional[str]):
        pulumi.set(self, "log_retention_ms", value)

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @log_segment_bytes.setter
    def log_segment_bytes(self, value: Optional[str]):
        pulumi.set(self, "log_segment_bytes", value)

    @property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "message_max_bytes")

    @message_max_bytes.setter
    def message_max_bytes(self, value: Optional[str]):
        pulumi.set(self, "message_max_bytes", value)

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @num_partitions.setter
    def num_partitions(self, value: Optional[str]):
        pulumi.set(self, "num_partitions", value)

    @property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "offsets_retention_minutes")

    @offsets_retention_minutes.setter
    def offsets_retention_minutes(self, value: Optional[str]):
        pulumi.set(self, "offsets_retention_minutes", value)

    @property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[str]:
        return pulumi.get(self, "replica_fetch_max_bytes")

    @replica_fetch_max_bytes.setter
    def replica_fetch_max_bytes(self, value: Optional[str]):
        pulumi.set(self, "replica_fetch_max_bytes", value)

    @property
    @pulumi.getter(name="saslEnabledMechanisms")
    def sasl_enabled_mechanisms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "sasl_enabled_mechanisms")

    @sasl_enabled_mechanisms.setter
    def sasl_enabled_mechanisms(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "sasl_enabled_mechanisms", value)

    @property
    @pulumi.getter(name="socketReceiveBufferBytes")
    def socket_receive_buffer_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_receive_buffer_bytes")

    @socket_receive_buffer_bytes.setter
    def socket_receive_buffer_bytes(self, value: Optional[str]):
        pulumi.set(self, "socket_receive_buffer_bytes", value)

    @property
    @pulumi.getter(name="socketSendBufferBytes")
    def socket_send_buffer_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_send_buffer_bytes")

    @socket_send_buffer_bytes.setter
    def socket_send_buffer_bytes(self, value: Optional[str]):
        pulumi.set(self, "socket_send_buffer_bytes", value)

    @property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssl_cipher_suites")

    @ssl_cipher_suites.setter
    def ssl_cipher_suites(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssl_cipher_suites", value)


if not MYPY:
    class GetMdbKafkaClusterConfigKafkaResourcesArgsDict(TypedDict):
        disk_size: int
        """
        (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        disk_type_id: str
        """
        (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        resource_preset_id: str
elif False:
    GetMdbKafkaClusterConfigKafkaResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigKafkaResourcesArgs:
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param str disk_type_id: (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: int):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: str):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: str):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbKafkaClusterConfigKraftArgsDict(TypedDict):
        resources: 'GetMdbKafkaClusterConfigKraftResourcesArgsDict'
        """
        (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
elif False:
    GetMdbKafkaClusterConfigKraftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigKraftArgs:
    def __init__(__self__, *,
                 resources: 'GetMdbKafkaClusterConfigKraftResourcesArgs'):
        """
        :param 'GetMdbKafkaClusterConfigKraftResourcesArgs' resources: (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'GetMdbKafkaClusterConfigKraftResourcesArgs':
        """
        (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: 'GetMdbKafkaClusterConfigKraftResourcesArgs'):
        pulumi.set(self, "resources", value)


if not MYPY:
    class GetMdbKafkaClusterConfigKraftResourcesArgsDict(TypedDict):
        disk_size: int
        """
        (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        disk_type_id: str
        """
        (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        resource_preset_id: str
elif False:
    GetMdbKafkaClusterConfigKraftResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigKraftResourcesArgs:
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param str disk_type_id: (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: int):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: str):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: str):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbKafkaClusterConfigZookeeperArgsDict(TypedDict):
        resources: 'GetMdbKafkaClusterConfigZookeeperResourcesArgsDict'
        """
        (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
elif False:
    GetMdbKafkaClusterConfigZookeeperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigZookeeperArgs:
    def __init__(__self__, *,
                 resources: 'GetMdbKafkaClusterConfigZookeeperResourcesArgs'):
        """
        :param 'GetMdbKafkaClusterConfigZookeeperResourcesArgs' resources: (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'GetMdbKafkaClusterConfigZookeeperResourcesArgs':
        """
        (Optional) Resources allocated to hosts of the KRaft-controller subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: 'GetMdbKafkaClusterConfigZookeeperResourcesArgs'):
        pulumi.set(self, "resources", value)


if not MYPY:
    class GetMdbKafkaClusterConfigZookeeperResourcesArgsDict(TypedDict):
        disk_size: int
        """
        (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        disk_type_id: str
        """
        (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        resource_preset_id: str
elif False:
    GetMdbKafkaClusterConfigZookeeperResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterConfigZookeeperResourcesArgs:
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param str disk_type_id: (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        (Optional) Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: int):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        (Optional) Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: str):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: str):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbKafkaClusterTopicArgsDict(TypedDict):
        name: str
        """
        The name of the Kafka cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        partitions: int
        """
        (Required) The number of the topic's partitions.
        """
        replication_factor: int
        """
        (Required) Amount of data copies (replicas) for the topic in the cluster.
        """
        topic_config: NotRequired['GetMdbKafkaClusterTopicTopicConfigArgsDict']
        """
        (Required) User-defined settings for the topic. The structure is documented below.
        """
elif False:
    GetMdbKafkaClusterTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterTopicArgs:
    def __init__(__self__, *,
                 name: str,
                 partitions: int,
                 replication_factor: int,
                 topic_config: Optional['GetMdbKafkaClusterTopicTopicConfigArgs'] = None):
        """
        :param str name: The name of the Kafka cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param int partitions: (Required) The number of the topic's partitions.
        :param int replication_factor: (Required) Amount of data copies (replicas) for the topic in the cluster.
        :param 'GetMdbKafkaClusterTopicTopicConfigArgs' topic_config: (Required) User-defined settings for the topic. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replication_factor", replication_factor)
        if topic_config is not None:
            pulumi.set(__self__, "topic_config", topic_config)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Kafka cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def partitions(self) -> int:
        """
        (Required) The number of the topic's partitions.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: int):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        (Required) Amount of data copies (replicas) for the topic in the cluster.
        """
        return pulumi.get(self, "replication_factor")

    @replication_factor.setter
    def replication_factor(self, value: int):
        pulumi.set(self, "replication_factor", value)

    @property
    @pulumi.getter(name="topicConfig")
    def topic_config(self) -> Optional['GetMdbKafkaClusterTopicTopicConfigArgs']:
        """
        (Required) User-defined settings for the topic. The structure is documented below.
        """
        return pulumi.get(self, "topic_config")

    @topic_config.setter
    def topic_config(self, value: Optional['GetMdbKafkaClusterTopicTopicConfigArgs']):
        pulumi.set(self, "topic_config", value)


if not MYPY:
    class GetMdbKafkaClusterTopicTopicConfigArgsDict(TypedDict):
        cleanup_policy: NotRequired[str]
        compression_type: NotRequired[str]
        """
        , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        delete_retention_ms: NotRequired[str]
        file_delete_delay_ms: NotRequired[str]
        flush_messages: NotRequired[str]
        flush_ms: NotRequired[str]
        max_message_bytes: NotRequired[str]
        min_compaction_lag_ms: NotRequired[str]
        min_insync_replicas: NotRequired[str]
        preallocate: NotRequired[bool]
        retention_bytes: NotRequired[str]
        retention_ms: NotRequired[str]
        segment_bytes: NotRequired[str]
elif False:
    GetMdbKafkaClusterTopicTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterTopicTopicConfigArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[bool] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None):
        """
        :param str compression_type: , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[str]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        , `delete_retention_ms`, `file_delete_delay_ms`, `flush_messages`, `flush_ms`, `min_compaction_lag_ms`, `retention_bytes`, `retention_ms`, `max_message_bytes`, `min_insync_replicas`, `segment_bytes`, `preallocate`, - (Optional) Kafka topic settings. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[str]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @delete_retention_ms.setter
    def delete_retention_ms(self, value: Optional[str]):
        pulumi.set(self, "delete_retention_ms", value)

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @file_delete_delay_ms.setter
    def file_delete_delay_ms(self, value: Optional[str]):
        pulumi.set(self, "file_delete_delay_ms", value)

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @flush_messages.setter
    def flush_messages(self, value: Optional[str]):
        pulumi.set(self, "flush_messages", value)

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @flush_ms.setter
    def flush_ms(self, value: Optional[str]):
        pulumi.set(self, "flush_ms", value)

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @max_message_bytes.setter
    def max_message_bytes(self, value: Optional[str]):
        pulumi.set(self, "max_message_bytes", value)

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @min_compaction_lag_ms.setter
    def min_compaction_lag_ms(self, value: Optional[str]):
        pulumi.set(self, "min_compaction_lag_ms", value)

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @min_insync_replicas.setter
    def min_insync_replicas(self, value: Optional[str]):
        pulumi.set(self, "min_insync_replicas", value)

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "preallocate")

    @preallocate.setter
    def preallocate(self, value: Optional[bool]):
        pulumi.set(self, "preallocate", value)

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @retention_bytes.setter
    def retention_bytes(self, value: Optional[str]):
        pulumi.set(self, "retention_bytes", value)

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @retention_ms.setter
    def retention_ms(self, value: Optional[str]):
        pulumi.set(self, "retention_ms", value)

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")

    @segment_bytes.setter
    def segment_bytes(self, value: Optional[str]):
        pulumi.set(self, "segment_bytes", value)


if not MYPY:
    class GetMdbKafkaClusterUserArgsDict(TypedDict):
        name: str
        """
        The name of the Kafka cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        password: str
        """
        (Required) The password of the user.
        """
        permissions: NotRequired[Sequence['GetMdbKafkaClusterUserPermissionArgsDict']]
        """
        (Optional) Set of permissions granted to the user. The structure is documented below.
        """
elif False:
    GetMdbKafkaClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterUserArgs:
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Optional[Sequence['GetMdbKafkaClusterUserPermissionArgs']] = None):
        """
        :param str name: The name of the Kafka cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param str password: (Required) The password of the user.
        :param Sequence['GetMdbKafkaClusterUserPermissionArgs'] permissions: (Optional) Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Kafka cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        (Required) The password of the user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['GetMdbKafkaClusterUserPermissionArgs']]:
        """
        (Optional) Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[Sequence['GetMdbKafkaClusterUserPermissionArgs']]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetMdbKafkaClusterUserPermissionArgsDict(TypedDict):
        role: str
        """
        Role of the host in the cluster.
        """
        topic_name: str
        """
        (Required) The name of the topic that the permission grants access to.
        """
        allow_hosts: NotRequired[Sequence[str]]
        """
        (Optional) Set of hosts, to which this permission grants access to.
        """
elif False:
    GetMdbKafkaClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbKafkaClusterUserPermissionArgs:
    def __init__(__self__, *,
                 role: str,
                 topic_name: str,
                 allow_hosts: Optional[Sequence[str]] = None):
        """
        :param str role: Role of the host in the cluster.
        :param str topic_name: (Required) The name of the topic that the permission grants access to.
        :param Sequence[str] allow_hosts: (Optional) Set of hosts, to which this permission grants access to.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)
        if allow_hosts is not None:
            pulumi.set(__self__, "allow_hosts", allow_hosts)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: str):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        (Required) The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: str):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Optional[Sequence[str]]:
        """
        (Optional) Set of hosts, to which this permission grants access to.
        """
        return pulumi.get(self, "allow_hosts")

    @allow_hosts.setter
    def allow_hosts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "allow_hosts", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigArgsDict(TypedDict):
        access: 'GetMdbMongodbClusterClusterConfigAccessArgsDict'
        """
        Access policy to MongoDB cluster. The structure is documented below.
        """
        backup_retain_period_days: int
        backup_window_start: 'GetMdbMongodbClusterClusterConfigBackupWindowStartArgsDict'
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        feature_compatibility_version: str
        """
        Feature compatibility version of MongoDB.
        """
        mongocfg: 'GetMdbMongodbClusterClusterConfigMongocfgArgsDict'
        mongod: 'GetMdbMongodbClusterClusterConfigMongodArgsDict'
        """
        (Optional) Configuration of the mongod service. The structure is documented below.
        """
        mongos: 'GetMdbMongodbClusterClusterConfigMongosArgsDict'
        performance_diagnostics: 'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict'
        version: NotRequired[str]
        """
        Version of MongoDB (either 6.0, 6.0-enterprise, 5.0, 5.0-enterprise, 4.4, 4.4-enterprise, 4.2).
        """
elif False:
    GetMdbMongodbClusterClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigArgs:
    def __init__(__self__, *,
                 access: 'GetMdbMongodbClusterClusterConfigAccessArgs',
                 backup_retain_period_days: int,
                 backup_window_start: 'GetMdbMongodbClusterClusterConfigBackupWindowStartArgs',
                 feature_compatibility_version: str,
                 mongocfg: 'GetMdbMongodbClusterClusterConfigMongocfgArgs',
                 mongod: 'GetMdbMongodbClusterClusterConfigMongodArgs',
                 mongos: 'GetMdbMongodbClusterClusterConfigMongosArgs',
                 performance_diagnostics: 'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs',
                 version: Optional[str] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigAccessArgs' access: Access policy to MongoDB cluster. The structure is documented below.
        :param 'GetMdbMongodbClusterClusterConfigBackupWindowStartArgs' backup_window_start: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param str feature_compatibility_version: Feature compatibility version of MongoDB.
        :param 'GetMdbMongodbClusterClusterConfigMongodArgs' mongod: (Optional) Configuration of the mongod service. The structure is documented below.
        :param str version: Version of MongoDB (either 6.0, 6.0-enterprise, 5.0, 5.0-enterprise, 4.4, 4.4-enterprise, 4.2).
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        pulumi.set(__self__, "backup_window_start", backup_window_start)
        pulumi.set(__self__, "feature_compatibility_version", feature_compatibility_version)
        pulumi.set(__self__, "mongocfg", mongocfg)
        pulumi.set(__self__, "mongod", mongod)
        pulumi.set(__self__, "mongos", mongos)
        pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def access(self) -> 'GetMdbMongodbClusterClusterConfigAccessArgs':
        """
        Access policy to MongoDB cluster. The structure is documented below.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: 'GetMdbMongodbClusterClusterConfigAccessArgs'):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> int:
        return pulumi.get(self, "backup_retain_period_days")

    @backup_retain_period_days.setter
    def backup_retain_period_days(self, value: int):
        pulumi.set(self, "backup_retain_period_days", value)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> 'GetMdbMongodbClusterClusterConfigBackupWindowStartArgs':
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_start")

    @backup_window_start.setter
    def backup_window_start(self, value: 'GetMdbMongodbClusterClusterConfigBackupWindowStartArgs'):
        pulumi.set(self, "backup_window_start", value)

    @property
    @pulumi.getter(name="featureCompatibilityVersion")
    def feature_compatibility_version(self) -> str:
        """
        Feature compatibility version of MongoDB.
        """
        return pulumi.get(self, "feature_compatibility_version")

    @feature_compatibility_version.setter
    def feature_compatibility_version(self, value: str):
        pulumi.set(self, "feature_compatibility_version", value)

    @property
    @pulumi.getter
    def mongocfg(self) -> 'GetMdbMongodbClusterClusterConfigMongocfgArgs':
        return pulumi.get(self, "mongocfg")

    @mongocfg.setter
    def mongocfg(self, value: 'GetMdbMongodbClusterClusterConfigMongocfgArgs'):
        pulumi.set(self, "mongocfg", value)

    @property
    @pulumi.getter
    def mongod(self) -> 'GetMdbMongodbClusterClusterConfigMongodArgs':
        """
        (Optional) Configuration of the mongod service. The structure is documented below.
        """
        return pulumi.get(self, "mongod")

    @mongod.setter
    def mongod(self, value: 'GetMdbMongodbClusterClusterConfigMongodArgs'):
        pulumi.set(self, "mongod", value)

    @property
    @pulumi.getter
    def mongos(self) -> 'GetMdbMongodbClusterClusterConfigMongosArgs':
        return pulumi.get(self, "mongos")

    @mongos.setter
    def mongos(self, value: 'GetMdbMongodbClusterClusterConfigMongosArgs'):
        pulumi.set(self, "mongos", value)

    @property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> 'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs':
        return pulumi.get(self, "performance_diagnostics")

    @performance_diagnostics.setter
    def performance_diagnostics(self, value: 'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs'):
        pulumi.set(self, "performance_diagnostics", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of MongoDB (either 6.0, 6.0-enterprise, 5.0, 5.0-enterprise, 4.4, 4.4-enterprise, 4.2).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigAccessArgsDict(TypedDict):
        data_lens: NotRequired[bool]
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        data_transfer: NotRequired[bool]
        """
        (Optional) Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
elif False:
    GetMdbMongodbClusterClusterConfigAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigAccessArgs:
    def __init__(__self__, *,
                 data_lens: Optional[bool] = None,
                 data_transfer: Optional[bool] = None):
        """
        :param bool data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param bool data_transfer: (Optional) Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[bool]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: Optional[bool]):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[bool]:
        """
        (Optional) Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: Optional[bool]):
        pulumi.set(self, "data_transfer", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigBackupWindowStartArgsDict(TypedDict):
        hours: NotRequired[int]
        """
        The hour at which backup will be started.
        """
        minutes: NotRequired[int]
        """
        The minute at which backup will be started.
        """
elif False:
    GetMdbMongodbClusterClusterConfigBackupWindowStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigBackupWindowStartArgs:
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[int]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongocfgArgsDict(TypedDict):
        net: NotRequired['GetMdbMongodbClusterClusterConfigMongocfgNetArgsDict']
        operation_profiling: NotRequired['GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict']
        storage: NotRequired['GetMdbMongodbClusterClusterConfigMongocfgStorageArgsDict']
elif False:
    GetMdbMongodbClusterClusterConfigMongocfgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongocfgArgs:
    def __init__(__self__, *,
                 net: Optional['GetMdbMongodbClusterClusterConfigMongocfgNetArgs'] = None,
                 operation_profiling: Optional['GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs'] = None,
                 storage: Optional['GetMdbMongodbClusterClusterConfigMongocfgStorageArgs'] = None):
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def net(self) -> Optional['GetMdbMongodbClusterClusterConfigMongocfgNetArgs']:
        return pulumi.get(self, "net")

    @net.setter
    def net(self, value: Optional['GetMdbMongodbClusterClusterConfigMongocfgNetArgs']):
        pulumi.set(self, "net", value)

    @property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional['GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs']:
        return pulumi.get(self, "operation_profiling")

    @operation_profiling.setter
    def operation_profiling(self, value: Optional['GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs']):
        pulumi.set(self, "operation_profiling", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional['GetMdbMongodbClusterClusterConfigMongocfgStorageArgs']:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional['GetMdbMongodbClusterClusterConfigMongocfgStorageArgs']):
        pulumi.set(self, "storage", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongocfgNetArgsDict(TypedDict):
        max_incoming_connections: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongocfgNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongocfgNetArgs:
    def __init__(__self__, *,
                 max_incoming_connections: Optional[int] = None):
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[int]:
        return pulumi.get(self, "max_incoming_connections")

    @max_incoming_connections.setter
    def max_incoming_connections(self, value: Optional[int]):
        pulumi.set(self, "max_incoming_connections", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict(TypedDict):
        mode: NotRequired[str]
        slow_op_threshold: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs:
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 slow_op_threshold: Optional[int] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[int]:
        return pulumi.get(self, "slow_op_threshold")

    @slow_op_threshold.setter
    def slow_op_threshold(self, value: Optional[int]):
        pulumi.set(self, "slow_op_threshold", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongocfgStorageArgsDict(TypedDict):
        wired_tiger: NotRequired['GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict']
elif False:
    GetMdbMongodbClusterClusterConfigMongocfgStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongocfgStorageArgs:
    def __init__(__self__, *,
                 wired_tiger: Optional['GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs'] = None):
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional['GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs']:
        return pulumi.get(self, "wired_tiger")

    @wired_tiger.setter
    def wired_tiger(self, value: Optional['GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs']):
        pulumi.set(self, "wired_tiger", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict(TypedDict):
        cache_size_gb: NotRequired[float]
elif False:
    GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs:
    def __init__(__self__, *,
                 cache_size_gb: Optional[float] = None):
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)

    @property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[float]:
        return pulumi.get(self, "cache_size_gb")

    @cache_size_gb.setter
    def cache_size_gb(self, value: Optional[float]):
        pulumi.set(self, "cache_size_gb", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodArgsDict(TypedDict):
        audit_log: 'GetMdbMongodbClusterClusterConfigMongodAuditLogArgsDict'
        """
        (Optional) A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). The structure is documented below. Available only in enterprise edition.
        """
        security: 'GetMdbMongodbClusterClusterConfigMongodSecurityArgsDict'
        """
        (Optional) A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). The structure is documented below. Available only in enterprise edition.
        """
        set_parameter: 'GetMdbMongodbClusterClusterConfigMongodSetParameterArgsDict'
        """
        (Optional) A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option). The structure is documented below.
        """
        net: NotRequired['GetMdbMongodbClusterClusterConfigMongodNetArgsDict']
        operation_profiling: NotRequired['GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict']
        storage: NotRequired['GetMdbMongodbClusterClusterConfigMongodStorageArgsDict']
elif False:
    GetMdbMongodbClusterClusterConfigMongodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodArgs:
    def __init__(__self__, *,
                 audit_log: 'GetMdbMongodbClusterClusterConfigMongodAuditLogArgs',
                 security: 'GetMdbMongodbClusterClusterConfigMongodSecurityArgs',
                 set_parameter: 'GetMdbMongodbClusterClusterConfigMongodSetParameterArgs',
                 net: Optional['GetMdbMongodbClusterClusterConfigMongodNetArgs'] = None,
                 operation_profiling: Optional['GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgs'] = None,
                 storage: Optional['GetMdbMongodbClusterClusterConfigMongodStorageArgs'] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongodAuditLogArgs' audit_log: (Optional) A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). The structure is documented below. Available only in enterprise edition.
        :param 'GetMdbMongodbClusterClusterConfigMongodSecurityArgs' security: (Optional) A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). The structure is documented below. Available only in enterprise edition.
        :param 'GetMdbMongodbClusterClusterConfigMongodSetParameterArgs' set_parameter: (Optional) A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option). The structure is documented below.
        """
        pulumi.set(__self__, "audit_log", audit_log)
        pulumi.set(__self__, "security", security)
        pulumi.set(__self__, "set_parameter", set_parameter)
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> 'GetMdbMongodbClusterClusterConfigMongodAuditLogArgs':
        """
        (Optional) A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_log")

    @audit_log.setter
    def audit_log(self, value: 'GetMdbMongodbClusterClusterConfigMongodAuditLogArgs'):
        pulumi.set(self, "audit_log", value)

    @property
    @pulumi.getter
    def security(self) -> 'GetMdbMongodbClusterClusterConfigMongodSecurityArgs':
        """
        (Optional) A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: 'GetMdbMongodbClusterClusterConfigMongodSecurityArgs'):
        pulumi.set(self, "security", value)

    @property
    @pulumi.getter(name="setParameter")
    def set_parameter(self) -> 'GetMdbMongodbClusterClusterConfigMongodSetParameterArgs':
        """
        (Optional) A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option). The structure is documented below.
        """
        return pulumi.get(self, "set_parameter")

    @set_parameter.setter
    def set_parameter(self, value: 'GetMdbMongodbClusterClusterConfigMongodSetParameterArgs'):
        pulumi.set(self, "set_parameter", value)

    @property
    @pulumi.getter
    def net(self) -> Optional['GetMdbMongodbClusterClusterConfigMongodNetArgs']:
        return pulumi.get(self, "net")

    @net.setter
    def net(self, value: Optional['GetMdbMongodbClusterClusterConfigMongodNetArgs']):
        pulumi.set(self, "net", value)

    @property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional['GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgs']:
        return pulumi.get(self, "operation_profiling")

    @operation_profiling.setter
    def operation_profiling(self, value: Optional['GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgs']):
        pulumi.set(self, "operation_profiling", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional['GetMdbMongodbClusterClusterConfigMongodStorageArgs']:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional['GetMdbMongodbClusterClusterConfigMongodStorageArgs']):
        pulumi.set(self, "storage", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodAuditLogArgsDict(TypedDict):
        filter: NotRequired[str]
        """
        (Optional) Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        runtime_configuration: NotRequired[bool]
elif False:
    GetMdbMongodbClusterClusterConfigMongodAuditLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodAuditLogArgs:
    def __init__(__self__, *,
                 filter: Optional[str] = None,
                 runtime_configuration: Optional[bool] = None):
        """
        :param str filter: (Optional) Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if runtime_configuration is not None:
            pulumi.set(__self__, "runtime_configuration", runtime_configuration)

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        (Optional) Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="runtimeConfiguration")
    def runtime_configuration(self) -> Optional[bool]:
        return pulumi.get(self, "runtime_configuration")

    @runtime_configuration.setter
    def runtime_configuration(self, value: Optional[bool]):
        pulumi.set(self, "runtime_configuration", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodNetArgsDict(TypedDict):
        compressors: NotRequired[Sequence[str]]
        max_incoming_connections: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongodNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodNetArgs:
    def __init__(__self__, *,
                 compressors: Optional[Sequence[str]] = None,
                 max_incoming_connections: Optional[int] = None):
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @property
    @pulumi.getter
    def compressors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "compressors")

    @compressors.setter
    def compressors(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "compressors", value)

    @property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[int]:
        return pulumi.get(self, "max_incoming_connections")

    @max_incoming_connections.setter
    def max_incoming_connections(self, value: Optional[int]):
        pulumi.set(self, "max_incoming_connections", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict(TypedDict):
        mode: NotRequired[str]
        slow_op_sample_rate: NotRequired[float]
        slow_op_threshold: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgs:
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 slow_op_sample_rate: Optional[float] = None,
                 slow_op_threshold: Optional[int] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_sample_rate is not None:
            pulumi.set(__self__, "slow_op_sample_rate", slow_op_sample_rate)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="slowOpSampleRate")
    def slow_op_sample_rate(self) -> Optional[float]:
        return pulumi.get(self, "slow_op_sample_rate")

    @slow_op_sample_rate.setter
    def slow_op_sample_rate(self, value: Optional[float]):
        pulumi.set(self, "slow_op_sample_rate", value)

    @property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[int]:
        return pulumi.get(self, "slow_op_threshold")

    @slow_op_threshold.setter
    def slow_op_threshold(self, value: Optional[int]):
        pulumi.set(self, "slow_op_threshold", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodSecurityArgsDict(TypedDict):
        kmip: 'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict'
        """
        (Optional) Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        enable_encryption: NotRequired[bool]
        """
        (Optional) Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
elif False:
    GetMdbMongodbClusterClusterConfigMongodSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodSecurityArgs:
    def __init__(__self__, *,
                 kmip: 'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs',
                 enable_encryption: Optional[bool] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs' kmip: (Optional) Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        :param bool enable_encryption: (Optional) Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        pulumi.set(__self__, "kmip", kmip)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)

    @property
    @pulumi.getter
    def kmip(self) -> 'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs':
        """
        (Optional) Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "kmip")

    @kmip.setter
    def kmip(self, value: 'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs'):
        pulumi.set(self, "kmip", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        """
        (Optional) Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict(TypedDict):
        client_certificate: NotRequired[str]
        """
        (Required) String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        """
        key_identifier: NotRequired[str]
        """
        (Optional) Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        """
        port: NotRequired[int]
        """
        (Optional) Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        """
        server_ca: NotRequired[str]
        """
        (Required) Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        """
        server_name: NotRequired[str]
        """
        (Required) Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
elif False:
    GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[str] = None,
                 key_identifier: Optional[str] = None,
                 port: Optional[int] = None,
                 server_ca: Optional[str] = None,
                 server_name: Optional[str] = None):
        """
        :param str client_certificate: (Required) String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        :param str key_identifier: (Optional) Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        :param int port: (Optional) Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        :param str server_ca: (Required) Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        :param str server_name: (Required) Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_ca is not None:
            pulumi.set(__self__, "server_ca", server_ca)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        (Required) String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[str]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[str]:
        """
        (Optional) Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: Optional[str]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        (Optional) Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serverCa")
    def server_ca(self) -> Optional[str]:
        """
        (Required) Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        """
        return pulumi.get(self, "server_ca")

    @server_ca.setter
    def server_ca(self, value: Optional[str]):
        pulumi.set(self, "server_ca", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        (Required) Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[str]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodSetParameterArgsDict(TypedDict):
        audit_authorization_success: NotRequired[bool]
        """
        (Optional) Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        enable_flow_control: NotRequired[bool]
        min_snapshot_history_window_in_seconds: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongodSetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodSetParameterArgs:
    def __init__(__self__, *,
                 audit_authorization_success: Optional[bool] = None,
                 enable_flow_control: Optional[bool] = None,
                 min_snapshot_history_window_in_seconds: Optional[int] = None):
        """
        :param bool audit_authorization_success: (Optional) Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        if audit_authorization_success is not None:
            pulumi.set(__self__, "audit_authorization_success", audit_authorization_success)
        if enable_flow_control is not None:
            pulumi.set(__self__, "enable_flow_control", enable_flow_control)
        if min_snapshot_history_window_in_seconds is not None:
            pulumi.set(__self__, "min_snapshot_history_window_in_seconds", min_snapshot_history_window_in_seconds)

    @property
    @pulumi.getter(name="auditAuthorizationSuccess")
    def audit_authorization_success(self) -> Optional[bool]:
        """
        (Optional) Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_authorization_success")

    @audit_authorization_success.setter
    def audit_authorization_success(self, value: Optional[bool]):
        pulumi.set(self, "audit_authorization_success", value)

    @property
    @pulumi.getter(name="enableFlowControl")
    def enable_flow_control(self) -> Optional[bool]:
        return pulumi.get(self, "enable_flow_control")

    @enable_flow_control.setter
    def enable_flow_control(self, value: Optional[bool]):
        pulumi.set(self, "enable_flow_control", value)

    @property
    @pulumi.getter(name="minSnapshotHistoryWindowInSeconds")
    def min_snapshot_history_window_in_seconds(self) -> Optional[int]:
        return pulumi.get(self, "min_snapshot_history_window_in_seconds")

    @min_snapshot_history_window_in_seconds.setter
    def min_snapshot_history_window_in_seconds(self, value: Optional[int]):
        pulumi.set(self, "min_snapshot_history_window_in_seconds", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodStorageArgsDict(TypedDict):
        journal: NotRequired['GetMdbMongodbClusterClusterConfigMongodStorageJournalArgsDict']
        wired_tiger: NotRequired['GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict']
elif False:
    GetMdbMongodbClusterClusterConfigMongodStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodStorageArgs:
    def __init__(__self__, *,
                 journal: Optional['GetMdbMongodbClusterClusterConfigMongodStorageJournalArgs'] = None,
                 wired_tiger: Optional['GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs'] = None):
        if journal is not None:
            pulumi.set(__self__, "journal", journal)
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @property
    @pulumi.getter
    def journal(self) -> Optional['GetMdbMongodbClusterClusterConfigMongodStorageJournalArgs']:
        return pulumi.get(self, "journal")

    @journal.setter
    def journal(self, value: Optional['GetMdbMongodbClusterClusterConfigMongodStorageJournalArgs']):
        pulumi.set(self, "journal", value)

    @property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional['GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs']:
        return pulumi.get(self, "wired_tiger")

    @wired_tiger.setter
    def wired_tiger(self, value: Optional['GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs']):
        pulumi.set(self, "wired_tiger", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodStorageJournalArgsDict(TypedDict):
        commit_interval: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongodStorageJournalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodStorageJournalArgs:
    def __init__(__self__, *,
                 commit_interval: Optional[int] = None):
        if commit_interval is not None:
            pulumi.set(__self__, "commit_interval", commit_interval)

    @property
    @pulumi.getter(name="commitInterval")
    def commit_interval(self) -> Optional[int]:
        return pulumi.get(self, "commit_interval")

    @commit_interval.setter
    def commit_interval(self, value: Optional[int]):
        pulumi.set(self, "commit_interval", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict(TypedDict):
        block_compressor: NotRequired[str]
        cache_size_gb: NotRequired[float]
        prefix_compression: NotRequired[bool]
elif False:
    GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs:
    def __init__(__self__, *,
                 block_compressor: Optional[str] = None,
                 cache_size_gb: Optional[float] = None,
                 prefix_compression: Optional[bool] = None):
        if block_compressor is not None:
            pulumi.set(__self__, "block_compressor", block_compressor)
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)
        if prefix_compression is not None:
            pulumi.set(__self__, "prefix_compression", prefix_compression)

    @property
    @pulumi.getter(name="blockCompressor")
    def block_compressor(self) -> Optional[str]:
        return pulumi.get(self, "block_compressor")

    @block_compressor.setter
    def block_compressor(self, value: Optional[str]):
        pulumi.set(self, "block_compressor", value)

    @property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[float]:
        return pulumi.get(self, "cache_size_gb")

    @cache_size_gb.setter
    def cache_size_gb(self, value: Optional[float]):
        pulumi.set(self, "cache_size_gb", value)

    @property
    @pulumi.getter(name="prefixCompression")
    def prefix_compression(self) -> Optional[bool]:
        return pulumi.get(self, "prefix_compression")

    @prefix_compression.setter
    def prefix_compression(self, value: Optional[bool]):
        pulumi.set(self, "prefix_compression", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongosArgsDict(TypedDict):
        net: NotRequired['GetMdbMongodbClusterClusterConfigMongosNetArgsDict']
elif False:
    GetMdbMongodbClusterClusterConfigMongosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongosArgs:
    def __init__(__self__, *,
                 net: Optional['GetMdbMongodbClusterClusterConfigMongosNetArgs'] = None):
        if net is not None:
            pulumi.set(__self__, "net", net)

    @property
    @pulumi.getter
    def net(self) -> Optional['GetMdbMongodbClusterClusterConfigMongosNetArgs']:
        return pulumi.get(self, "net")

    @net.setter
    def net(self, value: Optional['GetMdbMongodbClusterClusterConfigMongosNetArgs']):
        pulumi.set(self, "net", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigMongosNetArgsDict(TypedDict):
        compressors: NotRequired[Sequence[str]]
        max_incoming_connections: NotRequired[int]
elif False:
    GetMdbMongodbClusterClusterConfigMongosNetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigMongosNetArgs:
    def __init__(__self__, *,
                 compressors: Optional[Sequence[str]] = None,
                 max_incoming_connections: Optional[int] = None):
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @property
    @pulumi.getter
    def compressors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "compressors")

    @compressors.setter
    def compressors(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "compressors", value)

    @property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[int]:
        return pulumi.get(self, "max_incoming_connections")

    @max_incoming_connections.setter
    def max_incoming_connections(self, value: Optional[int]):
        pulumi.set(self, "max_incoming_connections", value)


if not MYPY:
    class GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict(TypedDict):
        enabled: NotRequired[bool]
elif False:
    GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetMdbMongodbClusterDatabaseArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the MongoDB cluster.

        > Either `cluster_id` or `name` should be specified.
        """
elif False:
    GetMdbMongodbClusterDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterDatabaseArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: The name of the MongoDB cluster.
               
               > Either `cluster_id` or `name` should be specified.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the MongoDB cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetMdbMongodbClusterDiskSizeAutoscalingMongocfgArgsDict(TypedDict):
        disk_size_limit: NotRequired[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[int]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[int]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    GetMdbMongodbClusterDiskSizeAutoscalingMongocfgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongocfgArgs:
    def __init__(__self__, *,
                 disk_size_limit: Optional[int] = None,
                 emergency_usage_threshold: Optional[int] = None,
                 planned_usage_threshold: Optional[int] = None):
        """
        :param int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: Optional[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class GetMdbMongodbClusterDiskSizeAutoscalingMongodArgsDict(TypedDict):
        disk_size_limit: NotRequired[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[int]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[int]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    GetMdbMongodbClusterDiskSizeAutoscalingMongodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongodArgs:
    def __init__(__self__, *,
                 disk_size_limit: Optional[int] = None,
                 emergency_usage_threshold: Optional[int] = None,
                 planned_usage_threshold: Optional[int] = None):
        """
        :param int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: Optional[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraArgsDict(TypedDict):
        disk_size_limit: NotRequired[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[int]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[int]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraArgs:
    def __init__(__self__, *,
                 disk_size_limit: Optional[int] = None,
                 emergency_usage_threshold: Optional[int] = None,
                 planned_usage_threshold: Optional[int] = None):
        """
        :param int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: Optional[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class GetMdbMongodbClusterDiskSizeAutoscalingMongosArgsDict(TypedDict):
        disk_size_limit: NotRequired[int]
        """
        Limit of disk size after autoscaling (GiB).
        """
        emergency_usage_threshold: NotRequired[int]
        """
        Immediate autoscaling disk usage (percent).
        """
        planned_usage_threshold: NotRequired[int]
        """
        Maintenance window autoscaling disk usage (percent).
        """
elif False:
    GetMdbMongodbClusterDiskSizeAutoscalingMongosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongosArgs:
    def __init__(__self__, *,
                 disk_size_limit: Optional[int] = None,
                 emergency_usage_threshold: Optional[int] = None,
                 planned_usage_threshold: Optional[int] = None):
        """
        :param int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[int]:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @disk_size_limit.setter
    def disk_size_limit(self, value: Optional[int]):
        pulumi.set(self, "disk_size_limit", value)

    @property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @emergency_usage_threshold.setter
    def emergency_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "emergency_usage_threshold", value)

    @property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")

    @planned_usage_threshold.setter
    def planned_usage_threshold(self, value: Optional[int]):
        pulumi.set(self, "planned_usage_threshold", value)


if not MYPY:
    class GetMdbMongodbClusterHostArgsDict(TypedDict):
        health: str
        """
        The health of the host.
        """
        host_parameters: 'GetMdbMongodbClusterHostHostParametersArgsDict'
        """
        (Optional) The parameters of mongod host in replicaset.
        """
        name: str
        """
        The name of the MongoDB cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        role: str
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        shard_name: str
        """
        The name of the shard to which the host belongs.
        """
        assign_public_ip: NotRequired[bool]
        """
        Has assigned public IP.
        """
        subnet_id: NotRequired[str]
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        type: NotRequired[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        zone_id: NotRequired[str]
        """
        The availability zone where the MongoDB host will be created.
        """
elif False:
    GetMdbMongodbClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterHostArgs:
    def __init__(__self__, *,
                 health: str,
                 host_parameters: 'GetMdbMongodbClusterHostHostParametersArgs',
                 name: str,
                 role: str,
                 shard_name: str,
                 assign_public_ip: Optional[bool] = None,
                 subnet_id: Optional[str] = None,
                 type: Optional[str] = None,
                 zone_id: Optional[str] = None):
        """
        :param str health: The health of the host.
        :param 'GetMdbMongodbClusterHostHostParametersArgs' host_parameters: (Optional) The parameters of mongod host in replicaset.
        :param str name: The name of the MongoDB cluster.
               
               > Either `cluster_id` or `name` should be specified.
        :param str role: The role of the cluster (either PRIMARY or SECONDARY).
        :param str shard_name: The name of the shard to which the host belongs.
        :param bool assign_public_ip: Has assigned public IP.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str zone_id: The availability zone where the MongoDB host will be created.
        """
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "host_parameters", host_parameters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "shard_name", shard_name)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def health(self) -> str:
        """
        The health of the host.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: str):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="hostParameters")
    def host_parameters(self) -> 'GetMdbMongodbClusterHostHostParametersArgs':
        """
        (Optional) The parameters of mongod host in replicaset.
        """
        return pulumi.get(self, "host_parameters")

    @host_parameters.setter
    def host_parameters(self, value: 'GetMdbMongodbClusterHostHostParametersArgs'):
        pulumi.set(self, "host_parameters", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the MongoDB cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: str):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @shard_name.setter
    def shard_name(self, value: str):
        pulumi.set(self, "shard_name", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Has assigned public IP.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[bool]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        The availability zone where the MongoDB host will be created.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetMdbMongodbClusterHostHostParametersArgsDict(TypedDict):
        hidden: NotRequired[bool]
        """
        (Optional) Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden)
        """
        priority: NotRequired[float]
        """
        (Optional) A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority)
        """
        secondary_delay_secs: NotRequired[int]
        """
        (Optional) The number of seconds "behind" the primary that this replica set member should "lag". For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs)
        """
        tags: NotRequired[Mapping[str, str]]
        """
        (Optional) A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags)
        """
elif False:
    GetMdbMongodbClusterHostHostParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterHostHostParametersArgs:
    def __init__(__self__, *,
                 hidden: Optional[bool] = None,
                 priority: Optional[float] = None,
                 secondary_delay_secs: Optional[int] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param bool hidden: (Optional) Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden)
        :param float priority: (Optional) A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority)
        :param int secondary_delay_secs: (Optional) The number of seconds "behind" the primary that this replica set member should "lag". For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs)
        :param Mapping[str, str] tags: (Optional) A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags)
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if secondary_delay_secs is not None:
            pulumi.set(__self__, "secondary_delay_secs", secondary_delay_secs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[bool]:
        """
        (Optional) Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden)
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[bool]):
        pulumi.set(self, "hidden", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        (Optional) A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority)
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[float]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="secondaryDelaySecs")
    def secondary_delay_secs(self) -> Optional[int]:
        """
        (Optional) The number of seconds "behind" the primary that this replica set member should "lag". For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs)
        """
        return pulumi.get(self, "secondary_delay_secs")

    @secondary_delay_secs.setter
    def secondary_delay_secs(self, value: Optional[int]):
        pulumi.set(self, "secondary_delay_secs", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        (Optional) A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetMdbMongodbClusterMaintenanceWindowArgsDict(TypedDict):
        day: NotRequired[str]
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        hour: NotRequired[int]
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        type: NotRequired[str]
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
elif False:
    GetMdbMongodbClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: Optional[str] = None,
                 hour: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[int]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetMdbMongodbClusterResourcesArgsDict(TypedDict):
        disk_size: NotRequired[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[str]
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        resource_preset_id: NotRequired[str]
elif False:
    GetMdbMongodbClusterResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterResourcesArgs:
    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbMongodbClusterResourcesMongocfgArgsDict(TypedDict):
        disk_size: NotRequired[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[str]
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        resource_preset_id: NotRequired[str]
elif False:
    GetMdbMongodbClusterResourcesMongocfgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterResourcesMongocfgArgs:
    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbMongodbClusterResourcesMongodArgsDict(TypedDict):
        disk_size: NotRequired[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[str]
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        resource_preset_id: NotRequired[str]
elif False:
    GetMdbMongodbClusterResourcesMongodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterResourcesMongodArgs:
    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbMongodbClusterResourcesMongoinfraArgsDict(TypedDict):
        disk_size: NotRequired[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[str]
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        resource_preset_id: NotRequired[str]
elif False:
    GetMdbMongodbClusterResourcesMongoinfraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterResourcesMongoinfraArgs:
    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbMongodbClusterResourcesMongosArgsDict(TypedDict):
        disk_size: NotRequired[int]
        """
        Volume of the storage available to a host, in gigabytes.
        """
        disk_type_id: NotRequired[str]
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        resource_preset_id: NotRequired[str]
elif False:
    GetMdbMongodbClusterResourcesMongosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterResourcesMongosArgs:
    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        return pulumi.get(self, "disk_type_id")

    @disk_type_id.setter
    def disk_type_id(self, value: Optional[str]):
        pulumi.set(self, "disk_type_id", value)

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")

    @resource_preset_id.setter
    def resource_preset_id(self, value: Optional[str]):
        pulumi.set(self, "resource_preset_id", value)


if not MYPY:
    class GetMdbMongodbClusterRestoreArgsDict(TypedDict):
        backup_id: NotRequired[str]
        time: NotRequired[str]
elif False:
    GetMdbMongodbClusterRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterRestoreArgs:
    def __init__(__self__, *,
                 backup_id: Optional[str] = None,
                 time: Optional[str] = None):
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[str]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class GetMdbMongodbClusterUserArgsDict(TypedDict):
        permissions: Sequence['GetMdbMongodbClusterUserPermissionArgsDict']
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        name: NotRequired[str]
        """
        The name of the MongoDB cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        password: NotRequired[str]
elif False:
    GetMdbMongodbClusterUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterUserArgs:
    def __init__(__self__, *,
                 permissions: Sequence['GetMdbMongodbClusterUserPermissionArgs'],
                 name: Optional[str] = None,
                 password: Optional[str] = None):
        """
        :param Sequence['GetMdbMongodbClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        :param str name: The name of the MongoDB cluster.
               
               > Either `cluster_id` or `name` should be specified.
        """
        pulumi.set(__self__, "permissions", permissions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['GetMdbMongodbClusterUserPermissionArgs']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence['GetMdbMongodbClusterUserPermissionArgs']):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the MongoDB cluster.

        > Either `cluster_id` or `name` should be specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class GetMdbMongodbClusterUserPermissionArgsDict(TypedDict):
        database_name: NotRequired[str]
        """
        The name of the database that the permission grants access to.
        """
        roles: NotRequired[Sequence[str]]
        """
        (Optional) List of strings. The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
elif False:
    GetMdbMongodbClusterUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMongodbClusterUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: (Optional) List of strings. The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        (Optional) List of strings. The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class GetMdbMysqlClusterAccessArgsDict(TypedDict):
        data_lens: bool
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        data_transfer: bool
        """
        (Optional) Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        web_sql: bool
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
elif False:
    GetMdbMysqlClusterAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMysqlClusterAccessArgs:
    def __init__(__self__, *,
                 data_lens: bool,
                 data_transfer: bool,
                 web_sql: bool):
        """
        :param bool data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param bool data_transfer: (Optional) Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        :param bool web_sql: Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "data_transfer", data_transfer)
        pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> bool:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @data_lens.setter
    def data_lens(self, value: bool):
        pulumi.set(self, "data_lens", value)

    @property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> bool:
        """
        (Optional) Allow access for [DataTransfer](https://cloud.yandex.com/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @data_transfer.setter
    def data_transfer(self, value: bool):
        pulumi.set(self, "data_transfer", value)

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> bool:
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")

    @web_sql.setter
    def web_sql(self, value: bool):
        pulumi.set(self, "web_sql", value)


if not MYPY:
    class GetMdbMysqlUserPermissionArgsDict(TypedDict):
        database_name: str
        """
        The name of the database that the permission grants access to.
        """
        roles: NotRequired[Sequence[str]]
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
elif False:
    GetMdbMysqlUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbMysqlUserPermissionArgs:
    def __init__(__self__, *,
                 database_name: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class GetMdbPostgresqlDatabaseExtensionArgsDict(TypedDict):
        name: str
        """
        The name of the PostgreSQL cluster.
        """
        version: NotRequired[str]
        """
        Version of the extension.
        """
elif False:
    GetMdbPostgresqlDatabaseExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMdbPostgresqlDatabaseExtensionArgs:
    def __init__(__self__, *,
                 name: str,
                 version: Optional[str] = None):
        """
        :param str name: The name of the PostgreSQL cluster.
        :param str version: Version of the extension.
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the PostgreSQL cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the extension.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsArgsDict(TypedDict):
        enabled: NotRequired[bool]
        """
        Enables or disables usage of ssh certificates signed by trusted CA.
        """
elif False:
    GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enables or disables usage of ssh certificates signed by trusted CA.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enables or disables usage of ssh certificates signed by trusted CA.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsArgsDict(TypedDict):
        allow_manage_own_keys: NotRequired[bool]
        """
        If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        """
        enabled: NotRequired[bool]
        """
        Enables or disables usage of ssh certificates signed by trusted CA.
        """
elif False:
    GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsArgs:
    def __init__(__self__, *,
                 allow_manage_own_keys: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param bool allow_manage_own_keys: If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        :param bool enabled: Enables or disables usage of ssh certificates signed by trusted CA.
        """
        if allow_manage_own_keys is not None:
            pulumi.set(__self__, "allow_manage_own_keys", allow_manage_own_keys)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="allowManageOwnKeys")
    def allow_manage_own_keys(self) -> Optional[bool]:
        """
        If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        """
        return pulumi.get(self, "allow_manage_own_keys")

    @allow_manage_own_keys.setter
    def allow_manage_own_keys(self, value: Optional[bool]):
        pulumi.set(self, "allow_manage_own_keys", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enables or disables usage of ssh certificates signed by trusted CA.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetServerlessContainerConnectivityArgsDict(TypedDict):
        network_id: str
        """
        Network the revision will have access to
        """
elif False:
    GetServerlessContainerConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerConnectivityArgs:
    def __init__(__self__, *,
                 network_id: str):
        """
        :param str network_id: Network the revision will have access to
        """
        pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        Network the revision will have access to
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: str):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class GetServerlessContainerMountArgsDict(TypedDict):
        mode: str
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`
        """
        mount_point_path: str
        """
        Path inside the container to access the directory in which the target is mounted
        """
        ephemeral_disk: NotRequired['GetServerlessContainerMountEphemeralDiskArgsDict']
        """
        One of the available mount types. Disk available during the function execution time
        """
        object_storage: NotRequired['GetServerlessContainerMountObjectStorageArgsDict']
        """
        One of the available mount types. Object storage as a mount
        """
elif False:
    GetServerlessContainerMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerMountArgs:
    def __init__(__self__, *,
                 mode: str,
                 mount_point_path: str,
                 ephemeral_disk: Optional['GetServerlessContainerMountEphemeralDiskArgs'] = None,
                 object_storage: Optional['GetServerlessContainerMountObjectStorageArgs'] = None):
        """
        :param str mode: Mounts accessibility mode. Valid values are `ro` and `rw`
        :param str mount_point_path: Path inside the container to access the directory in which the target is mounted
        :param 'GetServerlessContainerMountEphemeralDiskArgs' ephemeral_disk: One of the available mount types. Disk available during the function execution time
        :param 'GetServerlessContainerMountObjectStorageArgs' object_storage: One of the available mount types. Object storage as a mount
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: str):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> str:
        """
        Path inside the container to access the directory in which the target is mounted
        """
        return pulumi.get(self, "mount_point_path")

    @mount_point_path.setter
    def mount_point_path(self, value: str):
        pulumi.set(self, "mount_point_path", value)

    @property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional['GetServerlessContainerMountEphemeralDiskArgs']:
        """
        One of the available mount types. Disk available during the function execution time
        """
        return pulumi.get(self, "ephemeral_disk")

    @ephemeral_disk.setter
    def ephemeral_disk(self, value: Optional['GetServerlessContainerMountEphemeralDiskArgs']):
        pulumi.set(self, "ephemeral_disk", value)

    @property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional['GetServerlessContainerMountObjectStorageArgs']:
        """
        One of the available mount types. Object storage as a mount
        """
        return pulumi.get(self, "object_storage")

    @object_storage.setter
    def object_storage(self, value: Optional['GetServerlessContainerMountObjectStorageArgs']):
        pulumi.set(self, "object_storage", value)


if not MYPY:
    class GetServerlessContainerMountEphemeralDiskArgsDict(TypedDict):
        block_size_kb: int
        """
        Optional block size of the ephemeral disk in KB
        """
        size_gb: int
        """
        Size of the ephemeral disk in GB
        """
elif False:
    GetServerlessContainerMountEphemeralDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerMountEphemeralDiskArgs:
    def __init__(__self__, *,
                 block_size_kb: int,
                 size_gb: int):
        """
        :param int block_size_kb: Optional block size of the ephemeral disk in KB
        :param int size_gb: Size of the ephemeral disk in GB
        """
        pulumi.set(__self__, "block_size_kb", block_size_kb)
        pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> int:
        """
        Optional block size of the ephemeral disk in KB
        """
        return pulumi.get(self, "block_size_kb")

    @block_size_kb.setter
    def block_size_kb(self, value: int):
        pulumi.set(self, "block_size_kb", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        Size of the ephemeral disk in GB
        """
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: int):
        pulumi.set(self, "size_gb", value)


if not MYPY:
    class GetServerlessContainerMountObjectStorageArgsDict(TypedDict):
        bucket: str
        """
        Name of the mounting bucket
        """
        prefix: NotRequired[str]
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
elif False:
    GetServerlessContainerMountObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerMountObjectStorageArgs:
    def __init__(__self__, *,
                 bucket: str,
                 prefix: Optional[str] = None):
        """
        :param str bucket: Name of the mounting bucket
        :param str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the mounting bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: str):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class GetServerlessContainerRuntimeArgsDict(TypedDict):
        type: str
        """
        Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`
        """
elif False:
    GetServerlessContainerRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerRuntimeArgs:
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetServerlessContainerSecretArgsDict(TypedDict):
        environment_variable: str
        id: str
        key: str
        version_id: str
elif False:
    GetServerlessContainerSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerSecretArgs:
    def __init__(__self__, *,
                 environment_variable: str,
                 id: str,
                 key: str,
                 version_id: str):
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> str:
        return pulumi.get(self, "environment_variable")

    @environment_variable.setter
    def environment_variable(self, value: str):
        pulumi.set(self, "environment_variable", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: str):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class GetServerlessContainerStorageMountArgsDict(TypedDict):
        bucket: str
        """
        Name of the mounting bucket
        """
        mount_point_path: str
        """
        Path inside the container to access the directory in which the bucket is mounted
        """
        prefix: NotRequired[str]
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        read_only: NotRequired[bool]
        """
        Mount the bucket in read-only mode
        """
elif False:
    GetServerlessContainerStorageMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessContainerStorageMountArgs:
    def __init__(__self__, *,
                 bucket: str,
                 mount_point_path: str,
                 prefix: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str bucket: Name of the mounting bucket
        :param str mount_point_path: Path inside the container to access the directory in which the bucket is mounted
        :param str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        :param bool read_only: Mount the bucket in read-only mode
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the mounting bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: str):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> str:
        """
        Path inside the container to access the directory in which the bucket is mounted
        """
        return pulumi.get(self, "mount_point_path")

    @mount_point_path.setter
    def mount_point_path(self, value: str):
        pulumi.set(self, "mount_point_path", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mount the bucket in read-only mode
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[bool]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class GetVpcGatewaySharedEgressGatewayArgsDict(TypedDict):
        pass
elif False:
    GetVpcGatewaySharedEgressGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVpcGatewaySharedEgressGatewayArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetVpcPrivateEndpointObjectStorageArgsDict(TypedDict):
        pass
elif False:
    GetVpcPrivateEndpointObjectStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVpcPrivateEndpointObjectStorageArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetYdbDatabaseServerlessServerlessDatabaseArgsDict(TypedDict):
        enable_throttling_rcu_limit: bool
        provisioned_rcu_limit: int
        storage_size_limit: int
        throttling_rcu_limit: int
elif False:
    GetYdbDatabaseServerlessServerlessDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetYdbDatabaseServerlessServerlessDatabaseArgs:
    def __init__(__self__, *,
                 enable_throttling_rcu_limit: bool,
                 provisioned_rcu_limit: int,
                 storage_size_limit: int,
                 throttling_rcu_limit: int):
        pulumi.set(__self__, "enable_throttling_rcu_limit", enable_throttling_rcu_limit)
        pulumi.set(__self__, "provisioned_rcu_limit", provisioned_rcu_limit)
        pulumi.set(__self__, "storage_size_limit", storage_size_limit)
        pulumi.set(__self__, "throttling_rcu_limit", throttling_rcu_limit)

    @property
    @pulumi.getter(name="enableThrottlingRcuLimit")
    def enable_throttling_rcu_limit(self) -> bool:
        return pulumi.get(self, "enable_throttling_rcu_limit")

    @enable_throttling_rcu_limit.setter
    def enable_throttling_rcu_limit(self, value: bool):
        pulumi.set(self, "enable_throttling_rcu_limit", value)

    @property
    @pulumi.getter(name="provisionedRcuLimit")
    def provisioned_rcu_limit(self) -> int:
        return pulumi.get(self, "provisioned_rcu_limit")

    @provisioned_rcu_limit.setter
    def provisioned_rcu_limit(self, value: int):
        pulumi.set(self, "provisioned_rcu_limit", value)

    @property
    @pulumi.getter(name="storageSizeLimit")
    def storage_size_limit(self) -> int:
        return pulumi.get(self, "storage_size_limit")

    @storage_size_limit.setter
    def storage_size_limit(self, value: int):
        pulumi.set(self, "storage_size_limit", value)

    @property
    @pulumi.getter(name="throttlingRcuLimit")
    def throttling_rcu_limit(self) -> int:
        return pulumi.get(self, "throttling_rcu_limit")

    @throttling_rcu_limit.setter
    def throttling_rcu_limit(self, value: int):
        pulumi.set(self, "throttling_rcu_limit", value)


