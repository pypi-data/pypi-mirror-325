"use strict";(self.webpackChunk_jupyterlite_terminal=self.webpackChunk_jupyterlite_terminal||[]).push([[12],{12:(s,e,t)=>{t.r(e),t.d(e,{default:()=>h});var i=t(310),n=t(334),o=t(602),a=t(155);class r{constructor(s){this.options=s,this._disposed=new o.Signal(this),this._isDisposed=!1,this._running=!1,this._shell=new n.Shell({mountpoint:"/drive",driveFsBaseUrl:s.baseUrl,wasmBaseUrl:s.baseUrl+"extensions/@jupyterlite/terminal/static/wasm/",outputCallback:this._outputCallback.bind(this)}),this._shell.disposed.connect((()=>this.dispose()))}_outputCallback(s){if(this._socket){const e=JSON.stringify(["stdout",s]);this._socket.send(e)}}dispose(){this._isDisposed||(console.log("Terminal.dispose"),this._isDisposed=!0,void 0!==this._socket&&(this._socket.send(JSON.stringify(["disconnect"])),this._socket.close(),this._socket=void 0),void 0!==this._server&&(this._server.close(),this._server=void 0),this._shell.dispose(),this._disposed.emit())}get disposed(){return this._disposed}get isDisposed(){return this._isDisposed}get name(){return this.options.name}async wsConnect(s){console.log("==> Terminal.wsConnect",s),this._server=new a.Server(s),this._server.on("connection",(async s=>{console.log("==> server connection"),void 0!==this._socket&&(this._socket.send(JSON.stringify(["disconnect"])),this._socket.close(),this._socket=void 0),this._socket=s,s.on("message",(async s=>{const e=JSON.parse(s),t=e[0],i=e.slice(1);if("stdin"===t)await this._shell.input(i[0]);else if("set_size"===t){const s=i[0],e=i[1];await this._shell.setSize(s,e)}})),s.on("close",(()=>{console.log("==> socket close")})),s.on("error",(()=>{console.log("==> socket error")}));const e=JSON.stringify(["setup"]);console.log("==> Returning handshake via socket",e),s.send(e),this._running||(this._running=!0,await this._shell.start())}))}}class l{constructor(s){this._terminals=new Map,this._wsUrl=s,console.log("==> TerminalManager.constructor",this._wsUrl)}has(s){return this._terminals.has(s)}async listRunning(){return[...this._terminals.values()].map((s=>({name:s.name})))}async shutdownTerminal(s){const e=this._terminals.get(s);void 0!==e&&(console.log("==> TerminalManager.shutdownTerminal",s),this._terminals.delete(s),e.dispose())}async startNew(){const s=this._nextAvailableName();console.log("==> TerminalManager.startNew",s);const e=i.PageConfig.getBaseUrl(),t=new r({name:s,baseUrl:e});this._terminals.set(s,t),t.disposed.connect((()=>this.shutdownTerminal(s)));const n=`${this._wsUrl}terminals/websocket/${s}`;return await t.wsConnect(n),{name:s}}_nextAvailableName(){for(let s=1;;++s){const e=`${s}`;if(!this._terminals.has(e))return e}}}const c=new(t(262).Token)("@jupyterlite/terminal:ITerminalManager"),h=[{id:"@jupyterlite/terminal:plugin",description:"A terminal for JupyterLite",autoStart:!0,provides:c,activate:async s=>{console.log("JupyterLite extension @jupyterlite/terminal:plugin is activated!");const{serviceManager:e}=s,{serverSettings:t,terminals:i}=e;return console.log("terminals available:",i.isAvailable()),console.log("terminals ready:",i.isReady),console.log("terminals active:",i.isActive),await i.ready,console.log("terminals ready after await:",i.isReady),new l(t.wsUrl)}},{id:"@jupyterlite/terminal:routes-plugin",autoStart:!0,requires:[c],activate:(s,e)=>{console.log("JupyterLite extension @jupyterlite/terminal:routes-plugin is activated!",e),s.router.get("/api/terminals",(async s=>{const t=await e.listRunning();return new Response(JSON.stringify(t))})),s.router.post("/api/terminals",(async s=>{const t=await e.startNew();return new Response(JSON.stringify(t))})),s.router.delete("/api/terminals/(.+)",(async(s,t)=>{const i=e.has(t);if(i)await e.shutdownTerminal(t);else{const s=`The terminal session "${t}"" does not exist`;console.warn(s)}return new Response(null,{status:i?204:404})}))}}]}}]);