import typing, clr, abc
from System import Attribute, Array_1, ReadOnlySpan_1, DateTime, TimeSpan, Exception
from System.ComponentModel import Component, IContainer, ISite, ISynchronizeInvoke
from Microsoft.Win32.SafeHandles import SafeProcessHandle
from System.IO import StreamReader, StreamWriter
from System.Threading.Tasks import Task
from System.Threading import CancellationToken
from System.Collections.Generic import IEnumerable_1, IDictionary_2
from System.Security import SecureString
from System.Collections import ReadOnlyCollectionBase, IDictionary
from System.Collections.ObjectModel import Collection_1
from System.Collections.Specialized import StringDictionary
from System.Text import Encoding
from System.Reflection import MethodBase

class ConditionalAttribute(Attribute):
    def __init__(self, conditionString: str) -> None: ...
    @property
    def ConditionString(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Debug(abc.ABC):
    @classmethod
    @property
    def AutoFlush(cls) -> bool: ...
    @classmethod
    @AutoFlush.setter
    def AutoFlush(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def IndentLevel(cls) -> int: ...
    @classmethod
    @IndentLevel.setter
    def IndentLevel(cls, value: int) -> int: ...
    @classmethod
    @property
    def IndentSize(cls) -> int: ...
    @classmethod
    @IndentSize.setter
    def IndentSize(cls, value: int) -> int: ...
    @staticmethod
    def Close() -> None: ...
    @staticmethod
    def Flush() -> None: ...
    @staticmethod
    def Indent() -> None: ...
    @staticmethod
    def SetProvider(provider: DebugProvider) -> DebugProvider: ...
    @staticmethod
    def Unindent() -> None: ...
    # Skipped Assert due to it being static, abstract and generic.

    Assert : Assert_MethodGroup
    class Assert_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.AssertInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, detailMessage: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.AssertInterpolatedStringHandler], detailMessage: clr.Reference[Debug.AssertInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, detailMessageFormat: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Fail due to it being static, abstract and generic.

    Fail : Fail_MethodGroup
    class Fail_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, detailMessage: str) -> None:...

    # Skipped Print due to it being static, abstract and generic.

    Print : Print_MethodGroup
    class Print_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, category: str) -> None:...

    # Skipped WriteIf due to it being static, abstract and generic.

    WriteIf : WriteIf_MethodGroup
    class WriteIf_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler], category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, category: str) -> None:...

    # Skipped WriteLineIf due to it being static, abstract and generic.

    WriteLineIf : WriteLineIf_MethodGroup
    class WriteLineIf_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler], category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any, category: str) -> None:...


    class AssertInterpolatedStringHandler:
        def __init__(self, literalLength: int, formattedCount: int, condition: bool, shouldAppend: clr.Reference[bool]) -> None: ...
        def AppendLiteral(self, value: str) -> None: ...
        # Skipped AppendFormatted due to it being static, abstract and generic.

        AppendFormatted : AppendFormatted_MethodGroup
        class AppendFormatted_MethodGroup:
            def __getitem__(self, t:typing.Type[AppendFormatted_1_T1]) -> AppendFormatted_1[AppendFormatted_1_T1]: ...

            AppendFormatted_1_T1 = typing.TypeVar('AppendFormatted_1_T1')
            class AppendFormatted_1(typing.Generic[AppendFormatted_1_T1]):
                AppendFormatted_1_T = Debug.AssertInterpolatedStringHandler.AppendFormatted_MethodGroup.AppendFormatted_1_T1
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, format: str) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int, format: str) -> None:...

            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str]) -> None:...
            @typing.overload
            def __call__(self, value: str) -> None:...
            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str], alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: str, alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: typing.Any, alignment: int = ..., format: str = ...) -> None:...



    class WriteIfInterpolatedStringHandler:
        def __init__(self, literalLength: int, formattedCount: int, condition: bool, shouldAppend: clr.Reference[bool]) -> None: ...
        def AppendLiteral(self, value: str) -> None: ...
        # Skipped AppendFormatted due to it being static, abstract and generic.

        AppendFormatted : AppendFormatted_MethodGroup
        class AppendFormatted_MethodGroup:
            def __getitem__(self, t:typing.Type[AppendFormatted_1_T1]) -> AppendFormatted_1[AppendFormatted_1_T1]: ...

            AppendFormatted_1_T1 = typing.TypeVar('AppendFormatted_1_T1')
            class AppendFormatted_1(typing.Generic[AppendFormatted_1_T1]):
                AppendFormatted_1_T = Debug.WriteIfInterpolatedStringHandler.AppendFormatted_MethodGroup.AppendFormatted_1_T1
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, format: str) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int, format: str) -> None:...

            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str]) -> None:...
            @typing.overload
            def __call__(self, value: str) -> None:...
            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str], alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: str, alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: typing.Any, alignment: int = ..., format: str = ...) -> None:...




class DebuggableAttribute(Attribute):
    @typing.overload
    def __init__(self, isJITTrackingEnabled: bool, isJITOptimizerDisabled: bool) -> None: ...
    @typing.overload
    def __init__(self, modes: DebuggableAttribute.DebuggingModes) -> None: ...
    @property
    def DebuggingFlags(self) -> DebuggableAttribute.DebuggingModes: ...
    @property
    def IsJITOptimizerDisabled(self) -> bool: ...
    @property
    def IsJITTrackingEnabled(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...

    class DebuggingModes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : DebuggableAttribute.DebuggingModes # 0
        Default : DebuggableAttribute.DebuggingModes # 1
        IgnoreSymbolStoreSequencePoints : DebuggableAttribute.DebuggingModes # 2
        EnableEditAndContinue : DebuggableAttribute.DebuggingModes # 4
        DisableOptimizations : DebuggableAttribute.DebuggingModes # 256



class Debugger(abc.ABC):
    DefaultCategory : str
    @classmethod
    @property
    def IsAttached(cls) -> bool: ...
    @staticmethod
    def Break() -> None: ...
    @staticmethod
    def IsLogging() -> bool: ...
    @staticmethod
    def Launch() -> bool: ...
    @staticmethod
    def Log(level: int, category: str, message: str) -> None: ...
    @staticmethod
    def NotifyOfCrossThreadDependency() -> None: ...


class DebuggerBrowsableAttribute(Attribute):
    def __init__(self, state: DebuggerBrowsableState) -> None: ...
    @property
    def State(self) -> DebuggerBrowsableState: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerBrowsableState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Never : DebuggerBrowsableState # 0
    Collapsed : DebuggerBrowsableState # 2
    RootHidden : DebuggerBrowsableState # 3


class DebuggerDisplayAttribute(Attribute):
    def __init__(self, value: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Target(self) -> typing.Type[typing.Any]: ...
    @Target.setter
    def Target(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TargetTypeName(self) -> str: ...
    @TargetTypeName.setter
    def TargetTypeName(self, value: str) -> str: ...
    @property
    def Type(self) -> str: ...
    @Type.setter
    def Type(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> str: ...


class DebuggerHiddenAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerNonUserCodeAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerStepperBoundaryAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerStepThroughAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerTypeProxyAttribute(Attribute):
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    @property
    def ProxyTypeName(self) -> str: ...
    @property
    def Target(self) -> typing.Type[typing.Any]: ...
    @Target.setter
    def Target(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TargetTypeName(self) -> str: ...
    @TargetTypeName.setter
    def TargetTypeName(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerVisualizerAttribute(Attribute):
    @typing.overload
    def __init__(self, visualizer: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, visualizer: typing.Type[typing.Any], visualizerObjectSource: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, visualizer: typing.Type[typing.Any], visualizerObjectSourceTypeName: str) -> None: ...
    @typing.overload
    def __init__(self, visualizerTypeName: str) -> None: ...
    @typing.overload
    def __init__(self, visualizerTypeName: str, visualizerObjectSource: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, visualizerTypeName: str, visualizerObjectSourceTypeName: str) -> None: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Target(self) -> typing.Type[typing.Any]: ...
    @Target.setter
    def Target(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TargetTypeName(self) -> str: ...
    @TargetTypeName.setter
    def TargetTypeName(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def VisualizerObjectSourceTypeName(self) -> str: ...
    @property
    def VisualizerTypeName(self) -> str: ...


class DebugProvider:
    def __init__(self) -> None: ...
    def Fail(self, message: str, detailMessage: str) -> None: ...
    @staticmethod
    def FailCore(stackTrace: str, message: str, detailMessage: str, errorSource: str) -> None: ...
    def OnIndentLevelChanged(self, indentLevel: int) -> None: ...
    def OnIndentSizeChanged(self, indentSize: int) -> None: ...
    def Write(self, message: str) -> None: ...
    @staticmethod
    def WriteCore(message: str) -> None: ...
    def WriteLine(self, message: str) -> None: ...


class FileVersionInfo:
    @property
    def Comments(self) -> str: ...
    @property
    def CompanyName(self) -> str: ...
    @property
    def FileBuildPart(self) -> int: ...
    @property
    def FileDescription(self) -> str: ...
    @property
    def FileMajorPart(self) -> int: ...
    @property
    def FileMinorPart(self) -> int: ...
    @property
    def FileName(self) -> str: ...
    @property
    def FilePrivatePart(self) -> int: ...
    @property
    def FileVersion(self) -> str: ...
    @property
    def InternalName(self) -> str: ...
    @property
    def IsDebug(self) -> bool: ...
    @property
    def IsPatched(self) -> bool: ...
    @property
    def IsPreRelease(self) -> bool: ...
    @property
    def IsPrivateBuild(self) -> bool: ...
    @property
    def IsSpecialBuild(self) -> bool: ...
    @property
    def Language(self) -> str: ...
    @property
    def LegalCopyright(self) -> str: ...
    @property
    def LegalTrademarks(self) -> str: ...
    @property
    def OriginalFilename(self) -> str: ...
    @property
    def PrivateBuild(self) -> str: ...
    @property
    def ProductBuildPart(self) -> int: ...
    @property
    def ProductMajorPart(self) -> int: ...
    @property
    def ProductMinorPart(self) -> int: ...
    @property
    def ProductName(self) -> str: ...
    @property
    def ProductPrivatePart(self) -> int: ...
    @property
    def ProductVersion(self) -> str: ...
    @property
    def SpecialBuild(self) -> str: ...
    @staticmethod
    def GetVersionInfo(fileName: str) -> FileVersionInfo: ...
    def ToString(self) -> str: ...


class Process(Component):
    def __init__(self) -> None: ...
    @property
    def BasePriority(self) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def EnableRaisingEvents(self) -> bool: ...
    @EnableRaisingEvents.setter
    def EnableRaisingEvents(self, value: bool) -> bool: ...
    @property
    def ExitCode(self) -> int: ...
    @property
    def ExitTime(self) -> DateTime: ...
    @property
    def Handle(self) -> int: ...
    @property
    def HandleCount(self) -> int: ...
    @property
    def HasExited(self) -> bool: ...
    @property
    def Id(self) -> int: ...
    @property
    def MachineName(self) -> str: ...
    @property
    def MainModule(self) -> ProcessModule: ...
    @property
    def MainWindowHandle(self) -> int: ...
    @property
    def MainWindowTitle(self) -> str: ...
    @property
    def MaxWorkingSet(self) -> int: ...
    @MaxWorkingSet.setter
    def MaxWorkingSet(self, value: int) -> int: ...
    @property
    def MinWorkingSet(self) -> int: ...
    @MinWorkingSet.setter
    def MinWorkingSet(self, value: int) -> int: ...
    @property
    def Modules(self) -> ProcessModuleCollection: ...
    @property
    def NonpagedSystemMemorySize(self) -> int: ...
    @property
    def NonpagedSystemMemorySize64(self) -> int: ...
    @property
    def PagedMemorySize(self) -> int: ...
    @property
    def PagedMemorySize64(self) -> int: ...
    @property
    def PagedSystemMemorySize(self) -> int: ...
    @property
    def PagedSystemMemorySize64(self) -> int: ...
    @property
    def PeakPagedMemorySize(self) -> int: ...
    @property
    def PeakPagedMemorySize64(self) -> int: ...
    @property
    def PeakVirtualMemorySize(self) -> int: ...
    @property
    def PeakVirtualMemorySize64(self) -> int: ...
    @property
    def PeakWorkingSet(self) -> int: ...
    @property
    def PeakWorkingSet64(self) -> int: ...
    @property
    def PriorityBoostEnabled(self) -> bool: ...
    @PriorityBoostEnabled.setter
    def PriorityBoostEnabled(self, value: bool) -> bool: ...
    @property
    def PriorityClass(self) -> ProcessPriorityClass: ...
    @PriorityClass.setter
    def PriorityClass(self, value: ProcessPriorityClass) -> ProcessPriorityClass: ...
    @property
    def PrivateMemorySize(self) -> int: ...
    @property
    def PrivateMemorySize64(self) -> int: ...
    @property
    def PrivilegedProcessorTime(self) -> TimeSpan: ...
    @property
    def ProcessName(self) -> str: ...
    @property
    def ProcessorAffinity(self) -> int: ...
    @ProcessorAffinity.setter
    def ProcessorAffinity(self, value: int) -> int: ...
    @property
    def Responding(self) -> bool: ...
    @property
    def SafeHandle(self) -> SafeProcessHandle: ...
    @property
    def SessionId(self) -> int: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def StandardError(self) -> StreamReader: ...
    @property
    def StandardInput(self) -> StreamWriter: ...
    @property
    def StandardOutput(self) -> StreamReader: ...
    @property
    def StartInfo(self) -> ProcessStartInfo: ...
    @StartInfo.setter
    def StartInfo(self, value: ProcessStartInfo) -> ProcessStartInfo: ...
    @property
    def StartTime(self) -> DateTime: ...
    @property
    def SynchronizingObject(self) -> ISynchronizeInvoke: ...
    @SynchronizingObject.setter
    def SynchronizingObject(self, value: ISynchronizeInvoke) -> ISynchronizeInvoke: ...
    @property
    def Threads(self) -> ProcessThreadCollection: ...
    @property
    def TotalProcessorTime(self) -> TimeSpan: ...
    @property
    def UserProcessorTime(self) -> TimeSpan: ...
    @property
    def VirtualMemorySize(self) -> int: ...
    @property
    def VirtualMemorySize64(self) -> int: ...
    @property
    def WorkingSet(self) -> int: ...
    @property
    def WorkingSet64(self) -> int: ...
    def BeginErrorReadLine(self) -> None: ...
    def BeginOutputReadLine(self) -> None: ...
    def CancelErrorRead(self) -> None: ...
    def CancelOutputRead(self) -> None: ...
    def Close(self) -> None: ...
    def CloseMainWindow(self) -> bool: ...
    @staticmethod
    def EnterDebugMode() -> None: ...
    @staticmethod
    def GetCurrentProcess() -> Process: ...
    @staticmethod
    def LeaveDebugMode() -> None: ...
    def Refresh(self) -> None: ...
    def ToString(self) -> str: ...
    def WaitForExitAsync(self, cancellationToken: CancellationToken = ...) -> Task: ...
    # Skipped GetProcessById due to it being static, abstract and generic.

    GetProcessById : GetProcessById_MethodGroup
    class GetProcessById_MethodGroup:
        @typing.overload
        def __call__(self, processId: int) -> Process:...
        @typing.overload
        def __call__(self, processId: int, machineName: str) -> Process:...

    # Skipped GetProcesses due to it being static, abstract and generic.

    GetProcesses : GetProcesses_MethodGroup
    class GetProcesses_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Process]:...
        @typing.overload
        def __call__(self, machineName: str) -> Array_1[Process]:...

    # Skipped GetProcessesByName due to it being static, abstract and generic.

    GetProcessesByName : GetProcessesByName_MethodGroup
    class GetProcessesByName_MethodGroup:
        @typing.overload
        def __call__(self, processName: str) -> Array_1[Process]:...
        @typing.overload
        def __call__(self, processName: str, machineName: str) -> Array_1[Process]:...

    # Skipped Kill due to it being static, abstract and generic.

    Kill : Kill_MethodGroup
    class Kill_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, entireProcessTree: bool) -> None:...

    # Skipped Start due to it being static, abstract and generic.

    Start : Start_MethodGroup
    class Start_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, fileName: str) -> Process:...
        @typing.overload
        def __call__(self, startInfo: ProcessStartInfo) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, arguments: str) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, arguments: IEnumerable_1[str]) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, userName: str, password: SecureString, domain: str) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, arguments: str, userName: str, password: SecureString, domain: str) -> Process:...

    # Skipped WaitForExit due to it being static, abstract and generic.

    WaitForExit : WaitForExit_MethodGroup
    class WaitForExit_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, milliseconds: int) -> bool:...
        @typing.overload
        def __call__(self, timeout: TimeSpan) -> bool:...

    # Skipped WaitForInputIdle due to it being static, abstract and generic.

    WaitForInputIdle : WaitForInputIdle_MethodGroup
    class WaitForInputIdle_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, milliseconds: int) -> bool:...
        @typing.overload
        def __call__(self, timeout: TimeSpan) -> bool:...



class ProcessModule(Component):
    @property
    def BaseAddress(self) -> int: ...
    @BaseAddress.setter
    def BaseAddress(self, value: int) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def EntryPointAddress(self) -> int: ...
    @EntryPointAddress.setter
    def EntryPointAddress(self, value: int) -> int: ...
    @property
    def FileName(self) -> str: ...
    @property
    def FileVersionInfo(self) -> FileVersionInfo: ...
    @property
    def ModuleMemorySize(self) -> int: ...
    @ModuleMemorySize.setter
    def ModuleMemorySize(self, value: int) -> int: ...
    @property
    def ModuleName(self) -> str: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def ToString(self) -> str: ...


class ProcessModuleCollection(ReadOnlyCollectionBase):
    def __init__(self, processModules: Array_1[ProcessModule]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> ProcessModule: ...
    def Contains(self, module: ProcessModule) -> bool: ...
    def CopyTo(self, array: Array_1[ProcessModule], index: int) -> None: ...
    def IndexOf(self, module: ProcessModule) -> int: ...


class ProcessPriorityClass(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : ProcessPriorityClass # 32
    Idle : ProcessPriorityClass # 64
    High : ProcessPriorityClass # 128
    RealTime : ProcessPriorityClass # 256
    BelowNormal : ProcessPriorityClass # 16384
    AboveNormal : ProcessPriorityClass # 32768


class ProcessStartInfo:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fileName: str) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, arguments: str) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, arguments: IEnumerable_1[str]) -> None: ...
    @property
    def ArgumentList(self) -> Collection_1[str]: ...
    @property
    def Arguments(self) -> str: ...
    @Arguments.setter
    def Arguments(self, value: str) -> str: ...
    @property
    def CreateNoWindow(self) -> bool: ...
    @CreateNoWindow.setter
    def CreateNoWindow(self, value: bool) -> bool: ...
    @property
    def Domain(self) -> str: ...
    @Domain.setter
    def Domain(self, value: str) -> str: ...
    @property
    def Environment(self) -> IDictionary_2[str, str]: ...
    @property
    def EnvironmentVariables(self) -> StringDictionary: ...
    @property
    def ErrorDialog(self) -> bool: ...
    @ErrorDialog.setter
    def ErrorDialog(self, value: bool) -> bool: ...
    @property
    def ErrorDialogParentHandle(self) -> int: ...
    @ErrorDialogParentHandle.setter
    def ErrorDialogParentHandle(self, value: int) -> int: ...
    @property
    def FileName(self) -> str: ...
    @FileName.setter
    def FileName(self, value: str) -> str: ...
    @property
    def LoadUserProfile(self) -> bool: ...
    @LoadUserProfile.setter
    def LoadUserProfile(self, value: bool) -> bool: ...
    @property
    def Password(self) -> SecureString: ...
    @Password.setter
    def Password(self, value: SecureString) -> SecureString: ...
    @property
    def PasswordInClearText(self) -> str: ...
    @PasswordInClearText.setter
    def PasswordInClearText(self, value: str) -> str: ...
    @property
    def RedirectStandardError(self) -> bool: ...
    @RedirectStandardError.setter
    def RedirectStandardError(self, value: bool) -> bool: ...
    @property
    def RedirectStandardInput(self) -> bool: ...
    @RedirectStandardInput.setter
    def RedirectStandardInput(self, value: bool) -> bool: ...
    @property
    def RedirectStandardOutput(self) -> bool: ...
    @RedirectStandardOutput.setter
    def RedirectStandardOutput(self, value: bool) -> bool: ...
    @property
    def StandardErrorEncoding(self) -> Encoding: ...
    @StandardErrorEncoding.setter
    def StandardErrorEncoding(self, value: Encoding) -> Encoding: ...
    @property
    def StandardInputEncoding(self) -> Encoding: ...
    @StandardInputEncoding.setter
    def StandardInputEncoding(self, value: Encoding) -> Encoding: ...
    @property
    def StandardOutputEncoding(self) -> Encoding: ...
    @StandardOutputEncoding.setter
    def StandardOutputEncoding(self, value: Encoding) -> Encoding: ...
    @property
    def UseCredentialsForNetworkingOnly(self) -> bool: ...
    @UseCredentialsForNetworkingOnly.setter
    def UseCredentialsForNetworkingOnly(self, value: bool) -> bool: ...
    @property
    def UserName(self) -> str: ...
    @UserName.setter
    def UserName(self, value: str) -> str: ...
    @property
    def UseShellExecute(self) -> bool: ...
    @UseShellExecute.setter
    def UseShellExecute(self, value: bool) -> bool: ...
    @property
    def Verb(self) -> str: ...
    @Verb.setter
    def Verb(self, value: str) -> str: ...
    @property
    def Verbs(self) -> Array_1[str]: ...
    @property
    def WindowStyle(self) -> ProcessWindowStyle: ...
    @WindowStyle.setter
    def WindowStyle(self, value: ProcessWindowStyle) -> ProcessWindowStyle: ...
    @property
    def WorkingDirectory(self) -> str: ...
    @WorkingDirectory.setter
    def WorkingDirectory(self, value: str) -> str: ...


class ProcessThread(Component):
    @property
    def BasePriority(self) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def CurrentPriority(self) -> int: ...
    @property
    def Id(self) -> int: ...
    @property
    def IdealProcessor(self) -> None: ...
    @IdealProcessor.setter
    def IdealProcessor(self, value: int) -> None: ...
    @property
    def PriorityBoostEnabled(self) -> bool: ...
    @PriorityBoostEnabled.setter
    def PriorityBoostEnabled(self, value: bool) -> bool: ...
    @property
    def PriorityLevel(self) -> ThreadPriorityLevel: ...
    @PriorityLevel.setter
    def PriorityLevel(self, value: ThreadPriorityLevel) -> ThreadPriorityLevel: ...
    @property
    def PrivilegedProcessorTime(self) -> TimeSpan: ...
    @property
    def ProcessorAffinity(self) -> None: ...
    @ProcessorAffinity.setter
    def ProcessorAffinity(self, value: int) -> None: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def StartAddress(self) -> int: ...
    @property
    def StartTime(self) -> DateTime: ...
    @property
    def ThreadState(self) -> ThreadState: ...
    @property
    def TotalProcessorTime(self) -> TimeSpan: ...
    @property
    def UserProcessorTime(self) -> TimeSpan: ...
    @property
    def WaitReason(self) -> ThreadWaitReason: ...
    def ResetIdealProcessor(self) -> None: ...


class ProcessThreadCollection(ReadOnlyCollectionBase):
    def __init__(self, processThreads: Array_1[ProcessThread]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> ProcessThread: ...
    def Add(self, thread: ProcessThread) -> int: ...
    def Contains(self, thread: ProcessThread) -> bool: ...
    def CopyTo(self, array: Array_1[ProcessThread], index: int) -> None: ...
    def IndexOf(self, thread: ProcessThread) -> int: ...
    def Insert(self, index: int, thread: ProcessThread) -> None: ...
    def Remove(self, thread: ProcessThread) -> None: ...


class ProcessWindowStyle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : ProcessWindowStyle # 0
    Hidden : ProcessWindowStyle # 1
    Minimized : ProcessWindowStyle # 2
    Maximized : ProcessWindowStyle # 3


class StackFrame:
    # Constructor .ctor(skipFrames : Int32) was skipped since it collides with above method
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, lineNumber: int) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, lineNumber: int, colNumber: int) -> None: ...
    @typing.overload
    def __init__(self, needFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, skipFrames: int, needFileInfo: bool) -> None: ...
    OFFSET_UNKNOWN : int
    def GetFileColumnNumber(self) -> int: ...
    def GetFileLineNumber(self) -> int: ...
    def GetFileName(self) -> str: ...
    def GetILOffset(self) -> int: ...
    def GetMethod(self) -> MethodBase: ...
    def GetNativeOffset(self) -> int: ...
    def ToString(self) -> str: ...


class StackFrameExtensions(abc.ABC):
    @staticmethod
    def GetNativeImageBase(stackFrame: StackFrame) -> int: ...
    @staticmethod
    def GetNativeIP(stackFrame: StackFrame) -> int: ...
    @staticmethod
    def HasILOffset(stackFrame: StackFrame) -> bool: ...
    @staticmethod
    def HasMethod(stackFrame: StackFrame) -> bool: ...
    @staticmethod
    def HasNativeImage(stackFrame: StackFrame) -> bool: ...
    @staticmethod
    def HasSource(stackFrame: StackFrame) -> bool: ...


class StackTrace:
    # Constructor .ctor(e : Exception, skipFrames : Int32) was skipped since it collides with above method
    # Constructor .ctor(skipFrames : Int32) was skipped since it collides with above method
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, e: Exception) -> None: ...
    @typing.overload
    def __init__(self, e: Exception, fNeedFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, e: Exception, skipFrames: int, fNeedFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, fNeedFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, frame: StackFrame) -> None: ...
    @typing.overload
    def __init__(self, frames: IEnumerable_1[StackFrame]) -> None: ...
    @typing.overload
    def __init__(self, skipFrames: int, fNeedFileInfo: bool) -> None: ...
    METHODS_TO_SKIP : int
    @property
    def FrameCount(self) -> int: ...
    def GetFrame(self, index: int) -> StackFrame: ...
    def GetFrames(self) -> Array_1[StackFrame]: ...
    def ToString(self) -> str: ...


class StackTraceHiddenAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Stopwatch:
    def __init__(self) -> None: ...
    Frequency : int
    IsHighResolution : bool
    @property
    def Elapsed(self) -> TimeSpan: ...
    @property
    def ElapsedMilliseconds(self) -> int: ...
    @property
    def ElapsedTicks(self) -> int: ...
    @property
    def IsRunning(self) -> bool: ...
    @staticmethod
    def GetTimestamp() -> int: ...
    def Reset(self) -> None: ...
    def Restart(self) -> None: ...
    def Start(self) -> None: ...
    @staticmethod
    def StartNew() -> Stopwatch: ...
    def Stop(self) -> None: ...
    def ToString(self) -> str: ...
    # Skipped GetElapsedTime due to it being static, abstract and generic.

    GetElapsedTime : GetElapsedTime_MethodGroup
    class GetElapsedTime_MethodGroup:
        @typing.overload
        def __call__(self, startingTimestamp: int) -> TimeSpan:...
        @typing.overload
        def __call__(self, startingTimestamp: int, endingTimestamp: int) -> TimeSpan:...



class ThreadPriorityLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : ThreadPriorityLevel # 0
    AboveNormal : ThreadPriorityLevel # 1
    Highest : ThreadPriorityLevel # 2
    TimeCritical : ThreadPriorityLevel # 15
    Idle : ThreadPriorityLevel # -15
    Lowest : ThreadPriorityLevel # -2
    BelowNormal : ThreadPriorityLevel # -1


class ThreadState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Initialized : ThreadState # 0
    Ready : ThreadState # 1
    Running : ThreadState # 2
    Standby : ThreadState # 3
    Terminated : ThreadState # 4
    Wait : ThreadState # 5
    Transition : ThreadState # 6
    Unknown : ThreadState # 7


class ThreadWaitReason(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Executive : ThreadWaitReason # 0
    FreePage : ThreadWaitReason # 1
    PageIn : ThreadWaitReason # 2
    SystemAllocation : ThreadWaitReason # 3
    ExecutionDelay : ThreadWaitReason # 4
    Suspended : ThreadWaitReason # 5
    UserRequest : ThreadWaitReason # 6
    EventPairHigh : ThreadWaitReason # 7
    EventPairLow : ThreadWaitReason # 8
    LpcReceive : ThreadWaitReason # 9
    LpcReply : ThreadWaitReason # 10
    VirtualMemory : ThreadWaitReason # 11
    PageOut : ThreadWaitReason # 12
    Unknown : ThreadWaitReason # 13


class UnreachableException(Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...

