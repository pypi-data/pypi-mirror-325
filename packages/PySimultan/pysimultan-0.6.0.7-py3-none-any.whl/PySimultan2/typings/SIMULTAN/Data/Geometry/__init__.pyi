import typing, clr, abc
from SIMULTAN.Data.SimMath import SimPoint3D, SimVector3D, SimColor, SimVector, SimMatrix3D, SimSize, SimRect3D, SimQuaternion
from System import ValueTuple_2, Array_1, Action_1, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, ValueTuple_3, ValueTuple_4, IEquatable_1, Exception, Guid, DateTime
from System.Collections.Generic import IEnumerable_1, List_1, HashSet_1, Dictionary_2, IReadOnlyCollection_1, IList_1, IEnumerator_1
from SIMULTAN.Utils import IntIndex3D, IDispatcherTimerFactory, IDispatcherTimer
from SIMULTAN.Utils.UndoRedo import IUndoItem, UndoExecutionResult
from SIMULTAN.Data.Components import SimComponent, SimInstancePlacementGeometry, SimInstancePlacement, SimParameterValueSource, SimComponentInstance, SimBaseParameter
from System.Collections.ObjectModel import ObservableCollection_1
from System.ComponentModel import INotifyPropertyChanged
from System.Reflection import MethodInfo, MethodBase
from System.IO import FileInfo
from SIMULTAN.Data.Assets import ResourceFileEntry, ResourceEntry
from SIMULTAN.Data.ValueMappings import SimValueMapping
from SIMULTAN.Exchange import ComponentGeometryExchange
from SIMULTAN.Utils.BackgroundWork import IBackgroundAlgorithmInfo
from SIMULTAN.Projects import ProjectData
from System.Collections import IDictionary
from SIMULTAN.Data.Taxonomy import SimTaxonomyEntry, SimTaxonomyEntryReferenceCollection, SimTaxonomyEntryReference
from System.Collections.Specialized import INotifyCollectionChanged
from SIMULTAN.Data import SimObjectNew_1, SimId, SimManagedCollection_1, IReferenceLocation

class AABB:
    @typing.overload
    def __init__(self, edge: Edge) -> None: ...
    @typing.overload
    def __init__(self, face: Face) -> None: ...
    @typing.overload
    def __init__(self, min: SimPoint3D, max: SimPoint3D, content: BaseGeometry) -> None: ...
    @typing.overload
    def __init__(self, vertex: Vertex) -> None: ...
    @typing.overload
    def __init__(self, volume: Volume) -> None: ...
    @property
    def Content(self) -> BaseGeometry: ...
    @property
    def Max(self) -> SimPoint3D: ...
    @Max.setter
    def Max(self, value: SimPoint3D) -> SimPoint3D: ...
    @property
    def Min(self) -> SimPoint3D: ...
    @Min.setter
    def Min(self, value: SimPoint3D) -> SimPoint3D: ...
    @staticmethod
    def Merge(items: IEnumerable_1[AABB]) -> ValueTuple_2[SimPoint3D, SimPoint3D]: ...


class AABBGrid:
    def __init__(self, min: SimPoint3D, max: SimPoint3D, desiredCellSize: SimVector3D, maxCellSize: int = ...) -> None: ...
    @property
    def ActualCellSize(self) -> SimVector3D: ...
    @ActualCellSize.setter
    def ActualCellSize(self, value: SimVector3D) -> SimVector3D: ...
    @property
    def Cells(self) -> Array_1[List_1[AABB]]: ...
    @Cells.setter
    def Cells(self, value: Array_1[List_1[AABB]]) -> Array_1[List_1[AABB]]: ...
    @property
    def Item(self) -> IEnumerable_1[AABB]: ...
    @property
    def Max(self) -> SimPoint3D: ...
    @Max.setter
    def Max(self, value: SimPoint3D) -> SimPoint3D: ...
    @property
    def Min(self) -> SimPoint3D: ...
    @Min.setter
    def Min(self, value: SimPoint3D) -> SimPoint3D: ...
    def Add(self, item: AABB) -> None: ...
    def AddRange(self, items: IEnumerable_1[AABB]) -> None: ...
    def ForCell(self, position: SimPoint3D, action: Action_1[IntIndex3D]) -> None: ...
    def ForEachCell(self, item: AABB, action: Action_1[IntIndex3D]) -> None: ...
    def Remove(self, item: AABB) -> None: ...


class ActiveGeometryChangedEventArgs(EventArgs):
    def __init__(self, oldValue: BaseGeometry, newValue: BaseGeometry) -> None: ...
    @property
    def NewValue(self) -> BaseGeometry: ...
    @NewValue.setter
    def NewValue(self, value: BaseGeometry) -> BaseGeometry: ...
    @property
    def OldValue(self) -> BaseGeometry: ...
    @OldValue.setter
    def OldValue(self, value: BaseGeometry) -> BaseGeometry: ...


class AddGeometryRelationUndoItem(IUndoItem):
    def __init__(self, relation: SimGeometryRelation, relations: SimGeometryRelationCollection) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class AddPlacementUndoItem(IUndoItem):
    def __init__(self, geometry: BaseGeometry, component: SimComponent) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class BaseEdgeContainer(BaseGeometry):
    def __init__(self, id: int, layer: Layer) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Edges(self) -> ObservableCollection_1[PEdge]: ...
    @property
    def Faces(self) -> List_1[Face]: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...


class BaseGeometry(INotifyPropertyChanged, abc.ABC):
    def __init__(self, id: int, layer: Layer) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Id(self) -> int: ...
    @Id.setter
    def Id(self, value: int) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @abc.abstractmethod
    def AddToModel(self) -> None: ...
    @abc.abstractmethod
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def NotifyGeometryChanged(self) -> None: ...
    def NotifyTopologyChanged(self) -> None: ...
    def OnGeometryChanged(self, notifyGeometryChanged: bool) -> None: ...
    def OnTopologyChanged(self) -> None: ...
    @abc.abstractmethod
    def RemoveFromModel(self) -> bool: ...

    class GeometryEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any) -> None: ...



class BaseGeometryAlgorithms(abc.ABC):
    @staticmethod
    def GetVertices(geometry: BaseGeometry) -> List_1[Vertex]: ...


class BatchOperationGroupUndoItem(IUndoItem):
    @typing.overload
    def __init__(self, model: GeometryModelData) -> None: ...
    @typing.overload
    def __init__(self, model: GeometryModelData, items: List_1[IUndoItem]) -> None: ...
    @typing.overload
    def __init__(self, models: List_1[GeometryModelData]) -> None: ...
    @typing.overload
    def __init__(self, models: List_1[GeometryModelData], items: List_1[IUndoItem]) -> None: ...
    @property
    def Items(self) -> List_1[IUndoItem]: ...
    @Items.setter
    def Items(self, value: List_1[IUndoItem]) -> List_1[IUndoItem]: ...
    @property
    def Models(self) -> List_1[GeometryModelData]: ...
    @Models.setter
    def Models(self, value: List_1[GeometryModelData]) -> List_1[GeometryModelData]: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class ClipPlane:
    @typing.overload
    def __init__(self, normal: SimVector3D, distance: float) -> None: ...
    @typing.overload
    def __init__(self, plane: ClipPlane) -> None: ...
    @typing.overload
    def __init__(self, pointOnPlane: SimPoint3D, normal: SimVector3D) -> None: ...
    @property
    def Distance(self) -> float: ...
    @Distance.setter
    def Distance(self, value: float) -> float: ...
    @property
    def Normal(self) -> SimVector3D: ...
    @Normal.setter
    def Normal(self, value: SimVector3D) -> SimVector3D: ...
    def IntersectLine(self, p0: SimPoint3D, p1: SimPoint3D, epsilon: float = ..., insideEpsilon: float = ...) -> ValueTuple_2[SimPoint3D, float]: ...
    def IsInside(self, p: SimPoint3D) -> bool: ...


class DerivedColor(INotifyPropertyChanged):
    @typing.overload
    def __init__(self, color: SimColor, isFromParent: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, source: DerivedColor) -> None: ...
    @property
    def Color(self) -> SimColor: ...
    @Color.setter
    def Color(self, value: SimColor) -> SimColor: ...
    @property
    def IsFromParent(self) -> bool: ...
    @IsFromParent.setter
    def IsFromParent(self, value: bool) -> bool: ...
    @property
    def LocalColor(self) -> SimColor: ...
    @property
    def Parent(self) -> typing.Any: ...
    @Parent.setter
    def Parent(self, value: typing.Any) -> typing.Any: ...
    @property
    def ParentColor(self) -> SimColor: ...


class DetectionAlgorithms(abc.ABC):
    @staticmethod
    def BestFittingPlane(points: IEnumerable_1[SimPoint3D]) -> ValueTuple_3[SimPoint3D, SimVector3D, float]: ...
    @staticmethod
    def DetectFacesFromEdges(edges: List_1[Edge], model: GeometryModelData) -> List_1[BaseGeometry]: ...
    @staticmethod
    def DirectionFromFaceAndEdge(face: Face, edge: PEdge) -> SimVector3D: ...
    @staticmethod
    def FindConnectedEdgeGroups(edges: IEnumerable_1[Edge]) -> Array_1[List_1[Edge]]: ...
    @staticmethod
    def FindConnectedEdgeLoopGroups(loops: IEnumerable_1[EdgeLoop]) -> Array_1[List_1[EdgeLoop]]: ...
    @staticmethod
    def ShortAngleDist(a0: float, a1: float) -> float: ...
    # Skipped DetectXZFaces due to it being static, abstract and generic.

    DetectXZFaces : DetectXZFaces_MethodGroup
    class DetectXZFaces_MethodGroup:
        @typing.overload
        def __call__(self, model: GeometryModelData, tolerance: float) -> None:...
        @typing.overload
        def __call__(self, model: GeometryModelData, edges: IEnumerable_1[Edge], tolerance: float) -> None:...

    # Skipped SignedAngle due to it being static, abstract and generic.

    SignedAngle : SignedAngle_MethodGroup
    class SignedAngle_MethodGroup:
        @typing.overload
        def __call__(self, v1: SimVector, v2: SimVector) -> float:...
        @typing.overload
        def __call__(self, v1: SimVector3D, v2: SimVector3D, vn: SimVector3D) -> float:...



class DummyOffsetSurfaceGenerator(abc.ABC):
    # Skipped Update due to it being static, abstract and generic.

    Update : Update_MethodGroup
    class Update_MethodGroup:
        @typing.overload
        def __call__(self, model: GeometryModelData) -> None:...
        @typing.overload
        def __call__(self, model: GeometryModelData, invalidatedGeometry: IEnumerable_1[BaseGeometry]) -> IEnumerable_1[Face]:...



class Edge(BaseGeometry):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, vertices: IEnumerable_1[Vertex]) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, vertices: IEnumerable_1[Vertex]) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def PEdges(self) -> List_1[PEdge]: ...
    @PEdges.setter
    def PEdges(self, value: List_1[PEdge]) -> List_1[PEdge]: ...
    @property
    def Vertices(self) -> ObservableCollection_1[Vertex]: ...
    @Vertices.setter
    def Vertices(self, value: ObservableCollection_1[Vertex]) -> ObservableCollection_1[Vertex]: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFromModel(self) -> bool: ...


class EdgeAlgorithms(abc.ABC):
    @staticmethod
    def AdjacentFaces(e: Edge, faces: clr.Reference[HashSet_1[Face]]) -> None: ...
    @staticmethod
    def ContainedGeometry(e: Edge, geometries: clr.Reference[List_1[BaseGeometry]]) -> None: ...
    @staticmethod
    def EdgeEdgeIntersection(e1: Edge, e2: Edge, tolerance: float, endLineTolerance: float = ...) -> ValueTuple_3[bool, float, float]: ...
    @staticmethod
    def EdgeEdgeIntersection2D(e0p0: SimPoint3D, e0p1: SimPoint3D, e1p0: SimPoint3D, e1p1: SimPoint3D, tolerance: float) -> ValueTuple_3[bool, float, float]: ...
    @staticmethod
    def EdgePointIntersection(e1: Edge, p: SimPoint3D) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def IntersectEdges(edge1: Edge, edge2: Edge, tolerance: float = ...) -> ValueTuple_3[Vertex, Array_1[Edge], IUndoItem]: ...
    @staticmethod
    def IsConnectedEdge(e1: Edge, e2: Edge) -> bool: ...
    @staticmethod
    def IsHorizontal(e: Edge, epsilon: float = ...) -> bool: ...
    @staticmethod
    def IsOnSameLine(e1: Edge, e2: Edge, tolerance: float) -> bool: ...
    @staticmethod
    def IsSimilarEdge(e1: Edge, e2: Edge) -> bool: ...
    @staticmethod
    def Length(edge: Edge) -> float: ...
    @staticmethod
    def OrderedPointLoop(edges: IEnumerable_1[Edge], matrix: SimMatrix3D) -> List_1[SimPoint3D]: ...
    @staticmethod
    def OrderedVertexLoop(edges: IEnumerable_1[Edge]) -> List_1[Vertex]: ...
    @staticmethod
    def ReplaceEdge(original: Edge, replacements: List_1[Edge]) -> None: ...
    @staticmethod
    def SplitEdge(e: Edge, splitPosition: SimPoint3D) -> ValueTuple_3[Vertex, Array_1[Edge], IUndoItem]: ...
    # Skipped Direction due to it being static, abstract and generic.

    Direction : Direction_MethodGroup
    class Direction_MethodGroup:
        @typing.overload
        def __call__(self, e: Edge) -> SimVector3D:...
        @typing.overload
        def __call__(self, e: PEdge) -> SimVector3D:...

    # Skipped OrderLoop due to it being static, abstract and generic.

    OrderLoop : OrderLoop_MethodGroup
    class OrderLoop_MethodGroup:
        @typing.overload
        def __call__(self, edges: IEnumerable_1[Edge]) -> ValueTuple_2[bool, List_1[Edge]]:...
        @typing.overload
        def __call__(self, edges: IEnumerable_1[PEdge]) -> ValueTuple_2[bool, List_1[PEdge]]:...



class EdgeLoop(BaseEdgeContainer):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, edges: IEnumerable_1[Edge]) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, edges: IEnumerable_1[Edge]) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Edges(self) -> ObservableCollection_1[PEdge]: ...
    @property
    def Faces(self) -> List_1[Face]: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFromModel(self) -> bool: ...


class EdgeLoopAlgorithms(abc.ABC):
    @staticmethod
    def BoundaryFace(loop: EdgeLoop) -> Face: ...
    @staticmethod
    def Contains2D(polygon: List_1[SimPoint3D], point: SimPoint3D, tolerance: float, zTolerance: float) -> bool: ...
    @staticmethod
    def Extrude(inputLoop: EdgeLoop, distance: float, normal: SimVector3D) -> ValueTuple_2[List_1[BaseGeometry], EdgeLoop]: ...
    @staticmethod
    def Flip(loop: EdgeLoop) -> None: ...
    @staticmethod
    def HeightMinMax(loop: EdgeLoop) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def IsSimilar(loop1: EdgeLoop, loop2: EdgeLoop) -> bool: ...
    @staticmethod
    def LoopToXYMapping(loop: EdgeLoop) -> SimMatrix3D: ...
    @staticmethod
    def Size(loop: EdgeLoop) -> SimSize: ...
    @staticmethod
    def StraightEdgeCount(loop: EdgeLoop, tolerance: float) -> int: ...
    # Skipped Area due to it being static, abstract and generic.

    Area : Area_MethodGroup
    class Area_MethodGroup:
        @typing.overload
        def __call__(self, loop: EdgeLoop) -> float:...
        @typing.overload
        def __call__(self, boundary: IEnumerable_1[SimPoint3D]) -> float:...

    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, loop: EdgeLoop, other: EdgeLoop, tolerance: float, zTolerance: float) -> GeometricRelation:...
        @typing.overload
        def __call__(self, l: EdgeLoop, v: SimPoint3D, tolerance: float, zTolerance: float) -> GeometricRelation:...
        @typing.overload
        def __call__(self, loop: List_1[Edge], other: List_1[Edge], mapping: SimMatrix3D, tolerance: float, zTolerance: float) -> GeometricRelation:...

    # Skipped NormalCCW due to it being static, abstract and generic.

    NormalCCW : NormalCCW_MethodGroup
    class NormalCCW_MethodGroup:
        @typing.overload
        def __call__(self, edgeLoopPositions: List_1[SimPoint3D]) -> SimVector3D:...
        @typing.overload
        def __call__(self, loop: EdgeLoop) -> SimVector3D:...

    # Skipped Perimeter due to it being static, abstract and generic.

    Perimeter : Perimeter_MethodGroup
    class Perimeter_MethodGroup:
        @typing.overload
        def __call__(self, polygon: List_1[SimPoint3D]) -> float:...
        @typing.overload
        def __call__(self, loop: EdgeLoop) -> float:...



class Face(BaseGeometry):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, boundary: EdgeLoop, orientation: GeometricOrientation = ..., holes: IEnumerable_1[EdgeLoop] = ..., baseEdge: Edge = ...) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, boundary: EdgeLoop, orientation: GeometricOrientation = ..., holes: IEnumerable_1[EdgeLoop] = ..., baseEdge: Edge = ...) -> None: ...
    @property
    def BaseEdge(self) -> Edge: ...
    @BaseEdge.setter
    def BaseEdge(self, value: Edge) -> Edge: ...
    @property
    def Boundary(self) -> EdgeLoop: ...
    @Boundary.setter
    def Boundary(self, value: EdgeLoop) -> EdgeLoop: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Holes(self) -> ObservableCollection_1[EdgeLoop]: ...
    @Holes.setter
    def Holes(self, value: ObservableCollection_1[EdgeLoop]) -> ObservableCollection_1[EdgeLoop]: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Normal(self) -> SimVector3D: ...
    @Normal.setter
    def Normal(self, value: SimVector3D) -> SimVector3D: ...
    @property
    def Orientation(self) -> GeometricOrientation: ...
    @Orientation.setter
    def Orientation(self, value: GeometricOrientation) -> GeometricOrientation: ...
    @property
    def PFaces(self) -> List_1[PFace]: ...
    @PFaces.setter
    def PFaces(self, value: List_1[PFace]) -> List_1[PFace]: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFromModel(self) -> bool: ...


class FaceAlgorithms(abc.ABC):
    @staticmethod
    def AngleBetweenOrthogonalFaceDirections(currentFaceDirection: SimVector3D, edgeDirection: SimVector3D, otherFaceDirection: SimVector3D) -> float: ...
    @staticmethod
    def Area(f: Face) -> float: ...
    @staticmethod
    def AreaInnerOuter(f: Face) -> ValueTuple_3[float, float, float]: ...
    @staticmethod
    def AreaMinMax(f: Face) -> ValueTuple_3[float, float, float]: ...
    @staticmethod
    def Center(face: Face) -> SimPoint3D: ...
    @staticmethod
    def ContainedGeometry(f: Face, geometries: clr.Reference[List_1[BaseGeometry]]) -> None: ...
    @staticmethod
    def Contains(f: Face, v: SimPoint3D, tolerance: float, zTolerance: float) -> GeometricRelation: ...
    @staticmethod
    def FaceToXYMapping(face: Face, orientation: GeometricOrientation = ...) -> SimMatrix3D: ...
    @staticmethod
    def FindCommonVolume(faces: IEnumerable_1[Face], model: GeometryModelData) -> Volume: ...
    @staticmethod
    def FindOrthogonalDirectionInFace(inputEdge: Edge, face: Face, epsilon: float) -> SimVector3D: ...
    @staticmethod
    def Halfspace(face: Face, points: IEnumerable_1[SimPoint3D], tolerance: float = ...) -> GeometricOrientation: ...
    @staticmethod
    def HeightMinMax(f: Face) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def HessianPlane(f: Face) -> ClipPlane: ...
    @staticmethod
    def IntersectsLine(face: Face, lineStart: SimPoint3D, lineEnd: SimPoint3D, tolerance: float = ...) -> bool: ...
    @staticmethod
    def IntersectsRay(face: Face, rayStart: SimPoint3D, rayDirection: SimVector3D, tolerance: float = ...) -> bool: ...
    @staticmethod
    def IsClosedHull(faces: IEnumerable_1[Face]) -> bool: ...
    @staticmethod
    def IsFaceOfHole(face: Face) -> bool: ...
    @staticmethod
    def IsFloorOrCeiling(f: Face) -> bool: ...
    @staticmethod
    def IsSamePlane(plane1: ValueTuple_2[SimVector3D, float], plane2: ValueTuple_2[SimVector3D, float], angleTolerance: float, distanceTolerance: float) -> bool: ...
    @staticmethod
    def Perimeter(f: Face) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def Size(f: Face) -> ValueTuple_3[SimSize, SimSize, SimSize]: ...
    @staticmethod
    def SplitFace(f: Face) -> None: ...
    @staticmethod
    def XYSize(face: Face) -> SimSize: ...
    # Skipped Contains2D due to it being static, abstract and generic.

    Contains2D : Contains2D_MethodGroup
    class Contains2D_MethodGroup:
        @typing.overload
        def __call__(self, f: Face, e: Edge, tolerance: float, zTolerance: float) -> GeometricRelation:...
        @typing.overload
        def __call__(self, fouter: Face, f: Face, tolerance: float, zTolerance: float) -> GeometricRelation:...

    # Skipped Extrude due to it being static, abstract and generic.

    Extrude : Extrude_MethodGroup
    class Extrude_MethodGroup:
        @typing.overload
        def __call__(self, faces: IEnumerable_1[Face], referenceFace: Face, height: float) -> ValueTuple_3[List_1[BaseGeometry], List_1[Face], Face]:...
        @typing.overload
        def __call__(self, faces: IEnumerable_1[Face], referenceFace: Face, height: float, normal: SimVector3D) -> ValueTuple_3[List_1[BaseGeometry], List_1[Face], Face]:...

    # Skipped IsCeiling due to it being static, abstract and generic.

    IsCeiling : IsCeiling_MethodGroup
    class IsCeiling_MethodGroup:
        @typing.overload
        def __call__(self, normal: SimVector3D) -> bool:...
        @typing.overload
        def __call__(self, f: PFace) -> bool:...

    # Skipped IsFloor due to it being static, abstract and generic.

    IsFloor : IsFloor_MethodGroup
    class IsFloor_MethodGroup:
        @typing.overload
        def __call__(self, normal: SimVector3D) -> bool:...
        @typing.overload
        def __call__(self, f: PFace) -> bool:...

    # Skipped OrientationIncline due to it being static, abstract and generic.

    OrientationIncline : OrientationIncline_MethodGroup
    class OrientationIncline_MethodGroup:
        @typing.overload
        def __call__(self, normal: SimVector3D, tolerance: float = ...) -> ValueTuple_2[float, float]:...
        @typing.overload
        def __call__(self, pface: PFace, tolerance: float = ...) -> ValueTuple_2[float, float]:...

    # Skipped Triangulate due to it being static, abstract and generic.

    Triangulate : Triangulate_MethodGroup
    class Triangulate_MethodGroup:
        @typing.overload
        def __call__(self, face: Face, orientation: GeometricOrientation = ...) -> ValueTuple_3[List_1[SimPoint3D], List_1[SimVector3D], List_1[int]]:...
        @typing.overload
        def __call__(self, boundary: List_1[SimPoint3D], holes: IEnumerable_1[List_1[SimPoint3D]], normal: SimVector3D, orientation: GeometricOrientation = ...) -> ValueTuple_3[List_1[SimPoint3D], List_1[SimVector3D], List_1[int]]:...

    # Skipped TriangulateBoundary due to it being static, abstract and generic.

    TriangulateBoundary : TriangulateBoundary_MethodGroup
    class TriangulateBoundary_MethodGroup:
        @typing.overload
        def __call__(self, face: PFace) -> ValueTuple_3[List_1[SimPoint3D], List_1[SimVector3D], List_1[int]]:...
        @typing.overload
        def __call__(self, face: Face, orientation: GeometricOrientation) -> ValueTuple_3[List_1[SimPoint3D], List_1[SimVector3D], List_1[int]]:...
        @typing.overload
        def __call__(self, boundary: List_1[SimPoint3D], normal: SimVector3D, orientation: GeometricOrientation = ...) -> ValueTuple_3[List_1[SimPoint3D], List_1[SimVector3D], List_1[int]]:...



class Frustum:
    def __init__(self, clipPlanes: List_1[ClipPlane]) -> None: ...
    @property
    def Planes(self) -> List_1[ClipPlane]: ...
    @Planes.setter
    def Planes(self, value: List_1[ClipPlane]) -> List_1[ClipPlane]: ...
    def Clip(self, ngon: List_1[SimPoint3D]) -> List_1[SimPoint3D]: ...
    def IsNgonInside(self, ngon: List_1[SimPoint3D], allowPartially: bool = ...) -> bool: ...
    def IsPointInside(self, p: SimPoint3D) -> bool: ...


class GeometricOrientation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Undefined : GeometricOrientation # 0
    Forward : GeometricOrientation # 1
    Backward : GeometricOrientation # -1


class GeometricRelation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Contained : GeometricRelation # 0
    Intersecting : GeometricRelation # 1
    None_ : GeometricRelation # 2


class GeometryAddUndoItem(IUndoItem):
    def __init__(self, createdGeometry: List_1[BaseGeometry], model: GeometryModelData) -> None: ...
    @property
    def CreatedGeometry(self) -> List_1[BaseGeometry]: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class GeometryAlgorithms(abc.ABC):
    @staticmethod
    def ClosestPointOnLine(p: SimPoint3D, lineOrigin: SimPoint3D, lineDirection: SimVector3D) -> ValueTuple_2[SimPoint3D, float]: ...
    @staticmethod
    def LineLineClosestPoint(l0Origin: SimPoint3D, l0Direction: SimVector3D, l1Origin: SimPoint3D, l1Direction: SimVector3D) -> ValueTuple_4[SimPoint3D, float, SimPoint3D, float]: ...
    @staticmethod
    def LineLineDistance(l0Origin: SimPoint3D, l0Direction: SimVector3D, l1Origin: SimPoint3D, l1Direction: SimVector3D) -> float: ...
    @staticmethod
    def LineSegmentClosesPoint(segmentP0: SimPoint3D, segmentP1: SimPoint3D, rayOrigin: SimPoint3D, rayDirection: SimVector3D) -> ValueTuple_2[SimPoint3D, SimPoint3D]: ...
    @staticmethod
    def LineSegmentDistance(segmentP0: SimPoint3D, segmentP1: SimPoint3D, rayOrigin: SimPoint3D, rayDirection: SimVector3D) -> float: ...
    @staticmethod
    def TryOrthogonalize(reference: SimVector3D, toOrthogonalize: SimVector3D, epsilon: float, result: clr.Reference[SimVector3D]) -> bool: ...


class GeometryImporterCache:
    def __init__(self) -> None: ...
    def CacheImportedGeometry(self, file: FileInfo, geometry: SimMeshGeometryData) -> None: ...
    def TryGetCachedImportedGeometry(self, file: FileInfo) -> SimMeshGeometryData: ...


class GeometryInvalidatedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, affected_geometry: IEnumerable_1[BaseGeometry], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, affected_geometry: IEnumerable_1[BaseGeometry]) -> None: ...


class GeometryModel(INotifyPropertyChanged):
    def __init__(self, name: str, file: ResourceFileEntry, permissions: OperationPermission, geometry: GeometryModelData) -> None: ...
    @property
    def ActiveValueMapping(self) -> SimValueMapping: ...
    @ActiveValueMapping.setter
    def ActiveValueMapping(self, value: SimValueMapping) -> SimValueMapping: ...
    @property
    def CleanupTolerance(self) -> float: ...
    @CleanupTolerance.setter
    def CleanupTolerance(self, value: float) -> float: ...
    @property
    def Exchange(self) -> ComponentGeometryExchange: ...
    @Exchange.setter
    def Exchange(self, value: ComponentGeometryExchange) -> ComponentGeometryExchange: ...
    @property
    def File(self) -> ResourceFileEntry: ...
    @File.setter
    def File(self, value: ResourceFileEntry) -> ResourceFileEntry: ...
    @property
    def Geometry(self) -> GeometryModelData: ...
    @Geometry.setter
    def Geometry(self, value: GeometryModelData) -> GeometryModelData: ...
    @property
    def IsValueMappingEnabled(self) -> bool: ...
    @IsValueMappingEnabled.setter
    def IsValueMappingEnabled(self, value: bool) -> bool: ...
    @property
    def LinkedModels(self) -> ObservableCollection_1[GeometryModel]: ...
    @LinkedModels.setter
    def LinkedModels(self, value: ObservableCollection_1[GeometryModel]) -> ObservableCollection_1[GeometryModel]: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Permissions(self) -> OperationPermission: ...
    @Permissions.setter
    def Permissions(self, value: OperationPermission) -> OperationPermission: ...
    @property
    def ValueMappings(self) -> ObservableCollection_1[SimValueMapping]: ...


class GeometryModelAlgorithms(abc.ABC):
    @staticmethod
    def CheckConsistency(model: GeometryModelData) -> None: ...
    @staticmethod
    def CopyContent(from_: GeometryModelData, to: GeometryModelData, preserveIds: bool = ...) -> ValueTuple_2[Dictionary_2[BaseGeometry, BaseGeometry], Dictionary_2[Layer, Layer]]: ...
    @staticmethod
    def GetAllContainingGeometries(initialGeometry: IEnumerable_1[BaseGeometry]) -> List_1[BaseGeometry]: ...
    @staticmethod
    def GetAllVisibleGeometries(model: GeometryModelData) -> IEnumerable_1[BaseGeometry]: ...
    @staticmethod
    def SetAllVisibility(model: GeometryModelData, isVisible: bool) -> None: ...
    @staticmethod
    def UpdateGeometryModelWithExistingIds(oldGeometryModel: GeometryModelData, newGeometryModel: GeometryModelData, outGeometryModel: GeometryModelData) -> None: ...
    # Skipped Boundary due to it being static, abstract and generic.

    Boundary : Boundary_MethodGroup
    class Boundary_MethodGroup:
        @typing.overload
        def __call__(self, geometry: IEnumerable_1[BaseGeometry], includeInvisible: bool) -> SimRect3D:...
        @typing.overload
        def __call__(self, models: IEnumerable_1[GeometryModelData], includeInvisible: bool) -> SimRect3D:...

    # Skipped GetAllAffectedGeometries due to it being static, abstract and generic.

    GetAllAffectedGeometries : GetAllAffectedGeometries_MethodGroup
    class GetAllAffectedGeometries_MethodGroup:
        @typing.overload
        def __call__(self, initialGeometry: IEnumerable_1[Vertex]) -> List_1[BaseGeometry]:...
        @typing.overload
        def __call__(self, initialGeometry: IEnumerable_1[BaseGeometry]) -> List_1[BaseGeometry]:...



class GeometryModelData(INotifyPropertyChanged):
    @typing.overload
    def __init__(self, dispatcherTimer: IDispatcherTimerFactory) -> None: ...
    @typing.overload
    def __init__(self, nextId: int, dispatcherTimer: IDispatcherTimerFactory) -> None: ...
    @property
    def EdgeLoops(self) -> ObservableCollection_1[EdgeLoop]: ...
    @EdgeLoops.setter
    def EdgeLoops(self, value: ObservableCollection_1[EdgeLoop]) -> ObservableCollection_1[EdgeLoop]: ...
    @property
    def Edges(self) -> ObservableCollection_1[Edge]: ...
    @Edges.setter
    def Edges(self, value: ObservableCollection_1[Edge]) -> ObservableCollection_1[Edge]: ...
    @property
    def Faces(self) -> ObservableCollection_1[Face]: ...
    @Faces.setter
    def Faces(self, value: ObservableCollection_1[Face]) -> ObservableCollection_1[Face]: ...
    @property
    def Geometries(self) -> IEnumerable_1[BaseGeometry]: ...
    @property
    def GeoReferences(self) -> ObservableCollection_1[GeoReference]: ...
    @GeoReferences.setter
    def GeoReferences(self, value: ObservableCollection_1[GeoReference]) -> ObservableCollection_1[GeoReference]: ...
    @property
    def HandleConsistency(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layers(self) -> ObservableCollection_1[Layer]: ...
    @Layers.setter
    def Layers(self, value: ObservableCollection_1[Layer]) -> ObservableCollection_1[Layer]: ...
    @property
    def Model(self) -> GeometryModel: ...
    @Model.setter
    def Model(self, value: GeometryModel) -> GeometryModel: ...
    @property
    def OffsetModel(self) -> OffsetModel: ...
    @OffsetModel.setter
    def OffsetModel(self, value: OffsetModel) -> OffsetModel: ...
    @property
    def Polylines(self) -> ObservableCollection_1[Polyline]: ...
    @Polylines.setter
    def Polylines(self, value: ObservableCollection_1[Polyline]) -> ObservableCollection_1[Polyline]: ...
    @property
    def ProxyGeometries(self) -> ObservableCollection_1[ProxyGeometry]: ...
    @ProxyGeometries.setter
    def ProxyGeometries(self, value: ObservableCollection_1[ProxyGeometry]) -> ObservableCollection_1[ProxyGeometry]: ...
    @property
    def Vertices(self) -> ObservableCollection_1[Vertex]: ...
    @Vertices.setter
    def Vertices(self, value: ObservableCollection_1[Vertex]) -> ObservableCollection_1[Vertex]: ...
    @property
    def Volumes(self) -> ObservableCollection_1[Volume]: ...
    @Volumes.setter
    def Volumes(self, value: ObservableCollection_1[Volume]) -> ObservableCollection_1[Volume]: ...
    def Clone(self) -> GeometryModelData: ...
    def ContainsGeometry(self, geometry: BaseGeometry) -> bool: ...
    def EndBatchOperation(self) -> None: ...
    def FreeId(self, id: int) -> None: ...
    def GeometryFromId(self, id: int) -> BaseGeometry: ...
    def GetFreeId(self, increment: bool = ...) -> int: ...
    def LayerFromId(self, id: int) -> Layer: ...
    def MakeConsistent(self) -> None: ...
    def NotifyTopologyChanged(self, sender: BaseGeometry) -> None: ...
    def OnOperationFinished(self, affectedGeometries: IEnumerable_1[BaseGeometry]) -> None: ...
    def RegisterId(self, id: int, geometry: BaseGeometry) -> None: ...
    def StartBatchOperation(self) -> None: ...

    class BaseGeometryEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, geometry: IEnumerable_1[BaseGeometry], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, geometry: IEnumerable_1[BaseGeometry]) -> None: ...


    class GeometryChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, geometries: IEnumerable_1[BaseGeometry], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, geometries: IEnumerable_1[BaseGeometry]) -> None: ...


    class GeoReferencesChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, geoReferences: IEnumerable_1[GeoReference], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, geoReferences: IEnumerable_1[GeoReference]) -> None: ...


    class OperationFinishedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, affectedGeometries: IEnumerable_1[BaseGeometry], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, affectedGeometries: IEnumerable_1[BaseGeometry]) -> None: ...


    class TopologyChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, geometries: IEnumerable_1[BaseGeometry], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, geometries: IEnumerable_1[BaseGeometry]) -> None: ...



class GeometryModelOperationPermissions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : GeometryModelOperationPermissions # 0
    RemoveLinked : GeometryModelOperationPermissions # 1
    AddLinked : GeometryModelOperationPermissions # 2
    All : GeometryModelOperationPermissions # 18446744073709551615


class GeometryModelReplacedEventArgs(EventArgs):
    def __init__(self, oldGeometry: GeometryModelData, newGeometry: GeometryModelData) -> None: ...
    @property
    def NewGeometry(self) -> GeometryModelData: ...
    @property
    def OldGeometry(self) -> GeometryModelData: ...


class GeometryOperationPermissions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : GeometryOperationPermissions # 0
    Select : GeometryOperationPermissions # 1
    Move : GeometryOperationPermissions # 3
    Delete : GeometryOperationPermissions # 5
    Create : GeometryOperationPermissions # 8
    Split : GeometryOperationPermissions # 17
    Unsplit : GeometryOperationPermissions # 33
    ModifyLayer : GeometryOperationPermissions # 65
    ModifyName : GeometryOperationPermissions # 129
    ModifyColor : GeometryOperationPermissions # 257
    ModifyParent : GeometryOperationPermissions # 1025
    All : GeometryOperationPermissions # 18446744073709551615


class GeometryRelationChangedEventArgs(EventArgs):
    def __init__(self, relation: SimGeometryRelation) -> None: ...
    @property
    def Relation(self) -> SimGeometryRelation: ...


class GeometryRelationsFileMapping:
    def __init__(self, fileId: int, path: str) -> None: ...
    @property
    def FileId(self) -> int: ...
    @property
    def FilePath(self) -> str: ...


class GeometryRemoveUndoItem(IUndoItem):
    def __init__(self, deletedGeometry: List_1[BaseGeometry], model: GeometryModelData) -> None: ...
    @property
    def DeletedGeometry(self) -> List_1[BaseGeometry]: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class GeometrySelectionModel:
    def __init__(self, models: ObservableCollection_1[GeometryModel]) -> None: ...
    @property
    def ActiveGeometry(self) -> BaseGeometry: ...
    @ActiveGeometry.setter
    def ActiveGeometry(self, value: BaseGeometry) -> BaseGeometry: ...
    @property
    def SelectedGeometry(self) -> IReadOnlyCollection_1[BaseGeometry]: ...
    def Clear(self) -> None: ...
    def MakeConsistent(self) -> None: ...
    def ToggleSelection(self, geometry: BaseGeometry) -> None: ...
    # Skipped Deselect due to it being static, abstract and generic.

    Deselect : Deselect_MethodGroup
    class Deselect_MethodGroup:
        @typing.overload
        def __call__(self, geometry: IEnumerable_1[BaseGeometry]) -> None:...
        @typing.overload
        def __call__(self, geometry: BaseGeometry) -> None:...
        @typing.overload
        def __call__(self, model: GeometryModelData) -> None:...

    # Skipped IsSelected due to it being static, abstract and generic.

    IsSelected : IsSelected_MethodGroup
    class IsSelected_MethodGroup:
        @typing.overload
        def __call__(self, geometry: BaseGeometry) -> bool:...
        @typing.overload
        def __call__(self, model: GeometryModelData) -> bool:...

    # Skipped Select due to it being static, abstract and generic.

    Select : Select_MethodGroup
    class Select_MethodGroup:
        @typing.overload
        def __call__(self, geometry: IEnumerable_1[BaseGeometry], clearSelection: bool) -> None:...
        @typing.overload
        def __call__(self, geometry: BaseGeometry, clearSelection: bool) -> None:...
        @typing.overload
        def __call__(self, model: GeometryModelData, clearSelection: bool) -> None:...


    class ActiveGeometryChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, args: ActiveGeometryChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, args: ActiveGeometryChangedEventArgs) -> None: ...


    class SelectionChangedEventArgs(EventArgs):
        def __init__(self, reason: GeometrySelectionModel.SelectionChangedReason, added: IEnumerable_1[BaseGeometry], removed: IEnumerable_1[BaseGeometry]) -> None: ...
        @property
        def Added(self) -> IEnumerable_1[BaseGeometry]: ...
        @Added.setter
        def Added(self, value: IEnumerable_1[BaseGeometry]) -> IEnumerable_1[BaseGeometry]: ...
        @property
        def Reason(self) -> GeometrySelectionModel.SelectionChangedReason: ...
        @Reason.setter
        def Reason(self, value: GeometrySelectionModel.SelectionChangedReason) -> GeometrySelectionModel.SelectionChangedReason: ...
        @property
        def Removed(self) -> IEnumerable_1[BaseGeometry]: ...
        @Removed.setter
        def Removed(self, value: IEnumerable_1[BaseGeometry]) -> IEnumerable_1[BaseGeometry]: ...


    class SelectionChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, args: GeometrySelectionModel.SelectionChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, args: GeometrySelectionModel.SelectionChangedEventArgs) -> None: ...


    class SelectionChangedReason(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        User : GeometrySelectionModel.SelectionChangedReason # 0
        UndoRedo : GeometrySelectionModel.SelectionChangedReason # 1



class GeometrySettings:
    def __init__(self) -> None: ...
    @property
    def CalculateOffsetSurfaces(self) -> bool: ...
    @CalculateOffsetSurfaces.setter
    def CalculateOffsetSurfaces(self, value: bool) -> bool: ...
    @classmethod
    @property
    def Instance(cls) -> GeometrySettings: ...
    @property
    def OffsetSurfaceRecalcDelay(self) -> int: ...
    @OffsetSurfaceRecalcDelay.setter
    def OffsetSurfaceRecalcDelay(self, value: int) -> int: ...
    @property
    def Tolerance(self) -> float: ...
    @Tolerance.setter
    def Tolerance(self, value: float) -> float: ...
    @property
    def ToleranceSquared(self) -> float: ...


class GeoReference(INotifyPropertyChanged):
    def __init__(self, vertex: Vertex, reference: SimPoint3D) -> None: ...
    @property
    def ReferencePoint(self) -> SimPoint3D: ...
    @ReferencePoint.setter
    def ReferencePoint(self, value: SimPoint3D) -> SimPoint3D: ...
    @property
    def Vertex(self) -> Vertex: ...
    @Vertex.setter
    def Vertex(self, value: Vertex) -> Vertex: ...


class GeoReferenceAlgorithms(abc.ABC):
    @staticmethod
    def CartToWGS84(point: SimPoint3D, precision: float = ..., maxIterations: int = ...) -> SimPoint3D: ...
    @staticmethod
    def ConvertToFlatEarth(wgsCoordinates: IEnumerable_1[SimPoint3D], wgsOrigin: SimPoint3D) -> IEnumerable_1[SimPoint3D]: ...
    @staticmethod
    def ConvertUTMToWGS84(utm: UTMCoord) -> SimPoint3D: ...
    @staticmethod
    def CreateAlignedWGSGrid(midPoint: SimPoint3D, widthInM: float, heightInM: float, spacingX: float, spacingY: float, toCartesian: bool = ...) -> Array_1[SimPoint3D]: ...
    @staticmethod
    def EstimateWGSNonLinear(positions: List_1[SimPoint3D], geoReferences: List_1[GeoRefPoint]) -> List_1[SimPoint3D]: ...
    @staticmethod
    def GeoReferenceMesh(positions: List_1[SimPoint3D], geoReferences: List_1[GeoRefPoint]) -> ValueTuple_2[List_1[SimPoint3D], List_1[SimPoint3D]]: ...
    @staticmethod
    def TangentFrame(p: SimPoint3D) -> ValueTuple_3[SimVector3D, SimVector3D, SimVector3D]: ...
    @staticmethod
    def ValidateGeoReferences(geoReferences: List_1[GeoRefPoint]) -> bool: ...
    @staticmethod
    def VincentyDirect(p: SimPoint3D, azimuth: float, distance: float, tolerance: float = ..., maxIterations: int = ...) -> ValueTuple_2[SimPoint3D, float]: ...
    @staticmethod
    def VincentyIndirect(source: SimPoint3D, dest: SimPoint3D, tolerance: float = ...) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def WGS84ToCart(p: SimPoint3D) -> SimPoint3D: ...


class GeoRefPoint:
    def __init__(self, OS: SimPoint3D, WGS: SimPoint3D) -> None: ...
    @property
    def OS(self) -> SimPoint3D: ...
    @OS.setter
    def OS(self, value: SimPoint3D) -> SimPoint3D: ...
    @property
    def WGS(self) -> SimPoint3D: ...
    @WGS.setter
    def WGS(self, value: SimPoint3D) -> SimPoint3D: ...


class GeoRefTransform:
    def __init__(self, origin: GeoRefPoint, P1: GeoRefPoint, P2: GeoRefPoint) -> None: ...
    @property
    def Azimuth1(self) -> float: ...
    @Azimuth1.setter
    def Azimuth1(self, value: float) -> float: ...
    @property
    def Azimuth2(self) -> float: ...
    @Azimuth2.setter
    def Azimuth2(self, value: float) -> float: ...
    @property
    def RefOrigin(self) -> GeoRefPoint: ...
    @RefOrigin.setter
    def RefOrigin(self, value: GeoRefPoint) -> GeoRefPoint: ...
    @property
    def RefP1(self) -> GeoRefPoint: ...
    @RefP1.setter
    def RefP1(self, value: GeoRefPoint) -> GeoRefPoint: ...
    @property
    def RefP2(self) -> GeoRefPoint: ...
    @RefP2.setter
    def RefP2(self, value: GeoRefPoint) -> GeoRefPoint: ...


class HoleCycleDetector:
    def __init__(self, nr_of_holes: int, verbose: bool) -> None: ...
    INVALID_INDEX : int
    @property
    def AllNodes(self) -> Dictionary_2[int, HoleCycleNode]: ...
    def AddConnectingLine(self, connecting_line: ValueTuple_4[int, int, int, int]) -> None: ...
    def GetAllHolesConnectedToOnlyOneOtherHoleInclIndirection(self) -> ValueTuple_2[bool, Dictionary_2[int, int]]: ...
    def RemoveConnectingLine(self, connecting_line: ValueTuple_4[int, int, int, int]) -> None: ...


class HoleCycleNode:
    def __init__(self, index: int, verbose: bool) -> None: ...
    @property
    def Connected2Nnodes(self) -> Dictionary_2[ValueTuple_4[int, int, int, int], HoleCycleNode]: ...
    @property
    def Index(self) -> int: ...
    @property
    def Nodes(self) -> Dictionary_2[HoleCycleNode, int]: ...
    def Connect(self, connection: ValueTuple_4[int, int, int, int], node: HoleCycleNode) -> None: ...
    def Disconnect(self, connection: ValueTuple_4[int, int, int, int], node: HoleCycleNode) -> None: ...
    def ToString(self) -> str: ...


class HoleRemoveUndoItem(IUndoItem):
    def __init__(self, face: Face, hole: EdgeLoop) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class ImportWarningMessage(IEquatable_1[ImportWarningMessage]):
    def __init__(self, reason: ImportWarningReason, data: Array_1[typing.Any]) -> None: ...
    @property
    def Data(self) -> Array_1[typing.Any]: ...
    @property
    def Reason(self) -> ImportWarningReason: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, lhs: ImportWarningMessage, rhs: ImportWarningMessage) -> bool: ...
    def __ne__(self, lhs: ImportWarningMessage, rhs: ImportWarningMessage) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ImportWarningMessage) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ImportWarningReason(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FileNotFound : ImportWarningReason # 0
    ImportFailed : ImportWarningReason # 1


class ImprovedOffsetSurfaceGenerator:
    def __init__(self) -> None: ...
    # Skipped Update due to it being static, abstract and generic.

    Update : Update_MethodGroup
    class Update_MethodGroup:
        @typing.overload
        def __call__(self, model: GeometryModelData) -> None:...
        @typing.overload
        def __call__(self, model: GeometryModelData, invalidatedGeometry: IEnumerable_1[BaseGeometry]) -> IEnumerable_1[Face]:...



class IOffsetQueryable(typing.Protocol):
    @abc.abstractmethod
    def GetFaceOffset(self, _face: Face) -> ValueTuple_2[float, float]: ...


class Layer(INotifyPropertyChanged):
    @typing.overload
    def __init__(self, id: int, model: GeometryModelData, name: str) -> None: ...
    @typing.overload
    def __init__(self, model: GeometryModelData, name: str) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Elements(self) -> ObservableCollection_1[BaseGeometry]: ...
    @Elements.setter
    def Elements(self, value: ObservableCollection_1[BaseGeometry]) -> ObservableCollection_1[BaseGeometry]: ...
    @property
    def Id(self) -> int: ...
    @Id.setter
    def Id(self, value: int) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layers(self) -> ObservableCollection_1[Layer]: ...
    @Layers.setter
    def Layers(self, value: ObservableCollection_1[Layer]) -> ObservableCollection_1[Layer]: ...
    @property
    def Model(self) -> GeometryModelData: ...
    @Model.setter
    def Model(self, value: GeometryModelData) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Parent(self) -> Layer: ...
    @Parent.setter
    def Parent(self, value: Layer) -> Layer: ...
    def FindInHierarchy(self, layerName: str) -> Layer: ...


class LayerAlgorithms(abc.ABC):
    @staticmethod
    def DeleteLayerAndContent(layer: Layer) -> List_1[IUndoItem]: ...


class LayerMoveUndoItem(IUndoItem):
    def __init__(self, layer: Layer, oldParent: Layer, newParent: Layer) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class LayerOperationPermissions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : LayerOperationPermissions # 0
    Create : LayerOperationPermissions # 1
    Delete : LayerOperationPermissions # 2
    ModifyColor : LayerOperationPermissions # 4
    ModifyTopolgy : LayerOperationPermissions # 8
    ModifyName : LayerOperationPermissions # 16
    All : LayerOperationPermissions # 18446744073709551615


class LayerReorderUndoItem(IUndoItem):
    def __init__(self, layer: Layer, oldParent: Layer, oldPos: int, newParent: Layer, newPos: int) -> None: ...
    @property
    def OldPos(self) -> int: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class ModelCleanupAlgorithms(abc.ABC):
    @staticmethod
    def RemoveDegeneratedFaces(model: GeometryModelData, areaTolerance: float, faceGrid: clr.Reference[AABBGrid], backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def RemoveDuplicateEdges(model: GeometryModelData, edgeGrid: clr.Reference[AABBGrid], mergeTracker: ModelCleanupAlgorithms.MergeTracker_1[Edge] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def RemoveDuplicateFaces(model: GeometryModelData, faceGrid: clr.Reference[AABBGrid], mergeTracker: ModelCleanupAlgorithms.MergeTracker_1[Face] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def RemoveDuplicateHoleLoops(model: GeometryModelData, backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def RemoveDuplicateHoles(model: GeometryModelData, backgroundInfo: IBackgroundAlgorithmInfo = ...) -> None: ...
    @staticmethod
    def RemoveDuplicateVertices(model: GeometryModelData, tolerance: float, vertexGrid: clr.Reference[AABBGrid], edgeGrid: clr.Reference[AABBGrid], mergeTracker: ModelCleanupAlgorithms.MergeTracker_1[Vertex] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def RemoveDuplicateVolumes(model: GeometryModelData, volumeGrid: clr.Reference[AABBGrid], mergeTracker: ModelCleanupAlgorithms.MergeTracker_1[Volume] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def RemoveErrorLayerIfEmpty(model: GeometryModelData, errorLayerName: str) -> None: ...
    @staticmethod
    def RemoveZeroLengthSubLoops(modelData: GeometryModelData, tolerance: float, backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def SplitContainedFaces(model: GeometryModelData, tolerance: float, faceGrid: clr.Reference[AABBGrid], backgroundInfo: IBackgroundAlgorithmInfo = ...) -> None: ...
    @staticmethod
    def SplitEdgeEdgeIntersections(model: GeometryModelData, tolerance: float, edgeGrid: clr.Reference[AABBGrid], replacementTracker: ModelCleanupAlgorithms.ReplacementTracker_1[Edge] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def SplitEdgeVertexIntersections(model: GeometryModelData, tolerance: float, vertexGrid: clr.Reference[AABBGrid], edgeGrid: clr.Reference[AABBGrid], replacementTracker: ModelCleanupAlgorithms.ReplacementTracker_1[Edge] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> int: ...
    @staticmethod
    def SplitFaces(model: GeometryModelData, tolerance: float, vertexGrid: clr.Reference[AABBGrid], faceGrid: clr.Reference[AABBGrid], errorLayerName: str, splitNameFormat: str = ..., replacementTracker: ModelCleanupAlgorithms.ReplacementTracker_1[Face] = ..., backgroundInfo: IBackgroundAlgorithmInfo = ...) -> ModelCleanupAlgorithms.SplitFaceResult: ...
    # Skipped ReassignComponentsAfterMerge due to it being static, abstract and generic.

    ReassignComponentsAfterMerge : ReassignComponentsAfterMerge_MethodGroup
    class ReassignComponentsAfterMerge_MethodGroup:
        def __getitem__(self, t:typing.Type[ReassignComponentsAfterMerge_1_T1]) -> ReassignComponentsAfterMerge_1[ReassignComponentsAfterMerge_1_T1]: ...

        ReassignComponentsAfterMerge_1_T1 = typing.TypeVar('ReassignComponentsAfterMerge_1_T1')
        class ReassignComponentsAfterMerge_1(typing.Generic[ReassignComponentsAfterMerge_1_T1]):
            ReassignComponentsAfterMerge_1_T = ModelCleanupAlgorithms.ReassignComponentsAfterMerge_MethodGroup.ReassignComponentsAfterMerge_1_T1
            def __call__(self, toMerge: List_1[ValueTuple_2[ReassignComponentsAfterMerge_1_T, HashSet_1[ReassignComponentsAfterMerge_1_T]]], originals: IList_1[ReassignComponentsAfterMerge_1_T], exchange: ComponentGeometryExchange, toReassociate: IList_1[ValueTuple_2[BaseGeometry, SimComponent]], toDeassociate: HashSet_1[SimInstancePlacementGeometry], replacementTracker: ModelCleanupAlgorithms.ReplacementTracker_1[ReassignComponentsAfterMerge_1_T] = ...) -> None:...


    # Skipped ReassignComponentsAfterReplacement due to it being static, abstract and generic.

    ReassignComponentsAfterReplacement : ReassignComponentsAfterReplacement_MethodGroup
    class ReassignComponentsAfterReplacement_MethodGroup:
        def __getitem__(self, t:typing.Type[ReassignComponentsAfterReplacement_1_T1]) -> ReassignComponentsAfterReplacement_1[ReassignComponentsAfterReplacement_1_T1]: ...

        ReassignComponentsAfterReplacement_1_T1 = typing.TypeVar('ReassignComponentsAfterReplacement_1_T1')
        class ReassignComponentsAfterReplacement_1(typing.Generic[ReassignComponentsAfterReplacement_1_T1]):
            ReassignComponentsAfterReplacement_1_T = ModelCleanupAlgorithms.ReassignComponentsAfterReplacement_MethodGroup.ReassignComponentsAfterReplacement_1_T1
            def __call__(self, toReplace: List_1[ValueTuple_2[ReassignComponentsAfterReplacement_1_T, List_1[ReassignComponentsAfterReplacement_1_T]]], originals: IList_1[ReassignComponentsAfterReplacement_1_T], exchange: ComponentGeometryExchange, toReassociate: IList_1[ValueTuple_2[BaseGeometry, SimComponent]], toDeassociate: HashSet_1[SimInstancePlacementGeometry]) -> None:...


    # Skipped ReassignRelationsAfterMerge due to it being static, abstract and generic.

    ReassignRelationsAfterMerge : ReassignRelationsAfterMerge_MethodGroup
    class ReassignRelationsAfterMerge_MethodGroup:
        def __getitem__(self, t:typing.Type[ReassignRelationsAfterMerge_1_T1]) -> ReassignRelationsAfterMerge_1[ReassignRelationsAfterMerge_1_T1]: ...

        ReassignRelationsAfterMerge_1_T1 = typing.TypeVar('ReassignRelationsAfterMerge_1_T1')
        class ReassignRelationsAfterMerge_1(typing.Generic[ReassignRelationsAfterMerge_1_T1]):
            ReassignRelationsAfterMerge_1_T = ModelCleanupAlgorithms.ReassignRelationsAfterMerge_MethodGroup.ReassignRelationsAfterMerge_1_T1
            def __call__(self, toMerge: List_1[ValueTuple_2[ReassignRelationsAfterMerge_1_T, HashSet_1[ReassignRelationsAfterMerge_1_T]]], originals: IList_1[ReassignRelationsAfterMerge_1_T], projectData: ProjectData, replacementTracker: ModelCleanupAlgorithms.ReplacementTracker_1[ReassignRelationsAfterMerge_1_T] = ...) -> List_1[IUndoItem]:...


    # Skipped ReassignRelationsAfterReplacement due to it being static, abstract and generic.

    ReassignRelationsAfterReplacement : ReassignRelationsAfterReplacement_MethodGroup
    class ReassignRelationsAfterReplacement_MethodGroup:
        def __getitem__(self, t:typing.Type[ReassignRelationsAfterReplacement_1_T1]) -> ReassignRelationsAfterReplacement_1[ReassignRelationsAfterReplacement_1_T1]: ...

        ReassignRelationsAfterReplacement_1_T1 = typing.TypeVar('ReassignRelationsAfterReplacement_1_T1')
        class ReassignRelationsAfterReplacement_1(typing.Generic[ReassignRelationsAfterReplacement_1_T1]):
            ReassignRelationsAfterReplacement_1_T = ModelCleanupAlgorithms.ReassignRelationsAfterReplacement_MethodGroup.ReassignRelationsAfterReplacement_1_T1
            def __call__(self, toReplace: List_1[ValueTuple_2[ReassignRelationsAfterReplacement_1_T, List_1[ReassignRelationsAfterReplacement_1_T]]], originals: IList_1[ReassignRelationsAfterReplacement_1_T], projectData: ProjectData) -> List_1[IUndoItem]:...



    class MergeTracker_GenericClasses(abc.ABCMeta):
        Generic_MergeTracker_GenericClasses_MergeTracker_1_T = typing.TypeVar('Generic_MergeTracker_GenericClasses_MergeTracker_1_T')
        def __getitem__(self, types : typing.Type[Generic_MergeTracker_GenericClasses_MergeTracker_1_T]) -> typing.Type[ModelCleanupAlgorithms.MergeTracker_1[Generic_MergeTracker_GenericClasses_MergeTracker_1_T]]: ...

    MergeTracker : MergeTracker_GenericClasses

    MergeTracker_1_T = typing.TypeVar('MergeTracker_1_T')
    class MergeTracker_1(typing.Generic[MergeTracker_1_T]):
        MergeTracker_1_T = ModelCleanupAlgorithms.MergeTracker_1_T
        def __init__(self) -> None: ...
        @property
        def Tracked(self) -> List_1[ModelCleanupAlgorithms.MergeTracker_1.MergeTrackEntry_1[MergeTracker_1_T]]: ...
        def AsList(self) -> List_1[ValueTuple_2[MergeTracker_1_T, HashSet_1[MergeTracker_1_T]]]: ...
        def Track(self, a: MergeTracker_1_T, b: MergeTracker_1_T) -> None: ...
        # Skipped MergeWith due to it being static, abstract and generic.

        MergeWith : MergeWith_MethodGroup[MergeTracker_1_T]
        MergeWith_MethodGroup_MergeTracker_1_T = typing.TypeVar('MergeWith_MethodGroup_MergeTracker_1_T')
        class MergeWith_MethodGroup(typing.Generic[MergeWith_MethodGroup_MergeTracker_1_T]):
            MergeWith_MethodGroup_MergeTracker_1_T = ModelCleanupAlgorithms.MergeTracker_1.MergeWith_MethodGroup_MergeTracker_1_T
            @typing.overload
            def __call__(self, other: List_1[ValueTuple_2[MergeWith_MethodGroup_MergeTracker_1_T, HashSet_1[MergeWith_MethodGroup_MergeTracker_1_T]]]) -> None:...
            @typing.overload
            def __call__(self, other: ModelCleanupAlgorithms.MergeTracker_1[MergeWith_MethodGroup_MergeTracker_1_T]) -> None:...


        MergeTrackEntry_GenericClasses_MergeTracker_1_T = typing.TypeVar('MergeTrackEntry_GenericClasses_MergeTracker_1_T')
        class MergeTrackEntry_GenericClasses(typing.Generic[MergeTrackEntry_GenericClasses_MergeTracker_1_T], abc.ABCMeta):
            MergeTrackEntry_GenericClasses_MergeTracker_1_T = ModelCleanupAlgorithms.MergeTracker_1.MergeTrackEntry_GenericClasses_MergeTracker_1_T
            def __call__(self) -> ModelCleanupAlgorithms.MergeTracker_1.MergeTrackEntry_1[MergeTrackEntry_GenericClasses_MergeTracker_1_T]: ...

        MergeTrackEntry : MergeTrackEntry_GenericClasses[MergeTracker_1_T]

        MergeTrackEntry_1_T = typing.TypeVar('MergeTrackEntry_1_T')
        class MergeTrackEntry_1(typing.Generic[MergeTrackEntry_1_T]):
            MergeTrackEntry_1_T = ModelCleanupAlgorithms.MergeTracker_1.MergeTrackEntry_1_T
            def __init__(self, entries: IEnumerable_1[MergeTrackEntry_1_T], lastEntry: MergeTrackEntry_1_T) -> None: ...
            @property
            def Entries(self) -> HashSet_1[MergeTrackEntry_1_T]: ...
            @property
            def LastEntry(self) -> MergeTrackEntry_1_T: ...
            @LastEntry.setter
            def LastEntry(self, value: MergeTrackEntry_1_T) -> MergeTrackEntry_1_T: ...



    class ReplacementTracker_GenericClasses(abc.ABCMeta):
        Generic_ReplacementTracker_GenericClasses_ReplacementTracker_1_T = typing.TypeVar('Generic_ReplacementTracker_GenericClasses_ReplacementTracker_1_T')
        def __getitem__(self, types : typing.Type[Generic_ReplacementTracker_GenericClasses_ReplacementTracker_1_T]) -> typing.Type[ModelCleanupAlgorithms.ReplacementTracker_1[Generic_ReplacementTracker_GenericClasses_ReplacementTracker_1_T]]: ...

    ReplacementTracker : ReplacementTracker_GenericClasses

    ReplacementTracker_1_T = typing.TypeVar('ReplacementTracker_1_T')
    class ReplacementTracker_1(typing.Generic[ReplacementTracker_1_T]):
        ReplacementTracker_1_T = ModelCleanupAlgorithms.ReplacementTracker_1_T
        def __init__(self) -> None: ...
        def FindOriginal(self, geom: ReplacementTracker_1_T) -> ReplacementTracker_1_T: ...
        def GetReplacements(self) -> List_1[ValueTuple_2[ReplacementTracker_1_T, List_1[ReplacementTracker_1_T]]]: ...
        def MergeWith(self, other: ModelCleanupAlgorithms.ReplacementTracker_1[ReplacementTracker_1_T]) -> None: ...
        def Track(self, oldGeom: ReplacementTracker_1_T, newGeom: IEnumerable_1[ReplacementTracker_1_T]) -> None: ...


    class SplitFaceResult:
        exception : Exception
        exceptionFace : Face
        success : bool
        warningGeometry : List_1[BaseGeometry]



class ModelCompleteStateUndoItem(IUndoItem):
    def __init__(self, newGeometry: GeometryModelData, targetModel: GeometryModel) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class ModelInconsistentException(Exception):
    def __init__(self, msg: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class OffsetAlgorithm(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Full : OffsetAlgorithm # 0
    Fast : OffsetAlgorithm # 1
    Disabled : OffsetAlgorithm # 2


class OffsetFace:
    def __init__(self, face: Face, orientation: GeometricOrientation) -> None: ...
    @property
    def Boundary(self) -> List_1[SimPoint3D]: ...
    @property
    def Face(self) -> Face: ...
    @property
    def Offset(self) -> float: ...
    @Offset.setter
    def Offset(self, value: float) -> float: ...
    @property
    def Openings(self) -> Dictionary_2[EdgeLoop, List_1[SimPoint3D]]: ...
    @property
    def Orientation(self) -> GeometricOrientation: ...


class OffsetModel:
    def __init__(self, model: GeometryModelData, dispatcherTimer: IDispatcherTimer) -> None: ...
    @property
    def Faces(self) -> Dictionary_2[ValueTuple_2[Face, GeometricOrientation], OffsetFace]: ...
    @Faces.setter
    def Faces(self, value: Dictionary_2[ValueTuple_2[Face, GeometricOrientation], OffsetFace]) -> Dictionary_2[ValueTuple_2[Face, GeometricOrientation], OffsetFace]: ...
    @property
    def Generator(self) -> OffsetSurfaceGenerator: ...
    @Generator.setter
    def Generator(self, value: OffsetSurfaceGenerator) -> OffsetSurfaceGenerator: ...
    @property
    def HandleGeometryInvalidated(self) -> bool: ...
    @HandleGeometryInvalidated.setter
    def HandleGeometryInvalidated(self, value: bool) -> bool: ...
    @property
    def Model(self) -> GeometryModelData: ...
    @Model.setter
    def Model(self, value: GeometryModelData) -> GeometryModelData: ...
    def OnOffsetSurfaceChanged(self, faces: IEnumerable_1[Face]) -> None: ...

    class OffsetChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, modifiedFaces: IEnumerable_1[Face], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, modifiedFaces: IEnumerable_1[Face]) -> None: ...



class OffsetSurfaceAlgorithms(abc.ABC):
    @staticmethod
    def ConvertToModel(faces: IEnumerable_1[OffsetFace], transformation: SimMatrix3D, dispatcherTimer: IDispatcherTimerFactory, tolerance: float = ...) -> GeometryModelData: ...


class OffsetSurfaceGenerator:
    def __init__(self, model: GeometryModelData, dispatcherTimer: IDispatcherTimer) -> None: ...
    @property
    def Algorithm(self) -> OffsetAlgorithm: ...
    @Algorithm.setter
    def Algorithm(self, value: OffsetAlgorithm) -> OffsetAlgorithm: ...
    # Skipped Update due to it being static, abstract and generic.

    Update : Update_MethodGroup
    class Update_MethodGroup:
        @typing.overload
        def __call__(self, calculateSurfaces: bool = ...) -> None:...
        @typing.overload
        def __call__(self, invalidatedGeometry: IEnumerable_1[BaseGeometry], calculateSurfaces: bool = ...) -> IEnumerable_1[Face]:...



class OperationPermission:
    def __init__(self, modelPermissions: GeometryModelOperationPermissions, geometryPermissions: GeometryOperationPermissions, layerPermissions: LayerOperationPermissions) -> None: ...
    @classmethod
    @property
    def All(cls) -> OperationPermission: ...
    @classmethod
    @property
    def DefaultNetworkPermissions(cls) -> OperationPermission: ...
    @classmethod
    @property
    def DefaultSimNetworkPermissions(cls) -> OperationPermission: ...
    @classmethod
    @property
    def DefaultWallModelPermissions(cls) -> OperationPermission: ...
    @property
    def GeometryPermissions(self) -> GeometryOperationPermissions: ...
    @GeometryPermissions.setter
    def GeometryPermissions(self, value: GeometryOperationPermissions) -> GeometryOperationPermissions: ...
    @property
    def LayerPermissions(self) -> LayerOperationPermissions: ...
    @LayerPermissions.setter
    def LayerPermissions(self, value: LayerOperationPermissions) -> LayerOperationPermissions: ...
    @property
    def ModelPermissions(self) -> GeometryModelOperationPermissions: ...
    @ModelPermissions.setter
    def ModelPermissions(self, value: GeometryModelOperationPermissions) -> GeometryModelOperationPermissions: ...
    # Skipped property None since it is a reserved python word. Use reflection to access.


class PEdge:
    def __init__(self, edge: Edge, orientation: GeometricOrientation, parent: BaseEdgeContainer) -> None: ...
    @property
    def Edge(self) -> Edge: ...
    @Edge.setter
    def Edge(self, value: Edge) -> Edge: ...
    @property
    def EndVertex(self) -> Vertex: ...
    @property
    def Next(self) -> PEdge: ...
    @Next.setter
    def Next(self, value: PEdge) -> PEdge: ...
    @property
    def Orientation(self) -> GeometricOrientation: ...
    @Orientation.setter
    def Orientation(self, value: GeometricOrientation) -> GeometricOrientation: ...
    @property
    def Parent(self) -> BaseEdgeContainer: ...
    @Parent.setter
    def Parent(self, value: BaseEdgeContainer) -> BaseEdgeContainer: ...
    @property
    def Prev(self) -> PEdge: ...
    @Prev.setter
    def Prev(self, value: PEdge) -> PEdge: ...
    @property
    def StartVertex(self) -> Vertex: ...
    def MakeConsistent(self) -> None: ...


class PFace:
    def __init__(self, face: Face, volume: Volume, orientation: GeometricOrientation) -> None: ...
    @property
    def Face(self) -> Face: ...
    @Face.setter
    def Face(self, value: Face) -> Face: ...
    @property
    def Orientation(self) -> GeometricOrientation: ...
    @Orientation.setter
    def Orientation(self, value: GeometricOrientation) -> GeometricOrientation: ...
    @property
    def Volume(self) -> Volume: ...
    @Volume.setter
    def Volume(self, value: Volume) -> Volume: ...
    def MakeConsistent(self) -> None: ...


class Polyline(BaseEdgeContainer):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, edges: IEnumerable_1[Edge]) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, edges: IEnumerable_1[Edge]) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Edges(self) -> ObservableCollection_1[PEdge]: ...
    @property
    def Faces(self) -> List_1[Face]: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFromModel(self) -> bool: ...


class PolylineAlgorithms:
    def __init__(self) -> None: ...
    @staticmethod
    def GetStartEnd(edges: IEnumerable_1[Edge]) -> ValueTuple_3[bool, Vertex, Vertex]: ...
    @staticmethod
    def Order(edges: IEnumerable_1[PEdge]) -> ValueTuple_2[bool, List_1[PEdge]]: ...


class ProxyGeometry(BaseGeometry):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, vertex: Vertex, positions: List_1[SimPoint3D] = ..., normals: List_1[SimVector3D] = ..., indices: List_1[int] = ...) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, vertex: Vertex) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def EulerAngles(self) -> SimVector3D: ...
    @EulerAngles.setter
    def EulerAngles(self, value: SimVector3D) -> SimVector3D: ...
    @property
    def Id(self) -> int: ...
    @property
    def Indices(self) -> List_1[int]: ...
    @Indices.setter
    def Indices(self, value: List_1[int]) -> List_1[int]: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Normals(self) -> List_1[SimVector3D]: ...
    @Normals.setter
    def Normals(self, value: List_1[SimVector3D]) -> List_1[SimVector3D]: ...
    @property
    def Positions(self) -> List_1[SimPoint3D]: ...
    @Positions.setter
    def Positions(self, value: List_1[SimPoint3D]) -> List_1[SimPoint3D]: ...
    @property
    def Rotation(self) -> SimQuaternion: ...
    @Rotation.setter
    def Rotation(self, value: SimQuaternion) -> SimQuaternion: ...
    @property
    def Size(self) -> SimVector3D: ...
    @Size.setter
    def Size(self, value: SimVector3D) -> SimVector3D: ...
    @property
    def Transformation(self) -> SimMatrix3D: ...
    @property
    def Vertex(self) -> Vertex: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFromModel(self) -> bool: ...


class ProxyShapeGenerator(abc.ABC):
    @staticmethod
    def GenerateCube(layer: Layer, name: str, baseVertex: Vertex, size: SimPoint3D) -> ProxyGeometry: ...
    @staticmethod
    def LoadModelsCombined(layer: Layer, name: str, baseVertex: Vertex, paths: IEnumerable_1[FileInfo], projectData: ProjectData) -> ProxyGeometry: ...
    @staticmethod
    def UpdateCube(proxy: ProxyGeometry, size: SimPoint3D) -> None: ...
    @staticmethod
    def UpdateProxyGeometryCombined(proxy: ProxyGeometry, paths: IEnumerable_1[FileInfo], projectData: ProjectData) -> None: ...


class RemoveGeometryRelationUndoItem(IUndoItem):
    def __init__(self, relation: SimGeometryRelation) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class RemovePlacementUndoItem(IUndoItem):
    def __init__(self, placement: SimInstancePlacement) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class RetargetGeometryRelationUndoItem(IUndoItem):
    def __init__(self, relation: SimGeometryRelation, newRelationReference: SimBaseGeometryReference, targetProperty: RetargetGeometryRelationUndoItem.TargetProperty) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...

    class TargetProperty(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Source : RetargetGeometryRelationUndoItem.TargetProperty # 0
        Target : RetargetGeometryRelationUndoItem.TargetProperty # 1



class SetGeometryRelationTypeUndoItem(IUndoItem):
    def __init__(self, relation: SimGeometryRelation, relationType: SimTaxonomyEntry) -> None: ...
    def Execute(self) -> UndoExecutionResult: ...
    def Redo(self) -> None: ...
    def Undo(self) -> None: ...


class ShapeGenerator(abc.ABC):
    @staticmethod
    def GenerateCube(layer: Layer, position: SimPoint3D, size: SimPoint3D) -> Volume: ...
    @staticmethod
    def GenerateXZRectangle(layer: Layer, position: SimPoint3D, size: SimSize) -> Face: ...
    # Skipped GenerateFaceWithHole due to it being static, abstract and generic.

    GenerateFaceWithHole : GenerateFaceWithHole_MethodGroup
    class GenerateFaceWithHole_MethodGroup:
        @typing.overload
        def __call__(self, layer: Layer, size: SimSize, transformation: SimMatrix3D) -> Face:...
        @typing.overload
        def __call__(self, layer: Layer, size: SimSize, orientation: float, incline: float) -> Face:...



class SimBaseGeometryReference:
    @typing.overload
    def __init__(self, projectId: Guid, baseGeometry: BaseGeometry) -> None: ...
    @typing.overload
    def __init__(self, projectId: Guid, fileId: int, baseGeometryId: int) -> None: ...
    @property
    def BaseGeometryId(self) -> int: ...
    @BaseGeometryId.setter
    def BaseGeometryId(self, value: int) -> int: ...
    @property
    def FileId(self) -> int: ...
    @FileId.setter
    def FileId(self, value: int) -> int: ...
    @property
    def ProjectId(self) -> Guid: ...
    @ProjectId.setter
    def ProjectId(self, value: Guid) -> Guid: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class SimGeometryModelCollection(IEnumerable_1[GeometryModel], INotifyCollectionChanged):
    def __init__(self, projectData: ProjectData) -> None: ...
    @property
    def ProjectData(self) -> ProjectData: ...
    def AddGeometryModel(self, model: GeometryModel) -> None: ...
    def AddGeometryModels(self, models: IEnumerable_1[GeometryModel]) -> None: ...
    def CacheImportedGeometry(self, file: FileInfo, geometry: SimMeshGeometryData) -> None: ...
    @staticmethod
    def GetAllReachableModels(rootModel: GeometryModel, result: Dictionary_2[ResourceFileEntry, GeometryModel]) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[GeometryModel]: ...
    def OnImporterWarning(self, messages: IEnumerable_1[ImportWarningMessage]) -> None: ...
    def RemoveGeometryModel(self, model: GeometryModel) -> bool: ...
    def TryGetCachedImportedGeometry(self, file: FileInfo) -> SimMeshGeometryData: ...
    def TryGetGeometryModel(self, file: ResourceFileEntry, model: clr.Reference[GeometryModel], isOwning: bool = ...) -> bool: ...

    class ImporterWarningEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, messages: IEnumerable_1[ImportWarningMessage], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, messages: IEnumerable_1[ImportWarningMessage]) -> None: ...



class SimGeometryParameterSource(SimParameterValueSource):
    @typing.overload
    def __init__(self, geometryProperty: SimGeometrySourceProperty) -> None: ...
    @typing.overload
    def __init__(self, original: SimGeometryParameterSource) -> None: ...
    @property
    def FilterTags(self) -> SimTaxonomyEntryReferenceCollection: ...
    @property
    def GeometryProperty(self) -> SimGeometrySourceProperty: ...
    @property
    def InstancesPassingFilter(self) -> Dictionary_2[SimComponentInstance, bool]: ...
    @property
    def TargetParameter(self) -> SimBaseParameter: ...
    @TargetParameter.setter
    def TargetParameter(self, value: SimBaseParameter) -> SimBaseParameter: ...
    def Clone(self) -> SimParameterValueSource: ...
    def InstancePassesFilter(self, instance: SimComponentInstance) -> bool: ...
    def NotifyResourceEntryFilterChanged(self, entry: ResourceEntry) -> None: ...
    def RestoreDefaultTaxonomyReferences(self, projectData: ProjectData) -> None: ...
    def UpdateAllInstanceFilters(self) -> None: ...
    def UpdateInstanceFilter(self, instance: SimComponentInstance) -> None: ...


class SimGeometryRelation(SimObjectNew_1[SimGeometryRelationCollection]):
    @typing.overload
    def __init__(self, id: SimId, relationType: SimTaxonomyEntryReference, source: SimBaseGeometryReference, target: SimBaseGeometryReference, isAutogenerated: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, relationType: SimTaxonomyEntryReference, source: SimBaseGeometryReference, target: SimBaseGeometryReference, isAutogenerated: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, relationType: SimTaxonomyEntry, sourceProjectId: Guid, source: BaseGeometry, targetProjectId: Guid, target: BaseGeometry, isAutogenerated: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, relationType: SimTaxonomyEntry, sourceProjectId: Guid, sourceFileId: int, sourceGeometryId: int, targetProjectId: Guid, targetFileId: int, targetGeometryId: int, isAutogenerated: bool = ...) -> None: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Factory(self) -> SimGeometryRelationCollection: ...
    @Factory.setter
    def Factory(self, value: SimGeometryRelationCollection) -> SimGeometryRelationCollection: ...
    @property
    def GlobalID(self) -> Guid: ...
    @property
    def Id(self) -> SimId: ...
    @Id.setter
    def Id(self, value: SimId) -> SimId: ...
    @property
    def IsAutogenerated(self) -> bool: ...
    @IsAutogenerated.setter
    def IsAutogenerated(self, value: bool) -> bool: ...
    @property
    def LocalID(self) -> int: ...
    @property
    def RelationType(self) -> SimTaxonomyEntryReference: ...
    @RelationType.setter
    def RelationType(self, value: SimTaxonomyEntryReference) -> SimTaxonomyEntryReference: ...
    @property
    def Source(self) -> SimBaseGeometryReference: ...
    @Source.setter
    def Source(self, value: SimBaseGeometryReference) -> SimBaseGeometryReference: ...
    @property
    def Target(self) -> SimBaseGeometryReference: ...
    @Target.setter
    def Target(self, value: SimBaseGeometryReference) -> SimBaseGeometryReference: ...


class SimGeometryRelationCollection(SimManagedCollection_1[SimGeometryRelation]):
    def __init__(self, owner: ProjectData) -> None: ...
    @property
    def CalledFromLocation(self) -> IReferenceLocation: ...
    @property
    def Count(self) -> int: ...
    @property
    def HasChanges(self) -> bool: ...
    @property
    def IsLoading(self) -> bool: ...
    @IsLoading.setter
    def IsLoading(self, value: bool) -> bool: ...
    @property
    def Item(self) -> SimGeometryRelation: ...
    @Item.setter
    def Item(self, value: SimGeometryRelation) -> SimGeometryRelation: ...
    @property
    def LastChange(self) -> DateTime: ...
    @property
    def ProjectData(self) -> ProjectData: ...
    def GetRelationsFrom(self, fromGeometry: BaseGeometry) -> IEnumerable_1[SimGeometryRelation]: ...
    def GetRelationsTo(self, toGeometry: BaseGeometry) -> IEnumerable_1[SimGeometryRelation]: ...
    def OnGeometryRelationChanged(self, relation: SimGeometryRelation) -> None: ...
    def RestoreDefaultTaxonomyReferences(self) -> None: ...
    def StartLoading(self) -> None: ...
    def StopLoading(self) -> None: ...
    # Skipped GetRelationsOf due to it being static, abstract and generic.

    GetRelationsOf : GetRelationsOf_MethodGroup
    class GetRelationsOf_MethodGroup:
        @typing.overload
        def __call__(self, reference: SimBaseGeometryReference) -> IEnumerable_1[SimGeometryRelation]:...
        @typing.overload
        def __call__(self, baseGeometry: BaseGeometry) -> IEnumerable_1[SimGeometryRelation]:...
        @typing.overload
        def __call__(self, geometryModel: GeometryModel) -> HashSet_1[SimGeometryRelation]:...


    class GeometryRelationChangedHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, sender: typing.Any, args: GeometryRelationChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, args: GeometryRelationChangedEventArgs) -> None: ...



class SimGeometrySourceProperty(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Invalid : SimGeometrySourceProperty # 0
    FaceArea : SimGeometrySourceProperty # 1
    FaceIncline : SimGeometrySourceProperty # 2
    FaceOrientation : SimGeometrySourceProperty # 3
    VolumeFloorElevation : SimGeometrySourceProperty # 100
    VolumeCeilingElevation : SimGeometrySourceProperty # 101
    VolumeHeight : SimGeometrySourceProperty # 102
    VolumeFloorArea : SimGeometrySourceProperty # 103
    VolumeVolume : SimGeometrySourceProperty # 104
    EdgeLength : SimGeometrySourceProperty # 200


class SimMeshGeometryData:
    def __init__(self) -> None: ...
    @property
    def Indices(self) -> List_1[int]: ...
    @property
    def Normals(self) -> List_1[SimVector3D]: ...
    @property
    def Vertices(self) -> List_1[SimPoint3D]: ...


class Triangulation(abc.ABC):
    @staticmethod
    def DecomposeInSimplePolygons(polygon: List_1[SimPoint3D], holes: List_1[List_1[SimPoint3D]]) -> List_1[List_1[SimPoint3D]]: ...
    @staticmethod
    def PolygonComplexFill(polygon: List_1[SimPoint3D], holes: List_1[List_1[SimPoint3D]], positions: clr.Reference[List_1[SimPoint3D]], indices: clr.Reference[List_1[int]], reverse: bool = ...) -> None: ...


class UTMCoord:
    Easting : float
    Height : float
    NorthernHemisphere : bool
    Northing : float
    Zone : int


class Vertex(BaseGeometry):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, position: SimPoint3D) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, position: SimPoint3D) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Edges(self) -> List_1[Edge]: ...
    @Edges.setter
    def Edges(self, value: List_1[Edge]) -> List_1[Edge]: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Position(self) -> SimPoint3D: ...
    @Position.setter
    def Position(self, value: SimPoint3D) -> SimPoint3D: ...
    @property
    def ProxyGeometries(self) -> List_1[ProxyGeometry]: ...
    @ProxyGeometries.setter
    def ProxyGeometries(self, value: List_1[ProxyGeometry]) -> List_1[ProxyGeometry]: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFromModel(self) -> bool: ...
    # Skipped Clone due to it being static, abstract and generic.

    Clone : Clone_MethodGroup
    class Clone_MethodGroup:
        @typing.overload
        def __call__(self) -> Vertex:...
        @typing.overload
        def __call__(self, layer: Layer) -> Vertex:...



class VertexAlgorithms(abc.ABC):
    @staticmethod
    def AdjacentFaces(v: Vertex, faces: clr.Reference[HashSet_1[Face]]) -> None: ...
    @staticmethod
    def BoundingBox(points: IEnumerable_1[SimPoint3D]) -> ValueTuple_2[SimPoint3D, SimPoint3D]: ...
    @staticmethod
    def IsEqual(p1: SimPoint3D, p2: SimPoint3D, threshold: float = ...) -> bool: ...
    @staticmethod
    def ToMathematicalCoordinateSystem(p: SimPoint3D) -> SimPoint3D: ...
    # Skipped FromMathematicalCoordinateSystem due to it being static, abstract and generic.

    FromMathematicalCoordinateSystem : FromMathematicalCoordinateSystem_MethodGroup
    class FromMathematicalCoordinateSystem_MethodGroup:
        @typing.overload
        def __call__(self, p: SimPoint3D) -> SimPoint3D:...
        @typing.overload
        def __call__(self, v: Vertex) -> SimPoint3D:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> SimPoint3D:...

    # Skipped IsCollinear due to it being static, abstract and generic.

    IsCollinear : IsCollinear_MethodGroup
    class IsCollinear_MethodGroup:
        @typing.overload
        def __call__(self, positions: List_1[SimPoint3D], threshold: float = ...) -> bool:...
        @typing.overload
        def __call__(self, vertices: List_1[Vertex], threshold: float = ...) -> bool:...



class Volume(BaseGeometry):
    @typing.overload
    def __init__(self, id: int, layer: Layer, nameFormat: str, faces: IEnumerable_1[Face]) -> None: ...
    @typing.overload
    def __init__(self, layer: Layer, nameFormat: str, faces: IEnumerable_1[Face]) -> None: ...
    @property
    def Color(self) -> DerivedColor: ...
    @Color.setter
    def Color(self, value: DerivedColor) -> DerivedColor: ...
    @property
    def Faces(self) -> ObservableCollection_1[PFace]: ...
    @Faces.setter
    def Faces(self, value: ObservableCollection_1[PFace]) -> ObservableCollection_1[PFace]: ...
    @property
    def Id(self) -> int: ...
    @property
    def IsActuallyVisible(self) -> bool: ...
    @property
    def IsConsistentOriented(self) -> bool: ...
    @IsConsistentOriented.setter
    def IsConsistentOriented(self, value: bool) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Layer(self) -> Layer: ...
    @Layer.setter
    def Layer(self, value: Layer) -> Layer: ...
    @property
    def ModelGeometry(self) -> GeometryModelData: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    def AddFace(self, face: Face) -> PFace: ...
    def AddToModel(self) -> None: ...
    def MakeConsistent(self, notifyGeometryChanged: bool, hasTopologyChanged: bool) -> None: ...
    def RemoveFace(self, face: Face) -> bool: ...
    def RemoveFromModel(self) -> bool: ...


class VolumeAlgorithms(abc.ABC):
    @staticmethod
    def AddFacesToVolume(v: Volume, faces: IEnumerable_1[Face]) -> None: ...
    @staticmethod
    def AreaBruttoNetto(volume: Volume) -> ValueTuple_3[float, float, float]: ...
    @staticmethod
    def Center(v: Volume) -> SimPoint3D: ...
    @staticmethod
    def ContainedGeometry(v: Volume, geometries: clr.Reference[List_1[BaseGeometry]]) -> None: ...
    @staticmethod
    def Elevation(volume: Volume) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def ElevationReference(volume: Volume) -> ValueTuple_2[float, float]: ...
    @staticmethod
    def FindConsistentOrientation(volume: Volume) -> bool: ...
    @staticmethod
    def FindUnclosedEdges(volume: Volume) -> IEnumerable_1[Edge]: ...
    @staticmethod
    def FloorPerimeter(volume: Volume) -> float: ...
    @staticmethod
    def Height(vol: Volume) -> ValueTuple_3[float, float, float]: ...
    @staticmethod
    def IsInside(volume: Volume, point: SimPoint3D) -> bool: ...
    @staticmethod
    def MergeVolumes(v1: Volume, v2: Volume) -> List_1[BaseGeometry]: ...
    @staticmethod
    def RemoveFacesFromVolume(v: Volume, faces: List_1[Face]) -> None: ...
    @staticmethod
    def SignedVolume(faces: IEnumerable_1[ValueTuple_2[Face, GeometricOrientation]]) -> float: ...
    @staticmethod
    def Volume(vol: Volume) -> float: ...
    @staticmethod
    def VolumeBruttoNetto(vol: Volume) -> ValueTuple_3[float, float, float]: ...

