import typing
from System import IEquatable_1, IFormattable, IFormatProvider, Array_1
from System.ComponentModel import TypeConverter, ITypeDescriptorContext
from System.Globalization import CultureInfo

class SimColor(IEquatable_1[SimColor], IFormattable):
    @property
    def A(self) -> int: ...
    @A.setter
    def A(self, value: int) -> int: ...
    @property
    def B(self) -> int: ...
    @B.setter
    def B(self, value: int) -> int: ...
    @property
    def G(self) -> int: ...
    @G.setter
    def G(self, value: int) -> int: ...
    @property
    def R(self) -> int: ...
    @R.setter
    def R(self, value: int) -> int: ...
    @property
    def ScA(self) -> float: ...
    @ScA.setter
    def ScA(self, value: float) -> float: ...
    @property
    def ScB(self) -> float: ...
    @ScB.setter
    def ScB(self, value: float) -> float: ...
    @property
    def ScG(self) -> float: ...
    @ScG.setter
    def ScG(self, value: float) -> float: ...
    @property
    def ScR(self) -> float: ...
    @ScR.setter
    def ScR(self, value: float) -> float: ...
    @staticmethod
    def Add(color1: SimColor, color2: SimColor) -> SimColor: ...
    def Clamp(self) -> None: ...
    @staticmethod
    def FromArgb(a: int, r: int, g: int, b: int) -> SimColor: ...
    @staticmethod
    def FromRgb(r: int, g: int, b: int) -> SimColor: ...
    @staticmethod
    def FromScRgb(a: float, r: float, g: float, b: float) -> SimColor: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Multiply(color: SimColor, coefficient: float) -> SimColor: ...
    def __add__(self, color1: SimColor, color2: SimColor) -> SimColor: ...
    def __eq__(self, color1: SimColor, color2: SimColor) -> bool: ...
    def __ne__(self, color1: SimColor, color2: SimColor) -> bool: ...
    def __mul__(self, color: SimColor, coefficient: float) -> SimColor: ...
    def __sub__(self, color1: SimColor, color2: SimColor) -> SimColor: ...
    @staticmethod
    def Subtract(color1: SimColor, color2: SimColor) -> SimColor: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, color: SimColor) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, color1: SimColor, color2: SimColor) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimColorConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, td: ITypeDescriptorContext, t: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, td: ITypeDescriptorContext, ci: CultureInfo, value: typing.Any) -> typing.Any: ...
    @staticmethod
    def ConvertFromString(value: str) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimColors:
    @classmethod
    @property
    def AliceBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def AntiqueWhite(cls) -> SimColor: ...
    @classmethod
    @property
    def Aqua(cls) -> SimColor: ...
    @classmethod
    @property
    def Aquamarine(cls) -> SimColor: ...
    @classmethod
    @property
    def Azure(cls) -> SimColor: ...
    @classmethod
    @property
    def Beige(cls) -> SimColor: ...
    @classmethod
    @property
    def Bisque(cls) -> SimColor: ...
    @classmethod
    @property
    def Black(cls) -> SimColor: ...
    @classmethod
    @property
    def BlanchedAlmond(cls) -> SimColor: ...
    @classmethod
    @property
    def Blue(cls) -> SimColor: ...
    @classmethod
    @property
    def BlueViolet(cls) -> SimColor: ...
    @classmethod
    @property
    def Brown(cls) -> SimColor: ...
    @classmethod
    @property
    def BurlyWood(cls) -> SimColor: ...
    @classmethod
    @property
    def CadetBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def Chartreuse(cls) -> SimColor: ...
    @classmethod
    @property
    def Chocolate(cls) -> SimColor: ...
    @classmethod
    @property
    def Coral(cls) -> SimColor: ...
    @classmethod
    @property
    def CornflowerBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def Cornsilk(cls) -> SimColor: ...
    @classmethod
    @property
    def Crimson(cls) -> SimColor: ...
    @classmethod
    @property
    def Cyan(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkCyan(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkGoldenrod(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkGray(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkKhaki(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkMagenta(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkOliveGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkOrange(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkOrchid(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkRed(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkSalmon(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkSeaGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkSlateBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkSlateGray(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkTurquoise(cls) -> SimColor: ...
    @classmethod
    @property
    def DarkViolet(cls) -> SimColor: ...
    @classmethod
    @property
    def DeepPink(cls) -> SimColor: ...
    @classmethod
    @property
    def DeepSkyBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def DimGray(cls) -> SimColor: ...
    @classmethod
    @property
    def DodgerBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def Firebrick(cls) -> SimColor: ...
    @classmethod
    @property
    def FloralWhite(cls) -> SimColor: ...
    @classmethod
    @property
    def ForestGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def Fuchsia(cls) -> SimColor: ...
    @classmethod
    @property
    def Gainsboro(cls) -> SimColor: ...
    @classmethod
    @property
    def GhostWhite(cls) -> SimColor: ...
    @classmethod
    @property
    def Gold(cls) -> SimColor: ...
    @classmethod
    @property
    def Goldenrod(cls) -> SimColor: ...
    @classmethod
    @property
    def Gray(cls) -> SimColor: ...
    @classmethod
    @property
    def Green(cls) -> SimColor: ...
    @classmethod
    @property
    def GreenYellow(cls) -> SimColor: ...
    @classmethod
    @property
    def Honeydew(cls) -> SimColor: ...
    @classmethod
    @property
    def HotPink(cls) -> SimColor: ...
    @classmethod
    @property
    def IndianRed(cls) -> SimColor: ...
    @classmethod
    @property
    def Indigo(cls) -> SimColor: ...
    @classmethod
    @property
    def Ivory(cls) -> SimColor: ...
    @classmethod
    @property
    def Khaki(cls) -> SimColor: ...
    @classmethod
    @property
    def Lavender(cls) -> SimColor: ...
    @classmethod
    @property
    def LavenderBlush(cls) -> SimColor: ...
    @classmethod
    @property
    def LawnGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def LemonChiffon(cls) -> SimColor: ...
    @classmethod
    @property
    def LightBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def LightCoral(cls) -> SimColor: ...
    @classmethod
    @property
    def LightCyan(cls) -> SimColor: ...
    @classmethod
    @property
    def LightGoldenrodYellow(cls) -> SimColor: ...
    @classmethod
    @property
    def LightGray(cls) -> SimColor: ...
    @classmethod
    @property
    def LightGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def LightPink(cls) -> SimColor: ...
    @classmethod
    @property
    def LightSalmon(cls) -> SimColor: ...
    @classmethod
    @property
    def LightSeaGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def LightSkyBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def LightSlateGray(cls) -> SimColor: ...
    @classmethod
    @property
    def LightSteelBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def LightYellow(cls) -> SimColor: ...
    @classmethod
    @property
    def Lime(cls) -> SimColor: ...
    @classmethod
    @property
    def LimeGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def Linen(cls) -> SimColor: ...
    @classmethod
    @property
    def Magenta(cls) -> SimColor: ...
    @classmethod
    @property
    def Maroon(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumAquamarine(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumOrchid(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumPurple(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumSeaGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumSlateBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumSpringGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumTurquoise(cls) -> SimColor: ...
    @classmethod
    @property
    def MediumVioletRed(cls) -> SimColor: ...
    @classmethod
    @property
    def MidnightBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def MintCream(cls) -> SimColor: ...
    @classmethod
    @property
    def MistyRose(cls) -> SimColor: ...
    @classmethod
    @property
    def Moccasin(cls) -> SimColor: ...
    @classmethod
    @property
    def NavajoWhite(cls) -> SimColor: ...
    @classmethod
    @property
    def Navy(cls) -> SimColor: ...
    @classmethod
    @property
    def OldLace(cls) -> SimColor: ...
    @classmethod
    @property
    def Olive(cls) -> SimColor: ...
    @classmethod
    @property
    def OliveDrab(cls) -> SimColor: ...
    @classmethod
    @property
    def Orange(cls) -> SimColor: ...
    @classmethod
    @property
    def OrangeRed(cls) -> SimColor: ...
    @classmethod
    @property
    def Orchid(cls) -> SimColor: ...
    @classmethod
    @property
    def PaleGoldenrod(cls) -> SimColor: ...
    @classmethod
    @property
    def PaleGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def PaleTurquoise(cls) -> SimColor: ...
    @classmethod
    @property
    def PaleVioletRed(cls) -> SimColor: ...
    @classmethod
    @property
    def PapayaWhip(cls) -> SimColor: ...
    @classmethod
    @property
    def PeachPuff(cls) -> SimColor: ...
    @classmethod
    @property
    def Peru(cls) -> SimColor: ...
    @classmethod
    @property
    def Pink(cls) -> SimColor: ...
    @classmethod
    @property
    def Plum(cls) -> SimColor: ...
    @classmethod
    @property
    def PowderBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def Purple(cls) -> SimColor: ...
    @classmethod
    @property
    def Red(cls) -> SimColor: ...
    @classmethod
    @property
    def RosyBrown(cls) -> SimColor: ...
    @classmethod
    @property
    def RoyalBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def SaddleBrown(cls) -> SimColor: ...
    @classmethod
    @property
    def Salmon(cls) -> SimColor: ...
    @classmethod
    @property
    def SandyBrown(cls) -> SimColor: ...
    @classmethod
    @property
    def SeaGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def SeaShell(cls) -> SimColor: ...
    @classmethod
    @property
    def Sienna(cls) -> SimColor: ...
    @classmethod
    @property
    def Silver(cls) -> SimColor: ...
    @classmethod
    @property
    def SkyBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def SlateBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def SlateGray(cls) -> SimColor: ...
    @classmethod
    @property
    def Snow(cls) -> SimColor: ...
    @classmethod
    @property
    def SpringGreen(cls) -> SimColor: ...
    @classmethod
    @property
    def SteelBlue(cls) -> SimColor: ...
    @classmethod
    @property
    def Tan(cls) -> SimColor: ...
    @classmethod
    @property
    def Teal(cls) -> SimColor: ...
    @classmethod
    @property
    def Thistle(cls) -> SimColor: ...
    @classmethod
    @property
    def Tomato(cls) -> SimColor: ...
    @classmethod
    @property
    def Transparent(cls) -> SimColor: ...
    @classmethod
    @property
    def Turquoise(cls) -> SimColor: ...
    @classmethod
    @property
    def Violet(cls) -> SimColor: ...
    @classmethod
    @property
    def Wheat(cls) -> SimColor: ...
    @classmethod
    @property
    def White(cls) -> SimColor: ...
    @classmethod
    @property
    def WhiteSmoke(cls) -> SimColor: ...
    @classmethod
    @property
    def Yellow(cls) -> SimColor: ...
    @classmethod
    @property
    def YellowGreen(cls) -> SimColor: ...


class SimMatrix(IFormattable):
    def __init__(self, m11: float, m12: float, m21: float, m22: float, offsetX: float, offsetY: float) -> None: ...
    @property
    def Determinant(self) -> float: ...
    @property
    def HasInverse(self) -> bool: ...
    @classmethod
    @property
    def Identity(cls) -> SimMatrix: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def M11(self) -> float: ...
    @M11.setter
    def M11(self, value: float) -> float: ...
    @property
    def M12(self) -> float: ...
    @M12.setter
    def M12(self, value: float) -> float: ...
    @property
    def M21(self) -> float: ...
    @M21.setter
    def M21(self, value: float) -> float: ...
    @property
    def M22(self) -> float: ...
    @M22.setter
    def M22(self, value: float) -> float: ...
    @property
    def OffsetX(self) -> float: ...
    @OffsetX.setter
    def OffsetX(self, value: float) -> float: ...
    @property
    def OffsetY(self) -> float: ...
    @OffsetY.setter
    def OffsetY(self, value: float) -> float: ...
    def Append(self, matrix: SimMatrix) -> None: ...
    def GetHashCode(self) -> int: ...
    def Invert(self) -> None: ...
    @staticmethod
    def Multiply(trans1: SimMatrix, trans2: SimMatrix) -> SimMatrix: ...
    def __eq__(self, matrix1: SimMatrix, matrix2: SimMatrix) -> bool: ...
    def __ne__(self, matrix1: SimMatrix, matrix2: SimMatrix) -> bool: ...
    def __mul__(self, trans1: SimMatrix, trans2: SimMatrix) -> SimMatrix: ...
    @staticmethod
    def Parse(source: str) -> SimMatrix: ...
    def Prepend(self, matrix: SimMatrix) -> None: ...
    def Rotate(self, angle: float) -> None: ...
    def RotateAt(self, angle: float, centerX: float, centerY: float) -> None: ...
    def RotateAtPrepend(self, angle: float, centerX: float, centerY: float) -> None: ...
    def RotatePrepend(self, angle: float) -> None: ...
    def Scale(self, scaleX: float, scaleY: float) -> None: ...
    def ScaleAt(self, scaleX: float, scaleY: float, centerX: float, centerY: float) -> None: ...
    def ScaleAtPrepend(self, scaleX: float, scaleY: float, centerX: float, centerY: float) -> None: ...
    def ScalePrepend(self, scaleX: float, scaleY: float) -> None: ...
    def SetIdentity(self) -> None: ...
    def Skew(self, skewX: float, skewY: float) -> None: ...
    def SkewPrepend(self, skewX: float, skewY: float) -> None: ...
    def Translate(self, offsetX: float, offsetY: float) -> None: ...
    def TranslatePrepend(self, offsetX: float, offsetY: float) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimMatrix) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, matrix1: SimMatrix, matrix2: SimMatrix) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...

    # Skipped Transform due to it being static, abstract and generic.

    Transform : Transform_MethodGroup
    class Transform_MethodGroup:
        @typing.overload
        def __call__(self, points: Array_1[SimPoint]) -> None:...
        @typing.overload
        def __call__(self, vectors: Array_1[SimVector]) -> None:...
        @typing.overload
        def __call__(self, point: SimPoint) -> SimPoint:...
        @typing.overload
        def __call__(self, vector: SimVector) -> SimVector:...



class SimMatrix3D(IFormattable):
    def __init__(self, m11: float, m12: float, m13: float, m14: float, m21: float, m22: float, m23: float, m24: float, m31: float, m32: float, m33: float, m34: float, offsetX: float, offsetY: float, offsetZ: float, m44: float) -> None: ...
    @property
    def Determinant(self) -> float: ...
    @property
    def HasInverse(self) -> bool: ...
    @classmethod
    @property
    def Identity(cls) -> SimMatrix3D: ...
    @property
    def IsAffine(self) -> bool: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def M11(self) -> float: ...
    @M11.setter
    def M11(self, value: float) -> float: ...
    @property
    def M12(self) -> float: ...
    @M12.setter
    def M12(self, value: float) -> float: ...
    @property
    def M13(self) -> float: ...
    @M13.setter
    def M13(self, value: float) -> float: ...
    @property
    def M14(self) -> float: ...
    @M14.setter
    def M14(self, value: float) -> float: ...
    @property
    def M21(self) -> float: ...
    @M21.setter
    def M21(self, value: float) -> float: ...
    @property
    def M22(self) -> float: ...
    @M22.setter
    def M22(self, value: float) -> float: ...
    @property
    def M23(self) -> float: ...
    @M23.setter
    def M23(self, value: float) -> float: ...
    @property
    def M24(self) -> float: ...
    @M24.setter
    def M24(self, value: float) -> float: ...
    @property
    def M31(self) -> float: ...
    @M31.setter
    def M31(self, value: float) -> float: ...
    @property
    def M32(self) -> float: ...
    @M32.setter
    def M32(self, value: float) -> float: ...
    @property
    def M33(self) -> float: ...
    @M33.setter
    def M33(self, value: float) -> float: ...
    @property
    def M34(self) -> float: ...
    @M34.setter
    def M34(self, value: float) -> float: ...
    @property
    def M44(self) -> float: ...
    @M44.setter
    def M44(self, value: float) -> float: ...
    @property
    def OffsetX(self) -> float: ...
    @OffsetX.setter
    def OffsetX(self, value: float) -> float: ...
    @property
    def OffsetY(self) -> float: ...
    @OffsetY.setter
    def OffsetY(self, value: float) -> float: ...
    @property
    def OffsetZ(self) -> float: ...
    @OffsetZ.setter
    def OffsetZ(self, value: float) -> float: ...
    def Append(self, matrix: SimMatrix3D) -> None: ...
    def GetHashCode(self) -> int: ...
    def Invert(self) -> None: ...
    @staticmethod
    def Multiply(matrix1: SimMatrix3D, matrix2: SimMatrix3D) -> SimMatrix3D: ...
    def __eq__(self, matrix1: SimMatrix3D, matrix2: SimMatrix3D) -> bool: ...
    def __ne__(self, matrix1: SimMatrix3D, matrix2: SimMatrix3D) -> bool: ...
    def __mul__(self, matrix1: SimMatrix3D, matrix2: SimMatrix3D) -> SimMatrix3D: ...
    @staticmethod
    def Parse(source: str) -> SimMatrix3D: ...
    def Prepend(self, matrix: SimMatrix3D) -> None: ...
    def Rotate(self, quaternion: SimQuaternion) -> None: ...
    def RotateAt(self, quaternion: SimQuaternion, center: SimPoint3D) -> None: ...
    def RotateAtPrepend(self, quaternion: SimQuaternion, center: SimPoint3D) -> None: ...
    def RotatePrepend(self, quaternion: SimQuaternion) -> None: ...
    def Scale(self, scale: SimVector3D) -> None: ...
    def ScaleAt(self, scale: SimVector3D, center: SimPoint3D) -> None: ...
    def ScaleAtPrepend(self, scale: SimVector3D, center: SimPoint3D) -> None: ...
    def ScalePrepend(self, scale: SimVector3D) -> None: ...
    def SetIdentity(self) -> None: ...
    def Translate(self, offset: SimVector3D) -> None: ...
    def TranslatePrepend(self, offset: SimVector3D) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimMatrix3D) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, matrix1: SimMatrix3D, matrix2: SimMatrix3D) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...

    # Skipped Transform due to it being static, abstract and generic.

    Transform : Transform_MethodGroup
    class Transform_MethodGroup:
        @typing.overload
        def __call__(self, points: Array_1[SimPoint3D]) -> None:...
        @typing.overload
        def __call__(self, points: Array_1[SimPoint4D]) -> None:...
        @typing.overload
        def __call__(self, vectors: Array_1[SimVector3D]) -> None:...
        @typing.overload
        def __call__(self, point: SimPoint3D) -> SimPoint3D:...
        @typing.overload
        def __call__(self, point: SimPoint4D) -> SimPoint4D:...
        @typing.overload
        def __call__(self, vector: SimVector3D) -> SimVector3D:...



class SimMatrix3DConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimMatrixConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimPoint(IFormattable):
    def __init__(self, x: float, y: float) -> None: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @staticmethod
    def Add(point: SimPoint, vector: SimVector) -> SimPoint: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Multiply(point: SimPoint, matrix: SimMatrix) -> SimPoint: ...
    def Offset(self, offsetX: float, offsetY: float) -> None: ...
    def __add__(self, point: SimPoint, vector: SimVector) -> SimPoint: ...
    def __eq__(self, point1: SimPoint, point2: SimPoint) -> bool: ...
    # Operator not supported op_Explicit(point: SimPoint)
    # Operator not supported op_Explicit(point: SimPoint)
    def __ne__(self, point1: SimPoint, point2: SimPoint) -> bool: ...
    def __mul__(self, point: SimPoint, matrix: SimMatrix) -> SimPoint: ...
    @typing.overload
    def __sub__(self, point1: SimPoint, point2: SimPoint) -> SimVector: ...
    @typing.overload
    def __sub__(self, point: SimPoint, vector: SimVector) -> SimPoint: ...
    @staticmethod
    def Parse(source: str) -> SimPoint: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimPoint) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, point1: SimPoint, point2: SimPoint) -> bool:...

    # Skipped Subtract due to it being static, abstract and generic.

    Subtract : Subtract_MethodGroup
    class Subtract_MethodGroup:
        @typing.overload
        def __call__(self, point1: SimPoint, point2: SimPoint) -> SimVector:...
        @typing.overload
        def __call__(self, point: SimPoint, vector: SimVector) -> SimPoint:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimPoint3D(IFormattable):
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    @staticmethod
    def Add(point: SimPoint3D, vector: SimVector3D) -> SimPoint3D: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Multiply(point: SimPoint3D, matrix: SimMatrix3D) -> SimPoint3D: ...
    def Offset(self, offsetX: float, offsetY: float, offsetZ: float) -> None: ...
    def __add__(self, point: SimPoint3D, vector: SimVector3D) -> SimPoint3D: ...
    def __eq__(self, point1: SimPoint3D, point2: SimPoint3D) -> bool: ...
    # Operator not supported op_Explicit(point: SimPoint3D)
    # Operator not supported op_Explicit(point: SimPoint3D)
    def __ne__(self, point1: SimPoint3D, point2: SimPoint3D) -> bool: ...
    def __mul__(self, point: SimPoint3D, matrix: SimMatrix3D) -> SimPoint3D: ...
    @typing.overload
    def __sub__(self, point1: SimPoint3D, point2: SimPoint3D) -> SimVector3D: ...
    @typing.overload
    def __sub__(self, point: SimPoint3D, vector: SimVector3D) -> SimPoint3D: ...
    @staticmethod
    def Parse(source: str) -> SimPoint3D: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimPoint3D) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, point1: SimPoint3D, point2: SimPoint3D) -> bool:...

    # Skipped Subtract due to it being static, abstract and generic.

    Subtract : Subtract_MethodGroup
    class Subtract_MethodGroup:
        @typing.overload
        def __call__(self, point1: SimPoint3D, point2: SimPoint3D) -> SimVector3D:...
        @typing.overload
        def __call__(self, point: SimPoint3D, vector: SimVector3D) -> SimPoint3D:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimPoint3DConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimPoint4D(IFormattable):
    def __init__(self, x: float, y: float, z: float, w: float) -> None: ...
    @property
    def W(self) -> float: ...
    @W.setter
    def W(self, value: float) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    @staticmethod
    def Add(point1: SimPoint4D, point2: SimPoint4D) -> SimPoint4D: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Multiply(point: SimPoint4D, matrix: SimMatrix3D) -> SimPoint4D: ...
    def Offset(self, deltaX: float, deltaY: float, deltaZ: float, deltaW: float) -> None: ...
    def __add__(self, point1: SimPoint4D, point2: SimPoint4D) -> SimPoint4D: ...
    def __eq__(self, point1: SimPoint4D, point2: SimPoint4D) -> bool: ...
    def __ne__(self, point1: SimPoint4D, point2: SimPoint4D) -> bool: ...
    def __mul__(self, point: SimPoint4D, matrix: SimMatrix3D) -> SimPoint4D: ...
    def __sub__(self, point1: SimPoint4D, point2: SimPoint4D) -> SimPoint4D: ...
    @staticmethod
    def Parse(source: str) -> SimPoint4D: ...
    @staticmethod
    def Subtract(point1: SimPoint4D, point2: SimPoint4D) -> SimPoint4D: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimPoint4D) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, point1: SimPoint4D, point2: SimPoint4D) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimPoint4DConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimPointConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimQuaternion(IFormattable):
    @typing.overload
    def __init__(self, axisOfRotation: SimVector3D, angleInDegrees: float) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, z: float, w: float) -> None: ...
    @property
    def Angle(self) -> float: ...
    @property
    def Axis(self) -> SimVector3D: ...
    @classmethod
    @property
    def Identity(cls) -> SimQuaternion: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def IsNormalized(self) -> bool: ...
    @property
    def W(self) -> float: ...
    @W.setter
    def W(self, value: float) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    @staticmethod
    def Add(left: SimQuaternion, right: SimQuaternion) -> SimQuaternion: ...
    def Conjugate(self) -> None: ...
    def GetHashCode(self) -> int: ...
    def Invert(self) -> None: ...
    @staticmethod
    def Multiply(left: SimQuaternion, right: SimQuaternion) -> SimQuaternion: ...
    def Normalize(self) -> None: ...
    def __add__(self, left: SimQuaternion, right: SimQuaternion) -> SimQuaternion: ...
    def __eq__(self, quaternion1: SimQuaternion, quaternion2: SimQuaternion) -> bool: ...
    def __ne__(self, quaternion1: SimQuaternion, quaternion2: SimQuaternion) -> bool: ...
    def __mul__(self, left: SimQuaternion, right: SimQuaternion) -> SimQuaternion: ...
    def __sub__(self, left: SimQuaternion, right: SimQuaternion) -> SimQuaternion: ...
    @staticmethod
    def Parse(source: str) -> SimQuaternion: ...
    @staticmethod
    def Subtract(left: SimQuaternion, right: SimQuaternion) -> SimQuaternion: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimQuaternion) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, quaternion1: SimQuaternion, quaternion2: SimQuaternion) -> bool:...

    # Skipped Slerp due to it being static, abstract and generic.

    Slerp : Slerp_MethodGroup
    class Slerp_MethodGroup:
        @typing.overload
        def __call__(self, from_: SimQuaternion, to: SimQuaternion, t: float) -> SimQuaternion:...
        @typing.overload
        def __call__(self, from_: SimQuaternion, to: SimQuaternion, t: float, useShortestPath: bool) -> SimQuaternion:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimQuaternionConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimRect(IFormattable):
    @typing.overload
    def __init__(self, location: SimPoint, size: SimSize) -> None: ...
    @typing.overload
    def __init__(self, point: SimPoint, vector: SimVector) -> None: ...
    @typing.overload
    def __init__(self, point1: SimPoint, point2: SimPoint) -> None: ...
    @typing.overload
    def __init__(self, size: SimSize) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, width: float, height: float) -> None: ...
    @property
    def Bottom(self) -> float: ...
    @property
    def BottomLeft(self) -> SimPoint: ...
    @property
    def BottomRight(self) -> SimPoint: ...
    @classmethod
    @property
    def Empty(cls) -> SimRect: ...
    @property
    def Height(self) -> float: ...
    @Height.setter
    def Height(self, value: float) -> float: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Left(self) -> float: ...
    @property
    def Location(self) -> SimPoint: ...
    @Location.setter
    def Location(self, value: SimPoint) -> SimPoint: ...
    @property
    def Right(self) -> float: ...
    @property
    def Size(self) -> SimSize: ...
    @Size.setter
    def Size(self, value: SimSize) -> SimSize: ...
    @property
    def Top(self) -> float: ...
    @property
    def TopLeft(self) -> SimPoint: ...
    @property
    def TopRight(self) -> SimPoint: ...
    @property
    def Width(self) -> float: ...
    @Width.setter
    def Width(self, value: float) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def IntersectsWith(self, rect: SimRect) -> bool: ...
    def __eq__(self, rect1: SimRect, rect2: SimRect) -> bool: ...
    def __ne__(self, rect1: SimRect, rect2: SimRect) -> bool: ...
    @staticmethod
    def Parse(source: str) -> SimRect: ...
    def Scale(self, scaleX: float, scaleY: float) -> None: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, point: SimPoint) -> bool:...
        @typing.overload
        def __call__(self, rect: SimRect) -> bool:...
        @typing.overload
        def __call__(self, x: float, y: float) -> bool:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimRect) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, rect1: SimRect, rect2: SimRect) -> bool:...

    # Skipped Inflate due to it being static, abstract and generic.

    Inflate : Inflate_MethodGroup
    class Inflate_MethodGroup:
        @typing.overload
        def __call__(self, size: SimSize) -> None:...
        @typing.overload
        def __call__(self, width: float, height: float) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect, size: SimSize) -> SimRect:...
        @typing.overload
        def __call__(self, rect: SimRect, width: float, height: float) -> SimRect:...

    # Skipped Intersect due to it being static, abstract and generic.

    Intersect : Intersect_MethodGroup
    class Intersect_MethodGroup:
        @typing.overload
        def __call__(self, rect: SimRect) -> None:...
        @typing.overload
        def __call__(self, rect1: SimRect, rect2: SimRect) -> SimRect:...

    # Skipped Offset due to it being static, abstract and generic.

    Offset : Offset_MethodGroup
    class Offset_MethodGroup:
        @typing.overload
        def __call__(self, offsetVector: SimVector) -> None:...
        @typing.overload
        def __call__(self, offsetX: float, offsetY: float) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect, offsetVector: SimVector) -> SimRect:...
        @typing.overload
        def __call__(self, rect: SimRect, offsetX: float, offsetY: float) -> SimRect:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...

    # Skipped Transform due to it being static, abstract and generic.

    Transform : Transform_MethodGroup
    class Transform_MethodGroup:
        @typing.overload
        def __call__(self, matrix: SimMatrix) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect, matrix: SimMatrix) -> SimRect:...

    # Skipped Union due to it being static, abstract and generic.

    Union : Union_MethodGroup
    class Union_MethodGroup:
        @typing.overload
        def __call__(self, point: SimPoint) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect) -> None:...
        @typing.overload
        def __call__(self, rect1: SimRect, rect2: SimRect) -> SimRect:...
        @typing.overload
        def __call__(self, rect: SimRect, point: SimPoint) -> SimRect:...



class SimRect3D(IFormattable):
    @typing.overload
    def __init__(self, location: SimPoint3D, size: SimSize3D) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, z: float, sizeX: float, sizeY: float, sizeZ: float) -> None: ...
    @classmethod
    @property
    def Empty(cls) -> SimRect3D: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Location(self) -> SimPoint3D: ...
    @Location.setter
    def Location(self, value: SimPoint3D) -> SimPoint3D: ...
    @property
    def Size(self) -> SimSize3D: ...
    @Size.setter
    def Size(self, value: SimSize3D) -> SimSize3D: ...
    @property
    def SizeX(self) -> float: ...
    @SizeX.setter
    def SizeX(self, value: float) -> float: ...
    @property
    def SizeY(self) -> float: ...
    @SizeY.setter
    def SizeY(self, value: float) -> float: ...
    @property
    def SizeZ(self) -> float: ...
    @SizeZ.setter
    def SizeZ(self, value: float) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def IntersectsWith(self, rect: SimRect3D) -> bool: ...
    def __eq__(self, rect1: SimRect3D, rect2: SimRect3D) -> bool: ...
    def __ne__(self, rect1: SimRect3D, rect2: SimRect3D) -> bool: ...
    @staticmethod
    def Parse(source: str) -> SimRect3D: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, point: SimPoint3D) -> bool:...
        @typing.overload
        def __call__(self, rect: SimRect3D) -> bool:...
        @typing.overload
        def __call__(self, x: float, y: float, z: float) -> bool:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimRect3D) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, rect1: SimRect3D, rect2: SimRect3D) -> bool:...

    # Skipped Intersect due to it being static, abstract and generic.

    Intersect : Intersect_MethodGroup
    class Intersect_MethodGroup:
        @typing.overload
        def __call__(self, rect: SimRect3D) -> None:...
        @typing.overload
        def __call__(self, rect1: SimRect3D, rect2: SimRect3D) -> SimRect3D:...

    # Skipped Offset due to it being static, abstract and generic.

    Offset : Offset_MethodGroup
    class Offset_MethodGroup:
        @typing.overload
        def __call__(self, offsetVector: SimVector3D) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect3D, offsetVector: SimVector3D) -> SimRect3D:...
        @typing.overload
        def __call__(self, offsetX: float, offsetY: float, offsetZ: float) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect3D, offsetX: float, offsetY: float, offsetZ: float) -> SimRect3D:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...

    # Skipped Union due to it being static, abstract and generic.

    Union : Union_MethodGroup
    class Union_MethodGroup:
        @typing.overload
        def __call__(self, point: SimPoint3D) -> None:...
        @typing.overload
        def __call__(self, rect: SimRect3D) -> None:...
        @typing.overload
        def __call__(self, rect1: SimRect3D, rect2: SimRect3D) -> SimRect3D:...
        @typing.overload
        def __call__(self, rect: SimRect3D, point: SimPoint3D) -> SimRect3D:...



class SimRect3DConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimRectConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimSize(IFormattable):
    def __init__(self, width: float, height: float) -> None: ...
    @classmethod
    @property
    def Empty(cls) -> SimSize: ...
    @property
    def Height(self) -> float: ...
    @Height.setter
    def Height(self, value: float) -> float: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Width(self) -> float: ...
    @Width.setter
    def Width(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, size1: SimSize, size2: SimSize) -> bool: ...
    # Operator not supported op_Explicit(size: SimSize)
    # Operator not supported op_Explicit(size: SimSize)
    def __ne__(self, size1: SimSize, size2: SimSize) -> bool: ...
    @staticmethod
    def Parse(source: str) -> SimSize: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimSize) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, size1: SimSize, size2: SimSize) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimSize3D(IFormattable):
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @classmethod
    @property
    def Empty(cls) -> SimSize3D: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, size1: SimSize3D, size2: SimSize3D) -> bool: ...
    # Operator not supported op_Explicit(size: SimSize3D)
    # Operator not supported op_Explicit(size: SimSize3D)
    def __ne__(self, size1: SimSize3D, size2: SimSize3D) -> bool: ...
    @staticmethod
    def Parse(source: str) -> SimSize3D: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimSize3D) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, size1: SimSize3D, size2: SimSize3D) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimSize3DConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimSizeConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimVector(IFormattable):
    def __init__(self, x: float, y: float) -> None: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthSquared(self) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @staticmethod
    def AngleBetween(vector1: SimVector, vector2: SimVector) -> float: ...
    @staticmethod
    def CrossProduct(vector1: SimVector, vector2: SimVector) -> float: ...
    @staticmethod
    def Determinant(vector1: SimVector, vector2: SimVector) -> float: ...
    @staticmethod
    def Divide(vector: SimVector, scalar: float) -> SimVector: ...
    def GetHashCode(self) -> int: ...
    def Negate(self) -> None: ...
    def Normalize(self) -> None: ...
    @typing.overload
    def __add__(self, vector1: SimVector, vector2: SimVector) -> SimVector: ...
    @typing.overload
    def __add__(self, vector: SimVector, point: SimPoint) -> SimPoint: ...
    def __truediv__(self, vector: SimVector, scalar: float) -> SimVector: ...
    def __eq__(self, vector1: SimVector, vector2: SimVector) -> bool: ...
    # Operator not supported op_Explicit(vector: SimVector)
    # Operator not supported op_Explicit(vector: SimVector)
    def __ne__(self, vector1: SimVector, vector2: SimVector) -> bool: ...
    @typing.overload
    def __mul__(self, scalar: float, vector: SimVector) -> SimVector: ...
    @typing.overload
    def __mul__(self, vector: SimVector, scalar: float) -> SimVector: ...
    @typing.overload
    def __mul__(self, vector1: SimVector, vector2: SimVector) -> float: ...
    @typing.overload
    def __mul__(self, vector: SimVector, matrix: SimMatrix) -> SimVector: ...
    def __sub__(self, vector1: SimVector, vector2: SimVector) -> SimVector: ...
    def __neg__(self, vector: SimVector) -> SimVector: ...
    @staticmethod
    def Parse(source: str) -> SimVector: ...
    @staticmethod
    def Subtract(vector1: SimVector, vector2: SimVector) -> SimVector: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, vector1: SimVector, vector2: SimVector) -> SimVector:...
        @typing.overload
        def __call__(self, vector: SimVector, point: SimPoint) -> SimPoint:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimVector) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, vector1: SimVector, vector2: SimVector) -> bool:...

    # Skipped Multiply due to it being static, abstract and generic.

    Multiply : Multiply_MethodGroup
    class Multiply_MethodGroup:
        @typing.overload
        def __call__(self, scalar: float, vector: SimVector) -> SimVector:...
        @typing.overload
        def __call__(self, vector: SimVector, scalar: float) -> SimVector:...
        @typing.overload
        def __call__(self, vector1: SimVector, vector2: SimVector) -> float:...
        @typing.overload
        def __call__(self, vector: SimVector, matrix: SimMatrix) -> SimVector:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimVector3D(IFormattable):
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthSquared(self) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    @staticmethod
    def AngleBetween(vector1: SimVector3D, vector2: SimVector3D) -> float: ...
    @staticmethod
    def CrossProduct(vector1: SimVector3D, vector2: SimVector3D) -> SimVector3D: ...
    @staticmethod
    def Divide(vector: SimVector3D, scalar: float) -> SimVector3D: ...
    @staticmethod
    def DotProduct(vector1: SimVector3D, vector2: SimVector3D) -> float: ...
    def GetHashCode(self) -> int: ...
    def Negate(self) -> None: ...
    def Normalize(self) -> None: ...
    @typing.overload
    def __add__(self, vector1: SimVector3D, vector2: SimVector3D) -> SimVector3D: ...
    @typing.overload
    def __add__(self, vector: SimVector3D, point: SimPoint3D) -> SimPoint3D: ...
    def __truediv__(self, vector: SimVector3D, scalar: float) -> SimVector3D: ...
    def __eq__(self, vector1: SimVector3D, vector2: SimVector3D) -> bool: ...
    # Operator not supported op_Explicit(vector: SimVector3D)
    # Operator not supported op_Explicit(vector: SimVector3D)
    def __ne__(self, vector1: SimVector3D, vector2: SimVector3D) -> bool: ...
    @typing.overload
    def __mul__(self, scalar: float, vector: SimVector3D) -> SimVector3D: ...
    @typing.overload
    def __mul__(self, vector: SimVector3D, scalar: float) -> SimVector3D: ...
    @typing.overload
    def __mul__(self, vector: SimVector3D, matrix: SimMatrix3D) -> SimVector3D: ...
    @typing.overload
    def __sub__(self, vector1: SimVector3D, vector2: SimVector3D) -> SimVector3D: ...
    @typing.overload
    def __sub__(self, vector: SimVector3D, point: SimPoint3D) -> SimPoint3D: ...
    def __neg__(self, vector: SimVector3D) -> SimVector3D: ...
    @staticmethod
    def Parse(source: str) -> SimVector3D: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, vector1: SimVector3D, vector2: SimVector3D) -> SimVector3D:...
        @typing.overload
        def __call__(self, vector: SimVector3D, point: SimPoint3D) -> SimPoint3D:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: SimVector3D) -> bool:...
        @typing.overload
        def __call__(self, o: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, vector1: SimVector3D, vector2: SimVector3D) -> bool:...

    # Skipped Multiply due to it being static, abstract and generic.

    Multiply : Multiply_MethodGroup
    class Multiply_MethodGroup:
        @typing.overload
        def __call__(self, scalar: float, vector: SimVector3D) -> SimVector3D:...
        @typing.overload
        def __call__(self, vector: SimVector3D, scalar: float) -> SimVector3D:...
        @typing.overload
        def __call__(self, vector: SimVector3D, matrix: SimMatrix3D) -> SimVector3D:...

    # Skipped Subtract due to it being static, abstract and generic.

    Subtract : Subtract_MethodGroup
    class Subtract_MethodGroup:
        @typing.overload
        def __call__(self, vector1: SimVector3D, vector2: SimVector3D) -> SimVector3D:...
        @typing.overload
        def __call__(self, vector: SimVector3D, point: SimPoint3D) -> SimPoint3D:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, provider: IFormatProvider) -> str:...



class SimVector3DConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...


class SimVectorConverter(TypeConverter):
    def __init__(self) -> None: ...
    def CanConvertFrom(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool: ...
    def CanConvertTo(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool: ...
    def ConvertFrom(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any: ...
    def ConvertTo(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any: ...

