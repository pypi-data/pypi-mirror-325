from functools import cached_property
from typing import (Any, Callable, DefaultDict, Deque, List, Literal, Tuple,
                    Union)

from nltk import FreqDist
from selenium.webdriver.remote.webelement import WebElement

from kryptone.utils.urls import URL

EMAIL_REGEX = Literal[r'\S+\@\S+']


class TextMixin:
    page_documents: List[str] = ...
    fitted_page_documents: List[str] = ...
    text_processors: List[Callable[[list[str]], bool]] = ...

    @cached_property
    def stop_words_html(self) -> str: ...
    @staticmethod
    def tokenize(text) -> list[str]: ...
    def stop_words(self, language: str = ...) -> List[str]: ...

    @property
    def _fitted_text_tokens(self) -> List[str]: ...
    @staticmethod
    def _tokenize(text: str) -> List[str]: ...
    def _common_words(self, tokens: list[str]) -> List[Tuple[str, int]]: ...
    def _rare_words(self, tokens: list[str]) -> List[Tuple[str, int]]: ...

    def _remove_stop_words(
        self,
        tokens: list[str],
        language: str = ...
    ) -> list[str]: ...

    def _remove_stop_words_multipass(self, tokens: list[str]) -> list[str]: ...

    def get_page_text(self) -> str: ...

    def run_processors(
        self,
        tokens: List[str],
    ) -> List[str]: ...

    def normalize_spaces(self, text: str) -> str: ...
    def validate_text(self, text: str) -> Union[str, Literal['']]: ...
    def fit(self, text: str) -> str: ...

    def fit_transform(
        self,
        text: str = ...,
        language: str = ...,
        email_exception: bool = ...
    ) -> tuple[str, list[str]]: ...

    def fit(
        self,
        raw_text: str,
        email_exception: bool = ...,
        use_multipass: bool = ...,
        language: str = ...
    ) -> tuple[str, list[str]]: ...


class SEOMixin(TextMixin):
    word_frequency_by_page: dict[str, str] = ...
    text_by_page = DefaultDict[dict[str, str]]
    text_tokens_by_page = DefaultDict[list[str]]
    website_tokens = Deque[str]
    stemmed_tokens = Deque[str]
    page_audits = DefaultDict[dict[str, Any]]

    @property
    def grouped_text(self) -> str: ...
    @property
    def get_page_description(self) -> str: ...
    @property
    def get_page_title(self) -> str: ...
    @property
    def get_page_keywords(self) -> str: ...
    @cached_property
    def page_speed_script(self) -> str: ...

    @property
    def has_head_title(self) -> bool: ...
    @property
    def title_is_valid(self) -> bool: ...
    @property
    def description_is_valid(self) -> bool: ...
    @staticmethod
    def normalize_integers(items) -> dict: ...
    def create_word_cloud(self, frequency: dict[str, int]) -> None: ...

    def create_graph(
        self,
        current_url: URL,
        x_values: list[str],
        y_values: list[int]
    ) -> None: ...

    def calculate_word_frequency(
        self,
        tokens: list[str]
    ) -> tuple[FreqDist, list[str, int]]: ...

    def create_stemmed_words(self, tokens: list[str]) -> list[str]: ...
    def audit_structure(self, audit: dict) -> None: ...
    def audit_head(self, audit: dict) -> None: ...
    def audit_images(self, audit: dict) -> None: ...
    def audit_structured_data(self, audit: dict) -> None: ...
    def audit_page_speed(self, audit: dict) -> None: ...

    def audit_page_status_code(
        self, current_url: URL, audit: dict) -> None: ...

    def audit_page(
        self,
        current_url: URL,
        generate_graph: bool = ...
    ) -> dict: ...


class EmailMixin(TextMixin):
    emails_container: set = ...

    @staticmethod
    def identify_email(value: str) -> Union[str, None]: ...
    @staticmethod
    def parse_url(element: WebElement) -> Union[str, None]: ...
    def parse_protected_email(self, email: Union[URL, str]) -> str: ...
    def emails(self, text: str, elements: List[WebElement] = ...) -> None: ...
    def find_emails_from_text(self, text: str) -> set[str]: ...

    def find_emails_from_links(
        self,
        elements: List[WebElement]
    ) -> set[str]: ...


class ScrollMixin:
    def scroll_window(
        self,
        wait_time: int = Literal[5],
        increment: int = Literal[1000],
        stop_at: int = None
    ) -> None: ...

    def scroll_page_section(
        self,
        xpath: str = None,
        css_selector: str = None
    ) -> str: ...

    def scroll_into_view(
        self,
        css_selector: str
    ) -> None: ...
