# coding: utf-8

"""
    Shaped API

    Welcome to Shaped's API reference docs. These provide a detailed view of the endpoints and CLI commands that Shaped provides and brief explanations of how they should be used.   Shaped's API is composed of 3 components:   1. **Dataset** - used to provision and manage 'Shaped Datasets', which are persisted     data views of external data. Shaped Datasets can be created from any of our     'Shaped connectors' (e.g. S3, Segment, Snowflake, etc.) and support both batch     ingestion (up to a 15min delay) and stream ingestion (up to a 30 second     delay) depending on the specific connector used. Shaped datasets can also be     created from local files, which is particularly useful for getting started     with a snapshot of data.    2. **Model Management** - used to provision and manage 'Shaped Models', which     represent a system of data pipelines, training and serving infrastructure for     your ranking use-case.    3. **Model Inference** - a high performance API that's used to make     user-understanding requests or ranking inferences to your 'Shaped Models'. For     example, the 'rank' endpoint can be used to determine for a given user id     query, what is the content that is most engaging to that user.    The recommended workflow to interact with the Shaped API is as follows:   1. First create 'Shaped Datasets' to sync over data that your Shaped     understanding models will need. The models at the minimum need interaction     data to understand behavior of your users, so start with that and add your item     and user catalog data later.   2. Then create 'Shaped Models' that use your created 'Shaped Datasets' as     input. Your Shaped Model will will start streaming, processing and training     from your connected data immediately. After a few hours your model will have     tuned all parameters based on your data and will deploy an active model.   3. You can now use the 'Model Inference' endpoints to make real-time     inferences to your model based on your use-case. 

    The version of the OpenAPI document: 1.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated
from shaped.autogen.models.complement_items_request import ComplementItemsRequest
from shaped.autogen.models.complement_items_response import ComplementItemsResponse
from shaped.autogen.models.create_embedding_response import CreateEmbeddingResponse
from shaped.autogen.models.create_item_embedding_request import CreateItemEmbeddingRequest
from shaped.autogen.models.create_user_embedding_request import CreateUserEmbeddingRequest
from shaped.autogen.models.post_rank_request import PostRankRequest
from shaped.autogen.models.rank_attribute_response import RankAttributeResponse
from shaped.autogen.models.rank_grid_attribute_request import RankGridAttributeRequest
from shaped.autogen.models.rank_grid_attribute_request1 import RankGridAttributeRequest1
from shaped.autogen.models.rank_grid_attribute_response import RankGridAttributeResponse
from shaped.autogen.models.rank_response import RankResponse
from shaped.autogen.models.retrieve_request import RetrieveRequest
from shaped.autogen.models.retrieve_response import RetrieveResponse
from shaped.autogen.models.similar_item_request import SimilarItemRequest
from shaped.autogen.models.similar_response import SimilarResponse
from shaped.autogen.models.similar_users_request import SimilarUsersRequest

from shaped.autogen.api_client import ApiClient, RequestSerialized
from shaped.autogen.api_response import ApiResponse
from shaped.autogen.rest import RESTResponseType


class ModelInferenceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def post_complement_items_models_model_name_complement_items_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        complement_items_request: Optional[ComplementItemsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ComplementItemsResponse:
        """Complement Items

        Complement Items returns a list of items that complement the given input items. For example, if you have a list of items in a user's cart, you can use this endpoint to return items that complement the cart (i.e. \"Complete-the-bag\" use-cases). 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param complement_items_request:
        :type complement_items_request: ComplementItemsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_complement_items_models_model_name_complement_items_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            complement_items_request=complement_items_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComplementItemsResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_complement_items_models_model_name_complement_items_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        complement_items_request: Optional[ComplementItemsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ComplementItemsResponse]:
        """Complement Items

        Complement Items returns a list of items that complement the given input items. For example, if you have a list of items in a user's cart, you can use this endpoint to return items that complement the cart (i.e. \"Complete-the-bag\" use-cases). 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param complement_items_request:
        :type complement_items_request: ComplementItemsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_complement_items_models_model_name_complement_items_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            complement_items_request=complement_items_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComplementItemsResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_complement_items_models_model_name_complement_items_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        complement_items_request: Optional[ComplementItemsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Complement Items

        Complement Items returns a list of items that complement the given input items. For example, if you have a list of items in a user's cart, you can use this endpoint to return items that complement the cart (i.e. \"Complete-the-bag\" use-cases). 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param complement_items_request:
        :type complement_items_request: ComplementItemsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_complement_items_models_model_name_complement_items_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            complement_items_request=complement_items_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComplementItemsResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_complement_items_models_model_name_complement_items_post_serialize(
        self,
        model_name,
        x_api_key,
        complement_items_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if complement_items_request is not None:
            _body_params = complement_items_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/complement_items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_create_item_embedding_models_model_name_create_item_embedding_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        create_item_embedding_request: Optional[CreateItemEmbeddingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateEmbeddingResponse:
        """Create Item Embeddings

        Create Item Embeddings generates a real-time item embedding for the given item. These embeddings are used to power a variety of content/product understanding use-cases at a lower level than our other inference endpoints.  For example, in a zero-shot setting you can analyze these embeddings to understand the clusters of items in your catalog, which can be helpful for platform analytics and topic modeling use-cases. In a fine-tune setting, you can use these item embeddings as input into a downstream machine-learning task such as content moderation classification or your own recommendation model.  If the dimension parameter is given, we project the embeddings to the given dimension. Note that if projecting the embedding then the embeddings won't be aligned across calls or with the user embeddings. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param create_item_embedding_request:
        :type create_item_embedding_request: CreateItemEmbeddingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_create_item_embedding_models_model_name_create_item_embedding_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            create_item_embedding_request=create_item_embedding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateEmbeddingResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_create_item_embedding_models_model_name_create_item_embedding_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        create_item_embedding_request: Optional[CreateItemEmbeddingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateEmbeddingResponse]:
        """Create Item Embeddings

        Create Item Embeddings generates a real-time item embedding for the given item. These embeddings are used to power a variety of content/product understanding use-cases at a lower level than our other inference endpoints.  For example, in a zero-shot setting you can analyze these embeddings to understand the clusters of items in your catalog, which can be helpful for platform analytics and topic modeling use-cases. In a fine-tune setting, you can use these item embeddings as input into a downstream machine-learning task such as content moderation classification or your own recommendation model.  If the dimension parameter is given, we project the embeddings to the given dimension. Note that if projecting the embedding then the embeddings won't be aligned across calls or with the user embeddings. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param create_item_embedding_request:
        :type create_item_embedding_request: CreateItemEmbeddingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_create_item_embedding_models_model_name_create_item_embedding_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            create_item_embedding_request=create_item_embedding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateEmbeddingResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_create_item_embedding_models_model_name_create_item_embedding_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        create_item_embedding_request: Optional[CreateItemEmbeddingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Item Embeddings

        Create Item Embeddings generates a real-time item embedding for the given item. These embeddings are used to power a variety of content/product understanding use-cases at a lower level than our other inference endpoints.  For example, in a zero-shot setting you can analyze these embeddings to understand the clusters of items in your catalog, which can be helpful for platform analytics and topic modeling use-cases. In a fine-tune setting, you can use these item embeddings as input into a downstream machine-learning task such as content moderation classification or your own recommendation model.  If the dimension parameter is given, we project the embeddings to the given dimension. Note that if projecting the embedding then the embeddings won't be aligned across calls or with the user embeddings. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param create_item_embedding_request:
        :type create_item_embedding_request: CreateItemEmbeddingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_create_item_embedding_models_model_name_create_item_embedding_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            create_item_embedding_request=create_item_embedding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateEmbeddingResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_create_item_embedding_models_model_name_create_item_embedding_post_serialize(
        self,
        model_name,
        x_api_key,
        create_item_embedding_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if create_item_embedding_request is not None:
            _body_params = create_item_embedding_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/item_embeddings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_create_user_embedding_models_model_name_create_user_embedding_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        create_user_embedding_request: Optional[CreateUserEmbeddingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateEmbeddingResponse:
        """Create User Embeddings

        Create User Embeddings generates a real-time user embedding for the given user. These embeddings are used to power a variety of content/product understanding use-cases at a lower level than our other inference endpoints.  For example, in a zero-shot setting you can analyze these embeddings to understand the clusters of users, which can be helpful for platform analytics and user segmentation use-cases. In a fine-tune setting, you can use these user embeddings as input into a downstream machine-learning task such as churn prediction, fraud detection or your own recommendation model.  If the dimension parameter is given, we project the embeddings to the given dimension. Note that if projecting the embedding then the embeddings won't be aligned across calls or with the item embeddings. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param create_user_embedding_request:
        :type create_user_embedding_request: CreateUserEmbeddingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_create_user_embedding_models_model_name_create_user_embedding_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            create_user_embedding_request=create_user_embedding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateEmbeddingResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_create_user_embedding_models_model_name_create_user_embedding_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        create_user_embedding_request: Optional[CreateUserEmbeddingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateEmbeddingResponse]:
        """Create User Embeddings

        Create User Embeddings generates a real-time user embedding for the given user. These embeddings are used to power a variety of content/product understanding use-cases at a lower level than our other inference endpoints.  For example, in a zero-shot setting you can analyze these embeddings to understand the clusters of users, which can be helpful for platform analytics and user segmentation use-cases. In a fine-tune setting, you can use these user embeddings as input into a downstream machine-learning task such as churn prediction, fraud detection or your own recommendation model.  If the dimension parameter is given, we project the embeddings to the given dimension. Note that if projecting the embedding then the embeddings won't be aligned across calls or with the item embeddings. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param create_user_embedding_request:
        :type create_user_embedding_request: CreateUserEmbeddingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_create_user_embedding_models_model_name_create_user_embedding_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            create_user_embedding_request=create_user_embedding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateEmbeddingResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_create_user_embedding_models_model_name_create_user_embedding_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        create_user_embedding_request: Optional[CreateUserEmbeddingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create User Embeddings

        Create User Embeddings generates a real-time user embedding for the given user. These embeddings are used to power a variety of content/product understanding use-cases at a lower level than our other inference endpoints.  For example, in a zero-shot setting you can analyze these embeddings to understand the clusters of users, which can be helpful for platform analytics and user segmentation use-cases. In a fine-tune setting, you can use these user embeddings as input into a downstream machine-learning task such as churn prediction, fraud detection or your own recommendation model.  If the dimension parameter is given, we project the embeddings to the given dimension. Note that if projecting the embedding then the embeddings won't be aligned across calls or with the item embeddings. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param create_user_embedding_request:
        :type create_user_embedding_request: CreateUserEmbeddingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_create_user_embedding_models_model_name_create_user_embedding_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            create_user_embedding_request=create_user_embedding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateEmbeddingResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_create_user_embedding_models_model_name_create_user_embedding_post_serialize(
        self,
        model_name,
        x_api_key,
        create_user_embedding_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if create_user_embedding_request is not None:
            _body_params = create_user_embedding_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/user_embeddings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_rank_attribute_grid_models_model_name_rank_attribute_grid_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        rank_grid_attribute_request1: Optional[RankGridAttributeRequest1] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RankGridAttributeResponse:
        """Rank Attribute Grid

        Rank Attribute Grid is used to build a grid interface of items, much like what you'd see on streaming sites or e-commerce marketplaces. The rows define different attributes (the top-most being the most relevant to the query user) and the columns are different items (the left-most being the most relevant to the query user).  If a container type is used as the given attribute then the rows will be ranked by the inner container element values. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param rank_grid_attribute_request1:
        :type rank_grid_attribute_request1: RankGridAttributeRequest1
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_attribute_grid_models_model_name_rank_attribute_grid_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            rank_grid_attribute_request1=rank_grid_attribute_request1,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankGridAttributeResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_rank_attribute_grid_models_model_name_rank_attribute_grid_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        rank_grid_attribute_request1: Optional[RankGridAttributeRequest1] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RankGridAttributeResponse]:
        """Rank Attribute Grid

        Rank Attribute Grid is used to build a grid interface of items, much like what you'd see on streaming sites or e-commerce marketplaces. The rows define different attributes (the top-most being the most relevant to the query user) and the columns are different items (the left-most being the most relevant to the query user).  If a container type is used as the given attribute then the rows will be ranked by the inner container element values. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param rank_grid_attribute_request1:
        :type rank_grid_attribute_request1: RankGridAttributeRequest1
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_attribute_grid_models_model_name_rank_attribute_grid_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            rank_grid_attribute_request1=rank_grid_attribute_request1,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankGridAttributeResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_rank_attribute_grid_models_model_name_rank_attribute_grid_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        rank_grid_attribute_request1: Optional[RankGridAttributeRequest1] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rank Attribute Grid

        Rank Attribute Grid is used to build a grid interface of items, much like what you'd see on streaming sites or e-commerce marketplaces. The rows define different attributes (the top-most being the most relevant to the query user) and the columns are different items (the left-most being the most relevant to the query user).  If a container type is used as the given attribute then the rows will be ranked by the inner container element values. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param rank_grid_attribute_request1:
        :type rank_grid_attribute_request1: RankGridAttributeRequest1
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_attribute_grid_models_model_name_rank_attribute_grid_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            rank_grid_attribute_request1=rank_grid_attribute_request1,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankGridAttributeResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_rank_attribute_grid_models_model_name_rank_attribute_grid_post_serialize(
        self,
        model_name,
        x_api_key,
        rank_grid_attribute_request1,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if rank_grid_attribute_request1 is not None:
            _body_params = rank_grid_attribute_request1


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/rank_attribute_grid',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_rank_attributes_models_model_name_rank_attributes_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        rank_grid_attribute_request: Optional[RankGridAttributeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RankAttributeResponse:
        """Rank Attributes

        Rank Attributes returns the most relevant attribute values for the given input user and attribute name. The attribute_name must match the item attributes of the model. If no user_id is provided then the most popular attributes are returned. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param rank_grid_attribute_request:
        :type rank_grid_attribute_request: RankGridAttributeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_attributes_models_model_name_rank_attributes_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            rank_grid_attribute_request=rank_grid_attribute_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankAttributeResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_rank_attributes_models_model_name_rank_attributes_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        rank_grid_attribute_request: Optional[RankGridAttributeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RankAttributeResponse]:
        """Rank Attributes

        Rank Attributes returns the most relevant attribute values for the given input user and attribute name. The attribute_name must match the item attributes of the model. If no user_id is provided then the most popular attributes are returned. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param rank_grid_attribute_request:
        :type rank_grid_attribute_request: RankGridAttributeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_attributes_models_model_name_rank_attributes_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            rank_grid_attribute_request=rank_grid_attribute_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankAttributeResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_rank_attributes_models_model_name_rank_attributes_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        rank_grid_attribute_request: Optional[RankGridAttributeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rank Attributes

        Rank Attributes returns the most relevant attribute values for the given input user and attribute name. The attribute_name must match the item attributes of the model. If no user_id is provided then the most popular attributes are returned. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param rank_grid_attribute_request:
        :type rank_grid_attribute_request: RankGridAttributeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_attributes_models_model_name_rank_attributes_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            rank_grid_attribute_request=rank_grid_attribute_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankAttributeResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_rank_attributes_models_model_name_rank_attributes_post_serialize(
        self,
        model_name,
        x_api_key,
        rank_grid_attribute_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if rank_grid_attribute_request is not None:
            _body_params = rank_grid_attribute_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/rank_attributes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_rank_models_model_id_rank_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        post_rank_request: PostRankRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RankResponse:
        """Rank

        Rank returns the list of relevant item ids (from most-relevant to least) for the given request context. This is useful for many real-time ranking use-cases such as:   - Personalized recommendations e.g. used in 'For You' feeds, 'You May Also Like'     carousels and 'Recommended for You' sections, etc..   - Personalized search e.g. used to power any search bars or category pages.   - Trending items e.g. used to show recently popular items that are most relevant     to the user query.  There are several ways to use rank depending on the combination of request arguments given. Notably,  1. If no arguments are given, Rank will return a list of trending items. This is  useful if you want to add a trending items feed or carousel or if you want to  surface a generic ranking to a new non-persistent user.  2. If a user_id is given, Rank will return a list of relevant items  personalized for that user. Under-the-hood Shaped's underlying model will  estimate the most relevant items for this user and apply your personal filters  to determine the ranking.  3. If item_ids are given, then we restrict the output to the provided item_ids.  This is useful if you want to skip Shaped's 'Candidate Generation' step and  score a subset of items directly.  4. If interactions are given, then we re-rank based on the item_id sequence  provided. This is useful for real-time session based ranking when you haven't  connected a real-time data source or would prefer to accumulate interaction  windows yourself.  5. If filter_predicate is given, then we filter out the set of candidate ranking  items based on the given retrieval query. This is useful for metadata search  use-cases.  8. If flush_paginations is true, we clear the underlying pagination store cache.  9. If return_metadata is given, we will return raw metadata for the ranked items.  This is useful if you want to display item images, descriptions, etc. in your  application without having to hydrate the ids metadata yourself.  **latency:** This endpoint maintains a p95 200ms latency and is suitable for  real-time usage within your application.  We also provide a convenience GET request for this endpoint, it uses the user_id, limit and return_metadata query arguments. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param post_rank_request: (required)
        :type post_rank_request: PostRankRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_models_model_id_rank_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            post_rank_request=post_rank_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_rank_models_model_id_rank_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        post_rank_request: PostRankRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RankResponse]:
        """Rank

        Rank returns the list of relevant item ids (from most-relevant to least) for the given request context. This is useful for many real-time ranking use-cases such as:   - Personalized recommendations e.g. used in 'For You' feeds, 'You May Also Like'     carousels and 'Recommended for You' sections, etc..   - Personalized search e.g. used to power any search bars or category pages.   - Trending items e.g. used to show recently popular items that are most relevant     to the user query.  There are several ways to use rank depending on the combination of request arguments given. Notably,  1. If no arguments are given, Rank will return a list of trending items. This is  useful if you want to add a trending items feed or carousel or if you want to  surface a generic ranking to a new non-persistent user.  2. If a user_id is given, Rank will return a list of relevant items  personalized for that user. Under-the-hood Shaped's underlying model will  estimate the most relevant items for this user and apply your personal filters  to determine the ranking.  3. If item_ids are given, then we restrict the output to the provided item_ids.  This is useful if you want to skip Shaped's 'Candidate Generation' step and  score a subset of items directly.  4. If interactions are given, then we re-rank based on the item_id sequence  provided. This is useful for real-time session based ranking when you haven't  connected a real-time data source or would prefer to accumulate interaction  windows yourself.  5. If filter_predicate is given, then we filter out the set of candidate ranking  items based on the given retrieval query. This is useful for metadata search  use-cases.  8. If flush_paginations is true, we clear the underlying pagination store cache.  9. If return_metadata is given, we will return raw metadata for the ranked items.  This is useful if you want to display item images, descriptions, etc. in your  application without having to hydrate the ids metadata yourself.  **latency:** This endpoint maintains a p95 200ms latency and is suitable for  real-time usage within your application.  We also provide a convenience GET request for this endpoint, it uses the user_id, limit and return_metadata query arguments. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param post_rank_request: (required)
        :type post_rank_request: PostRankRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_models_model_id_rank_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            post_rank_request=post_rank_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_rank_models_model_id_rank_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        post_rank_request: PostRankRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rank

        Rank returns the list of relevant item ids (from most-relevant to least) for the given request context. This is useful for many real-time ranking use-cases such as:   - Personalized recommendations e.g. used in 'For You' feeds, 'You May Also Like'     carousels and 'Recommended for You' sections, etc..   - Personalized search e.g. used to power any search bars or category pages.   - Trending items e.g. used to show recently popular items that are most relevant     to the user query.  There are several ways to use rank depending on the combination of request arguments given. Notably,  1. If no arguments are given, Rank will return a list of trending items. This is  useful if you want to add a trending items feed or carousel or if you want to  surface a generic ranking to a new non-persistent user.  2. If a user_id is given, Rank will return a list of relevant items  personalized for that user. Under-the-hood Shaped's underlying model will  estimate the most relevant items for this user and apply your personal filters  to determine the ranking.  3. If item_ids are given, then we restrict the output to the provided item_ids.  This is useful if you want to skip Shaped's 'Candidate Generation' step and  score a subset of items directly.  4. If interactions are given, then we re-rank based on the item_id sequence  provided. This is useful for real-time session based ranking when you haven't  connected a real-time data source or would prefer to accumulate interaction  windows yourself.  5. If filter_predicate is given, then we filter out the set of candidate ranking  items based on the given retrieval query. This is useful for metadata search  use-cases.  8. If flush_paginations is true, we clear the underlying pagination store cache.  9. If return_metadata is given, we will return raw metadata for the ranked items.  This is useful if you want to display item images, descriptions, etc. in your  application without having to hydrate the ids metadata yourself.  **latency:** This endpoint maintains a p95 200ms latency and is suitable for  real-time usage within your application.  We also provide a convenience GET request for this endpoint, it uses the user_id, limit and return_metadata query arguments. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param post_rank_request: (required)
        :type post_rank_request: PostRankRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_rank_models_model_id_rank_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            post_rank_request=post_rank_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_rank_models_model_id_rank_post_serialize(
        self,
        model_name,
        x_api_key,
        post_rank_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if post_rank_request is not None:
            _body_params = post_rank_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/rank',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_retrieve_models_model_id_retrieve_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        retrieve_request: RetrieveRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetrieveResponse:
        """Retrieve

        Retrieve returns relevant item_ids for the given input text or user query. It can be used instead of rank if the filtering, scoring and ordering stages aren't needed for the final ranking. Typically people use this endpoint over rank if they want to reduce latency and complexity of the ranking pipeline and only need a subset of the functionality, e.g. just search but without personalization. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param retrieve_request: (required)
        :type retrieve_request: RetrieveRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_retrieve_models_model_id_retrieve_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            retrieve_request=retrieve_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetrieveResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_retrieve_models_model_id_retrieve_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        retrieve_request: RetrieveRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetrieveResponse]:
        """Retrieve

        Retrieve returns relevant item_ids for the given input text or user query. It can be used instead of rank if the filtering, scoring and ordering stages aren't needed for the final ranking. Typically people use this endpoint over rank if they want to reduce latency and complexity of the ranking pipeline and only need a subset of the functionality, e.g. just search but without personalization. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param retrieve_request: (required)
        :type retrieve_request: RetrieveRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_retrieve_models_model_id_retrieve_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            retrieve_request=retrieve_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetrieveResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_retrieve_models_model_id_retrieve_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        retrieve_request: RetrieveRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve

        Retrieve returns relevant item_ids for the given input text or user query. It can be used instead of rank if the filtering, scoring and ordering stages aren't needed for the final ranking. Typically people use this endpoint over rank if they want to reduce latency and complexity of the ranking pipeline and only need a subset of the functionality, e.g. just search but without personalization. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param retrieve_request: (required)
        :type retrieve_request: RetrieveRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_retrieve_models_model_id_retrieve_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            retrieve_request=retrieve_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetrieveResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_retrieve_models_model_id_retrieve_post_serialize(
        self,
        model_name,
        x_api_key,
        retrieve_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if retrieve_request is not None:
            _body_params = retrieve_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/retrieve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_similar_items_models_model_name_similar_items_post(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        similar_item_request: Optional[SimilarItemRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SimilarResponse:
        """Similar Items

        Similar Items returns a list of similar items to the given input item query. If a user_id is given the response will return similar items personalized for that user.  This endpoint can be used to power use-cases like:   1. \"You May Also Like\" surfaces.   2. \"What-to-watch next\" surfaces.   4. \"Similar to this item\" surfaces. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param similar_item_request:
        :type similar_item_request: SimilarItemRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_similar_items_models_model_name_similar_items_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            similar_item_request=similar_item_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SimilarResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_similar_items_models_model_name_similar_items_post_with_http_info(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        similar_item_request: Optional[SimilarItemRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SimilarResponse]:
        """Similar Items

        Similar Items returns a list of similar items to the given input item query. If a user_id is given the response will return similar items personalized for that user.  This endpoint can be used to power use-cases like:   1. \"You May Also Like\" surfaces.   2. \"What-to-watch next\" surfaces.   4. \"Similar to this item\" surfaces. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param similar_item_request:
        :type similar_item_request: SimilarItemRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_similar_items_models_model_name_similar_items_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            similar_item_request=similar_item_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SimilarResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_similar_items_models_model_name_similar_items_post_without_preload_content(
        self,
        model_name: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        similar_item_request: Optional[SimilarItemRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Similar Items

        Similar Items returns a list of similar items to the given input item query. If a user_id is given the response will return similar items personalized for that user.  This endpoint can be used to power use-cases like:   1. \"You May Also Like\" surfaces.   2. \"What-to-watch next\" surfaces.   4. \"Similar to this item\" surfaces. 

        :param model_name: (required)
        :type model_name: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param similar_item_request:
        :type similar_item_request: SimilarItemRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_similar_items_models_model_name_similar_items_post_serialize(
            model_name=model_name,
            x_api_key=x_api_key,
            similar_item_request=similar_item_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SimilarResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_similar_items_models_model_name_similar_items_post_serialize(
        self,
        model_name,
        x_api_key,
        similar_item_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if similar_item_request is not None:
            _body_params = similar_item_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/similar_items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_similar_users_models_model_name_similar_users_post(
        self,
        model_name: StrictStr,
        user_id: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        similar_users_request: Optional[SimilarUsersRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SimilarResponse:
        """Similar Users

        Similar Users returns a list of similar user to the given input user query.  This endpoint can be used to power use-cases like:   1. \"Who to follow\" surfaces.   2. \"People like you\" surfaces.   3. \"Connection recommendation\" surfaces. 

        :param model_name: (required)
        :type model_name: str
        :param user_id: (required)
        :type user_id: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param similar_users_request:
        :type similar_users_request: SimilarUsersRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_similar_users_models_model_name_similar_users_post_serialize(
            model_name=model_name,
            user_id=user_id,
            x_api_key=x_api_key,
            similar_users_request=similar_users_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SimilarResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_similar_users_models_model_name_similar_users_post_with_http_info(
        self,
        model_name: StrictStr,
        user_id: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        similar_users_request: Optional[SimilarUsersRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SimilarResponse]:
        """Similar Users

        Similar Users returns a list of similar user to the given input user query.  This endpoint can be used to power use-cases like:   1. \"Who to follow\" surfaces.   2. \"People like you\" surfaces.   3. \"Connection recommendation\" surfaces. 

        :param model_name: (required)
        :type model_name: str
        :param user_id: (required)
        :type user_id: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param similar_users_request:
        :type similar_users_request: SimilarUsersRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_similar_users_models_model_name_similar_users_post_serialize(
            model_name=model_name,
            user_id=user_id,
            x_api_key=x_api_key,
            similar_users_request=similar_users_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SimilarResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_similar_users_models_model_name_similar_users_post_without_preload_content(
        self,
        model_name: StrictStr,
        user_id: StrictStr,
        x_api_key: Annotated[str, Field(min_length=40, strict=True, max_length=40)],
        similar_users_request: Optional[SimilarUsersRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Similar Users

        Similar Users returns a list of similar user to the given input user query.  This endpoint can be used to power use-cases like:   1. \"Who to follow\" surfaces.   2. \"People like you\" surfaces.   3. \"Connection recommendation\" surfaces. 

        :param model_name: (required)
        :type model_name: str
        :param user_id: (required)
        :type user_id: str
        :param x_api_key: (required)
        :type x_api_key: str
        :param similar_users_request:
        :type similar_users_request: SimilarUsersRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_similar_users_models_model_name_similar_users_post_serialize(
            model_name=model_name,
            user_id=user_id,
            x_api_key=x_api_key,
            similar_users_request=similar_users_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SimilarResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_similar_users_models_model_name_similar_users_post_serialize(
        self,
        model_name,
        user_id,
        x_api_key,
        similar_users_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if model_name is not None:
            _path_params['model_name'] = model_name
        # process the query parameters
        if user_id is not None:
            
            _query_params.append(('user_id', user_id))
            
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if similar_users_request is not None:
            _body_params = similar_users_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/models/{model_name}/similar_users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


